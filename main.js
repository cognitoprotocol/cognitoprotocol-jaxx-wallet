var PlatformUtils = function() {
    
};

PlatformUtils.outputAllChecks = function() {
    "use strict"
    console.log("browserChromeCheck :: " + PlatformUtils.browserChromeCheck());
    console.log("extensionSafariCheck :: " + PlatformUtils.extensionSafariCheck());
    console.log("extensionChromeCheck :: " + PlatformUtils.extensionChromeCheck());
    console.log("extensionFirefoxCheck :: " + PlatformUtils.extensionFirefoxCheck());
};

PlatformUtils.browserChromeCheck = function() {
    "use strict";
    if (typeof(chrome) !== "undefined" && typeof(chrome.extension) === "undefined") {
        return true;
    } else {
        return false;
    }
};

PlatformUtils.extensionSafariCheck = function() {
    "use strict";
    if (typeof(safari) !== 'undefined' && safari.self && /Safari/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent)) {
      return true;
    } else {
      return false;
    }
};

PlatformUtils.extensionChromeCheck = function() {
    "use strict";
    if (typeof(chrome) !== "undefined" && typeof(chrome.extension) !== "undefined" && typeof(chrome.extension.connect) !== "undefined") {
        //@note: this should be the final packed extension key: ilbikpphdpklejgkfhfmmllabablgcil
        var myPort = chrome.extension.connect('ilbikpphdpklejgkfhfmmllabablgcil', null);
        if (typeof(myPort) !== "undefined") {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
};

PlatformUtils.extensionFirefoxCheck = function() {
    "use strict";
    //if (window.chrome && window.chrome.storage && window.chrome.storage.local && window.chrome.storage.local.get) {
    if (navigator.userAgent.indexOf("Firefox") > 0){
        return true;

        //@note: @todo: something about this doesn't work, but there's no debug capability in
        //FF Nightly to debug this, so I'm out of options at the moment.
        //        if (chrome.storage.local.get('firefox_extension')) {
        //            return true;
        //        } else {
        //            return false;
        //        }
    } else {
        return false;
    }
};

PlatformUtils.extensionCheck = function() {
    "use strict";
    return (PlatformUtils.extensionChromeCheck() || PlatformUtils.extensionFirefoxCheck() || PlatformUtils.extensionSafariCheck());
};

PlatformUtils.desktopCheck = function() {
    "use strict";
    if (typeof process !== 'undefined' && process.versions['electron']) {
        return true;
    } else{
        return false;
    }
};

PlatformUtils.mobileCheck = function() {
    "use strict";
    if( /webOS|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
        return true;
    } else {
        if (PlatformUtils.mobileIphoneCheck() || PlatformUtils.mobileIpadCheck() || PlatformUtils.mobileBlackberryCheck() || PlatformUtils.mobileAndroidCheck) {
            return true;
        } else {
            return false;
        }
    }
};

PlatformUtils.mobileIphoneCheck = function() {
    "use strict";
    if( /iPhone|iPod/i.test(navigator.userAgent) ) {
      return true;
    } else {
      return false;
    }
};

PlatformUtils.mobileIpadCheck = function() {
    "use strict";
    if( /iPad/i.test(navigator.userAgent) ) {
      return true;
    } else {
      return false;
    }
};

PlatformUtils.mobileiOSCheck = function() {
    "use strict";
    if( PlatformUtils.mobileIphoneCheck() || PlatformUtils.mobileIpadCheck() )  {
      return true;
    } else {
      return false;
    }
};


PlatformUtils.mobileBlackberryCheck = function() {
    "use strict";
    if( /BlackBerry/i.test(navigator.userAgent) ) {
      return true;
    } else {
      return false;
    }
};

PlatformUtils.mobileAndroidCheck = function() {
    "use strict";
    if( /Android/i.test(navigator.userAgent) ) {
      return true;
    } else {
      return false;
    }

};
(function () {
  "use strict";
  if (window.JaxxAndroid) {
      window.native = {};
      if (window.JaxxAndroid.scanCode) {
          window.native.scanCode = function(processScanData){
              window.JaxxAndroid.scanCode();
              window.native_gotScan = function (data) {
                  processScanData(data);
              };
          };
      }
      if (window.JaxxAndroid.getWindowWidth) {
          window.native.getWindowWidth = function() {
              return window.JaxxAndroid.getWindowWidth();
          };
      }
      if (window.JaxxAndroid.getWindowHeight) {
          window.native.getWindowHeight = function() {
              return window.JaxxAndroid.getWindowHeight();
          };
      }

      if (window.JaxxAndroid.getSoftNavbarHeight) {
          window.native.getAndroidSoftNavbarHeight = function() {
              return window.JaxxAndroid.getSoftNavbarHeight();
          };
      }

      if (window.JaxxAndroid.openExternalURL) {
          window.native.openExternalURL = function(url){
              window.JaxxAndroid.openExternalURL(url);
          };
      }

      if (window.JaxxAndroid.copyToClipboard) {
          window.native.copyToClipboard = function(textToCopy) {
              window.JaxxAndroid.copyToClipboard(textToCopy);
          };
      }

      if (window.JaxxAndroid.hideSplashScreen) {
          window.native.hideSplashScreen = function() {
              window.JaxxAndroid.hideSplashScreen(true);
          };
      }

      if (window.JaxxAndroid.setMainMenuOpenStatus) {
          window.native.setMainMenuOpenStatus = function(isMainMenuOpenStatus) {
              window.JaxxAndroid.setMainMenuOpenStatus(isMainMenuOpenStatus);
          };

          window.native_setMainMenuOpen = function(statusString) {
              if (statusString === 'false') {
                  window.Navigation.setMainMenuOpen(false);
              } else if (statusString === 'true') {
                  window.Navigation.setMainMenuOpen(true);
              }
          };
      }

    if (window.JaxxAndroid.setIsModalOpenStatus) { // True if this function is defined.
      window.native.setIsModalOpenStatus = function(isModalOpenStatus){ // Responds to calls in the webapp.
        window.JaxxAndroid.setIsModalOpenStatus(isModalOpenStatus);
      };
      window.native_closeModal = function(){ // Responds to calls from the Android front end.
        window.Navigation.closeModal();
      };

    }

    if (window.JaxxAndroid.createLogMessage) { // Sends messages to the Android Studio Console.
      window.native.createLogMessage = function(pStrMessage){
        window.JaxxAndroid.createLogMessage(pStrMessage);
      };
    }

    if (window.JaxxAndroid.setSettingsStackStatusSize || window.JaxxAndroid.createLogMessage) {
      window.JaxxAndroid.createLogMessage("getSettingsStackStatusSize method has been initialized by the Android App.");
      // @TODO: Re-implement this logic when the program needs access to the stackSettingsContent
      //		window.native_setSettingsStackStatus = function(){
      //			window.native.setSettingsStackStatus();
      //		}
      //
      //		window.native.setSettingsStackStatus = function(){
      //			// Functionality: Push settingsStackStatus to Android App.
      //			// Note: One client for this function is getSettingsStackStatus in the Android App.
      //			JaxxAndroid.setSettingsStackStatus(Navigation.getSettingsStack().join(',')); // Change Navigation settingsStack to String.
      //		}
      window.native_popSettings = function(){
        //if (Navigation.getSettingsStack().length > 0) {
        window.JaxxAndroid.createLogMessage("In window.native_popSettings, the settings stack in the web app is " + window.Navigation.getSettingsStack().join(','));
        window.Navigation.popSettings();
        window.JaxxAndroid.setSettingsStackStatusSize(window.Navigation.getSettingsStack().length);
        //}
      };

      window.native.setSettingsStackStatusSize = function(pSize) {
        window.JaxxAndroid.setSettingsStackStatusSize(pSize);
      };
    }

    window.native.setProfileMode = function(newProfileMode) {
        window.Navigation.setProfileMode(newProfileMode);
    };

    if (window.JaxxAndroid.setTabName || window.JaxxAndroid.createLogMessage) {
      window.JaxxAndroid.createLogMessage("setTabName method has been initialized by the Android App.");
      window.native.setTabName = function(pStrTabName){ // Sets the tab name in the Android file.
        if (!pStrTabName) {
          pStrTabName = "";
        }
        window.JaxxAndroid.setTabName(pStrTabName);
        window.JaxxAndroid.createLogMessage("Setting tab name in Android App to " + pStrTabName);
      };
      window.native_pullTabName = function(){ // Called from Android file
        window.native.setTabName(window.Navigation.getTab());
      };
      window.native_collapseTabs = function(){ // Called from Android file to respond to back button
        window.Navigation.collapseTabs();
      };
    }

      window.native_runBackButtonBusinessLogicInJavascript = function(){
          //@Add in modal closing functionality
          window.console.log("Running back button business logic.");
          var strTopOfSettingsStack = window.Navigation.getTopOfSettingsStack();
          if (strTopOfSettingsStack === null){
              window.console.log("The settings stack is empty.");
              if (window.g_JaxxApp.getUI().isMainMenuOpen()) {
                  window.console.log("Closing the main menu.");
                  window.g_JaxxApp.getUI().closeMainMenu();
              } else {
                  if (window.JaxxAndroid.exitApplication && window.JaxxAndroid.createLogMessage) {
                      window.console.log("Exiting Application Location BBB.");
                      window.JaxxAndroid.exitApplication();
                  }
              }
          } else {
              window.console.log("The top of the settings stack is " + strTopOfSettingsStack);
              if (window.g_JaxxApp.getSettings().isBackButtonExitApplication(strTopOfSettingsStack)) {
                  if (window.JaxxAndroid.exitApplication && window.JaxxAndroid.createLogMessage) {
                      window.console.log("Exiting Application Location AAA.");
                      window.JaxxAndroid.exitApplication();
                  }
              } else {
                  window.console.log("Popping Settings.");
                  window.Navigation.popSettings();
              }
          }
      };

  }
}());

window.$(function() {
    "use strict";
    var userAgent = parseGETparam('userAgent');
    window.storeData('userAgent',userAgent);
});

function parseGETparam(val) {
    "use strict";
    var result = "-1",
        tmp = [];
    location.search
    // this is better, there might be a question mark inside
    .substr(1)
        .split("&")
        .forEach(function (item) {
        tmp = item.split("=");
        if (tmp[0] === val) {
          result = decodeURIComponent(tmp[1]);
        }
    });
    return result;
}
if (window.webkit) {
    window.webkit.messageHandlers.Jaxx.postMessage({action: "console.log", message: "Bootstrap start"});

    (function () {
        window._scannerCallback = null;

        window.console = {};
        window.console.log = function () {
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
                if ({number: true, string: true}[typeof(arguments[i])]) {
                    args.push(arguments[i]);
                } else {
                    args.push("" + arguments[i]);
                }
            }
            window.webkit.messageHandlers.Jaxx.postMessage({action: "console.log", arguments: args});
        };

        window.console.error = function (err) {
            if(err && typeof err === 'object') {
              window.webkit.messageHandlers.Jaxx.postMessage({
                action: "console.error",
                message: err.message,
                stack: err.stack
              });
            }
        };

        window.console.warn = function(warn) {
          window.webkit.messageHandlers.Jaxx.postMessage({
            action: "console.warn",
            message: warn.message,
            stack: warn.stack
          });
        }


        var nextCallbackIndex = 0;
        var callbacks = {};
        var registerCallback = function (callback) {
            var key = 'cb-' + (nextCallbackIndex++);
            callbacks[key] = callback;
            return key;
        }
        window._callCallback = function (data) {
            try {
                callbacks[data.callbackKey](data);
            } catch (error) {
                console.log("Native callback error: " + error.message);
            }
            delete callbacks[data.callbackKey];
        }

//    console.log("window.iosdefaultprofilemode :: " + window.iosdefaultprofilemode);

        window.native = {
            scanCode: function (callback) {
                if (!callback) {
                    console.log("!! ios js error :: No callback provided to scanCode !!");
                    throw new Error("No callback provided to scanCode");
                }

                window._scannerCallback = function (result) {

                    if (result && result.code) {
                        console.log("ios js result from scan :: " + result.code);
                        callback(result.code);
                    } else {
                        console.log("ios js result from scan is null");
                        callback(null);
                    }
                }

                window.webkit.messageHandlers.Jaxx.postMessage({
                    action: "native.scanCode",
                    callbackKey: registerCallback(function (data) {
                        callback(data.code);
                    })
                });
            },
            tweet: function (tweet, callback) {
                if (!tweet) {
                    return;
                }
                window._tweetCallback = function (result) {
                    if (!callback || !result) {
                        return;
                    }
                    callback(result.success);
                }

                window.webkit.messageHandlers.Jaxx.postMessage({action: "native.tweet", tweet: tweet});
            },
            openExternalURL: function (url) {
                console.log("try to open external URL : " + url);
                if (!url) {
                    return;
                }
                window.webkit.messageHandlers.Jaxx.postMessage({action: "native.openExternalURL", url: url});
            },
            copyToClipboard: function (textToCopy) {
                console.log("copy text to clipboard :: " + textToCopy);
                window.webkit.messageHandlers.Jaxx.postMessage({
                    action: "native.copyToClipboard",
                    textToCopy: textToCopy
                });
            },
            setProfileMode: function (newProfileMode) {
                Navigation.setProfileMode(newProfileMode);
            }

//        },
//        getWindowWidth: function() {
//            window.webkit.messageHandlers.Jaxx.postMessage({
//                action: "native.getWindowWidth",
//                callbackKey: registerCallback(function (data) {callback(data.code); })
//            });
//        }
        }

    })();

    console.log("Bootstrap complete");
}
/**
 * @see http://stackoverflow.com/q/7616461/940217
 * @return {number}
 */
String.prototype.hashCode = function(){
    if (Array.prototype.reduce){
        return this.split("").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0);
    }
    var hash = 0;
    if (this.length === 0) return hash;
    for (var i = 0; i < this.length; i++) {
        var character  = this.charCodeAt(i);
        hash  = ((hash<<5)-hash)+character;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
}

//var BigInteger = Bitcoin.BigInteger;

/*
function isEmpty(ob)
{
    for (var i in ob)
    {
        if (ob.hasOwnProperty(i))
        {
            return false;
        }
    }
    return true;
}
*/
/*
function endian(string)
{
    var out = []

    for (var i = string.length; i > 0; i -= 2)
    {
        out.push(string.substring(i - 2, i));
    }
    return out.join("");
}
*/
/*
function btcFormat (amount)
{
    return amount.toFixed(8);
}
*/
/*
function btcstr2bignum(btc)
{
    var i = btc.indexOf('.');
    var value = new BigInteger(btc.replace(/\./, ''));
    var diff = 9 - (btc.length - i);
    if (i == -1)
    {
        var mul = "100000000";
    }
    else if (diff < 0)
    {
        return value.divide(new BigInteger(Math.pow(10, -1 * diff).toString()));
    }
    else
    {
        var mul = Math.pow(10, diff).toString();
    }
    return value.multiply(new BigInteger(mul));
}
*/
/*
function parseScript(script)
{
    var newScript = new Bitcoin.Script();
    var s = script.split(" ");
    for (var i in s)
    {
        if (Bitcoin.Opcode.map.hasOwnProperty(s[i]))
        {
            newScript.writeOp(Bitcoin.Opcode.map[s[i]]);
        }
        else
        {
            newScript.writeBytes(Bitcoin.convert.hexToBytes(s[i]));
        }
    }
    return newScript;
}
*/
/*
function tx_fetch(url, onSuccess, onError, postdata)
{

    $.ajax(
    {
        url: url,
        data: postdata,

        type: "POST",
        success: function (res)
        {
            onSuccess(JSON.stringify(res));

        },
        error: function (xhr, opt, err)
        {
            console.log("error!");
        }
    });
}
*/
/*
function hasTouch()
{
    return (typeof Touch == 'object');
};
*/
/*
function setCookie(cookieName,cookieValue,nDays) {
    var today = new Date();
    var expire = new Date();
    if (nDays==null || nDays==0) nDays=1;
    expire.setTime(today.getTime() + 3600000*24*nDays);
    document.cookie = cookieName+"="+escape(cookieValue) + ";expires="+expire.toGMTString();
}
*/
/*
function readCookie(cookieName) {
    var theCookie=" "+document.cookie;
    var ind=theCookie.indexOf(" "+cookieName+"=");
    if (ind==-1) ind=theCookie.indexOf(";"+cookieName+"=");
    if (ind==-1 || cookieName=="") return "";
    var ind1=theCookie.indexOf(";",ind+1);
    if (ind1==-1) ind1=theCookie.length; 
    return unescape(theCookie.substring(ind+cookieName.length+2,ind1));
}
*/
/*
function formatMoney(x)
{
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
*/

Date.prototype.format = function (format) 
{
    var o = {
        "Y+": this.getFullYear(), //year
        "M+": this.getMonth() + 1, //month
        "J+": getMonthName( this.getMonth() ),
        "L+": getDayName( this.getDay() ),
        "D+": this.getDate(), //day
        "H+": this.getHours(), //hour
        "h+": ((this.getHours() % 12)==0)?"12":(this.getHours() % 12), //hour
        "z+": ( this.getHours()>11 )?"pm":"am", //hour
        "m+": this.getMinutes(), //minute

        "q+": Math.floor((this.getMonth() + 3) / 3), //quarter
    }

    // if (/(y+)/.test(format)) format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
        if (new RegExp("(" + k + ")").test(format))
            format = format.replace(RegExp.$1,
                RegExp.$1.length == 1 ? o[k] :
                ( o[k]));
    return format;
}

function getMonthName( num )
{
    var month = new Array();
    month[0] = "Jan";
    month[1] = "Feb";
    month[2] = "Mar";
    month[3] = "Apr";
    month[4] = "May";
    month[5] = "Jun";
    month[6] = "Jul";
    month[7] = "Aug";
    month[8] = "Sep";
    month[9] = "Oct";
    month[10] = "Nov";
    month[11] = "Dec";

    return month[num];
}

function getDayName( num )
{
    var day = new Array();
    day[0] = "Sunday";
    day[1] = "Monday";
    day[2] = "Tuesday";
    day[3] = "Wednesday";
    day[4] = "Thursday";
    day[5] = "Friday";
    day[6] = "Saturday";

    return day[num];
}

function htmlEncode(value){
  return $('<div/>').text(value).html();
}

var nativeIntegration = null;
var nativeSuppoprtsLocalStrogae = true;

//This method checks if native (IOS Android etc are hooked in
// return true is Native methods are there else false
function IsNativeSetup(){
    if(typeof JaxxAndroid != 'undefined'){
        console.log('Found android integration');
        nativeIntegration = JaxxAndroid;
        nativeSuppoprtsLocalStrogae = false;
        return true;

    }else if (window.native && window.native.scanCode) {
        console.log('Found ios integration test');

        nativeIntegration = {
            ShowScanner:native_showScanner,
            getFromStorage: native_getFromStorage,
            setToStorage:native_setToStorage
        };

        return true;
    }

    return false;
}

/* Never used

// Tell us if we should store this data securely
function IsSensitiveData(name){
     return 'passcode' == name;
}

function getStore( name, callback ) {
  var value = null;
  var data = null;

  // No reason to store non sesitive info in native storage.... it will simply be stored as browers HTML5 local storage
  // in IOS secured data (password) is stored in key chain and in Android as app private data
  if ( null != nativeIntegration && (!nativeSuppoprtsLocalStrogae || IsSensitiveData(name)) ) {
      data = nativeIntegration.getFromStorage(name );
  } else {
      data = localStorage[name];
      try {
        data = JSON.parse(data);
      } catch(e) {
      }
  }

  if ( data !== undefined && data !== "" ) {
    if (data === 'false') {
      value = false;
    } else if ( data === 'true') {
      value = true;
    } else {
      value = data;
    }
  } else {
    value = '';
  }

  if (callback !== undefined) {
    callback(value);
  } else {
    return value;
  }
}

function setStore( keyVal, callback ) {
    for ( key in keyVal ) {
        if(null!= nativeIntegration && (!nativeSuppoprtsLocalStrogae || IsSensitiveData(name))){
            console.log('using native_setToStorage');
            nativeIntegration.setToStorage(key,keyVal[key]);
        }else{
            localStorage[key] = JSON.stringify(keyVal[key]);
        }
    }
    if (callback !== undefined) {
      callback();
    }
}
*/

var isApp = function() {
  return window.chrome && chrome.app !== undefined && chrome.app.getDetails() !== undefined && chrome.app.getDetails() !== null && chrome.app.getDetails()['author'] !== null;
}
var storage = {
  queue: [],
  addListener: function(value) {
    if (isApp() === true) {
      chrome.storage.onChanged.addListener(value);
    } else {
      this.queue.push(value);
    }
  },
  set: function(items, callback) {
    if (isApp() === true) {
      for (var i = 0; i < this.queue.length; i++) {
        chrome.storage.local.get(null, this.queue[i]);
      }
      chrome.storage.local.set(items, callback);
    } else {
      setStore(items, callback);
      var values = {};
      for (item in localStorage) {
        values[item].newValue = localStorage[item];
      }
      for (var i = 0; i < this.queue.length; i++) {
        this.queue[i](values);
      }
    }
  },
  get: function(items, callback) {
    if (isApp() === true) {
        chrome.storage.local.get(items, callback);
    } else {
      var value = {}
      if (items.constructor === Array) {
        for (var i = 0; i < items.length; i++) {
          value[items[i]] = getStore(items[i]);
        }
        callback(value);
      } else {
        value[items] = getStore(items);
        callback(value);
      }
    }
  }
};

function playSound(soundfile_ogg, soundfile_mp, soundfile_ma) {
    //@note:@todo: remove the return;
    return;
    if ("Audio" in window) {
        var a = new Audio();
        if (!!(a.canPlayType && a.canPlayType('audio/ogg; codecs="vorbis"')
               .replace(/no/, '')))
            a.src = soundfile_ogg;
        else if (!!(a.canPlayType && a.canPlayType('audio/mpeg;').replace(/no/,
                                                                          '')))
            a.src = soundfile_mp;
        else if (!!(a.canPlayType && a.canPlayType(
            'audio/mp4; codecs="mp4a.40.2"').replace(/no/, '')))
            a.src = soundfile_ma;
        else {
            a.src = soundfile_mp;
        }
        console.log("looking for :: " + a.src)

        a.autoplay = true;
        return;
    }
}




/*
function setMsg (msg)
{
    console.log( "Message: " + msg );
    return;
}
*/
function commify(value) {
    return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}


//! moment.js
//! version : 2.6.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
(function(a){function b(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function c(a,b){function c(){ib.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+a)}var d=!0;return i(function(){return d&&(c(),d=!1),b.apply(this,arguments)},b)}function d(a,b){return function(c){return l(a.call(this,c),b)}}function e(a,b){return function(c){return this.lang().ordinal(a.call(this,c),b)}}function f(){}function g(a){y(a),i(this,a)}function h(a){var b=r(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._milliseconds=+k+1e3*j+6e4*i+36e5*h,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._bubble()}function i(a,b){for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return b.hasOwnProperty("toString")&&(a.toString=b.toString),b.hasOwnProperty("valueOf")&&(a.valueOf=b.valueOf),a}function j(a){var b,c={};for(b in a)a.hasOwnProperty(b)&&wb.hasOwnProperty(b)&&(c[b]=a[b]);return c}function k(a){return 0>a?Math.ceil(a):Math.floor(a)}function l(a,b,c){for(var d=""+Math.abs(a),e=a>=0;d.length<b;)d="0"+d;return(e?c?"+":"":"-")+d}function m(a,b,c,d){var e=b._milliseconds,f=b._days,g=b._months;d=null==d?!0:d,e&&a._d.setTime(+a._d+e*c),f&&db(a,"Date",cb(a,"Date")+f*c),g&&bb(a,cb(a,"Month")+g*c),d&&ib.updateOffset(a,f||g)}function n(a){return"[object Array]"===Object.prototype.toString.call(a)}function o(a){return"[object Date]"===Object.prototype.toString.call(a)||a instanceof Date}function p(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&t(a[d])!==t(b[d]))&&g++;return g+f}function q(a){if(a){var b=a.toLowerCase().replace(/(.)s$/,"$1");a=Zb[a]||$b[b]||b}return a}function r(a){var b,c,d={};for(c in a)a.hasOwnProperty(c)&&(b=q(c),b&&(d[b]=a[c]));return d}function s(b){var c,d;if(0===b.indexOf("week"))c=7,d="day";else{if(0!==b.indexOf("month"))return;c=12,d="month"}ib[b]=function(e,f){var g,h,i=ib.fn._lang[b],j=[];if("number"==typeof e&&(f=e,e=a),h=function(a){var b=ib().utc().set(d,a);return i.call(ib.fn._lang,b,e||"")},null!=f)return h(f);for(g=0;c>g;g++)j.push(h(g));return j}}function t(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=b>=0?Math.floor(b):Math.ceil(b)),c}function u(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function v(a,b,c){return $(ib([a,11,31+b-c]),b,c).week}function w(a){return x(a)?366:365}function x(a){return a%4===0&&a%100!==0||a%400===0}function y(a){var b;a._a&&-2===a._pf.overflow&&(b=a._a[pb]<0||a._a[pb]>11?pb:a._a[qb]<1||a._a[qb]>u(a._a[ob],a._a[pb])?qb:a._a[rb]<0||a._a[rb]>23?rb:a._a[sb]<0||a._a[sb]>59?sb:a._a[tb]<0||a._a[tb]>59?tb:a._a[ub]<0||a._a[ub]>999?ub:-1,a._pf._overflowDayOfYear&&(ob>b||b>qb)&&(b=qb),a._pf.overflow=b)}function z(a){return null==a._isValid&&(a._isValid=!isNaN(a._d.getTime())&&a._pf.overflow<0&&!a._pf.empty&&!a._pf.invalidMonth&&!a._pf.nullInput&&!a._pf.invalidFormat&&!a._pf.userInvalidated,a._strict&&(a._isValid=a._isValid&&0===a._pf.charsLeftOver&&0===a._pf.unusedTokens.length)),a._isValid}function A(a){return a?a.toLowerCase().replace("_","-"):a}function B(a,b){return b._isUTC?ib(a).zone(b._offset||0):ib(a).local()}function C(a,b){return b.abbr=a,vb[a]||(vb[a]=new f),vb[a].set(b),vb[a]}function D(a){delete vb[a]}function E(a){var b,c,d,e,f=0,g=function(a){if(!vb[a]&&xb)try{require("./lang/"+a)}catch(b){}return vb[a]};if(!a)return ib.fn._lang;if(!n(a)){if(c=g(a))return c;a=[a]}for(;f<a.length;){for(e=A(a[f]).split("-"),b=e.length,d=A(a[f+1]),d=d?d.split("-"):null;b>0;){if(c=g(e.slice(0,b).join("-")))return c;if(d&&d.length>=b&&p(e,d,!0)>=b-1)break;b--}f++}return ib.fn._lang}function F(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function G(a){var b,c,d=a.match(Bb);for(b=0,c=d.length;c>b;b++)d[b]=cc[d[b]]?cc[d[b]]:F(d[b]);return function(e){var f="";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function H(a,b){return a.isValid()?(b=I(b,a.lang()),_b[b]||(_b[b]=G(b)),_b[b](a)):a.lang().invalidDate()}function I(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Cb.lastIndex=0;d>=0&&Cb.test(a);)a=a.replace(Cb,c),Cb.lastIndex=0,d-=1;return a}function J(a,b){var c,d=b._strict;switch(a){case"Q":return Nb;case"DDDD":return Pb;case"YYYY":case"GGGG":case"gggg":return d?Qb:Fb;case"Y":case"G":case"g":return Sb;case"YYYYYY":case"YYYYY":case"GGGGG":case"ggggg":return d?Rb:Gb;case"S":if(d)return Nb;case"SS":if(d)return Ob;case"SSS":if(d)return Pb;case"DDD":return Eb;case"MMM":case"MMMM":case"dd":case"ddd":case"dddd":return Ib;case"a":case"A":return E(b._l)._meridiemParse;case"X":return Lb;case"Z":case"ZZ":return Jb;case"T":return Kb;case"SSSS":return Hb;case"MM":case"DD":case"YY":case"GG":case"gg":case"HH":case"hh":case"mm":case"ss":case"ww":case"WW":return d?Ob:Db;case"M":case"D":case"d":case"H":case"h":case"m":case"s":case"w":case"W":case"e":case"E":return Db;case"Do":return Mb;default:return c=new RegExp(R(Q(a.replace("\\","")),"i"))}}function K(a){a=a||"";var b=a.match(Jb)||[],c=b[b.length-1]||[],d=(c+"").match(Xb)||["-",0,0],e=+(60*d[1])+t(d[2]);return"+"===d[0]?-e:e}function L(a,b,c){var d,e=c._a;switch(a){case"Q":null!=b&&(e[pb]=3*(t(b)-1));break;case"M":case"MM":null!=b&&(e[pb]=t(b)-1);break;case"MMM":case"MMMM":d=E(c._l).monthsParse(b),null!=d?e[pb]=d:c._pf.invalidMonth=b;break;case"D":case"DD":null!=b&&(e[qb]=t(b));break;case"Do":null!=b&&(e[qb]=t(parseInt(b,10)));break;case"DDD":case"DDDD":null!=b&&(c._dayOfYear=t(b));break;case"YY":e[ob]=ib.parseTwoDigitYear(b);break;case"YYYY":case"YYYYY":case"YYYYYY":e[ob]=t(b);break;case"a":case"A":c._isPm=E(c._l).isPM(b);break;case"H":case"HH":case"h":case"hh":e[rb]=t(b);break;case"m":case"mm":e[sb]=t(b);break;case"s":case"ss":e[tb]=t(b);break;case"S":case"SS":case"SSS":case"SSSS":e[ub]=t(1e3*("0."+b));break;case"X":c._d=new Date(1e3*parseFloat(b));break;case"Z":case"ZZ":c._useUTC=!0,c._tzm=K(b);break;case"w":case"ww":case"W":case"WW":case"d":case"dd":case"ddd":case"dddd":case"e":case"E":a=a.substr(0,1);case"gg":case"gggg":case"GG":case"GGGG":case"GGGGG":a=a.substr(0,2),b&&(c._w=c._w||{},c._w[a]=b)}}function M(a){var b,c,d,e,f,g,h,i,j,k,l=[];if(!a._d){for(d=O(a),a._w&&null==a._a[qb]&&null==a._a[pb]&&(f=function(b){var c=parseInt(b,10);return b?b.length<3?c>68?1900+c:2e3+c:c:null==a._a[ob]?ib().weekYear():a._a[ob]},g=a._w,null!=g.GG||null!=g.W||null!=g.E?h=_(f(g.GG),g.W||1,g.E,4,1):(i=E(a._l),j=null!=g.d?X(g.d,i):null!=g.e?parseInt(g.e,10)+i._week.dow:0,k=parseInt(g.w,10)||1,null!=g.d&&j<i._week.dow&&k++,h=_(f(g.gg),k,j,i._week.doy,i._week.dow)),a._a[ob]=h.year,a._dayOfYear=h.dayOfYear),a._dayOfYear&&(e=null==a._a[ob]?d[ob]:a._a[ob],a._dayOfYear>w(e)&&(a._pf._overflowDayOfYear=!0),c=W(e,0,a._dayOfYear),a._a[pb]=c.getUTCMonth(),a._a[qb]=c.getUTCDate()),b=0;3>b&&null==a._a[b];++b)a._a[b]=l[b]=d[b];for(;7>b;b++)a._a[b]=l[b]=null==a._a[b]?2===b?1:0:a._a[b];l[rb]+=t((a._tzm||0)/60),l[sb]+=t((a._tzm||0)%60),a._d=(a._useUTC?W:V).apply(null,l)}}function N(a){var b;a._d||(b=r(a._i),a._a=[b.year,b.month,b.day,b.hour,b.minute,b.second,b.millisecond],M(a))}function O(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function P(a){a._a=[],a._pf.empty=!0;var b,c,d,e,f,g=E(a._l),h=""+a._i,i=h.length,j=0;for(d=I(a._f,g).match(Bb)||[],b=0;b<d.length;b++)e=d[b],c=(h.match(J(e,a))||[])[0],c&&(f=h.substr(0,h.indexOf(c)),f.length>0&&a._pf.unusedInput.push(f),h=h.slice(h.indexOf(c)+c.length),j+=c.length),cc[e]?(c?a._pf.empty=!1:a._pf.unusedTokens.push(e),L(e,c,a)):a._strict&&!c&&a._pf.unusedTokens.push(e);a._pf.charsLeftOver=i-j,h.length>0&&a._pf.unusedInput.push(h),a._isPm&&a._a[rb]<12&&(a._a[rb]+=12),a._isPm===!1&&12===a._a[rb]&&(a._a[rb]=0),M(a),y(a)}function Q(a){return a.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e})}function R(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function S(a){var c,d,e,f,g;if(0===a._f.length)return a._pf.invalidFormat=!0,void(a._d=new Date(0/0));for(f=0;f<a._f.length;f++)g=0,c=i({},a),c._pf=b(),c._f=a._f[f],P(c),z(c)&&(g+=c._pf.charsLeftOver,g+=10*c._pf.unusedTokens.length,c._pf.score=g,(null==e||e>g)&&(e=g,d=c));i(a,d||c)}function T(a){var b,c,d=a._i,e=Tb.exec(d);if(e){for(a._pf.iso=!0,b=0,c=Vb.length;c>b;b++)if(Vb[b][1].exec(d)){a._f=Vb[b][0]+(e[6]||" ");break}for(b=0,c=Wb.length;c>b;b++)if(Wb[b][1].exec(d)){a._f+=Wb[b][0];break}d.match(Jb)&&(a._f+="Z"),P(a)}else ib.createFromInputFallback(a)}function U(b){var c=b._i,d=yb.exec(c);c===a?b._d=new Date:d?b._d=new Date(+d[1]):"string"==typeof c?T(b):n(c)?(b._a=c.slice(0),M(b)):o(c)?b._d=new Date(+c):"object"==typeof c?N(b):"number"==typeof c?b._d=new Date(c):ib.createFromInputFallback(b)}function V(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970>a&&h.setFullYear(a),h}function W(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970>a&&b.setUTCFullYear(a),b}function X(a,b){if("string"==typeof a)if(isNaN(a)){if(a=b.weekdaysParse(a),"number"!=typeof a)return null}else a=parseInt(a,10);return a}function Y(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function Z(a,b,c){var d=nb(Math.abs(a)/1e3),e=nb(d/60),f=nb(e/60),g=nb(f/24),h=nb(g/365),i=45>d&&["s",d]||1===e&&["m"]||45>e&&["mm",e]||1===f&&["h"]||22>f&&["hh",f]||1===g&&["d"]||25>=g&&["dd",g]||45>=g&&["M"]||345>g&&["MM",nb(g/30)]||1===h&&["y"]||["yy",h];return i[2]=b,i[3]=a>0,i[4]=c,Y.apply({},i)}function $(a,b,c){var d,e=c-b,f=c-a.day();return f>e&&(f-=7),e-7>f&&(f+=7),d=ib(a).add("d",f),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function _(a,b,c,d,e){var f,g,h=W(a,0,1).getUTCDay();return c=null!=c?c:e,f=e-h+(h>d?7:0)-(e>h?7:0),g=7*(b-1)+(c-e)+f+1,{year:g>0?a:a-1,dayOfYear:g>0?g:w(a-1)+g}}function ab(b){var c=b._i,d=b._f;return null===c||d===a&&""===c?ib.invalid({nullInput:!0}):("string"==typeof c&&(b._i=c=E().preparse(c)),ib.isMoment(c)?(b=j(c),b._d=new Date(+c._d)):d?n(d)?S(b):P(b):U(b),new g(b))}function bb(a,b){var c;return"string"==typeof b&&(b=a.lang().monthsParse(b),"number"!=typeof b)?a:(c=Math.min(a.date(),u(a.year(),b)),a._d["set"+(a._isUTC?"UTC":"")+"Month"](b,c),a)}function cb(a,b){return a._d["get"+(a._isUTC?"UTC":"")+b]()}function db(a,b,c){return"Month"===b?bb(a,c):a._d["set"+(a._isUTC?"UTC":"")+b](c)}function eb(a,b){return function(c){return null!=c?(db(this,a,c),ib.updateOffset(this,b),this):cb(this,a)}}function fb(a){ib.duration.fn[a]=function(){return this._data[a]}}function gb(a,b){ib.duration.fn["as"+a]=function(){return+this/b}}function hb(a){"undefined"==typeof ender&&(jb=mb.moment,mb.moment=a?c("Accessing Moment through the global scope is deprecated, and will be removed in an upcoming release.",ib):ib)}for(var ib,jb,kb,lb="2.6.0",mb="undefined"!=typeof global?global:this,nb=Math.round,ob=0,pb=1,qb=2,rb=3,sb=4,tb=5,ub=6,vb={},wb={_isAMomentObject:null,_i:null,_f:null,_l:null,_strict:null,_isUTC:null,_offset:null,_pf:null,_lang:null},xb="undefined"!=typeof module&&module.exports,yb=/^\/?Date\((\-?\d+)/i,zb=/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,Ab=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,Bb=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,Cb=/(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,Db=/\d\d?/,Eb=/\d{1,3}/,Fb=/\d{1,4}/,Gb=/[+\-]?\d{1,6}/,Hb=/\d+/,Ib=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,Jb=/Z|[\+\-]\d\d:?\d\d/gi,Kb=/T/i,Lb=/[\+\-]?\d+(\.\d{1,3})?/,Mb=/\d{1,2}/,Nb=/\d/,Ob=/\d\d/,Pb=/\d{3}/,Qb=/\d{4}/,Rb=/[+-]?\d{6}/,Sb=/[+-]?\d+/,Tb=/^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Ub="YYYY-MM-DDTHH:mm:ssZ",Vb=[["YYYYYY-MM-DD",/[+-]\d{6}-\d{2}-\d{2}/],["YYYY-MM-DD",/\d{4}-\d{2}-\d{2}/],["GGGG-[W]WW-E",/\d{4}-W\d{2}-\d/],["GGGG-[W]WW",/\d{4}-W\d{2}/],["YYYY-DDD",/\d{4}-\d{3}/]],Wb=[["HH:mm:ss.SSSS",/(T| )\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],Xb=/([\+\-]|\d\d)/gi,Yb=("Date|Hours|Minutes|Seconds|Milliseconds".split("|"),{Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6}),Zb={ms:"millisecond",s:"second",m:"minute",h:"hour",d:"day",D:"date",w:"week",W:"isoWeek",M:"month",Q:"quarter",y:"year",DDD:"dayOfYear",e:"weekday",E:"isoWeekday",gg:"weekYear",GG:"isoWeekYear"},$b={dayofyear:"dayOfYear",isoweekday:"isoWeekday",isoweek:"isoWeek",weekyear:"weekYear",isoweekyear:"isoWeekYear"},_b={},ac="DDD w W M D d".split(" "),bc="M D H h m s w W".split(" "),cc={M:function(){return this.month()+1},MMM:function(a){return this.lang().monthsShort(this,a)},MMMM:function(a){return this.lang().months(this,a)},D:function(){return this.date()},DDD:function(){return this.dayOfYear()},d:function(){return this.day()},dd:function(a){return this.lang().weekdaysMin(this,a)},ddd:function(a){return this.lang().weekdaysShort(this,a)},dddd:function(a){return this.lang().weekdays(this,a)},w:function(){return this.week()},W:function(){return this.isoWeek()},YY:function(){return l(this.year()%100,2)},YYYY:function(){return l(this.year(),4)},YYYYY:function(){return l(this.year(),5)},YYYYYY:function(){var a=this.year(),b=a>=0?"+":"-";return b+l(Math.abs(a),6)},gg:function(){return l(this.weekYear()%100,2)},gggg:function(){return l(this.weekYear(),4)},ggggg:function(){return l(this.weekYear(),5)},GG:function(){return l(this.isoWeekYear()%100,2)},GGGG:function(){return l(this.isoWeekYear(),4)},GGGGG:function(){return l(this.isoWeekYear(),5)},e:function(){return this.weekday()},E:function(){return this.isoWeekday()},a:function(){return this.lang().meridiem(this.hours(),this.minutes(),!0)},A:function(){return this.lang().meridiem(this.hours(),this.minutes(),!1)},H:function(){return this.hours()},h:function(){return this.hours()%12||12},m:function(){return this.minutes()},s:function(){return this.seconds()},S:function(){return t(this.milliseconds()/100)},SS:function(){return l(t(this.milliseconds()/10),2)},SSS:function(){return l(this.milliseconds(),3)},SSSS:function(){return l(this.milliseconds(),3)},Z:function(){var a=-this.zone(),b="+";return 0>a&&(a=-a,b="-"),b+l(t(a/60),2)+":"+l(t(a)%60,2)},ZZ:function(){var a=-this.zone(),b="+";return 0>a&&(a=-a,b="-"),b+l(t(a/60),2)+l(t(a)%60,2)},z:function(){return this.zoneAbbr()},zz:function(){return this.zoneName()},X:function(){return this.unix()},Q:function(){return this.quarter()}},dc=["months","monthsShort","weekdays","weekdaysShort","weekdaysMin"];ac.length;)kb=ac.pop(),cc[kb+"o"]=e(cc[kb],kb);for(;bc.length;)kb=bc.pop(),cc[kb+kb]=d(cc[kb],2);for(cc.DDDD=d(cc.DDD,3),i(f.prototype,{set:function(a){var b,c;for(c in a)b=a[c],"function"==typeof b?this[c]=b:this["_"+c]=b},_months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),months:function(a){return this._months[a.month()]},_monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),monthsShort:function(a){return this._monthsShort[a.month()]},monthsParse:function(a){var b,c,d;for(this._monthsParse||(this._monthsParse=[]),b=0;12>b;b++)if(this._monthsParse[b]||(c=ib.utc([2e3,b]),d="^"+this.months(c,"")+"|^"+this.monthsShort(c,""),this._monthsParse[b]=new RegExp(d.replace(".",""),"i")),this._monthsParse[b].test(a))return b},_weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdays:function(a){return this._weekdays[a.day()]},_weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysShort:function(a){return this._weekdaysShort[a.day()]},_weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),weekdaysMin:function(a){return this._weekdaysMin[a.day()]},weekdaysParse:function(a){var b,c,d;for(this._weekdaysParse||(this._weekdaysParse=[]),b=0;7>b;b++)if(this._weekdaysParse[b]||(c=ib([2e3,1]).day(b),d="^"+this.weekdays(c,"")+"|^"+this.weekdaysShort(c,"")+"|^"+this.weekdaysMin(c,""),this._weekdaysParse[b]=new RegExp(d.replace(".",""),"i")),this._weekdaysParse[b].test(a))return b},_longDateFormat:{LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D YYYY",LLL:"MMMM D YYYY LT",LLLL:"dddd, MMMM D YYYY LT"},longDateFormat:function(a){var b=this._longDateFormat[a];return!b&&this._longDateFormat[a.toUpperCase()]&&(b=this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a]=b),b},isPM:function(a){return"p"===(a+"").toLowerCase().charAt(0)},_meridiemParse:/[ap]\.?m?\.?/i,meridiem:function(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"},_calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},calendar:function(a,b){var c=this._calendar[a];return"function"==typeof c?c.apply(b):c},_relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},relativeTime:function(a,b,c,d){var e=this._relativeTime[c];return"function"==typeof e?e(a,b,c,d):e.replace(/%d/i,a)},pastFuture:function(a,b){var c=this._relativeTime[a>0?"future":"past"];return"function"==typeof c?c(b):c.replace(/%s/i,b)},ordinal:function(a){return this._ordinal.replace("%d",a)},_ordinal:"%d",preparse:function(a){return a},postformat:function(a){return a},week:function(a){return $(a,this._week.dow,this._week.doy).week},_week:{dow:0,doy:6},_invalidDate:"Invalid date",invalidDate:function(){return this._invalidDate}}),ib=function(c,d,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._i=c,g._f=d,g._l=e,g._strict=f,g._isUTC=!1,g._pf=b(),ab(g)},ib.suppressDeprecationWarnings=!1,ib.createFromInputFallback=c("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.",function(a){a._d=new Date(a._i)}),ib.utc=function(c,d,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._useUTC=!0,g._isUTC=!0,g._l=e,g._i=c,g._f=d,g._strict=f,g._pf=b(),ab(g).utc()},ib.unix=function(a){return ib(1e3*a)},ib.duration=function(a,b){var c,d,e,f=a,g=null;return ib.isDuration(a)?f={ms:a._milliseconds,d:a._days,M:a._months}:"number"==typeof a?(f={},b?f[b]=a:f.milliseconds=a):(g=zb.exec(a))?(c="-"===g[1]?-1:1,f={y:0,d:t(g[qb])*c,h:t(g[rb])*c,m:t(g[sb])*c,s:t(g[tb])*c,ms:t(g[ub])*c}):(g=Ab.exec(a))&&(c="-"===g[1]?-1:1,e=function(a){var b=a&&parseFloat(a.replace(",","."));return(isNaN(b)?0:b)*c},f={y:e(g[2]),M:e(g[3]),d:e(g[4]),h:e(g[5]),m:e(g[6]),s:e(g[7]),w:e(g[8])}),d=new h(f),ib.isDuration(a)&&a.hasOwnProperty("_lang")&&(d._lang=a._lang),d},ib.version=lb,ib.defaultFormat=Ub,ib.momentProperties=wb,ib.updateOffset=function(){},ib.lang=function(a,b){var c;return a?(b?C(A(a),b):null===b?(D(a),a="en"):vb[a]||E(a),c=ib.duration.fn._lang=ib.fn._lang=E(a),c._abbr):ib.fn._lang._abbr},ib.langData=function(a){return a&&a._lang&&a._lang._abbr&&(a=a._lang._abbr),E(a)},ib.isMoment=function(a){return a instanceof g||null!=a&&a.hasOwnProperty("_isAMomentObject")},ib.isDuration=function(a){return a instanceof h},kb=dc.length-1;kb>=0;--kb)s(dc[kb]);ib.normalizeUnits=function(a){return q(a)},ib.invalid=function(a){var b=ib.utc(0/0);return null!=a?i(b._pf,a):b._pf.userInvalidated=!0,b},ib.parseZone=function(){return ib.apply(null,arguments).parseZone()},ib.parseTwoDigitYear=function(a){return t(a)+(t(a)>68?1900:2e3)},i(ib.fn=g.prototype,{clone:function(){return ib(this)},valueOf:function(){return+this._d+6e4*(this._offset||0)},unix:function(){return Math.floor(+this/1e3)},toString:function(){return this.clone().lang("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},toDate:function(){return this._offset?new Date(+this):this._d},toISOString:function(){var a=ib(this).utc();return 0<a.year()&&a.year()<=9999?H(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):H(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")},toArray:function(){var a=this;return[a.year(),a.month(),a.date(),a.hours(),a.minutes(),a.seconds(),a.milliseconds()]},isValid:function(){return z(this)},isDSTShifted:function(){return this._a?this.isValid()&&p(this._a,(this._isUTC?ib.utc(this._a):ib(this._a)).toArray())>0:!1},parsingFlags:function(){return i({},this._pf)},invalidAt:function(){return this._pf.overflow},utc:function(){return this.zone(0)},local:function(){return this.zone(0),this._isUTC=!1,this},format:function(a){var b=H(this,a||ib.defaultFormat);return this.lang().postformat(b)},add:function(a,b){var c;return c="string"==typeof a?ib.duration(+b,a):ib.duration(a,b),m(this,c,1),this},subtract:function(a,b){var c;return c="string"==typeof a?ib.duration(+b,a):ib.duration(a,b),m(this,c,-1),this},diff:function(a,b,c){var d,e,f=B(a,this),g=6e4*(this.zone()-f.zone());return b=q(b),"year"===b||"month"===b?(d=432e5*(this.daysInMonth()+f.daysInMonth()),e=12*(this.year()-f.year())+(this.month()-f.month()),e+=(this-ib(this).startOf("month")-(f-ib(f).startOf("month")))/d,e-=6e4*(this.zone()-ib(this).startOf("month").zone()-(f.zone()-ib(f).startOf("month").zone()))/d,"year"===b&&(e/=12)):(d=this-f,e="second"===b?d/1e3:"minute"===b?d/6e4:"hour"===b?d/36e5:"day"===b?(d-g)/864e5:"week"===b?(d-g)/6048e5:d),c?e:k(e)},from:function(a,b){return ib.duration(this.diff(a)).lang(this.lang()._abbr).humanize(!b)},fromNow:function(a){return this.from(ib(),a)},calendar:function(){var a=B(ib(),this).startOf("day"),b=this.diff(a,"days",!0),c=-6>b?"sameElse":-1>b?"lastWeek":0>b?"lastDay":1>b?"sameDay":2>b?"nextDay":7>b?"nextWeek":"sameElse";return this.format(this.lang().calendar(c,this))},isLeapYear:function(){return x(this.year())},isDST:function(){return this.zone()<this.clone().month(0).zone()||this.zone()<this.clone().month(5).zone()},day:function(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=X(a,this.lang()),this.add({d:a-b})):b},month:eb("Month",!0),startOf:function(a){switch(a=q(a)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===a?this.weekday(0):"isoWeek"===a&&this.isoWeekday(1),"quarter"===a&&this.month(3*Math.floor(this.month()/3)),this},endOf:function(a){return a=q(a),this.startOf(a).add("isoWeek"===a?"week":a,1).subtract("ms",1)},isAfter:function(a,b){return b="undefined"!=typeof b?b:"millisecond",+this.clone().startOf(b)>+ib(a).startOf(b)},isBefore:function(a,b){return b="undefined"!=typeof b?b:"millisecond",+this.clone().startOf(b)<+ib(a).startOf(b)},isSame:function(a,b){return b=b||"ms",+this.clone().startOf(b)===+B(a,this).startOf(b)},min:function(a){return a=ib.apply(null,arguments),this>a?this:a},max:function(a){return a=ib.apply(null,arguments),a>this?this:a},zone:function(a,b){var c=this._offset||0;return null==a?this._isUTC?c:this._d.getTimezoneOffset():("string"==typeof a&&(a=K(a)),Math.abs(a)<16&&(a=60*a),this._offset=a,this._isUTC=!0,c!==a&&(!b||this._changeInProgress?m(this,ib.duration(c-a,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,ib.updateOffset(this,!0),this._changeInProgress=null)),this)},zoneAbbr:function(){return this._isUTC?"UTC":""},zoneName:function(){return this._isUTC?"Coordinated Universal Time":""},parseZone:function(){return this._tzm?this.zone(this._tzm):"string"==typeof this._i&&this.zone(this._i),this},hasAlignedHourOffset:function(a){return a=a?ib(a).zone():0,(this.zone()-a)%60===0},daysInMonth:function(){return u(this.year(),this.month())},dayOfYear:function(a){var b=nb((ib(this).startOf("day")-ib(this).startOf("year"))/864e5)+1;return null==a?b:this.add("d",a-b)},quarter:function(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)},weekYear:function(a){var b=$(this,this.lang()._week.dow,this.lang()._week.doy).year;return null==a?b:this.add("y",a-b)},isoWeekYear:function(a){var b=$(this,1,4).year;return null==a?b:this.add("y",a-b)},week:function(a){var b=this.lang().week(this);return null==a?b:this.add("d",7*(a-b))},isoWeek:function(a){var b=$(this,1,4).week;return null==a?b:this.add("d",7*(a-b))},weekday:function(a){var b=(this.day()+7-this.lang()._week.dow)%7;return null==a?b:this.add("d",a-b)},isoWeekday:function(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)},isoWeeksInYear:function(){return v(this.year(),1,4)},weeksInYear:function(){var a=this._lang._week;return v(this.year(),a.dow,a.doy)},get:function(a){return a=q(a),this[a]()},set:function(a,b){return a=q(a),"function"==typeof this[a]&&this[a](b),this},lang:function(b){return b===a?this._lang:(this._lang=E(b),this)}}),ib.fn.millisecond=ib.fn.milliseconds=eb("Milliseconds",!1),ib.fn.second=ib.fn.seconds=eb("Seconds",!1),ib.fn.minute=ib.fn.minutes=eb("Minutes",!1),ib.fn.hour=ib.fn.hours=eb("Hours",!0),ib.fn.date=eb("Date",!0),ib.fn.dates=c("dates accessor is deprecated. Use date instead.",eb("Date",!0)),ib.fn.year=eb("FullYear",!0),ib.fn.years=c("years accessor is deprecated. Use year instead.",eb("FullYear",!0)),ib.fn.days=ib.fn.day,ib.fn.months=ib.fn.month,ib.fn.weeks=ib.fn.week,ib.fn.isoWeeks=ib.fn.isoWeek,ib.fn.quarters=ib.fn.quarter,ib.fn.toJSON=ib.fn.toISOString,i(ib.duration.fn=h.prototype,{_bubble:function(){var a,b,c,d,e=this._milliseconds,f=this._days,g=this._months,h=this._data;h.milliseconds=e%1e3,a=k(e/1e3),h.seconds=a%60,b=k(a/60),h.minutes=b%60,c=k(b/60),h.hours=c%24,f+=k(c/24),h.days=f%30,g+=k(f/30),h.months=g%12,d=k(g/12),h.years=d},weeks:function(){return k(this.days()/7)},valueOf:function(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*t(this._months/12)},humanize:function(a){var b=+this,c=Z(b,!a,this.lang());return a&&(c=this.lang().pastFuture(b,c)),this.lang().postformat(c)},add:function(a,b){var c=ib.duration(a,b);return this._milliseconds+=c._milliseconds,this._days+=c._days,this._months+=c._months,this._bubble(),this},subtract:function(a,b){var c=ib.duration(a,b);return this._milliseconds-=c._milliseconds,this._days-=c._days,this._months-=c._months,this._bubble(),this},get:function(a){return a=q(a),this[a.toLowerCase()+"s"]()},as:function(a){return a=q(a),this["as"+a.charAt(0).toUpperCase()+a.slice(1)+"s"]()},lang:ib.fn.lang,toIsoString:function(){var a=Math.abs(this.years()),b=Math.abs(this.months()),c=Math.abs(this.days()),d=Math.abs(this.hours()),e=Math.abs(this.minutes()),f=Math.abs(this.seconds()+this.milliseconds()/1e3);return this.asSeconds()?(this.asSeconds()<0?"-":"")+"P"+(a?a+"Y":"")+(b?b+"M":"")+(c?c+"D":"")+(d||e||f?"T":"")+(d?d+"H":"")+(e?e+"M":"")+(f?f+"S":""):"P0D"}});for(kb in Yb)Yb.hasOwnProperty(kb)&&(gb(kb,Yb[kb]),fb(kb.toLowerCase()));gb("Weeks",6048e5),ib.duration.fn.asMonths=function(){return(+this-31536e6*this.years())/2592e6+12*this.years()},ib.lang("en",{ordinal:function(a){var b=a%10,c=1===t(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),xb?module.exports=ib:"function"==typeof define&&define.amd?(define("moment",function(a,b,c){return c.config&&c.config()&&c.config().noGlobal===!0&&(mb.moment=jb),ib}),hb(!0)):hb()}).call(this);
// End moment.js

var cacheDebugLog = false;

var CacheUtils = function() {

};

CacheUtils.getCachedOrRun = function(cKey, runFunction) {
    var retItem = getStoredData(cKey,true);

    if (retItem != null) {
        //        console.log("@removeLog: found :: " + cKey + " :: " + retItem);
        return JSON.parse(retItem);
    } else {
        //        console.log("@removeLog: creating :: " + cKey);
        var runFunctionReturnVal = runFunction();

        storeData(cKey, JSON.stringify(runFunctionReturnVal),true);
        //        console.log("@removeLog: created :: " + cKey + " :: " + runFunctionReturnVal);
        return runFunctionReturnVal;
    }
}



//Encrypt using google crypto-js AES-base cypher
var key = "6Le0DgMTAAAAANokdfEial"; //length=22
var iv  = "mHGFxENnZLbienLyALoi.e"; //length=22
var keyB;
var ivB;

function encryptSimple(clearTxt) {
    keyB = thirdparty.CryptoJS.enc.Base64.parse(key);
    ivB = thirdparty.CryptoJS.enc.Base64.parse(iv);
    var encrypted = thirdparty.CryptoJS.AES.encrypt(clearTxt, keyB, { iv: ivB });
    var encryptedString = encrypted.toString();
    return encryptedString;
}

function decryptSimple(encryptedTxt) {
    keyB = thirdparty.CryptoJS.enc.Base64.parse(key);
    ivB = thirdparty.CryptoJS.enc.Base64.parse(iv);
    var decrypted = thirdparty.CryptoJS.AES.decrypt(encryptedTxt, keyB, { iv: ivB });
    var decryptedText = decrypted.toString(thirdparty.CryptoJS.enc.Utf8);
    return decryptedText;
}


// ------------------------- Interact with local storage via interface
// We can't always reply on HTML5 window.localStorage
// Sample Write :
//  storeData('name','nico') 
//  storeData('sensitive','secret0r',true)
// Sample Read: 
//  getStoredData('name')
//  getStoredData('sensitive',,true)
// removeStoredData('name')
// clearAllData();

function storeData(key,value,encrypt){
   // if(key ==='mnemonic') console.error(value);
    if(typeof key !== 'undefined' && typeof value !== 'undefined'){ //Check inputs
        var valueToStore = (encrypt == true) ? encryptSimple(value) : value; //Encrypt if needed
        //console.log('Request to store entry on local db - key:' + key + ' ; valueToStore:'+valueToStore+' encrypted:'+encrypt);

        //Basic implementation : use HTML local storage
        //@TODO other platform-specific implementations

        window.localStorage.setItem(key,valueToStore);
    }
    else {
        console.log('storeData() : error in the request - key:' + key + ' ; valueToStore:'+valueToStore+' encrypted:'+encrypt);
    }
}

function getStoredData(key,decrypt){
  //  if(key ==='mnemonic') console.error(key);
    if(typeof key !== 'undefined'){
        //console.log('Requested locally stored entry : ' + key );
        var value ;

        //Simple implementation 
        //@TODO other platform-specific implementations
        value = window.localStorage.getItem(key); 

        //Check if exists
        if (typeof value == 'undefined' || !value) {
            if (cacheDebugLog === true) {
                console.log('getStoredData :: Cannot find an entry for :: ' + key);
            }
            
            return null;
        }

        //Decrypt if necessary
        value = (decrypt == true) ? decryptSimple(value) : value;

        return value;
    }
    else {
        console.log('getStoredData() : error in the request - key is undefined');
    }
}



function removeStoredData(key){
    if(typeof key !== 'undefined'){
        //console.log('Requested locally stored entry : ' + key );

        //Simple implementation 
        //@TODO other platform-specific implementations
        value = window.localStorage.getItem(key); 

        //Check if exists
        if(typeof value == 'undefined' || !value){
            console.log('Cannot find an entry for : ' + key );
            return null;
        }

        if (cacheDebugLog === true) {
            console.log('Removing from storage : '+key+ ':'+value.substr(0,10)+'...');
        }
        window.localStorage.removeItem(key);

    }
    else {
        console.log('getStoredData() : error in the request - key is undefined');
    }
}

function clearAllData(){ //TODO
    //Basic implementation : using HTML local storage 
    //@TODO other platform-specific implementations
    if (cacheDebugLog === true) {
        console.log('Clearing all data!');
    }
    window.localStorage.clear();
}



// -------------------------END storage utils

//@note: @todo: @here: this needs to be somewhere proper.

//--------------------------Validate private keys utils

//returns true if starts with 0x
function isValidETHAddress(testString){
    var patt = new RegExp(/^[a-f0-9]{40}$/i);
    return patt.test(testString.substring(2)) && testString.substring(0, 2) == '0x'; 
}


function isValidETHPrivateKey(text){
    var patt = new RegExp(/^[a-f0-9]{64}$/i);
    return patt.test(text);
}


function isValidBTCPrivateKey(text, networkDef){
    //@note: @here: @todo: remove global NETWORK references.
    if (typeof(networkDef) === 'undefined' || networkDef === null) {
        networkDef = NETWORK;
    }
    var valid = false;
    try {
        var keypair = thirdparty.bitcoin.ECPair.fromWIF(text, networkDef);
        if (keypair) { valid = true; }
    } catch (err) {
        valid = false;
    }
    return valid;
}


//--------------------------END Validate keys utils

//--------------------------BIP38 utils

//temp variables used by async processes
var bip38KeyToDecrypt = "" ;
var bip38passphrase = "";

//Use this function to decrypt: will load bip38-dist.js async
function tryToDecryptBIP38KeyAsync(key,passphrase){
    bip38KeyToDecrypt = key;
    bip38passphrase = passphrase;
    loadScript('js/thirdparty/bip38-dist.js', callBackOnLoadBIP38, callBackOnErrLoadBIP38); 
}

function callBackOnLoadBIP38Internal(){
    console.log("Loaded BIP38 js library.")
}

function callBackOnLoadBIP38(){
    if(isValidBIP38key(bip38KeyToDecrypt)) {
        if(bip38passphrase!=null){      
            console.log('Unecrypted key (WIF Compressed) :'+ decryptBIP38key(bip38KeyToDecrypt,bip38passphrase)); 
        } else {
            console.log('User did not provided a passphrase');
            return;
        }
    }
    else {
        console.log('Invalid key format, not BIP38 valid.')
    }

    //reset temp variables
    bip38KeyToDecrypt = "";
    bip38passphrase = "";

}

function tryToDecryptBIP38KeySync(key,passphrase){
    if(isValidBIP38key(key)) {
        if(passphrase!=null){  
            var unencrypted =  decryptBIP38key(key,passphrase);
            return unencrypted;
        } else {
            console.log('User did not provided a passphrase');
            return;
        }
    }
    else {
        console.log('Invalid key format, not BIP38 valid.')
    }

}

callBackOnErrLoadBIP38 = function(jqXHR, textStatus, errorThrown) {
    console.log("[ Jaxx :: Error Loading bip38-dist.js :: " + errorThrown + " ]");
    //reset temp variables
    bip38KeyToDecrypt = "";
    bip38passphrase = "";
}


function decryptBIP38key(encryptedKey,passphrase)
{
    var bip38 = new Bip38();

    var privateKeyWif = bip38.decrypt(encryptedKey, passphrase, function (status) {
        $('#bip38Progress').text((status.percent | 0)+"%");
        console.log("Decrypting BIP38 key : "+(status.percent | 0)+"%") // Will print the precent every time current increases by 1000
    });
    return privateKeyWif;
}

function isValidBIP38key(testString)
{
    //58 characters base58, starts with '6P'
    var patt = new RegExp(/^[6P][1-9A-Za-z][^OIl]{56}$/);
    return patt.test(testString); 
}
//--------------------------END BIP38 utils



//--------------------------Decrypt myethereumwallet Private keys  (march2016)

function isValidETHAESkey(testString)
{

    var patt1 = new RegExp(/^[0-9A-Za-z+\/]{132}$/);
    var patt2 = new RegExp(/^[0-9A-Za-z+\/]{128}$/);

    return patt1.test(testString) || patt2.test(testString); 
}



function decryptETHKey(encryptedPrivateKey, passphrase){
    if(encryptedPrivateKey.length==128){
        var privatebytes = CryptoJS.AES.decrypt(encryptedPrivateKey, passphrase);
        var privkey = hexToStr(CryptoJS.enc.Hex.stringify(privatebytes));
    } else if(encryptedPrivateKey.length==132){
        var privatebytes = CryptoJS.AES.decrypt(encryptedPrivateKey.substr(0,128), passphrase);
        var privkey = hexToStr(CryptoJS.enc.Hex.stringify(privatebytes));
        var addressHash = encryptedPrivateKey.substr(encryptedPrivateKey.length-4);

    } else if(encryptedPrivateKey.length==64){
        var privkey = encryptedPrivateKey;
    } else {
        console.log('Error while decrypting the private key');
        return "-1";
    }
    return privkey;
}

function hexToStr(hex) {
    var hex = hex.toString();
    var str = '';
    for (var i = 0; i < hex.length; i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return str;
}



//--------------------------END Decrypt myethereumwallet Private keys 



//--------------Shake function to avoid importing the whole jquery ui library
//By bradleyhamilton

function shake(div){                                                                                                                                                                                            
    var interval = 100;                                                                                                 
    var distance = 10;                                                                                                  
    var times = 4;                                                                                                      

    $(div).css('position','relative');                                                                                  

    for(var iter=0;iter<(times+1);iter++){                                                                              
        $(div).animate({ 
            left:((iter%2==0 ? distance : distance*-1))
        },interval);                                   
    }//for                                                                                                              

    $(div).animate({ left: 0},interval);                                                                                

}//shake       


// -----------------------END ETH smartcontract detection

//clearAllData();
//
//var cVal = CacheUtils.getCachedOrRun('cVal', function() {
//    return 'cheesy'; 
//});
//
//console.log('newc :: ' + cVal);
var JaxxUtils = function() {

}

JaxxUtils.scrubInput = function(inputString) {
    //    console.log("inputString :: " + inputString);
    var mInput = thirdparty.sanitizeHtml(inputString, {
        allowedTags: [ 'h3', 'b', 'strong', 'em', 'ul', 'ol', 'li',  'p', 'br','hr'],
        allowedAttributes: [],
        selfClosing: ['br', 'hr'],
        nonTextTags: [ 'style', 'script', 'textarea', 'noscript' ],
        allowedClasses: {
            'li': ['cssJaxxMainFontColor', 'cssFunThingsColor', 'cssWarningFontColor', 'cssCurrencyFontColor' ],
            'ul': ['cssJaxxMainFontColor', 'cssFunThingsColor', 'cssWarningFontColor', 'cssCurrencyFontColor' ],
            'ol': ['cssJaxxMainFontColor', 'cssFunThingsColor', 'cssWarningFontColor', 'cssCurrencyFontColor' ],
            'p':  ['cssJaxxMainFontColor', 'cssFunThingsColor', 'cssWarningFontColor', 'cssCurrencyFontColor' ],
            'h3':  ['cssJaxxMainFontColor', 'cssFunThingsColor', 'cssWarningFontColor', 'cssCurrencyFontColor' ]
        }

    });
    //        inputString.replace(/<script.*?<\/script>/g, '').replace(/<a.*?<\/a>/g, '');

    if (mInput !== inputString) {
        //        console.log("recurse");
        mInput = JaxxUtils.scrubInput(mInput);
    }

    //    console.log("mInput :: " + mInput);
    return mInput;
}
//@note: @here: super useful for debugging stack traces of objects being hidden/shown
//jQuery(function($) {
//
//    var _oldShow = $.fn.show;
//
//    $.fn.show = function(speed, oldCallback) {
//        return $(this).each(function() {
//            var obj         = $(this),
//                newCallback = function() {
//                    if ($.isFunction(oldCallback)) {
//                        oldCallback.apply(obj);
//                    }
//                    obj.trigger('afterShow');
//                };
//
//            // you can trigger a before show if you want
//            obj.trigger('beforeShow');
//
//            // now use the old function to show the element passing the new callback
//            _oldShow.apply(obj, [speed, newCallback]);
//        });
//    }
//
//    var _oldHide = $.fn.hide;
//
//    $.fn.hide = function(speed, oldCallback) {
//        return $(this).each(function() {
//            var obj         = $(this),
//                newCallback = function() {
//                    if ($.isFunction(oldCallback)) {
//                        oldCallback.apply(obj);
//                    }
//                    obj.trigger('afterHide');
//                };
//
//            // you can trigger a before show if you want
//            obj.trigger('beforeHide');
//
//            // now use the old function to show the element passing the new callback
//            _oldHide.apply(obj, [speed, newCallback]);
//        });
//    }
//});

var JaxxUI = function() {

    this._jaxxUIIntro = new JaxxUIIntro();
    jaxx.Registry.registry['JaxxUIIntro'] = this._jaxxUIIntro;

    // console.warn(this._jaxxUIIntro);

    this._uiTimers = {};

    this._wWidth = 0;
    this._wHeight = 0;

    this._mainMenuIsOpen = false;

    this._numPinEntryFields = 4;
    this._sUI = null;

    this._hasDisplayedJaxxNews = false;

    this._numHistoryElementsDefault = 10;
    this._numHistoryElementsDisplayed = [];

    this._txFullHistory = [];

    this._walletWasChangedInMenu = false;
    this._hasAttachedScriptAction = false;

    this._coinBannerCarousel = null; // Should be not null when the banner carousel has been initialized.
    this._coinBannerCarouselTimeout = null;
    this._coinBannerCarouselAnimationTime = 300;
    this._coinBannerCarouselTimeoutTime = 5000;

    this._coinBannerCarouselDragTimeout = null;

    this.$topCarousel = null;
    this.$topCarouselData = null;

    this._coinDontHover = {} // Example {0: true, 1 : false, ..., NUMCOINTYPES(of whatever its called)}

    //@note: @todo: @here: @next: refactor into JaxxData
    this._jaxxNewsData = null;

    this._criticalVersionUpdatesShown = [];

    this._shouldShowEtcEthSplitIfNoneAvailable = false;

    this._disableETCETHSplitOption = false;

    this._windowsActive = {};

    // Flickity carousel stuff
    this._flickityNotificationFooter = null;

    this._isNotificationFooterOpen = false;

    //pin stuff
    this._correctPINTimeout = false;
    this._incorrectPINTimeout = null;
    this._pinPadResetText = null;
    this._transferPaperWalletCoinType = 0;

    this._mainMenuToggleLocked = false; // Used to surpress events where the menu is locked

    this._defaultPaperWalletMessage = ""; //
    this._isTipsAndTricksShown = false;
    this._debugLockBalanceUpdate = ""; // Used for debugging the balance display.

    this._privateKeysDisplayedInList = [];
    this._strKeyPair = "";

    this._dictWholeNumberFontSize = {1: 41, 2: 41, 3: 41, 4: 38, 5: 38, 6: 38, 7: 30, 8: 30, 9: 30, 10: 30};
    this._dictWholeNumberFontSizeOverride = [{"max-width": 375, "font-dict": {1: 40, 2: 40, 3: 40, 4: 33, 5: 33, 6: 33, 7: 33, 8: 24, 9: 24, 10: 24}}, {"max-width": 360, "font-dict": {1: 37, 2: 37, 3: 37, 4: 33, 5: 33, 6: 31, 7: 29, 8: 25, 9: 24, 10: 22}},{"max-width": 320, "font-dict": {1: 32, 2: 32, 3: 32, 4: 26, 5: 26, 6: 26, 7: 23, 8: 20, 9: 18, 10: 17}}]; // max-width must be in descending order.

    this._release_notes_have_been_shown = false;
    this._jaxxReleaseBulletin = [];
    this._jaxxReleaseBulletinVersions = [];

    this._changeLog = "";
    this._changeLogSummaryInfoFromServer = "";

    this._jaxxCoinBulletin = {};

    this._startJaxxWithTermsOfServicePageWasRun = false;
}



JaxxUI.allWindows = {
    "mainMenuPrimary": false,
    "mainMenuWallets": false,
    "mainMenuCurrencies": false,
};

JaxxUI.runAfterNextFrame = function(callback, passthroughParams) {
    //@note: this causes the tx list to behave strangely.
//    var callbackNextFrame = function() {
    callback(passthroughParams);
//    }
//
//    requestAnimationFrame(callbackNextFrame);
}

JaxxUI.prototype.setWindowActive = function(windowName, status) {
    if (JaxxUI.allWindows.hasOwnProperty(windowName)) {
        this._windowsActive[windowName] = status;
    } else {
        console.log("JaxxUI.setWindowActive :: error :: window :: " + windowName + " doesn't exist in JaxxUI.allWindows");
    }
}

JaxxUI.prototype.getWindowActive = function(windowName) {
    if (JaxxUI.allWindows.hasOwnProperty(windowName)) {
        return this._windowsActive[windowName];
    } else {
        console.log("JaxxUI.setWindowActive :: error :: window :: " + windowName + " doesn't exist in JaxxUI.allWindows");
    }
}

JaxxUI.prototype.reset = function() {
    for (key in JaxxUI.allWindows) {
        this._windowsActive[key] = JaxxUI.allWindows[key];
    }
}

JaxxUI.prototype.initialize = function() {
    console.log("[ Jaxx :: UI Initialize ]");

    if (curProfileMode === PROFILE_LANDSCAPE) {
        this._numHistoryElementsDefault = 20;
    } else {
        this._numHistoryElementsDefault = 10;
    }

    this.attachClickEventsToAllScriptActionElements();

    this._jaxxUIIntro.initialize();

    JaxxUI._sUI = this;

    this._mainPinPadElementName = '';

    this._pinEntryFocus = 0;
    this._f_onPinSuccess = function() {};
    this._f_onPinFailure = function() {};

    this._temporaryPin = '';

    this._miningFeeModalSetup = {};

    this.refreshSizes();
    this.initializeElements();

    this.mainMenuShowMenu();


//    console.log("JaxxUI.allWindows :: " + JSON.stringify(JaxxUI.allWindows, null, 4) + " :: " + Object.keys(JaxxUI.allWindows));

    var allKeys = Object.keys(JaxxUI.allWindows);

    for (var i = 0; i < allKeys.length; i++) {
        var curKey = allKeys[i];

        console.log("change key :: " + key + " :: " + JaxxUI.allWindows[key]);
        this._windowsActive[key] = JaxxUI.allWindows[key];
    }

    this._uiTimers['displayPrivateKey'];
    // this.initializeBTCMiningOptions(wallet);

    this._defaultPaperWalletMessage = $(".settings.confirmSweepPrivateKey .spinner").text();
}

JaxxUI.prototype.UITimer = function(strTimerName, objTimer){
    if (typeof(objTimer) !== 'undefined' && objTimer !== null){
        return this._uiTimers[strTimerName] = objTimer;
    } else {
        return this._uiTimers[strTimerName];
    }
}


JaxxUI.prototype.populateCurrencyList = function(targetCoinType) {
    if(!this.rowsGenerated){
        this.generateSettingsCurrencyRows();
        this.rowsGenerated = true;
    }


    //console.warn('JaxxUI.prototype.populateCurrencyList  ' + targetCoinType);

    if (typeof(targetCoinType) === 'undefined' || targetCoinType === null){
        targetCoinType = curCoinType;
    }

    //if (this.getWindowActive('mainMenuCurrencies')) {
        var activeCurrencies = Registry.getFiatPriceController().getActiveFiatCurrencies();

        var currencylist = $('.exchangeRateList').children().children(); // Gets the table rows.
        for (i = 0; i < currencylist.length; i++){
            var element = currencylist[i];
            // console.log(element);
            var fiatUnit = $(element).attr('value');

            if ($.inArray(fiatUnit, activeCurrencies) > -1) // means it's in the array
            {
                this.toggleCurrencyCheckbox(element);
            }
            //console.log(fiatUnit);
            //var targetElement = $('.cssSetCurrency .cssCurrency').filter('tr[value="' + value + '"]').find('.rate');
            this.populateExchangeRateInMainMenuCurrencyList(targetCoinType, fiatUnit);
            //$(targetElement).text();
        }
   // }
}

JaxxUI.prototype.generateSettingsCurrencyRows = function(){
   // console.warn('generateSettingsCurrencyRows');
    // This function generates the currency position order as well as the html elements for the settings rows.
    // <tr class="currency cssCurrency toggleCurrency scriptAction" value="AUD"><td class="cssSelectedCurrency"><div class="cssCircleUnchecked"></div></td> <td class="cssUnit">AUD</td><td class="name">Australian Dollar</td><td class="rate rateAUD"> </td></tr>
    var self = this;
    var fiatUnitArray = [];
    //var strTableSelector = ''; @TODO: implement this as a refactor.
    // if currency order is stored
    // 		then restore from currency order
    // else
    // 		Get all currency keys as listed from HDWalletHelper.dictFiatCurrency
    var storedCurrencyOrder = getStoredData('currencies_position_order', false);
    if (storedCurrencyOrder) {
        fiatUnitArray = JSON.parse(storedCurrencyOrder);
    } else {
        for (var key in jaxx.FiatPriceController.fiatDictionary){
            //if (jaxx.FiatPriceController.fiatDictionary.hasOwnProperty(key)) { // hasOwnProperty is needed because it's possible to insert keys into the prototype object of dictionary
                fiatUnitArray.push(key);
            //}
        }
    }
    // @TODO: We should push currencies to the array that are not included just as a safeguard (also remove ones that don't exist at all.)
    $('.mainMenuCurrencies .exchangeRateList tbody').empty();
    for (var i = 0; i < fiatUnitArray.length; i++) {
        key = fiatUnitArray[i] // We should expect key to be something like 'CAD'
        if (jaxx.FiatPriceController.fiatDictionary.hasOwnProperty(key)) { // hasOwnProperty is needed because it's possible to insert keys into the prototype object of dictionary
            // 'key' should be something like 'USD'
            // Use HDWalletHelper.dictFiatCurrency['AUD']['name']
            //			console.log(key);
            var column1 = '<td class="cssSelectedCurrency"><div class="cssCircleUnchecked"></div></td>';
            var column2 = '<td class="cssUnitAndCurrency"><div class="cssUnit">'  + key + '</div><div class="name">' +jaxx.FiatPriceController.fiatDictionary[key]['name'] + '</div></td>'
            var column4 = '<td class="rate rate' + key.trim().toUpperCase() + '"></td>';
            var column5 = '<td class="handle cssHandle"><img src="images/dragAndDrop.svg" alt="" height="13" width="13" style="position:absolute; padding-top:12px;"></td>';
            var tableRow = '<tr class="currency cssCurrency scriptAction" value="' + key + '" specialAction="toggleCurrency">' + column1 + column2 + column4 + column5 + '</tr>';
            $('.mainMenuCurrencies .exchangeRateList tbody').append(tableRow);
        } else {
            console.log('Somehow an invalid key was put in.')
        }
    }

    //this.pushCurrencyMainMenuToJaxxSettings();

    // Attach listeners.
    $('.mainMenuCurrencies .exchangeRateList .scriptAction').off();
    $('.mainMenuCurrencies .exchangeRateList .scriptAction').click(function (event) { // Add the scriptAction triggers again.
         scriptAction(event);
    });

    var strSelectorForTable = '.mainMenuCurrencies .exchangeRateList';
    // Make the table sortable.
    $(strSelectorForTable + " tbody").sortable({
        /*items: "> tr:not(:first)",*/
        appendTo: "parent",
        axis: 'y',
        helper: "clone",
        handle: ".handle",
        update: function(event, ui) { // This function runs when we re-order the list.
            // @TODO: Javascript optimization
            self.pushCurrencyMainMenuToJaxxSettings();
            wallet.getHelper().setFiatUnit(g_JaxxApp.getSettings().getDefaultCurrency());
        },
    }).disableSelection();
}

JaxxUI.prototype.refreshSizes = function() {
    var wWidth = window.innerWidth;
    var wHeight = window.innerHeight;

    //console.log("window dimensions inner (width/height) :: " + window.innerWidth + " :: " + window.innerHeight + " :: outer :: " + window.outerWidth + " :: " + window.outerHeight + " :: " + window.width + " :: " + window.height);

    //console.log(JSON.stringify(window));

    //@note: for Android.

    if (wWidth == 0) {
        if (window.native && window.native.getWindowWidth) {
            wWidth = window.native.getWindowWidth();
            wHeight = window.native.getWindowHeight();
            console.log("Android window dimensions (height/width) :: " + wHeight + " :: " + wWidth);
        }
    }

    //    console.log("screen dimensions :: width :: " + wWidth + " :: " + wHeight);

    //    $('.wallet').css('width', '320px');// !important');
    //    $('.wallet').css('height', '568px');// !important');
    //    this._wWidth = 320;
    //    this._wHeight = 568;
    this._wWidth = wWidth;
    this._wHeight = wHeight;
}

JaxxUI.prototype.getWindowWidth = function() {
    //    if (window.native && window.native.getWindowWidth) {
    //        if (curProfileMode == PROFILE_LANDSCAPE) {
    //            return this._wHeight;
    //        } else {
    //            return this._wWidth;
    //        }
    //    } else {
    return this._wWidth;
    //    }
}

JaxxUI.prototype.getWindowHeight = function() {
    //    if (window.native && window.native.getWindowWidth) {
    //        if (curProfileMode == PROFILE_LANDSCAPE) {
    //            return this._wWidth;
    //        } else {
    //            return this._wHeight;
    //        }
    //    } else {
    return this._wHeight;
    //    }
}

JaxxUI.prototype.getLargerScreenDimension = function() {
    if (this._wWidth > this._wHeight) {
        return this._wWidth;
    } else {
        return this._wHeight;
    }
}

JaxxUI.prototype.setupExternalLink = function(element, linkDisplayText, linkAddress) {
    var stringVersion = null;

    if (element) {
        element.data('linkToExplorer',linkAddress);
        console.log("A :: for element :: " + element + " :: trying :: " + linkAddress + " :: " + linkDisplayText)
        // //test browser env, simple href
        // if(!PlatformUtils.mobileCheck() && !PlatformUtils.extensionCheck() && !PlatformUtils.desktopCheck() ){
        //     element.html("<a href=\"" + linkAddress + "\" target=\"_blank\">" + linkDisplayText + "</a>");
        // }
        // else if(PlatformUtils.extensionChromeCheck() || PlatformUtils.extensionFirefoxCheck()) { //ChromeExt doesn't support inline js.
        //     //Possible Workaround #1 : use an href with target blank.
        //     //        console.log("B :: for element :: " + element + " :: trying :: " + linkAddress + " :: " + linkDisplayText)
        //     element.html("<a href=\"" + linkAddress + "\" target=\"_blank\">" + linkDisplayText + "</a>");
        // } else if(PlatformUtils.mobileiOSCheck()){
        //     element.html("<a href=\"#\" target=\"_blank\">" + linkDisplayText + "</a>");
        //     element.unbind('click');
        //     element.click({param1: linkAddress}, Navigation.tryToOpenExternalLinkMobile);
        // } else if (PlatformUtils.mobileAndroidCheck()) {
            // We should always call tryToOpenExternalLink() to prevent electron to open url in native Window
            if(PlatformUtils.extensionChromeCheck()){
                element.html("<a href=\"" + linkAddress + "\" target=\"_blank\">" + linkDisplayText + "</a>");
            } else {
                element.html("<a href='#' onclick=\"Navigation.tryToOpenExternalLink('"+linkAddress+"')\">" + linkDisplayText + "</a>");
            }
         // } else {
        //     element.html("<a href=\"" + linkAddress + "\" target=\"_blank\">" + linkDisplayText + "</a>");
        // }
    } else {
        // if(!PlatformUtils.mobileCheck() && !PlatformUtils.extensionCheck() && !PlatformUtils.desktopCheck() ){
        //     stringVersion = "<a href=\"" + linkAddress + "\" target=\"_blank\">" + linkDisplayText + "</a>";
        // } else if (PlatformUtils.extensionChromeCheck() || PlatformUtils.extensionFirefoxCheck()) { //ChromeExt doesn't support inline js.
        //     stringVersion = "<a href=\"" + linkAddress + "\" target=\"_blank\">" + linkDisplayText + "</a>";
        // } else if (PlatformUtils.mobileAndroidCheck() || PlatformUtils.mobileiOSCheck()) {
        // We should always call tryToOpenExternalLink() to prevent electron to open url in native Window
        if(PlatformUtils.extensionChromeCheck()){
            stringVersion = "<a href=\"" + linkAddress + "\" target=\"_blank\">" + linkDisplayText + "</a>";
        } else {
            stringVersion = "<a href='#' onclick=\"Navigation.tryToOpenExternalLink('"+linkAddress+"')\">" + linkDisplayText + "</a>";
        }
         // } else {
        //     stringVersion = "<a href=\"" + linkAddress + "\" target=\"_blank\">" + linkDisplayText + "</a>";
        // }
    }
    return stringVersion;
}

JaxxUI.prototype.showHamburgerMenu = function() {
    $('.hamburger').show();
}

JaxxUI.prototype.hideHamburgerMenu = function() {
    $('.hamburger').hide();
}

/*
* Initializes Intro screens with appropriate data
* */
JaxxUI.prototype.initializeElements = function() {
    //    console.log("JaxxUI._sUI :: " + JaxxUI._sUI + " :: " + JaxxUI._sUI._numPinEntryFields);
    //	try {
    //this.initializeTopCarousel();


    //@note: @here: @todo: this is incorrectly placed, should be set up later when an actual wallet is loaded.
    ///this.updateCryptoCurrencyBannersInHeader(true);
    ///this.updateCryptoCurrencyBannersInHeaderCarousel();
    //this.generateSettingsCurrencyRows();
    //this.generateSettingsCryptoCurrencyRows();
    //this.initializeCarouselStickyProperty();
    ///this.initializeFlickityCarousels();
    //this.generatePrivateKeyMenuOptions();
    this.generateTextInDisplayPrivateKeysMenu();

    var versionsForNewsUpdates = JSON.parse(getStoredData('criticalVersionUpdatesShown', false));
    if (typeof(versionsForNewsUpdates) !== 'undefined' && versionsForNewsUpdates !== null){
        this._criticalVersionUpdatesShown = versionsForNewsUpdates;
    }

    var versionForReleaseBulletinUpdates = JSON.parse(getStoredData('_jaxxReleaseBulletinVersions', false));
    if (typeof(versionForReleaseBulletinUpdates) !== 'undefined' && versionForReleaseBulletinUpdates !== null){
        this._jaxxReleaseBulletinVersions = versionForReleaseBulletinUpdates;
    }


    var cryptoCurrenciesAllowed = {};
    if (PlatformUtils.mobileiOSCheck()) {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.ios;
    } else {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.regular;
    }

    var allKeys = Object.keys(jaxx.FiatPriceController.fiatDictionary);

    var currenciesEnabled = [];

    for (var i = 0; i < allKeys.length; i++) {
        var cryptoEnabled = cryptoCurrenciesAllowed[allKeys[i]];
        if (typeof(cryptoEnabled) !== 'undefined' && cryptoEnabled !== null && cryptoEnabled === true) {
            currenciesEnabled.push(allKeys[i]);
            var curElement = $('.displayPrivateKeys' + allKeys[i] + 'SettingsButton');

            if (typeof(curElement) !== 'undefined' && curElement !== null) {
                curElement.show();
            }
        } else {
            var curElement = '.displayPrivateKeys' + allKeys[i] + 'SettingsButton';

            try {
                $(curElement).hide();
            } catch(err) {
                console.log("possible error :: " + err);
            }

            //@note: hide the etc/eth split button if ETC is not enabled.
            if (allKeys[i] === "ETC") {
                this._disableETCETHSplitOption = true;
                $('.checkForEtcEthSplitToolsButton').hide();
            }
        }
    }

    //    $('.displayPrivateKeysDashSettingsButton').hide();


    var pvtKeysDisplayText = "";

    for (var i = 0; i < currenciesEnabled.length; i++) {
        pvtKeysDisplayText += currenciesEnabled[i];
        if (i !== currenciesEnabled.length - 1) {
            if (i === currenciesEnabled.length - 2) {
                pvtKeysDisplayText += " and ";
            } else {
                pvtKeysDisplayText += ", ";
            }
        }
    }


    $('.displayPrivateKeysText').text(pvtKeysDisplayText);
    //this.initializeCarousels(); // Must be run after this.updateCryptoCurrencyBannersInHeader(true);
    //this.updateCoinBannerCarousel();
    //		this.animateHamburgerMenu();
    //	} catch(error) {
    //		console.log('Failed to initialize the programmatic elements of the table.');
    //		console.log(error.message);
    //	}
    if (IS_RELEASE_VERSION) {
        $(".testIndicator").hide();
    } else {
        $(".testIndicator").show();
    }
}

JaxxUI.prototype.initializeFlickityCarousels = function(){
    var self = this;
    //$(document).ready(function(){
    self._flickityNotificationFooter = $('.notificationFooter .carousel').flickity({
        // options
        imagesLoaded: true,
        setGallerySize: false,
    });
    //});
}

JaxxUI.prototype.generateProgrammaticElementsInUI = function(){
    this.updateCryptoCurrencyBannersInHeader(true);
   // this.generateSettingsCurrencyRows();
    // this.generateSettingsCryptoCurrencyRows();
}

JaxxUI.prototype.initializePinPad = function(callback) {
    // callback will pass back 1 parameter indicating the key pressed.
    if(!JaxxUI._sUI._mainPinPadElementName) {
        return callback();
    }
    var self = this;
    JaxxUI._sUI.deinitializePinPad();

    console.log("initialize pin pad");
    for (var i = 0; i < JaxxUI._sUI._numPinEntryFields; i++) {
        var element = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + i);

        element.index = i;

        if (i !== 0) {
            element.prevElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + (i - 1));
        }

        if (i < JaxxUI._sUI._numPinEntryFields - 1) {
            element.nextElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + (i + 1));
        }

        element.bind('input', { prevElement: element.prevElement, curElement: element, newFocusTarget: element.nextElement }, JaxxUI._sUI.enterPinData);

        element.bind('keyup', { prevElement: element.prevElement, curElement: element, newFocusTarget: element.nextElement }, JaxxUI._sUI.removePinData);

        element.bind('focus', { index: i }, function(e) {
            $(e.target).val("");
            JaxxUI._sUI._pinEntryFocus = e.data.index;
        });

        if (PlatformUtils.mobileCheck()) {
            element.attr('disabled', 'true');
        }

        //        console.log("setup :: " + JSON.stringify(element) + " :: nextElement :: " + element.nextElement);
    }

    for (var i = 0; i < 10; i++) {
        var element = $(JaxxUI._sUI._mainPinPadElementName + ' .numPadButton' + i);
        var curVal = i;
        element.bind('click', { curNum: i }, function(event){
            if (typeof(callback) !== 'undefined' && callback !== null){
                callback(i);
            }
            JaxxUI._sUI.clickNumPad(event);
        });
    }

    $(JaxxUI._sUI._mainPinPadElementName + ' .numPadDelete').bind('click', null, function() {
        if (typeof(callback) !== 'undefined' && callback !== null){
            callback('DEL');
        }
        if (JaxxUI._sUI._pinEntryFocus > 0) {

            var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);
            var intDecrementFlag = true;
            if (self.getEnteredPINCode().length === JaxxUI._sUI._numPinEntryFields){
                intDecrementFlag = false;
            }
            //pinEntry must be decremented before event is created
            if (JaxxUI._sUI._pinEntryFocus > 0) {
                if (intDecrementFlag){
                    JaxxUI._sUI._pinEntryFocus--;
                }
            }

            var event = {};
            event.keyCode = 8;
            event.data = {};
            event.data.curElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

            if (JaxxUI._sUI._pinEntryFocus > 0) {
                event.data.prevElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + (JaxxUI._sUI._pinEntryFocus - 1));
            }

            JaxxUI._sUI.removePinData(event);

            if (JaxxUI._sUI._pinEntryFocus === 0) {
                JaxxUI._sUI.setPinCirclesToOrangeBorder(JaxxUI._sUI._mainPinPadElementName);
                if (JaxxUI._sUI._pinPadResetText) {
                    $(JaxxUI._sUI._mainPinPadElementName + ' .settingsEnterPinPadText').text(JaxxUI._sUI._pinPadResetText);
                } else {
                    $(JaxxUI._sUI._mainPinPadElementName + ' .settingsEnterPinPadText').text('Confirm PIN');
                }
            }

        } else {

            var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

            if (PlatformUtils.mobileCheck()) {
                inputElement.val('');
            } else {
                inputElement.focus();
            }
        }

    });

    $(JaxxUI._sUI._mainPinPadElementName + ' .numPadClear').bind('click', null, function() {
        if (typeof(callback) !== 'undefined' && callback !== null){
            callback('CLR');
        }
        JaxxUI._sUI.clearAllNumPadData();
        if (JaxxUI._sUI._pinPadResetText) {
            $(JaxxUI._sUI._mainPinPadElementName + ' .settingsEnterPinPadText').text(JaxxUI._sUI._pinPadResetText);
        } else {
            $(JaxxUI._sUI._mainPinPadElementName + ' .settingsEnterPinPadText').text('Confirm PIN');
        }
        JaxxUI._sUI.setPinCirclesToOrangeBorder(JaxxUI._sUI._mainPinPadElementName);
    });
}

JaxxUI.prototype.clickDELDefaultCallback = function(){
    if (JaxxUI._sUI._pinEntryFocus > 0) {
        var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

        if (PlatformUtils.mobileCheck()) {
            var event = {};
            event.keyCode = 8;
            event.data = {};
            event.data.curElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

            event.data.curElement.val('');

            if (JaxxUI._sUI._pinEntryFocus > 0) {
                event.data.prevElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + (JaxxUI._sUI._pinEntryFocus - 1));
            }

            JaxxUI._sUI.removePinData(event);

            if (JaxxUI._sUI._pinEntryFocus > 0) {
                JaxxUI._sUI._pinEntryFocus--;
            }
        } else {
            inputElement.trigger(jQuery.Event('keyup', {keyCode: 8}));
        }
    } else {
        var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

        if (PlatformUtils.mobileCheck()) {
            inputElement.val('');
        } else {
            inputElement.focus();
        }
    }
}

JaxxUI.prototype.deinitializePinPad = function() {
    for (var i = 0; i < JaxxUI._sUI._numPinEntryFields; i++) {
        var element = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + i);

        element.unbind('input');
        element.unbind('keyup');
        element.unbind('focus');
    }

    for (var i = 0; i < 10; i++) {
        var element = $(JaxxUI._sUI._mainPinPadElementName + ' .numPadButton' + i);

        element.unbind('click');
    }

    $(JaxxUI._sUI._mainPinPadElementName + ' .numPadDelete').unbind();
    $(JaxxUI._sUI._mainPinPadElementName + ' .numPadClear').unbind();
}

JaxxUI.prototype.removePinData = function(e) {
    //    console.log(e.keyCode);

    var prevElement = e.data.prevElement;
    var curElement = e.data.curElement;

    if (e.keyCode == 8) {
        curElement.val("");
        //curElement.css('background-color','#F27221')

        if (typeof(prevElement) !== 'undefined') {
            prevElement.focus();
        }
    }

    JaxxUI._sUI.setupUIWithEnteredPin(JaxxUI._sUI.getEnteredPINCode());
}

JaxxUI.prototype.enterPinData = function(e) {

    var prevElement = e.data.prevElement;
    var curElement = e.data.curElement;
    var newFocusTarget = e.data.newFocusTarget;

    var curVal = curElement.val();

    //        console.log("entered input:: " + JSON.stringify(curElement) + " :: " + curVal + " :: " + newFocusTarget);

    if (isDecimal(curVal)) {
        curElement.val(curVal.substring(curVal.length - 1));

        if (typeof(newFocusTarget) !== 'undefined') {
            newFocusTarget.focus();
        }
    } else {
        curElement.val("");
    }

    JaxxUI._sUI.setupUIWithEnteredPin(JaxxUI._sUI.getEnteredPINCode());
}


JaxxUI.prototype.clickNumPad = function(e) {
    //    console.log(e.data + " :: " + JaxxUI._sUI._pinEntryFocus);

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

    if (JaxxUI._sUI._pinEntryFocus < JaxxUI._sUI._numPinEntryFields - 1) {
        JaxxUI._sUI._pinEntryFocus++;

        var nextElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

        nextElement.focus();
    } else {
        //        console.log("focus binding");
        inputElement.unbind('focus');

        inputElement.focus();

        inputElement.bind('focus', { index: JaxxUI._sUI._pinEntryFocus }, function(e) {
            $(e.target).val("");
            JaxxUI._sUI._pinEntryFocus = e.data.index;
        });
    }

    inputElement.val(e.data.curNum);
    inputElement.trigger('keyup');
}

JaxxUI.prototype.clearAllNumPadData = function() {
    JaxxUI._sUI._pinEntryFocus = 0;

    for (var i = 0; i < JaxxUI._sUI._numPinEntryFields; i++) {
        var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + i);
        inputElement.val('');
    }

    $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus).focus().select();
}


JaxxUI.prototype.getEnteredPINCode = function() {
    var pinCode = "";

    for (var i = 0; i < JaxxUI._sUI._numPinEntryFields; i++) {
        var element = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + i);
        pinCode += element.val();
    }

    return pinCode;
}

JaxxUI.prototype.setupUIWithEnteredPin = function(pinCode) {
    if (g_JaxxApp.getUser().hasPin()) {
        var validPin = g_JaxxApp.getUser().checkForValidPin(pinCode);

        if (validPin) {
            JaxxUI._sUI._f_onPinSuccess();
        } else {
            JaxxUI._sUI._f_onPinFailure();
        }
    } else {
        JaxxUI._sUI._f_onPinFailure();
    }
}

JaxxUI.prototype.setOnPinSuccess = function(callback) {
    JaxxUI._sUI._f_onPinSuccess = callback;
}

JaxxUI.prototype.setOnPinFailure = function(callback) {
    JaxxUI._sUI._f_onPinFailure = callback;
}

JaxxUI.prototype.showEnterPinModal = function(successCallback) {
    //this handles the pin pad modal after the send confirmation modal

    $('.enterPin .settingsEnterPinPadText').text('Confirm PIN');

    JaxxUI._sUI.setOnPinSuccess(function() {
        JaxxUI._sUI.deinitializePinPad();
        Navigation.closeModal();
        successCallback(null);
    });

    JaxxUI._sUI.setOnPinFailure(function() {
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();
        if (enteredPin.length === JaxxUI._sUI._numPinEntryFields) {
            //this code is run if user has finished entering a pin, but it's incorrect
            JaxxUI._sUI.incorrectPinIsEntered('.enterPin .modalSendEnterPinPad', 'Confirm PIN');
        }
    });

    JaxxUI._sUI.setupPinPad('.modalSendEnterPinPad');

    Navigation.openModal('enterPin');

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);
    inputElement.trigger('keyup');

    inputElement.focus();
}

/*
JaxxUI.prototype.turnHoverEffectOff = function(){
    for (var i = 0; i < COIN_NUMCOINTYPES; i++){
        if (i !== curCoinType){
            this._coinDontHover[i] = true;
        }
    }
}
*/

/*
JaxxUI.prototype.turnHoverEffectOn = function(){
    for (var i = 0; i < COIN_NUMCOINTYPES; i++){
        if (i !== curCoinType){
            this._coinDontHover[i] = false;
        }
    }
}
*/

JaxxUI.prototype.resetCoinButton = function(coinType) {
    var self = this;
    var coinButtonName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonName'];
    var coinButtonSVGName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonSVGName'];
    $(coinButtonName).css({background: 'url(images/' + coinButtonSVGName + '-gray.svg) no-repeat center center', color: '#888888'});
    $(coinButtonName).removeClass('cssSelected');
    $(coinButtonName).off('mouseover');
    $(coinButtonName).off('mouseleave');
    $(coinButtonName).on({
        mouseover: function(){
            if (!self._coinDontHover[coinType]) {
                var coinButtonSVGName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonSVGName'];
                $(this).css({background: 'url(images/' + coinButtonSVGName + '.svg) no-repeat center center', color: '#FFFFFF'});
            }
        },
        mouseleave: function(){
            if (!self._coinDontHover[coinType]) {
                var coinButtonSVGName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonSVGName'];
                $(this).css({background: 'url(images/' + coinButtonSVGName + '-gray.svg) no-repeat center center', color: '#888888'});
                $(this).removeClass('cssSelected');
            }
        },
        //click: function(){
        //$(this).off('mouseleave');
        //}
    });
}

JaxxUI.prototype.setupMiningFeeSelector = function(miningFeeRadioButtonSetOverride, noOverrideUIOnSetup) {
    return;
    //    console.log("$('.modal.send.averageMiningFee') :: " + $('.modal.send.averageMiningFee'));
    var self= this;
    if (typeof(this._miningFeeModalSetup[miningFeeRadioButtonSetOverride]) ===
        'undefined' || this._miningFeeModalSetup[miningFeeRadioButtonSetOverride] === null) {
        this._miningFeeModalSetup[miningFeeRadioButtonSetOverride] = true;

        $('input[type=radio][name=miningFee' + miningFeeRadioButtonSetOverride + 'Button]').on('change', function(event) {
            //            console.log("clicky :: " + JSON.stringify($(this).val()));
            //            if (this.value === 'customMiningFee') {
            //                $('.modal.send .slider').slideDown();
            //
            //                var curMiningFeeDict = wallet.getPouchFold(COIN_BITCOIN).getMiningFeeDict();
            //
            //                var lowerLimit = 20;
            //                var upperLimit = parseFloat(curMiningFeeDict.fastestFee);
            //
            //                var overrideFee = parseFloat(wallet.getPouchFold(COIN_BITCOIN).getCurrentMiningFee()) / 1000.0;
            //
            //                console.log("overrideFee :: " + overrideFee + " :: lowerLimit :: " + lowerLimit + " :: upperLimit :: " + upperLimit);
            //
            //                if (upperLimit !== 0) {
            //                    for (var i = 0; i < 1000; i++) {
            //                        if (lowerLimit > upperLimit) {
            //                            lowerLimit /= 2;
            //                        }
            //                    }
            //                }
            //
            //                var curPercent = (overrideFee - lowerLimit) / (upperLimit - lowerLimit);
            //
            //                //                console.log("curPercent :: " + curPercent);
            //                $('.modal.send .slider').slider('value', parseInt(curPercent * 100));
            //            } else {
            //                $('.modal.send .slider').slideUp();
            var curMiningFeeDict = wallet.getPouchFold(COIN_BITCOIN).getMiningFeeDict();

            var overrideFee = 0;

            var lowerLimit = 40;
            var slowerLimit = parseFloat(curMiningFeeDict.hourFee);
            var fasterLimit = parseFloat(curMiningFeeDict.halfHourFee);
            var customLimit = parseFloat(curMiningFeeDict.customFee);

            if (slowerLimit !== 0) {
                for (var i = 0; i < 1000; i++) {
                    if (lowerLimit > slowerLimit) {
                        lowerLimit /= 2;
                    }
                }
            }

            if (this.value === 'slowMiningFee' + miningFeeRadioButtonSetOverride ) {
                overrideFee = (lowerLimit * 1000);
                g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelSlow);
                wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelSlow);
                $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelSlow]);
            } else if (this.value === 'averageMiningFee' + miningFeeRadioButtonSetOverride) {
                overrideFee = (slowerLimit * 1000);
                g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelAverage);
                wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelAverage);
                $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelAverage]);
            } else if (this.value === 'fastMiningFee' + miningFeeRadioButtonSetOverride) {
                overrideFee = (fasterLimit * 1000);
                g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelFast);
                wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelFast);
                $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelFast]);
            } else if (this.value === 'customMiningFee' + miningFeeRadioButtonSetOverride) {// Fourth Option Custom
                overrideFee = (customLimit * 1000);
                g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelCustom);
                wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelCustom);
                $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelCustom]);
            }
            self.overrideMiningFeeRadioButton(miningFeeRadioButtonSetOverride);

            //            var newMiningFeeLevel = wallet.getPouchFold(COIN_BITCOIN).getMiningFeeLevel();
            //            console.log("miningFeeRadioButtonSetOverride :: " + miningFeeRadioButtonSetOverride + " :: radiobutton value :: " + this.value + " :: overrideFee :: " + overrideFee + " :: newMiningFeeLevel :: " + newMiningFeeLevel);

            updateFromInputFieldEntry();
            specialAction('walletSendReceive');

            //        }
        });

        //        var sliderChanged = function(event, ui) {
        //            if (event.originalEvent) {
        //                //manual change
        //                console.log(ui.value);
        //                //@note: @todo: move the following function to this class.
        //
        //                var curMiningFeeDict = wallet.getPouchFold(COIN_BITCOIN).getMiningFeeDict();
        //
        //                var lowerLimit = 20;
        //                var upperLimit = parseFloat(curMiningFeeDict.fastestFee);
        //
        //                var overrideFee = 0;
        //
        //                if (upperLimit !== 0) {
        //                    for (var i = 0; i < 1000; i++) {
        //                        if (lowerLimit > upperLimit) {
        //                            lowerLimit /= 2;
        //                        }
        //                    }
        //
        //                    var modifier = parseFloat(ui.value) / 100.0;
        //
        ////                    console.log("modifier :: " + modifier);
        //
        //                    overrideFee = lowerLimit + (upperLimit - lowerLimit) * modifier;
        //                    overrideFee = parseInt(overrideFee * 1000);
        //                }
        //
        ////                console.log("overrideFee :: " + overrideFee);
        //
        //                wallet.getPouchFold(COIN_BITCOIN).setMiningFeeOverride(overrideFee);
        //
        //                updateFromInputFieldEntry();
        //                specialAction('walletSendReceive');
        //            }
        //            else {
        //                //programmatic change
        //            }
        //        }
        //
        //        $('.modal.send .slider').slider({
        //            range: "max",
        //            min: 0,
        //            max: 100,
        //            value: 50,
        //            slide: sliderChanged,
        //            change: sliderChanged
        //        });
        //
        //        $('.modal.send .slider').slideUp();

        //updateFromInputFieldEntry();
        //specialAction('walletSendReceive');
    }
    //if (!noOverrideUIOnSetup) {
    // this.overrideMiningFeeRadioButton(miningFeeRadioButtonSetOverride);
    //}
}

JaxxUI.prototype.pushBTCMiningFeeFromUIOptionsToPouch = function(){
    var miningFeeRadioButtonSetOverride = "MainMenu";
    var strMiningFeeOptionChecked = $('input[name=miningFeeMainMenuButton]:checked').attr('value');
    var curMiningFeeDict = wallet.getPouchFold(COIN_BITCOIN).getMiningFeeDict();

    var overrideFee = 0;

    var lowerLimit = 40;
    var slowerLimit = parseFloat(curMiningFeeDict.hourFee);
    var fasterLimit = parseFloat(curMiningFeeDict.halfHourFee);
    var customLimit = parseFloat(curMiningFeeDict.customFee);

    if (slowerLimit !== 0) {
        for (var i = 0; i < 1000; i++) {
            if (lowerLimit > slowerLimit) {
                lowerLimit /= 2;
            }
        }
    }

    if (strMiningFeeOptionChecked === 'slowMiningFee' + miningFeeRadioButtonSetOverride ) {
        overrideFee = (lowerLimit * 1000);
        g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelSlow);
        wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelSlow);
        $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelSlow]);
    } else if (strMiningFeeOptionChecked === 'averageMiningFee' + miningFeeRadioButtonSetOverride) {
        overrideFee = (slowerLimit * 1000);
        g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelAverage);
        wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelAverage);
        $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelAverage]);
    } else if (strMiningFeeOptionChecked === 'fastMiningFee' + miningFeeRadioButtonSetOverride) {
        overrideFee = (fasterLimit * 1000);
        g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelFast);
        wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelFast);
        $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelFast]);
    } else if (strMiningFeeOptionChecked === 'customMiningFee' + miningFeeRadioButtonSetOverride) {// Fourth Option Custom
        overrideFee = (customLimit * 1000);
        g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelCustom);
        wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelCustom);
        $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelCustom]);
    }
    this.overrideMiningFeeRadioButton(miningFeeRadioButtonSetOverride);
}

JaxxUI.prototype.pushBTCMiningFeeFromPouchToModal = function(){
    console.log('COIN_BITCOIN ' +COIN_BITCOIN);
    //TODO Bitcoin Mining fee
    return;
    var miningFeeOptionChosen = wallet.getPouchFold(COIN_BITCOIN).getMiningFeeLevel();
    var curMiningFeeDict = wallet.getPouchFold(COIN_BITCOIN).getMiningFeeDict();

    var slowerLimit = parseFloat(curMiningFeeDict.hourFee);
    var fasterLimit = parseFloat(curMiningFeeDict.halfHourFee);
    var customLimit = parseFloat(curMiningFeeDict.customFee);
    if (miningFeeOptionChosen === HDWalletPouch.MiningFeeLevelSlow) {
        //overrideFee = (lowerLimit * 1000);
        //g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelSlow);
        //wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelSlow);
        $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelSlow]);
    } else if (miningFeeOptionChosen === HDWalletPouch.MiningFeeLevelAverage) {
        //overrideFee = (slowerLimit * 1000);
        //g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelAverage);
        //wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelAverage);
        $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelAverage]);
    } else if (miningFeeOptionChosen === HDWalletPouch.MiningFeeLevelFast) {
        //overrideFee = (fasterLimit * 1000);
        //g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelFast);
        //wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelFast);

        $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelFast]);
    } else if (miningFeeOptionChosen === HDWalletPouch.MiningFeeLevelCustom) {// Fourth Option Custom
        //overrideFee = (customLimit * 1000);
        //g_JaxxApp.getSettings().setMiningFeeOptionForCoin(0, HDWalletPouch.MiningFeeLevelCustom);
        //wallet.getPouchFold(COIN_BITCOIN).setMiningFeeLevel(HDWalletPouch.MiningFeeLevelCustom);
        $(".miningFeeDescription").html(HDWalletPouch.dictMiningOptionText[HDWalletPouch.MiningFeeLevelCustom]);
    } else { // Default mining fee option chosen
        $(".miningFeeDescription").html("Default mining fee is selected. BTC mining fee can be adjusted in the setting menu");
    }
}

JaxxUI.prototype.overrideMiningFeeRadioButton = function(miningFeeRadioButtonSetOverride) {
    // This takes the mining fee option from the pouch and sets the transaction fee.
    // This also checks the button according to the mining fee.
    var curMiningFeeDict = wallet.getPouchFold(COIN_BITCOIN).getMiningFeeDict();

    var overrideFee = wallet.getPouchFold(COIN_BITCOIN).getDefaultTransactionFee();

    var lowerLimit = 40;
    var slowerLimit = parseFloat(curMiningFeeDict.hourFee);
    var fasterLimit = parseFloat(curMiningFeeDict.halfHourFee);

    if (slowerLimit !== 0) {
        for (var i = 0; i < 1000; i++) {
            if (lowerLimit > slowerLimit) {
                lowerLimit /= 2;
            }
        }
    }

    var curMiningFeeOverride = lowerLimit;
    var curMiningFeeLevel = wallet.getPouchFold(COIN_BITCOIN).getMiningFeeLevel(); // Slow, Average or Fast

    if (curMiningFeeLevel === HDWalletPouch.MiningFeeLevelSlow) {
        $('input:radio[type=radio][name=miningFee' + miningFeeRadioButtonSetOverride + 'Button][id=slowMiningFee' + miningFeeRadioButtonSetOverride + ']').prop('checked', true);
        curMiningFeeOverride = lowerLimit;
    } else if (curMiningFeeLevel === HDWalletPouch.MiningFeeLevelAverage) {
        $('input:radio[type=radio][name=miningFee' + miningFeeRadioButtonSetOverride + 'Button][id=averageMiningFee' + miningFeeRadioButtonSetOverride + ']').prop('checked', true);
        curMiningFeeOverride = slowerLimit;
    } else if (curMiningFeeLevel === HDWalletPouch.MiningFeeLevelFast) {
        $('input:radio[type=radio][name=miningFee' + miningFeeRadioButtonSetOverride + 'Button][id=fastMiningFee' + miningFeeRadioButtonSetOverride + ']').prop('checked', true);
        curMiningFeeOverride = fasterLimit;
    } else if (curMiningFeeLevel === HDWalletPouch.MiningFeeLevelCustom) {
        $('input:radio[type=radio][name=miningFee' + miningFeeRadioButtonSetOverride + 'Button][id=customMiningFee' + miningFeeRadioButtonSetOverride + ']').prop('checked', true);
    }
    overrideFee = (curMiningFeeOverride * 1000);
    //    console.log("overrideMiningFeeRadioButton :: " + miningFeeRadioButtonSetOverride + " :: curMiningFeeLevel :: " + curMiningFeeLevel + " :: overrideFee :: " + overrideFee);
    wallet.getPouchFold(COIN_BITCOIN).setMiningFeeOverride(overrideFee);
}

JaxxUI.prototype.setBTCMiningFee = function(){

}

JaxxUI.prototype.setMainMenuToggleLocked = function(boolLockedFlag) {
    this._mainMenuToggleLocked = boolLockedFlag;
}
JaxxUI.prototype.openShapeShiftSendModal = function() {
    $('.notificationOverlay .cssShapeShiftConfirmation').parent().removeClass('cssStartHidden');
    if( $('.tabContent.cssTabContent').hasClass('cssSelected') ) {
        $('.tabSend.tab').trigger('click');
        setTimeout(function () {
            Navigation.openNotificationBanner('.cssShapeShiftConfirmation');
        }, 800);
    }
    else {
        Navigation.openNotificationBanner('.cssShapeShiftConfirmation');
    }

}
JaxxUI.prototype.closeShapeShiftSendModal = function() {
    Navigation.closeNotificationBanner('.cssShapeShiftConfirmation');
}
JaxxUI.prototype.openSendConfirmationModal = function() {
    $('.notificationOverlay .cssSendConfirmation').parent().removeClass('cssStartHidden');
    if ($('.tabContent.cssTabContent').hasClass('cssSelected')) {
        $('.tabSend.tab').trigger('click');
        setTimeout(function () {
            Navigation.openNotificationBanner('.cssSendConfirmation');
        }, 800);
    }
    else {
        Navigation.openNotificationBanner('.cssSendConfirmation');
    }
}
JaxxUI.prototype.closeSendConfirmationModal = function() {
    Navigation.closeNotificationBanner('.cssSendConfirmation');
}
JaxxUI.prototype.showSendModal = function() {
    if (!$('.modal-bottom .cssSendConfirmation').hasClass('visibleNotificationFooter')) {
        /* Navigation.openModal('send'); */
        this.openSendConfirmationModal();
    }

    if (curCoinType === COIN_BITCOIN) {
        this.setupMiningFeeSelector('Generic');

        /* $('.modal.send .miningFeeSelector').show(); */
        $('.modal-bottom .cssSendConfirmation .miningFeeSelector').show();
        $('.modal-bottom .cssSendConfirmation .modal-body-bottom-description').show();

        if($('.modal-bottom .cssSendConfirmation .mining-fee-title').hasClass('modal-body-bottom-title-description-visible')) {
            return;
        }
        else {
            $('.modal-bottom .cssSendConfirmation .mining-fee-title').addClass('modal-body-bottom-title-description-visible');
            $('.modal-bottom .cssSendConfirmation .mining-fee-title').removeClass('modal-body-bottom-title');
        }
    } else {
        /* $('.modal.send .miningFeeSelector').hide(); */
        $('.modal-bottom .cssSendConfirmation .miningFeeSelector').hide();
        $('.modal-bottom .cssSendConfirmation .modal-body-bottom-description').hide();

        if($('.modal-bottom .cssSendConfirmation .mining-fee-title').hasClass('modal-body-bottom-title')) {
            return;
        }
        else {
            $('.modal-bottom .cssSendConfirmation .mining-fee-title').removeClass('modal-body-bottom-title-description-visible');
            $('.modal-bottom .cssSendConfirmation .mining-fee-title').addClass('modal-body-bottom-title');
        }
    }
    /*
    if (!$('.modal.send').hasClass('visible')) {
        Navigation.openModal('send');
    }
    */

}

JaxxUI.prototype.showShiftModal = function() {
    if (!$('.modal-bottom .cssShapeShiftConfirmation').hasClass('visible')) {
        this.openShapeShiftSendModal();
    }

    if (curCoinType === COIN_BITCOIN) {
        this.setupMiningFeeSelector('ShapeShift');

        /* $('.modal.shift .miningFeeSelector').show(); */
        $('.modal-bottom .cssShapeShiftConfirmation .miningFeeSelector').show();
        $('.modal-bottom .cssShapeShiftConfirmation .modal-body-bottom-description').show();

        if($('.modal-bottom .cssShapeShiftConfirmation .mining-fee-title').hasClass('modal-body-bottom-title-description-visible')) {
            return;
        }
        else {
            $('.modal-bottom .cssShapeShiftConfirmation .mining-fee-title').addClass('modal-body-bottom-title-description-visible');
            $('.modal-bottom .cssShapeShiftConfirmation .mining-fee-title').removeClass('modal-body-bottom-title');
        }
    } else {
        /* $('.modal.shift .miningFeeSelector').hide(); */
        $('.modal-bottom .cssShapeShiftConfirmation .miningFeeSelector').hide();
        $('.modal-bottom .cssShapeShiftConfirmation .modal-body-bottom-description').hide();

        if($('.modal-bottom .cssShapeShiftConfirmation .mining-fee-title').hasClass('modal-body-bottom-title')) {
            return;
        }
        else {
            $('.modal-bottom .cssShapeShiftConfirmation .mining-fee-title').removeClass('modal-body-bottom-title-description-visible');
            $('.modal-bottom .cssShapeShiftConfirmation .mining-fee-title').addClass('modal-body-bottom-title');
        }
    }
    /*
    if (!$('.modal.shift').hasClass('visible')) {
        Navigation.openModal('shift');
    }
    */
}

JaxxUI.prototype.setupPinPad = function(elementName, callback) {
    JaxxUI._sUI._mainPinPadElementName = elementName;
    JaxxUI._sUI._pinPadResetText = null;
    $(elementName + ' .settingsEnterPinPadText').css('color','#fff');

    JaxxUI._sUI.initializePinPad(callback);
    JaxxUI._sUI.setPinCirclesToOrangeBorder(elementName);

    console.log($(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry0'));
}

JaxxUI.prototype.showEnterPinSettings = function() {
    if (g_JaxxApp.getUser().hasPin()) {
        JaxxUI._sUI.showConfirmExistingPinSettings(function() {
            JaxxUI._sUI.showEnterNewPinSettings("Your PIN has been changed.");
        });
    } else {
        JaxxUI._sUI.showEnterNewPinSettings("Your PIN has been set.");
    }
}

JaxxUI.prototype.setPinCirclesToRedBorder = function(pinPadInstance){
    //pinPadInstance is a string representing the class of the pin pad used
    $(pinPadInstance + ' input').addClass('cssRedBorder');
    $(pinPadInstance + ' input').removeClass('cssOrangeBorder');
    $(pinPadInstance + ' input').removeClass('cssBlueBorder');
    $(pinPadInstance + ' input').css('color', '#FF0000 !important');
}

JaxxUI.prototype.setPinCirclesToBlueBorder = function(pinPadInstance){
    //pinPadInstance is a string representing the class of the pin pad used
    $(pinPadInstance + ' input').removeClass('cssRedBorder');
    $(pinPadInstance + ' input').removeClass('cssOrangeBorder');
    $(pinPadInstance + ' input').addClass('cssBlueBorder');
    $(pinPadInstance + ' input').css('color', '#07630B !important');
}

JaxxUI.prototype.setPinCirclesToOrangeBorder = function(pinPadInstance){
    //pinPadInstance is a string representing the class of the pin pad used
    $(pinPadInstance + ' input').removeClass('cssRedBorder');
    $(pinPadInstance + ' input').addClass('cssOrangeBorder');
    $(pinPadInstance + ' input').removeClass('cssBlueBorder');
    $(pinPadInstance + ' input').css('color', '#E76F22 !important');
}

JaxxUI.prototype.showRemovePinSettings = function() {
    JaxxUI._sUI.showConfirmExistingPinSettings(function() {
        JaxxUI._sUI.correctPinIsEntered('.removePinCode .settingsEnterPinPad', 'Your PIN has been removed');
        JaxxUI._sUI.clearUserPin();
        Navigation.clearSettings();
        Registry.jaxxUI.closeMainMenu();
    });
}

JaxxUI.prototype.showConfirmExistingPinSettings = function(successCallback) {
    //this handles the pin confirmations on change pin and remove pin inside the settings menu

    JaxxUI._sUI.setupPinPad('.settings.changePinCode .settingsEnterPinPad');

    $('.settingsEnterPinPadText').text('Enter Current PIN');
    $('.settingsEnterNewPinConfirmButton').hide();

    JaxxUI._sUI.setOnPinSuccess(function() {
        successCallback();
    });

    JaxxUI._sUI.setOnPinFailure(function() {
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();
        if (enteredPin.length === JaxxUI._sUI._numPinEntryFields) {
            JaxxUI._sUI.incorrectPinIsEntered('.changePinCode .settingsEnterPinPad', 'Confirm PIN');
        }
    });

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);
    inputElement.trigger('keyup');
    inputElement.focus();
}

JaxxUI.prototype.showEnterNewPinSettings = function(successMessage) {
    //used when setting up a new pin within settings menu, and changing one

    JaxxUI._sUI.setupPinPad('.settings.changePinCode .settingsEnterPinPad');

    $('.settingsEnterPinPadText').text('Select New PIN');
    $('.settingsEnterNewPinConfirmButton').hide();

    var checkForValid = function() {
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();

        //        console.log("entered pin :: " + enteredPin);

        if (enteredPin.length === JaxxUI._sUI._numPinEntryFields) {
            JaxxUI._sUI.setupTemporaryPin(JaxxUI._sUI.getEnteredPINCode());
            JaxxUI._sUI.showConfirmNewPinSettings(successMessage);
        }
    }

    JaxxUI._sUI.setOnPinSuccess(checkForValid);
    JaxxUI._sUI.setOnPinFailure(checkForValid);

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);
    inputElement.trigger('keyup');
    inputElement.focus();
}

JaxxUI.prototype.showConfirmNewPinSettings = function() {
    //used when setting up a new pin within settings menu

    this._pinPadResetText = 'Confirm New PIN'

    $('.settingsEnterPinPadText').text('Confirm New PIN');
    $('.settingsEnterNewPinConfirmButton').hide();

    var checkForMatchingPin = function() {
        //this function gets called on first enter of proposed pin, and also on confirmation
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();

        if (enteredPin === JaxxUI._sUI._temporaryPin) {
            //if user has correctly retyped pin, set pin and give ui feedback
            Navigation.clearSettings();
            Registry.jaxxUI.closeMainMenu();
            g_JaxxApp.getUser().setPin(enteredPin);
            clearTimeout(JaxxUI._sUI._incorrectPINTimeout);
            JaxxUI._sUI.correctPinIsEntered('.changePinCode .settingsEnterPinPad', 'Your PIN has been set');
        } else if (enteredPin.length === 4) {
            //this code is run if user has finished entering a pin, but it's incorrect
            JaxxUI._sUI.incorrectPinIsEntered('.changePinCode .settingsEnterPinPad', 'Confirm New PIN');
        }
    }

    JaxxUI._sUI.setOnPinSuccess(checkForMatchingPin);
    JaxxUI._sUI.setOnPinFailure(checkForMatchingPin);

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);
    inputElement.trigger('keyup');

    inputElement.focus();
}

JaxxUI.prototype.correctPinIsEntered = function(pinPadInstance, confirmationMessage){
    JaxxUI._sUI.setPinCirclesToBlueBorder(pinPadInstance);
    $(pinPadInstance + 'Text').text('Success!');
    //Below snippet ensures that if user keeps clicking number keys after pin is set the confirmation banner
    //is still only flashed once
    if ($(pinPadInstance + 'Text').attr("temp_disable") == "disabled") {
        //nothing to do, temporarily disabled...
    }
    else {
        Navigation.flashBanner(confirmationMessage, 5);
        $(pinPadInstance + 'Text').attr("temp_disable", "disabled");
        window.setTimeout(function() { $(pinPadInstance + 'Text').attr("temp_disable", ""); }, 10000);
    }

}

JaxxUI.prototype.incorrectPinIsEntered = function(pinPadInstance, resetMessage){
    //used inside the settings menu for change pin and remove pin
    //ui feedback for send confirmation modal and view private keys/mnemonic happens in callbacks
    JaxxUI._sUI.setPinCirclesToRedBorder(pinPadInstance);
    $(pinPadInstance + 'Text').text('Incorrect PIN');
    clearTimeout(this._incorrectPINTimeout);
    this._incorrectPINTimeout = setTimeout(function(){
        //timeout resets ui after a few seconds if use doesn't press clr or del
        $(pinPadInstance + 'Text').text(resetMessage);
        JaxxUI._sUI.setPinCirclesToOrangeBorder(pinPadInstance);
        JaxxUI._sUI.clearAllNumPadData();
    }, 1000);
}

JaxxUI.prototype.setupTemporaryPin = function(temporaryPin) {
    JaxxUI._sUI._temporaryPin = temporaryPin;
}

JaxxUI.prototype.clearUserPin = function() {
    g_JaxxApp.getUser().clearPin();
}

JaxxUI.prototype.showSettingsMnemonicConfirmPin = function(settingsPinPadElementName, successCallback) {
    //this pinpad handles the backup mnemonic, from within the tools menu

    JaxxUI._sUI.setupPinPad(settingsPinPadElementName);
    $('.viewMnemonicConfirmPin .settingsEnterPinPadText').text('Confirm PIN');

    JaxxUI._sUI.setOnPinSuccess(function() {
        JaxxUI._sUI.deinitializePinPad();
        var mnemonic = getStoredData('mnemonic', true);
        var uri = "jaxx:" + thirdparty.bip39.mnemonicToEntropy(mnemonic);
        var qrCodeImage = thirdparty.qrImage.imageSync(uri, {
            type: "png",
            ec_level: "H"
        }).toString('base64');
        $(".settings.viewJaxxBackupPhrase .jaxxToken img").attr("src", "data:image/png;base64," + qrCodeImage);
        $('.populateMnemonic').text(mnemonic);
        successCallback();
    });

    JaxxUI._sUI.setOnPinFailure(function() {
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();
        if (enteredPin.length === JaxxUI._sUI._numPinEntryFields) {
            //this code is run if user has finished entering a pin, but it's incorrect
            JaxxUI._sUI.incorrectPinIsEntered('.viewMnemonicConfirmPin .settingsViewMnemonicConfirmPinPad', 'Confirm PIN');
        }
    });

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

    inputElement.trigger('keyup');
    setTimeout(function() {
        inputElement.focus();
    }, 100);
}

JaxxUI.prototype.showPrivateKeysConfirmPin = function(settingsPinPadElementName, successCallback) {
    //this pinpad handles display private keys pages, from within the tools menu

    JaxxUI._sUI.setupPinPad(settingsPinPadElementName);
    $('.backupPrivateKeysConfirmPin .settingsEnterPinPadText').text('Confirm PIN');

    JaxxUI._sUI.setOnPinSuccess(function() {
        JaxxUI._sUI.deinitializePinPad();
        successCallback();
    });

    JaxxUI._sUI.setOnPinFailure(function() {
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();
        if (enteredPin.length === JaxxUI._sUI._numPinEntryFields) {
            //this code is run if user has finished entering a pin, but it's incorrect
            JaxxUI._sUI.incorrectPinIsEntered('.backupPrivateKeysConfirmPin .settingsBackupPrivateKeysConfirmPinPad', 'Confirm PIN');
        }
    });

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

    inputElement.trigger('keyup');
    setTimeout(function() {
        inputElement.focus();
    }, 100);
}

JaxxUI.prototype.showPairDeviceConfirmPin = function(settingsPinPadElementName, successCallback) {
    //this pinpad handles the pair devices pin, from within the tools menu

    JaxxUI._sUI.setupPinPad(settingsPinPadElementName);
    $('.pairToDeviceConfirmPin .settingsEnterPinPadText').text('Confirm PIN');

    JaxxUI._sUI.setOnPinSuccess(function() {
        JaxxUI._sUI.deinitializePinPad();
        successCallback();
    });

    JaxxUI._sUI.setOnPinFailure(function() {
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();
        if (enteredPin.length === JaxxUI._sUI._numPinEntryFields) {
            //this code is run if user has finished entering a pin, but it's incorrect
            JaxxUI._sUI.incorrectPinIsEntered('.pairToDeviceConfirmPin .settingsPairToDeviceConfirmPinPad', 'Confirm PIN');
        }
    });

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);

    inputElement.trigger('keyup');
    setTimeout(function() {
        inputElement.focus();
    }, 100);
}

JaxxUI.prototype.setupTransactionList = function(coinType, numItemsToCreate) {
    //this.removeLoadMoreButtonTransactionList(coinType);
    this._numHistoryElementsDisplayed[coinType] = this._numHistoryElementsDefault;

    for (var i = 0; i < numItemsToCreate; i++) {
        //                console.log("creating new transaction list row :: " + i);
        this.createNewTransactionRow(coinType);
    }

    var self = this;

    var transactionsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName'];

    var transactionTable = $('.table.transactions' + transactionsListElement);

    var scrollStopFunction = function() {
        self.checkForTXScroll(coinType);
        //
        //        var coinType = parseInt($(this).attr('coinType'));
        //
        //        clearTimeout($.data(this, 'scrollTimer'));
        //        $.data(this, 'scrollTimer', setTimeout(function() {
        //
        //            self.checkForTXScroll(coinType);
        //        }, 50));
    }

    //@note: attribute the coinType to the table for later 'scrollStop' functionality reference.
    transactionTable.attr('coinType', coinType);

    //@note: basic 'scrollStop' functionality.
    transactionTable.off('scroll', scrollStopFunction);
    transactionTable.on('scroll', scrollStopFunction);

    //    console.log("table :: " + transactionTable + " :: number of children :: " + transactionTable.children('.tableRow').length + " :: " + transactionTable.coinType);

    //this.addLoadMoreButtonTransactionList(coinType);
}

JaxxUI.prototype.checkForTXScroll = function(coinType) {
    coinType = parseInt(coinType);

    var transactionsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName'];

    var transactionTable = $('.table.transactions' + transactionsListElement);

    var numChildren = transactionTable.children('.tableRow').length;

    if (numChildren > 1) {
        //@note: this works because only one can be expanded at a time.
        var minHeight = 0;

        minHeight = $(transactionTable.children('.tableRow')[0]).height();
        var otherMinHeight = $(transactionTable.children('.tableRow')[1]).height();
        if (otherMinHeight < minHeight) {
            minHeight = otherMinHeight;
        }

        if (minHeight !== 0) {
            var numRowsScrolled = transactionTable.scrollTop() / minHeight;
            var numRowsVisible = transactionTable.height() / minHeight;

            //            console.log("table :: " + coinType +
            //            " :: scroll :: numRowsScrolled :: " + numRowsScrolled + " :: numRowsVisible :: " + numRowsVisible + " :: history length :: " + g_JaxxApp.getUI().getTXHistoryLength(coinType) + " :: " + (numRowsScrolled + numRowsVisible));

            if (numRowsScrolled + numRowsVisible >= g_JaxxApp.getUI().getTXHistoryLength(coinType)) {
                //                console.log("table :: increase visible table cells");
                g_JaxxApp.getUI().increaseTXHistoryLength(coinType);
            }
        }

        //        console.log("table scroll :: " + transactionTable + " :: coinType :: " + transactionTable.attr('coinType') + " :: numChildren :: " + numChildren + " :: scrollTop :: " + transactionTable.scrollTop() + " :: row min height :: " + minHeight + " :: table height :: " + transactionTable.height() + " :: table row height :: " + (minHeight * numChildren));
    }
}

JaxxUI.prototype.getTXHistoryLength = function(coinType) {
    return this._numHistoryElementsDisplayed[coinType];
}

JaxxUI.prototype.increaseTXHistoryLength = function(coinType) {
    var transactionHistoryList = wallet.getPouchFold(coinType).getHistory();
    var lengthOfTransactionList = transactionHistoryList.length;
    //    console.log("table :: " + coinType + " :: displayed length :: " +  this._numHistoryElementsDisplayed[coinType] + " :: full tx history length :: " + this._txFullHistory[coinType].length);
    if (this._numHistoryElementsDisplayed[coinType] < lengthOfTransactionList) {
        this._numHistoryElementsDisplayed[coinType] += this._numHistoryElementsDefault;
        var newTransactionHistoryList = transactionHistoryList.slice(0, this._numHistoryElementsDisplayed[coinType]);
        //        console.log("table :: " + coinType + " :: new tx history length :: " + this._numHistoryElementsDisplayed[coinType]);
        this.updateTransactionList(coinType, newTransactionHistoryList);
    }
}

JaxxUI.prototype.resetTXHistory = function(coinType) {
    console.log('TODO  JaxxUI.prototype.resetTXHistory');
    return;
    this._numHistoryElementsDisplayed[coinType] = this._numHistoryElementsDefault;

    var transactionsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName'];

    var transactionTable = $('.table.transactions' + transactionsListElement);

    //    $('html, body').animate({
    //        scrollTop: transactionTable.offset().top
    //    }, 500);
    transactionTable.scrollTop(0);

    //    console.log("transactionTable.scrollTop :: " + transactionTable.scrollTop());
}

JaxxUI.prototype.resetTransactionList = function(coin) {
    console.error()

    //for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
    //var transactionsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName'];

    // var transactionTableElementNoTransactions = $('.table.transactions' + transactionsListElement + ' .noTransactions');

    // transactionTableElementNoTransactions.show();

    // var transactionTableElementTableRows = $('.table.transactions' + transactionsListElement + ' .tableRow');

    //transactionTableElementNoTransactions.remove();
    //}
}

JaxxUI.prototype.isTransactionListEqualToHistory = function(coinType, history) {

    console.warn('TODO transactions history')

    //var transactionsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName'];



    //var transactionTable = $('.table.transactions' + transactionsListElement);

    //  var tableChildren = transactionTable.children('.tableRow');
    //  var numExistingRows = tableChildren.length;

    //@note: check for differences between existing tx list and history.
    // var itemCountDiff = history.length - numExistingRows;

    //    console.log("[pre] table :: " + transactionTable + " :: number of children :: " + numExistingRows + " :: history.length :: " + history.length + " :: itemCountDiff :: " + itemCountDiff);


    // if (itemCountDiff === 0) {
    //     return true;
    // } else {
//    //}
}

JaxxUI.prototype.createNewTransactionRow = function(coin) {
    console.error(coin);

    var transactionsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName'];

    var transactionTemplateElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionTemplateElementName'];

    var transactionTable = $('.table.transactions' + transactionsListElement);
    var templateTransaction = $('.transactionRowTemplate' + transactionTemplateElement + ' > div');

    var row = templateTransaction.clone(true);
    row.addClass('tableRow');

    //    console.log("with table :: " + JSON.stringify($(transactionTable)) + " :: cloning :: " + JSON.stringify(templateTransaction) + " :: " + JSON.stringify(row));

    $('.receiveConfirmations', row).hide();
    $('.sendToAddress', row).show();
    // $(row, '.transactionDirectionHeader').text("Received From");
    $('.transactionDirectionHeader', row).text("Sent To");

    row.attr('rowtxid', -1);

    (function (row) {

        $('.glance', row).click(function() {

            var thisElement = $(this).parent()[0];

            console.log("glance :: " + row);



            $('.glance', row).toggleClass("cssTransactionRowSelected");


            //@note: hide the send/receive tabs, hide all other table elements.
            Navigation.returnToDefaultView();
            Navigation.hideTransactionHistoryDetails(thisElement);

            $('.verbose', row).slideToggle();


        });

        $('.verbose', row).click(function() {

            $('.glance', row).toggleClass("cssTransactionRowSelected");

        });
        $('.verbose', row).click(function() {
            $('.glance', row).toggleClass("cssTransactionRowSelected");
        });
        $('.verbose', row).css({display: 'none'}).click(function() {
//            console.log("verbose :: " + row);
            $('.verbose', row).slideToggle();
        });
    })(row);

    transactionTable.append(row);
}

JaxxUI.prototype.updateTransactionList = function(coinType, history) {
    console.log('TODO transactions list');

    return;
    //return;

    //    console.log("updateTransactionList :: " + coinType + " :: " + history.length + " :: this._numHistoryElementsDisplayed[coinType] :: " + this._numHistoryElementsDisplayed[coinType]);
    this.removeLoadMoreButtonTransactionList(coinType);

    this._txFullHistory[coinType] = history;

    history = history.slice(0, this._numHistoryElementsDisplayed[coinType]);

    var transactionsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName'];

    var transactionTable = $('.table.transactions' + transactionsListElement);

    var tableChildren = transactionTable.children('.tableRow');
    var numExistingRows = tableChildren.length;

    //    console.log("[pre] table :: " + transactionTable + " :: number of children :: " + numExistingRows + " :: history.length :: " + history.length);

    //@note: check for differences between existing tx list and history. push or pop as necessary.
    var itemCountDiff = history.length - numExistingRows;
    if (itemCountDiff < 0) {
        for (var i = 0; i < -itemCountDiff; i++) {
            transactionTable.children('.tableRow').last().remove();
        }

        tableChildren = transactionTable.children('.tableRow');
        numExistingRows = tableChildren.length;
    } else if (itemCountDiff > 0) {
        for (var i = 0; i < itemCountDiff; i++) {
            this.createNewTransactionRow(coinType);
        }

        tableChildren = transactionTable.children('.tableRow');
        numExistingRows = tableChildren.length;
    }

    //    console.log("[post] table :: " + transactionTable + " :: number of children :: " + numExistingRows + " :: history.length :: " + history.length);


    if (history.length === 0) {
        $('.noTransactions', transactionTable).show();
    } else {
        $('.noTransactions', transactionTable).hide();
    }

    ////__________________________________________________________
    /// console.log(history);

    for (var i = 0; i < history.length; i++) {
        var item = history[i];


        var row = $(tableChildren[i]);

        //@note: caches the rows via txid.
        var rowtxid = row.attr('rowtxid');
        if (history[i].txid === rowtxid) {
            // continue;
        } else {
            row.attr('rowtxid', history[i].txid);
        }

        if (item.deltaBalance < 0) {
            $('.receiveConfirmations', row).hide();
            $('.sendToAddress', row).show();
            $('.transactionDirectionHeader', row).text("Sent To");
        } else {
            $('.receiveConfirmations', row).show();
            $('.sendToAddress', row).hide();
            $('.transactionDirectionHeader', row).text("Received From");
        }

        //            console.log("bitcoin history item :: " + i + " :: " + item.deltaBalance);

        var itemAmount = item.deltaBalance;
        var amountFieldText = "";
        var blockExplorerEntrypoint = "";
        var itemTime = 0;

        if (coinType === COIN_BITCOIN) {
            if (itemAmount < 0) {
                itemAmount -= item.miningFee;

            }


            amountFieldText = ((itemAmount > 0) ? '+' : '') + HDWalletHelper.convertSatoshisToBitcoins(itemAmount) + ' BTC';

            itemTime = item.timestamp;

            //            blockExplorerEntrypoint = HDWallet.TESTNET ? 'https://tbtc.blockr.io/tx/info/' : 'https://blockr.io/tx/info/';
            blockExplorerEntrypoint = 'https://live.blockcypher.com/btc/tx/';
            var blockHeight = item.blockHeight;
            if(blockHeight < 1 ) blockHeight = '--';

            $('.blockHeight', row).text(blockHeight);

            $('.miningFee', row).text(HDWalletHelper.convertSatoshisToBitcoins(item.miningFee));

        } else if (coinType === COIN_ETHEREUM) {

            var indexOfDecimalPlace = itemAmount.indexOf('.');

            if (itemAmount.length - indexOfDecimalPlace - 1 > 8) { // If the string is too long.
                // Then we cut it off and add ....
                itemAmount = itemAmount.substring(0, indexOfDecimalPlace + 1 + 8) + '...';
            }

            amountFieldText = ((parseFloat(itemAmount) > 0) ? '+' : '') + itemAmount + ' ETH';
            //            }

            itemTime = item.timestamp * 1000;

            blockExplorerEntrypoint = 'https://www.etherscan.io/tx/';


            var blockHeight = item.blockHeight;
            if(blockHeight < 1 ) blockHeight = '--';

            $('.blockHeight', row).text(blockHeight);


            $('.gasCost', row).text(item.gasCost + " Ether");
        } else if (coinType === COIN_ETHEREUM_CLASSIC) {

            var indexOfDecimalPlace = itemAmount.indexOf('.');

            if (itemAmount.length - indexOfDecimalPlace - 1 > 8) { // If the string is too long.
                // Then we cut it off and add ....
                itemAmount = itemAmount.substring(0, indexOfDecimalPlace + 1 + 8) + '...';
            }


            //var decimalDifference = parseFloat(item.deltaBalance) - parseFloat(parseFloat(item.deltaBalance).toFixed(8));

            //if (decimalDifference !== 0.0) {
            //    itemAmount = parseFloat(item.deltaBalance).toFixed(8) + "...";
            //}

            // This is where logic is inserted that allows us to create transaction display data.

            //			console.log("(" + item.toAddress + "," + wallet.theDAOAddress + ")");
            //            if (item.toAddressFull === HDWalletHelper.theDAOAddress) {
            //                // This 'if' branch is entered when a DAO transaction takes place.
            //                amountFieldText = ((parseFloat(itemAmount) > 0) ? '+': '') + itemAmount + ' ETH';
            //                $( "div[rowtxid=" + item.txid + "]").find(".cssDisplayForDAOImageInTransaction").css("display", "block"); // Displays the 'td' element that has the attached image.
            //
            //            } else {
            // This 'if' branch is entered when an ETH transaction takes place.
            amountFieldText = ((parseFloat(itemAmount) > 0) ? '+' : '') + itemAmount + ' ETC';
            //            }

            itemTime = item.timestamp * 1000;

            blockExplorerEntrypoint = 'https://gastracker.io/tx/';

            var blockHeight = item.blockHeight;
            if(blockHeight < 1 ) blockHeight = '--';

            $('.blockHeight', row).text(blockHeight);

            $('.gasCost', row).text(item.gasCost + " Ether");
        } else if (coinType === COIN_THEDAO_ETHEREUM) {
            //@note: @todo: @next:
            //            var decimalDifference = parseFloat(item.deltaBalance) - parseFloat(parseFloat(item.deltaBalance).toFixed(8));
            //
            //            if (decimalDifference !== 0.0) {
            //                itemAmount = parseFloat(item.deltaBalance).toFixed(8) + "...";
            //            }
            //
            //            amountFieldText = ((item.deltaBalance > 0) ? '+': '') + itemAmount + ' ETH';
            //
            //            itemTime = item.timestamp * 1000;
            //
            //            blockExplorerEntrypoint = 'https://www.etherchain.org/tx/';
            //
            //            $('.blockNumber', row).text(item.blockNumber);
            //
            //            $('.gasCost', row).text(item.gasCost + " Ether");
        } else if (coinType === COIN_DASH) {
            if (itemAmount < 0) {
                itemAmount -= item.miningFee;
            }

            amountFieldText = ((itemAmount > 0) ? '+' : '') + HDWalletHelper.convertSatoshisToBitcoins(itemAmount) + ' DASH';

            itemTime = item.timestamp; // Changed for display purposes

            //            blockExplorerEntrypoint = HDWallet.TESTNET ? 'https://tbtc.blockr.io/tx/info/' : 'https://blockr.io/tx/info/';

            //@note: @here: @todo: @next:
            blockExplorerEntrypoint = 'https://chainz.cryptoid.info/dash/tx.dws?';

            var blockHeight = item.blockHeight;
            if(blockHeight < 1 ) blockHeight = '--';

            $('.blockHeight', row).text(blockHeight);

            $('.miningFee', row).text(HDWalletHelper.convertSatoshisToBitcoins(item.miningFee));
        } else if (coinType === COIN_LITECOIN) {

            if (itemAmount < 0) {
                itemAmount -= item.miningFee;
            }


            amountFieldText = ((itemAmount > 0) ? '+' : '') + HDWalletHelper.convertSatoshisToBitcoins(itemAmount) + ' LTC';

            itemTime = item.timestamp;

            //            blockExplorerEntrypoint = HDWallet.TESTNET ? 'https://tbtc.blockr.io/tx/info/' : 'https://blockr.io/tx/info/';
            blockExplorerEntrypoint = 'https://live.blockcypher.com/ltc/tx/';

            var blockHeight = item.blockHeight;
            if(blockHeight < 1 ) blockHeight = '--';

            $('.blockHeight', row).text(blockHeight);


            $('.miningFee', row).text(HDWalletHelper.convertSatoshisToBitcoins(item.miningFee));
        } else if (coinType === COIN_LISK) {
            //@note: @todo: @here: @lisk:
//            if (itemAmount < 0) {
//                itemAmount -= item.miningFee;
//            }
//
//
//            amountFieldText = ((itemAmount > 0) ? '+': '') + HDWalletHelper.convertSatoshisToBitcoins(itemAmount) + ' LSK';
//
//            itemTime = item.timestamp;
//
//            //            blockExplorerEntrypoint = HDWallet.TESTNET ? 'https://tbtc.blockr.io/tx/info/' : 'https://blockr.io/tx/info/';
//            blockExplorerEntrypoint = 'https://live.blockcypher.com/ltc/tx/';
//
//            $('.blockHeight', row).text(item.blockHeight);
//
//            $('.miningFee', row).text(HDWalletHelper.convertSatoshisToBitcoins(item.miningFee));
        } else if (coinType === COIN_ZCASH) {

            if (itemAmount < 0) {
                itemAmount -= item.miningFee;
            }


            amountFieldText = ((itemAmount > 0) ? '+' : '') + HDWalletHelper.convertSatoshisToBitcoins(itemAmount) + ' ZEC';

            itemTime = item.timestamp;

            //@note: @here: @todo: @zcash: reevaluate this block explorer.
            blockExplorerEntrypoint = 'https://explorer.zcha.in/transactions/';

            var blockHeight = item.blockHeight;
            if(blockHeight < 1 ) blockHeight = '--';

            $('.blockHeight', row).text(blockHeight);


            $('.miningFee', row).text(HDWalletHelper.convertSatoshisToBitcoins(item.miningFee));
        } else if (coinType === COIN_TESTNET_ROOTSTOCK) {
            var indexOfDecimalPlace = itemAmount.indexOf('.');

            if (itemAmount.length - indexOfDecimalPlace - 1 > 8) { // If the string is too long.
                // Then we cut it off and add ....
                itemAmount = itemAmount.substring(0, indexOfDecimalPlace + 1 + 8) + '...';
            }


            //var decimalDifference = parseFloat(item.deltaBalance) - parseFloat(parseFloat(item.deltaBalance).toFixed(8));

            //if (decimalDifference !== 0.0) {
            //    itemAmount = parseFloat(item.deltaBalance).toFixed(8) + "...";
            //}

            // This is where logic is inserted that allows us to create transaction display data.

            //			console.log("(" + item.toAddress + "," + wallet.theDAOAddress + ")");
            //            if (item.toAddressFull === HDWalletHelper.theDAOAddress) {
            //                // This 'if' branch is entered when a DAO transaction takes place.
            //                amountFieldText = ((parseFloat(itemAmount) > 0) ? '+': '') + itemAmount + ' ETH';
            //                $( "div[rowtxid=" + item.txid + "]").find(".cssDisplayForDAOImageInTransaction").css("display", "block"); // Displays the 'td' element that has the attached image.
            //
            //            } else {
            // This 'if' branch is entered when an ETH transaction takes place.
            amountFieldText = ((parseFloat(itemAmount) > 0) ? '+' : '') + itemAmount + ' RSK';
            //            }
            itemTime = item.timestamp * 1000;

            blockExplorerEntrypoint = null;

            var blockHeight = item.blockHeight;
            if(blockHeight < 1 ) blockHeight = '--';

            $('.blockHeight', row).text(blockHeight);


            $('.gasCost', row).text(item.gasCost + " Ether");
        } else if (coinType === COIN_DOGE) {

            if (itemAmount < 0) {
                itemAmount -= item.miningFee;
            }


            amountFieldText = ((itemAmount > 0) ? '+' : '') + HDWalletHelper.convertSatoshisToBitcoins(itemAmount) + ' DOGE';

            itemTime = item.timestamp;

            //            blockExplorerEntrypoint = HDWallet.TESTNET ? 'https://tbtc.blockr.io/tx/info/' : 'https://blockr.io/tx/info/';
            blockExplorerEntrypoint = 'https://live.blockcypher.com/doge/tx/';

            var blockHeight = item.blockHeight;
            if(blockHeight < 1 ) blockHeight = '--';

            $('.blockHeight', row).text(blockHeight);


            $('.miningFee', row).text(HDWalletHelper.convertSatoshisToBitcoins(item.miningFee));
        }

        $('.amount', row).text(amountFieldText);

        $('.date', row).text(moment(itemTime).format("MMM D YYYY"));
        $('.time', row).text(moment(itemTime).format("h:mma"));

        $('.txid', row).text(item.txid);

        var linkDisplayText = truncate(item.txid, 5, 5);

        //@note:@here:@todo:

        if (blockExplorerEntrypoint === null) {
            $('.txidShort').text((item.txid + "").substr(0, 5) + "..." + (item.txid + "").substr((item.txid + "").length - 5));
        } else {
            var linkToExplorer = blockExplorerEntrypoint + item.txid;

            g_JaxxApp.getUI().setupExternalLink($('.txidShort', row), linkDisplayText, linkToExplorer);
        }

        if (item.toAddress === null) {
            item.toAddress = "Self";
            $('.toAddresscopy', row).hide();
        }


        $('.toAddress', row).text(item.toAddress);
        $('.toAddressShort', row).text(truncate(item.toAddress, 4, 4));
        $('.toAddresscopy', row).attr('copy', item.toAddress);

        var confirmationString = wallet.getPouchFold(coinType).getConfirmationDisplayString(item.confirmations);
        // item.confirmations

        $('.glance .confirmations', row).text(confirmationString);
        if (item.confirmations) {
            $('.verbose .confirmations', row).text(wallet.getPouchFold(coinType).getConfirmationDisplayStringForNumberOfConfirmations(item.confirmations));
            $('.verbose .heading', row).text("Confirmations");
        } else {
            $('.verbose .confirmations', row).text("");
            $('.verbose .heading', row).text("");
        }
    }

    // this.resizeTransactionTable(coinType);
    // Set the height of the transaction wrapper:
    // ie. $(".transactionsBitcoin").parent().height($(".transactionsBitcoin").height() - 20);
    //this.addLoadMoreButtonTransactionList(coinType);
}

JaxxUI.prototype.pushCurrencyMainMenuToJaxxSettings = function(){
    var arrCurrencyRowsInList = $('.mainMenuCurrencies .exchangeRateList tbody').children();
    var arrFiatUnits = [];
    var arrActiveFiatUnits = [];
    for (var i = 0; i < arrCurrencyRowsInList.length; i++){
        if ($(arrCurrencyRowsInList[i]).children('.cssSelectedCurrency').children('.cssCircleUnchecked').hasClass('cssCurrencyisChecked'))
        {
            arrActiveFiatUnits.push($(arrCurrencyRowsInList[i]).attr('value'))
        }    

        arrFiatUnits.push($(arrCurrencyRowsInList[i]).attr('value'));    
    }
    g_JaxxApp.getSettings().setCurrencyPositionList(arrFiatUnits);

    var fiatController = Registry.getFiatPriceController();
    fiatController.setActiveFiatCurrencies(arrActiveFiatUnits);
}

JaxxUI.prototype.createNewAccountRow = function(coinType) {
    var accountsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['accountsListElementName'];
    var accountTemplateElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['accountTemplateElementName']
    var accountTable = $(accountsListElement);
    var templateAccount = $('.accountDataRowTemplate' + accountTemplateElement + ' > div');
    var row = templateAccount.clone(true);
    row.addClass('tableRow');
    //    console.log("with table :: " + JSON.stringify($(transactionTable)) + " :: cloning :: " + JSON.stringify(templateTransaction) + " :: " + JSON.stringify(row));
    //    row.attr('rowtxid', -1);
    accountTable.append(row);
}

JaxxUI.prototype.getAccountRow = function(coinType, strPrivateKey, strAddress, strBalance){
    var accountTemplateElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['accountTemplateElementName'];
    var templateAccount = $('.accountDataRowTemplate' + accountTemplateElement + ' > div');
    var row = templateAccount.clone(true);
    row.addClass('tableRow');
    //    console.log("with table :: " + JSON.stringify($(transactionTable)) + " :: cloning :: " + JSON.stringify(templateTransaction) + " :: " + JSON.stringify(row));
    //    row.attr('rowtxid', -1);
    $('.accountPublicAddress', row).text(strAddress);
    $('.accountPrivateKey', row).text(strPrivateKey);
    //rohit changes
    //$('.populateNonHDPrivateKey').attr('copy', strPrivateKey);
    //rohit
    $('.accountBalance', row).text(strBalance);
    return row;
}

JaxxUI.prototype.appendAccountRowToAccountList = function(coinType, row){
    var accountsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['accountsListElementName'];
    var accountTable = $(accountsListElement);
    accountTable.append(row);
}

JaxxUI.prototype.updateAndLoadPrivateKeyList = function(symbol) {

    // this._strKeyPair = "address,privatekey, ";

    // $('.cssWrapperPrivateKeys').each(function(index, element) {
    //     $(element).hide();
    // });

    var ctr = jaxx.Registry.getCryptoControllerBySymbol(symbol);
    ctr.getPrivateKeys().done(function(result) {
        jaxx.PrivateKeyList.instance.displayPrivateKeys(result, symbol);
    });

}

JaxxUI.prototype.updatePrivateKeyList = function(coinType) {
    var pageDisplayPrivateKeysName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['pageDisplayPrivateKeysName'];
    var accountsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['accountsListElementName'];
    var accounts = g_JaxxApp.getDataStoreController().getCryptoControllerByCoinType(coinType).getBalances();
    var accountTable = $(accountsListElement);
    var tableChildren = accountTable.children('.tableRow'); // accountTable.children().remove(); // accountTable.children('.tableRow');
    // var numExistingRows = tableChildren.length;
    //    console.log("[pre] table :: " + accountTable + " :: number of children :: " + numExistingRows + " :: accounts.length :: " + accounts.length);
    //@note: check for differences between existing tx list and history. push or pop as necessary.
    // var itemCountDiff = accounts.length - numExistingRows;
    // if (itemCountDiff < 0) {
    //     for (var i = 0; i < -itemCountDiff; i++) {
    //         accountTable.children('.tableRow').last().remove();
    //     }
    //
    //     tableChildren = accountTable.children('.tableRow');
    //     numExistingRows = tableChildren.length;
    // } else if (itemCountDiff > 0) {
    //     for (var i = 0; i < itemCountDiff; i++) {
    //         this.createNewAccountRow(coinType);
    //     }
    //
    //     tableChildren = accountTable.children('.tableRow');
    //     numExistingRows = tableChildren.length;
    // }
    //    console.log("[post] table :: " + accountTable + " :: number of children :: " + numExistingRows + " :: accounts.length :: " + accounts.length);

    accountTable.children('.cssKeySpacer').remove();
    tableChildren.remove();
    //@note: @here: @token: this seems necessary.
    //$('.' + pageDisplayPrivateKeysName + ' .textDisplayMessageForPrivateKeys').hide();
    for (var i = 0; i < accounts.length; i++) {
        var account = accounts[i];
        // We retrieve balance information from DCL Layer Data.
        var address = account.id;
        var balanceFromDCL = wallet.getPouchFold(coinType).getDataStorageController().getBalanceByAddress(address);
        var displayBalanceFromDCL = HDWalletHelper.convertCoinToUnitType(coinType, balanceFromDCL, COIN_UNITLARGE);
        var displayBalanceForPrivateKeys = wallet.getPouchFold(coinType).getPrivateKeyDisplayBalance(displayBalanceFromDCL);

        var row = g_JaxxApp.getUI().getAccountRow(coinType, "<error getting private key>", address, displayBalanceForPrivateKeys); //
        var largeBalance = displayBalanceForPrivateKeys;
        //        console.log("account :: " + i + " :: balance :: " + account.balance + " :: largeBalance :: " + largeBalance + " :: " + JSON.stringify(account));
        //$('.accountPublicAddress', row).text(address);
        //$('.accountPrivateKey', row).text(privateKeyFromDCL);
        //if (coinType === COIN_BITCOIN) {
        //    $('.accountBalance', row).text(displayBalanceForPrivateKeys);
        this.appendAccountRowToAccountList(coinType, row);
        for (var j = 0; j < COIN_NUMCOINTYPES; j++) {
            var coinLargePngName = HDWalletPouch.getStaticCoinPouchImplementation(j).uiComponents['coinLargePngName'];
            $(coinLargePngName, row).hide();
        }
        if (coinType === COIN_ETHEREUM) {

            largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

            if (parseFloat(largeBalance) >= 0.000001) {
                $(row).find(".HDAccounts .etherDisplay").show();
            } else {
                largeBalance = 0;
                $(row).find(".HDAccounts .etherDisplay").show();
                //$(row, ".backupPrivateKeysEthereum .HDAccounts .etherDisplay").show();
            }

            var accountDAOBalance = HDWalletHelper.convertCoinToUnitType(COIN_THEDAO_ETHEREUM, wallet.getPouchFold(COIN_THEDAO_ETHEREUM).getAccountBalance(address), COIN_UNITLARGE) * 100;
            accountDAOBalance = parseFloat(parseFloat(accountDAOBalance).toFixed(8));
            if (parseFloat(accountDAOBalance) >= 0.000001) {
                $(row).find(".DAODisplay").show();
            } else {
                accountDAOBalance = 0;
                $(row).find(".DAODisplay").hide();
            }

            var accountREPRawBalance = wallet.getPouchFold(COIN_AUGUR_ETHEREUM).getDataStorageController().getBalanceByAddress(address);
            var accountREPBalance = HDWalletHelper.convertCoinToUnitType(COIN_AUGUR_ETHEREUM, accountREPRawBalance, COIN_UNITLARGE);
            accountREPBalance = parseFloat(parseFloat(accountREPBalance).toFixed(8));
            if (parseFloat(accountREPBalance) >= 0.000001) { // Show token display?
                $(row).find('.REPDisplay').show();
            } else {
                accountREPBalance = 0;
                $(row).find('.REPDisplay').hide();
            }

            var accountICNRawBalance = wallet.getPouchFold(COIN_ICONOMI_ETHEREUM).getDataStorageController().getBalanceByAddress(address);
            var accountICNBalance = HDWalletHelper.convertCoinToUnitType(COIN_ICONOMI_ETHEREUM, accountICNRawBalance, COIN_UNITLARGE);
            accountICNBalance = parseFloat(parseFloat(accountICNBalance).toFixed(8));
            if (parseFloat(accountICNBalance) >= 0.000001) { // Show token display?
                $(row).find('.ICNDisplay').show();
            } else {
                accountICNBalance = 0;
                $(row).find('.ICNDisplay').hide();
            }

            var accountGNTRawBalance = wallet.getPouchFold(COIN_GOLEM_ETHEREUM).getDataStorageController().getBalanceByAddress(address);
            var accountGNTBalance = HDWalletHelper.convertCoinToUnitType(COIN_GOLEM_ETHEREUM, accountGNTRawBalance, COIN_UNITLARGE);
            accountGNTBalance = parseFloat(parseFloat(accountGNTBalance).toFixed(8));
            if (parseFloat(accountGNTBalance) >= 0.000001) { // Show token display?
                $(row).find('.GNTDisplay').show();
            } else {
                accountGNTBalance = 0;
                $(row).find('.GNTDisplay').hide();
            }

            var accountGNORawBalance = wallet.getPouchFold(COIN_GNOSIS_ETHEREUM).getDataStorageController().getBalanceByAddress(address);
            var accountGNOBalance = HDWalletHelper.convertCoinToUnitType(COIN_GNOSIS_ETHEREUM, accountGNORawBalance, COIN_UNITLARGE);
            accountGNOBalance = parseFloat(parseFloat(accountGNOBalance).toFixed(8));
            if (parseFloat(accountGNOBalance) >= 0.000001) { // Show token display?
                $(row).find('.GNODisplay').show();
            } else {
                accountGNOBalance = 0;
                $(row).find('.GNODisplay').hide();
            }

            var accountSNGLSRawBalance = wallet.getPouchFold(COIN_SINGULARDTV_ETHEREUM).getDataStorageController().getBalanceByAddress(address);
            var accountSNGLSBalance = HDWalletHelper.convertCoinToUnitType(COIN_SINGULARDTV_ETHEREUM, accountSNGLSRawBalance, COIN_UNITLARGE);
            accountSNGLSBalance = parseFloat(parseFloat(accountSNGLSBalance).toFixed(8));
            if (parseFloat(accountSNGLSBalance) >= 0.000001) { // Show token display?
                $(row).find('.SNGLSDisplay').show();
            } else {
                accountSNGLSBalance = 0;
                $(row).find('.SNGLSDisplay').hide();
            }

            var accountDGDRawBalance = wallet.getPouchFold(COIN_DIGIX_ETHEREUM).getDataStorageController().getBalanceByAddress(address);
            var accountDGDBalance = HDWalletHelper.convertCoinToUnitType(COIN_DIGIX_ETHEREUM, accountDGDRawBalance, COIN_UNITLARGE);
            accountDGDBalance = parseFloat(parseFloat(accountDGDBalance).toFixed(8));
            if (parseFloat(accountDGDBalance) >= 0.000001) { // Show token display?
                $(row).find('.DGDDisplay').show();
            } else {
                accountDGDBalance = 0;
                $(row).find('.DGDDisplay').hide();
            }

            var accountBCAPRawBalance = wallet.getPouchFold(COIN_BLOCKCHAINCAPITAL_ETHEREUM).getDataStorageController().getBalanceByAddress(address);
            var accountBCAPBalance = HDWalletHelper.convertCoinToUnitType(COIN_BLOCKCHAINCAPITAL_ETHEREUM, accountBCAPRawBalance, COIN_UNITLARGE);
            accountBCAPBalance = parseFloat(parseFloat(accountBCAPBalance).toFixed(8));
            if (parseFloat(accountBCAPBalance) >= 0.000001) { // Show token display?
                $(row).find('.BCAPDisplay').show();
            } else {
                accountBCAPBalance = 0;
                $(row).find('.BCAPDisplay').hide();
            }

            var accountCVCBalance = HDWalletHelper.convertCoinToUnitType(COIN_CIVIC_ETHEREUM, accountCVCRawBalance, COIN_UNITLARGE);
            accountCVCBalance = parseFloat(parseFloat(accountCVCBalance).toFixed(8));
            if (parseFloat(accountCVCBalance) >= 0.000001) { // Show token display?
                $(row).find('.CVCDisplay').show();
            } else {
                accountCVCBalance = 0;
                $(row).find('.CVCDisplay').hide();
            }

            var coinAbbreviatedNameEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameTheDAOEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_THEDAO_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameAugurEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_AUGUR_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameIconomiEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_ICONOMI_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameGolemEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_GOLEM_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameGnosisEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_GNOSIS_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameSingulardtvEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_SINGULARDTV_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameDigixEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_DIGIX_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameBlockchainCapitalEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_BLOCKCHAINCAPITAL_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameCivic = HDWalletPouch.getStaticCoinPouchImplementation(COIN_CIVIC_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            $(row).find('.accountBalanceEther').text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedNameEthereum + '\xa0');

            $(row).find('.accountBalanceDAO').text(("" + accountDAOBalance).substring(0, 8) + " " + coinAbbreviatedNameTheDAOEthereum);

            $(row).find('.accountBalanceREP').text(("" + accountREPBalance).substring(0, 8) + " " + coinAbbreviatedNameAugurEthereum);

            $(row).find('.accountBalanceICN').text(("" + accountICNBalance).substring(0, 8) + " " + coinAbbreviatedNameIconomiEthereum);

            $(row).find('.accountBalanceGNT').text(("" + accountGNTBalance).substring(0, 8) + " " + coinAbbreviatedNameGolemEthereum);

            $(row).find('.accountBalanceGNO').text(("" + accountGNOBalance).substring(0, 8) + " " + coinAbbreviatedNameGnosisEthereum);

            $(row).find('.accountBalanceSNGLS').text(("" + accountSNGLSBalance).substring(0, 8) + " " + coinAbbreviatedNameSingulardtvEthereum);

            $(row).find('.accountBalanceDGD').text(("" + accountDGDBalance).substring(0, 8) + " " + coinAbbreviatedNameDigixEthereum);

            $(row).find('.accountBalanceBCAP').text(("" + accountBCAPBalance).substring(0, 8) + " " + coinAbbreviatedNameBlockchainCapitalEthereum);

            $(row).find('.accountBalanceCVC').text(("" + accountCVCBalance).substring(0, 8) + " " + coinAbbreviatedNameCivic);

            //            if (accountDAOBalance > 0) {
            $('.imgDAO', row).show();
            $('.imgDAO', row).css('display', 'inline-block');
            $('.imgREP', row).show();
            $('.imgREP', row).css('display', 'inline-block');
            $('.imgICN', row).show();
            $('.imgICN', row).css('display', 'inline-block');
            $('.imgGNT', row).show();
            $('.imgGNT', row).css('display', 'inline-block');
            $('.imgGNO', row).show();
            $('.imgGNO', row).css('display', 'inline-block');
            $('.imgSNGLS', row).show();
            $('.imgSNGLS', row).css('display', 'inline-block');
            $('.imgDGD', row).show();
            $('.imgDGD', row).css('display', 'inline-block');
            $('.imgBCAP', row).show();
            $('.imgBCAP', row).css('display', 'inline-block');
            $('.imgCVC', row).show();
            $('.imgCVC', row).css('display', 'inline-block');

            //            } else {
            //                $('.imgDAO', row).hide();
            //            }

            //            if (accountREPBalance > 0) {

            //            } else {
            //                $('.imgREP', row).hide();
            //            }
        } else if (coinType === COIN_ETHEREUM_CLASSIC) {
            largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

            if (parseFloat(largeBalance) >= 0.000001) {

            } else {
                largeBalance = 0;
            }

            var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(COIN_ETHEREUM_CLASSIC).pouchParameters['coinAbbreviatedName'];

            $('.accountBalanceEther', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName + '\xa0');
        } else if (coinType === COIN_THEDAO_ETHEREUM) {
            var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoin).pouchParameters['coinAbbreviatedName'];

            $('.accountBalance', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName);
            //@note: @here: @todo: @augur:
        } else if (coinType === COIN_TESTNET_ROOTSTOCK) {
            largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

            if (parseFloat(largeBalance) >= 0.000001) {
            } else {
                largeBalance = 0;
            }

            var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(COIN_TESTNET_ROOTSTOCK).pouchParameters['coinAbbreviatedName'];

            $('.accountBalanceEther', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName + '\xa0');
            /*
             } else if (coinType === COIN_ZCASH) {
             largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

             if (parseFloat(largeBalance) >= 0.000001) {
             } else {
             largeBalance = 0;
             }

             var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(COIN_ZCASH).pouchParameters['coinAbbreviatedName'];

             $('.accountBalance', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName + '\xa0');
             */
            //} else if (coinType === COIN_DOGE) {
            //largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

            //if (parseFloat(largeBalance) >= 0.000001) {
            //} else {
            //    largeBalance = 0;
            //}

            // var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(COIN_DOGE).pouchParameters['coinAbbreviatedName'];

            // $('.accountBalance', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName + '\xa0');
            //$('.accountBalance', row).text(displayBalanceForPrivateKeys);
        } else {
            // Option For the default private key balance display

            $('.accountBalance', row).text(displayBalanceForPrivateKeys);
        }
        // Show only the active image.
        for (var j = 0; j < COIN_NUMCOINTYPES; j++) {
            var coinLargePngName = HDWalletPouch.getStaticCoinPouchImplementation(j).uiComponents['coinLargePngName'];
            if (j === coinType) {
                $(coinLargePngName, row).show();
                $(coinLargePngName, row).css('display', 'inline-block');
            }
        }

        $(".accountPrivateKey", row).text(wallet.getPouchFold(coinType).getPrivateKeyFromAddress(address));
        this.formatExportPrivateKeys(address, wallet.getPouchFold(coinType).getPrivateKeyFromAddress(address));

        $('.imgShapeShift', row).hide();


        //        $('.imgDAO', row).bind('beforeShow', function() {
        //            console.log("yo");
        //        });
        //
        //        $('.imgDAO', row).bind('beforeHide', function() {
        //            console.log("sup");
        //        });
        /*
        if (item.isShapeShiftAssociated === true) {
            $('.imgShapeShift', row).show();
        } else {
            $('.imgShapeShift', row).hide();
        }*/
    }
    $('.' + pageDisplayPrivateKeysName + ' .textDisplayMessageForPrivateKeys').hide();
    if (coinType === COIN_ETHEREUM){
        $(".backupPrivateKeyListETHLegacyWarning").show();
        $(".accountDataEthereumLegacyKeypair").show();
        $(".nonHDAccounts").show();
        $(".nonHDMessage").show();
        $(".wrapperDisplayMessageForPrivateKeys").show();
    }
    var accountsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['accountsListElementName'];
    var accountTable = $(accountsListElement);
    accountTable.append("<div class='cssKeySpacer'></div>");
}

JaxxUI.prototype.formatExportPrivateKeys = function(address, keys) {
    this._strKeyPair += address + "," + keys + ",\n";
}

JaxxUI.prototype.updateAccountList = function(coinType, accounts) {
    var accountsListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['accountsListElementName'];

    var accountTable = $(accountsListElement);

    var tableChildren = accountTable.children('.tableRow');
    var numExistingRows = tableChildren.length;

    //    console.log("[pre] table :: " + accountTable + " :: number of children :: " + numExistingRows + " :: accounts.length :: " + accounts.length);

    //@note: check for differences between existing tx list and history. push or pop as necessary.
    var itemCountDiff = accounts.length - numExistingRows;
    if (itemCountDiff < 0) {
        for (var i = 0; i < -itemCountDiff; i++) {
            accountTable.children('.tableRow').last().remove();
        }

        tableChildren = accountTable.children('.tableRow');
        numExistingRows = tableChildren.length;
    } else if (itemCountDiff > 0) {
        for (var i = 0; i < itemCountDiff; i++) {
            this.createNewAccountRow(coinType);
        }

        tableChildren = accountTable.children('.tableRow');
        numExistingRows = tableChildren.length;
    }

    //    console.log("[post] table :: " + accountTable + " :: number of children :: " + numExistingRows + " :: accounts.length :: " + accounts.length);


    //@note: @here: @token: this seems necessary.
    for (var i = 0; i < accounts.length; i++) {
        var item = accounts[i];
        // We retrieve balance information from DCL Layer Data.
        var balanceFromDCL = wallet.getPouchFold(coinType).getDataStorageController().getBalanceByAddress(item.pubAddr);
        var displayBalanceFromDCL = HDWalletHelper.convertCoinToUnitType(coinType, balanceFromDCL, COIN_UNITLARGE);
        var displayBalanceForPrivateKeys = wallet.getPouchFold(coinType).getPrivateKeyDisplayBalance(displayBalanceFromDCL);

        var row = $(tableChildren[i]);

        var largeBalance = displayBalanceForPrivateKeys;

        //        console.log("account :: " + i + " :: balance :: " + item.balance + " :: largeBalance :: " + largeBalance + " :: " + JSON.stringify(item));

        $('.accountPublicAddress', row).text(item.pubAddr);
        $('.accountPrivateKey', row).text(item.pvtKey);

        for (var j = 0; j < COIN_NUMCOINTYPES; j++) {
            var coinLargePngName = HDWalletPouch.getStaticCoinPouchImplementation(j).uiComponents['coinLargePngName'];

            if (j === coinType) {
                $(coinLargePngName, row).show();
            } else {
                $(coinLargePngName, row).hide();
            }
        }

        //if (coinType === COIN_BITCOIN) {
        //    $('.accountBalance', row).text(displayBalanceForPrivateKeys);
        if (coinType === COIN_ETHEREUM) {
            largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

            if (parseFloat(largeBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .etherDisplay").show();
            } else {
                largeBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .etherDisplay").hide();
            }

            var accountDAOBalance = HDWalletHelper.convertCoinToUnitType(COIN_THEDAO_ETHEREUM, wallet.getPouchFold(COIN_THEDAO_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE) * 100;

            accountDAOBalance = parseFloat(parseFloat(accountDAOBalance).toFixed(8));
            if (parseFloat(accountDAOBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .DAODisplay").show();
            } else {
                accountDAOBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .DAODisplay").hide();
            }

            var accountREPBalance = HDWalletHelper.convertCoinToUnitType(COIN_AUGUR_ETHEREUM, wallet.getPouchFold(COIN_AUGUR_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE);

            accountREPBalance = parseFloat(parseFloat(accountREPBalance).toFixed(8));
            if (parseFloat(accountREPBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .REPDisplay").hide();
            } else {
                accountREPBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .REPDisplay").hide();
            }

            var accountICNBalance = HDWalletHelper.convertCoinToUnitType(COIN_ICONOMI_ETHEREUM, wallet.getPouchFold(COIN_ICONOMI_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE);

            accountICNBalance = parseFloat(parseFloat(accountICNBalance).toFixed(8));
            if (parseFloat(accountICNBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .ICNDisplay").hide();
            } else {
                accountICNBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .ICNDisplay").hide();
            }

            var accountGNOBalance = HDWalletHelper.convertCoinToUnitType(COIN_GNOSIS_ETHEREUM, wallet.getPouchFold(COIN_GNOSIS_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE);

            accountGNOBalance = parseFloat(parseFloat(accountGNOBalance).toFixed(8));
            if (parseFloat(accountGNOBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .GNODisplay").hide();
            } else {
                accountGNOBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .GNODisplay").hide();
            }

            var accountSNGLSBalance = HDWalletHelper.convertCoinToUnitType(COIN_SINGULARDTV_ETHEREUM, wallet.getPouchFold(COIN_SINGULARDTV_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE);

            accountSNGLSBalance = parseFloat(parseFloat(accountSNGLSBalance).toFixed(8));
            if (parseFloat(accountSNGLSBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .SNGLSDisplay").hide();
            } else {
                accountSNGLSBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .SNGLSDisplay").hide();
            }

            var accountGNTBalance = HDWalletHelper.convertCoinToUnitType(COIN_GOLEM_ETHEREUM, wallet.getPouchFold(COIN_GOLEM_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE);

            accountGNTBalance = parseFloat(parseFloat(accountGNTBalance).toFixed(8));
            if (parseFloat(accountGNTBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .GNTDisplay").hide();
            } else {
                accountGNTBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .GNTDisplay").hide();
            }

            var accountDGDBalance = HDWalletHelper.convertCoinToUnitType(COIN_DIGIX_ETHEREUM, wallet.getPouchFold(COIN_DIGIX_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE);

            accountDGDBalance = parseFloat(parseFloat(accountDGDBalance).toFixed(8));
            if (parseFloat(accountDGDBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .DGDDisplay").hide();
            } else {
                accountDGDBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .DGDDisplay").hide();
            }

            var accountBCAPBalance = HDWalletHelper.convertCoinToUnitType(COIN_BLOCKCHAINCAPITAL_ETHEREUM, wallet.getPouchFold(COIN_BLOCKCHAINCAPITAL_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE);

            accountBCAPBalance = parseFloat(parseFloat(accountBCAPBalance).toFixed(8));
            if (parseFloat(accountBCAPBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .BCAPDisplay").hide();
            } else {
                accountBCAPBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .BCAPDisplay").hide();
            }

            var accountCVCBalance = HDWalletHelper.convertCoinToUnitType(COIN_CIVIC_ETHEREUM, wallet.getPouchFold(COIN_CIVIC_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE);

            accountCVCBalance = parseFloat(parseFloat(accountCVCBalance).toFixed(8));
            if (parseFloat(accountCVCBalance) >= 0.000001) {
                $(".backupPrivateKeysEthereum .HDAccounts .CVCDisplay").hide();
            } else {
                accountCVCBalance = 0;
                $(".backupPrivateKeysEthereum .HDAccounts .CVCDisplay").hide();
            }

            var coinAbbreviatedNameEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameTheDAOEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_THEDAO_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameAugurEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_AUGUR_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameIconomiEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_ICONOMI_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameGnosisEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_GNOSIS_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameGolemEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_GOLEM_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameSingulardtvEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_SINGULARDTV_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameDigixEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_DIGIX_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameBlockchainCapitalEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_BLOCKCHAINCAPITAL_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            var coinAbbreviatedNameCivic = HDWalletPouch.getStaticCoinPouchImplementation(COIN_CIVIC_ETHEREUM).pouchParameters['coinAbbreviatedName'];

            $('.accountBalanceEther', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedNameEthereum + '\xa0');

            $('.accountBalanceDAO', row).text(("" + accountDAOBalance).substring(0, 8) + " " + coinAbbreviatedNameTheDAOEthereum);

            $('.accountBalanceREP', row).text(("" + accountREPBalance).substring(0, 8) + " " + coinAbbreviatedNameAugurEthereum);

            $('.accountBalanceGNT', row).text(("" + accountGNTBalance).substring(0, 8) + " " + coinAbbreviatedNameIconomiEthereum);
            $('.accountBalanceSNGLS', row).text(("" + accountSNGLSBalance).substring(0, 8) + " " + coinAbbreviatedNameGnosisEthereum);
            $('.accountBalanceICN', row).text(("" + accountICNBalance).substring(0, 8) + " " + coinAbbreviatedNameGolemEthereum);
            $('.accountBalanceGNO', row).text(("" + accountGNOBalance).substring(0, 8) + " " + coinAbbreviatedNameSingulardtvEthereum);
            $('.accountBalanceDGD', row).text(("" + accountDGDBalance).substring(0, 8) + " " + coinAbbreviatedNameDigixEthereum);
            $('.accountBalanceBCAP', row).text(("" + accountBCAPBalance).substring(0, 8) + " " + coinAbbreviatedNameBlockchainCapitalEthereum);
            $('.accountBalanceCVC', row).text(("" + accountCVCBalance).substring(0, 8) + " " + coinAbbreviatedNameCivic);


//            if (accountDAOBalance > 0) {
            $('.imgDAO', row).show();
//            } else {
//                $('.imgDAO', row).hide();
//            }

//            if (accountREPBalance > 0) {
            $('.imgREP', row).show();
            $('.imgICN', row).show();
            $('.imgGNT', row).show();
            $('.imgGNO', row).show();
            $('.imgSNGLS', row).show();
            $('.imgDGD', row).show();
            $('.imgBCAP', row).show();
            $('.imgCVC', row).show();

//            } else {
//                $('.imgREP', row).hide();
//            }
        } else if (coinType === COIN_ETHEREUM_CLASSIC) {
            largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

            if (parseFloat(largeBalance) >= 0.000001) {
            } else {
                largeBalance = 0;
            }

            var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(COIN_ETHEREUM_CLASSIC).pouchParameters['coinAbbreviatedName'];

            $('.accountBalanceEther', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName + '\xa0');
        } else if (coinType === COIN_THEDAO_ETHEREUM) {
            var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoin).pouchParameters['coinAbbreviatedName'];

            $('.accountBalance', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName);
            //@note: @here: @todo: @augur:
        } else if (coinType === COIN_TESTNET_ROOTSTOCK) {
            largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

            if (parseFloat(largeBalance) >= 0.000001) {
            } else {
                largeBalance = 0;
            }

            var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(COIN_TESTNET_ROOTSTOCK).pouchParameters['coinAbbreviatedName'];

            $('.accountBalanceEther', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName + '\xa0');
            /*
            } else if (coinType === COIN_ZCASH) {
                largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

                if (parseFloat(largeBalance) >= 0.000001) {
                } else {
                    largeBalance = 0;
                }

                var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(COIN_ZCASH).pouchParameters['coinAbbreviatedName'];

                $('.accountBalance', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName + '\xa0');
            */
            //} else if (coinType === COIN_DOGE) {
            //largeBalance = parseFloat(parseFloat(largeBalance).toFixed(8));

            //if (parseFloat(largeBalance) >= 0.000001) {
            //} else {
            //    largeBalance = 0;
            //}

            // var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(COIN_DOGE).pouchParameters['coinAbbreviatedName'];

            // $('.accountBalance', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedName + '\xa0');
            //$('.accountBalance', row).text(displayBalanceForPrivateKeys);
        } else {
            // Option For the default private key balance display
            $('.accountBalance', row).text(displayBalanceForPrivateKeys);
        }

//        $('.imgDAO', row).bind('beforeShow', function() {
//            console.log("yo");
//        });
//
//        $('.imgDAO', row).bind('beforeHide', function() {
//            console.log("sup");
//        });

        if (item.isShapeShiftAssociated === true) {
            $('.imgShapeShift', row).show();
        } else {
            $('.imgShapeShift', row).hide();
        }
    }




}
/*
JaxxUI.prototype.setupEthereumLegacyKeypairDisplay = function(item) {
    var largeBalance = HDWalletHelper.convertCoinToUnitType(COIN_ETHEREUM, item.balance, COIN_UNITLARGE);

    //    console.log("ethereum legacy account :: balance :: " + item.balance + " :: largeBalance :: " + largeBalance + " :: " + JSON.stringify(item));

    var row = $('.accountDataEthereumLegacyKeypair');

    var accountDAOBalance = HDWalletHelper.convertCoinToUnitType(COIN_THEDAO_ETHEREUM, wallet.getPouchFold(COIN_THEDAO_ETHEREUM).getAccountBalance(item.pubAddr), COIN_UNITLARGE) * 100;

    var coinAbbreviatedNameEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_ETHEREUM).pouchParameters['coinAbbreviatedName'];

    var coinAbbreviatedNameTheDAOEthereum = HDWalletPouch.getStaticCoinPouchImplementation(COIN_THEDAO_ETHEREUM).pouchParameters['coinAbbreviatedName'];

    $('.accountPublicAddress', row).text(item.pubAddr);
    $('.accountPrivateKey', row).text(item.pvtKey);
    //change was made to pass copytoclipboard for ETH private keys
    $('.populateNonHDPublicKey').attr('copy', item.pubAddr);
    $('.populateNonHDPrivateKey').attr('copy', item.pvtKey);
    //changes-end
    $('.accountBalanceEther', row).text(("" + largeBalance).substring(0, 8) + " " + coinAbbreviatedNameEthereum + '\xa0');
    $('.accountBalanceDAO', row).text(("" + accountDAOBalance).substring(0, 8) + " " + coinAbbreviatedNameTheDAOEthereum); // This line will display something like XX.XXX DAO in the legacy key pairs.

    for (var j = 0; j < COIN_NUMCOINTYPES; j++) {
        var coinLargePngName = HDWalletPouch.getStaticCoinPouchImplementation(j).uiComponents['coinLargePngName'];

        if (j === COIN_ETHEREUM || j === COIN_THEDAO_ETHEREUM) {
            $(coinLargePngName, row).show();
        } else {
            $(coinLargePngName, row).hide();
        }
    }

    if (parseFloat(largeBalance) >= 0.000001) {
        $(".backupPrivateKeysEthereum .nonHDAccounts .etherDisplay").show();
    } else {
        largeBalance = 0;
        $(".backupPrivateKeysEthereum .nonHDAccounts .etherDisplay").hide();
    }

    if (parseFloat(accountDAOBalance) >= 0.000001) {
        $(".backupPrivateKeysEthereum .nonHDAccounts .DAODisplay").show();
    } else {
        accountDAOBalance = 0;
        $(".backupPrivateKeysEthereum .nonHDAccounts .DAODisplay").hide();
    }

    if (item.isShapeShiftAssociated === true) {
        $('.imgShapeShift', row).show();
    } else {
        $('.imgShapeShift', row).hide();
    }
}*/

JaxxUI.prototype.resetShapeShift = function() {
    console.log('resetShapeShift');

    //@note: @todo: @here: @optimization: this might want to be checked for validity re: opacity or such.

    g_JaxxApp.getUI().hideShapeshiftSpinner();

    // console.error(' JaxxUI.prototype.resetShapeShift     ')

    return

    if (g_JaxxApp.getShapeShiftHelper().getIsTriggered()) {
        if (this.isShapeshiftCoinListOpen()) {
            this.closeShapeshiftCoinList();
        }

        $('.shapeShiftToggleItem :checkbox').prop('checked', false);

        // $('.spendableShapeshift').slideUp();

        //Reset normal UI values (remove shapeshift)
        $('.tabContent .address input').css({backgroundImage: 'none'}).removeClass('validShapeshift').removeClass('cssValidShapeshift ');
        $('.tabContent .amount input').attr("placeholder", "Amount"); //Change text of amount placeholder
        $('#sendLabel').text("Send");
        $('.tabContent .amount input').removeClass('validShapeshiftAmount').removeClass('cssValidShapeshiftAmount ');

        /*if (curCoinType === COIN_ETHEREUM) {
            $('.tabContent .advancedTabButton').show().slideDown();
        }*/

        //  var coinDisplayColor = HDWalletPouch.getStaticCoinPouchImplementation(receiveCoinType).uiComponents['coinDisplayColor'];

        //$('.shapeShiftToggleButtonLabel').css({'background': coinDisplayColor});
    }

    // g_JaxxApp.getShapeShiftHelper().setReceivePairForCoinType(curCoinType, receiveCoinType);

    g_JaxxApp.getShapeShiftHelper().reset();
}

JaxxUI.prototype.beginShapeShiftMultiShift = function() {
    g_JaxxApp.getUI().showShapeshiftSpinner();
}

JaxxUI.prototype.endShapeShiftMultiShift = function() {
    g_JaxxApp.getUI().hideShapeshiftSpinner();
}


JaxxUI.prototype.populateShapeShiftReceiveData = function(ssMarketData) {

    // console.warn(ssMarketData);
    //@note: @todo: in the Grand Cleaning.

    var curMarketData = g_JaxxApp.getShapeShiftHelper().getMarketForCoinTypeSend(curCoinType);

    if (curMarketData.multiShift !== null) {
        var foundIssue = false;

        for (var i = 0; i < curMarketData.multiShift.length; i++) {
            if (typeof(curMarketData.multiShift[i]) !== 'undefined' && curMarketData.multiShift[i] !== null && curMarketData.multiShift[i].depositAddress !== null) {
                //                console.log("shapeShift :: multiShifting :: " + i + " :: with deposit :: " + curMarketData.multiShift[i].depositAddress);
                //                depositAddresses[i] = curMarketData.multiShift[i].depositAddress;
            } else {
                console.log("shapeShift :: issue with deposit :: " + i);
                foundIssue = true;
            }
        }

        if (foundIssue !== true) {
            console.log("shapeShift :: done multishifting :: " + curMarketData.multiShift.length);
        }
    } else {
        console.log("shapeShift :: issue with multishifting :: " + JSON.stringify(curMarketData, null, 4));
    }

    $('.tabContent .amount input').trigger('keyup');
    updateSpendable();
}

JaxxUI.prototype.triggerShapeShift = function(curCoinType, numShiftsRequired) {

    var self = this;

    g_JaxxApp.getShapeShiftHelper().requestMultiShift(curCoinType, numShiftsRequired, function(shiftParams) {
        //
        var depositAddress = wallet.getPouchFold(curCoinType).setShapeShiftDepositAddress( shiftParams.shiftMarketData.depositAddress);
        var coinTypeDict = g_JaxxApp.getShapeShiftHelper().getPairCoinTypeDict(shiftParams.shiftMarketData.pair);

        if (coinTypeDict.send === curCoinType) {
            g_JaxxApp.getUI().populateShapeShiftReceiveData(g_JaxxApp.getShapeShiftHelper()._marketData[coinTypeDict.send][coinTypeDict.receive]);
        }
    });
};

// JAXX COIN BULLETIN STUFF BEGINS

JaxxUI.prototype.fetchAndStoreCoinBulletinData = function(){
    var self = this;

    var callback = function(data){
        self.storeCoinBulletinData(data);
        self.populateCoinBulletinMenu();
    };

    this.getJaxxCoinBulletin(callback);
};
/*
* Obtain jaxx news data located in local storage
* @method getJaxxCoinBulletin
* @param {Function} callback - function to fire after obtaining jaxxNews
* */
JaxxUI.prototype.getJaxxCoinBulletin = function(callback) {
    // **** Reminder:  When testing use different endpoint - not the live one ****
    var url;
    if(Registry.application.config.utils) {
      url = Registry.application.config.utils.coinBulletin;
      var filePath = Registry.application.config.utils.localCoinBulletin;
      var key = UTILS_COIN_BULLETIN;
      jaxx.FileManager.updateLocalStorage(url, filePath, key, function(err) {
        if(err) {
          console.error(err);
        } else {
          var data = jaxx.FileManager.getLocalStorage(key);
          callback(data || []);
        }
      });
    } else {
      url = "https://jaxx.io/jaxx-data/jaxx-coin-bulletin.php";
      $.getJSON( url, function( data ) {
        callback(data || []);
      });
    }

};

JaxxUI.prototype.storeCoinBulletinData = function(data){
    // coinTypes = Object.keys(data);
    var newData = {};
    var coinType;
   // console.warn(data);
    for (var i = 0; i < data.length; i++) {
        coinType = Object.keys(data[i]);
        if(!coinType[0]) continue;
        newData[coinType[0]] = {};
        newData[coinType[0]]["criticality"] = JaxxUtils.scrubInput(data[i][coinType[0]]["criticality"]);
        newData[coinType[0]]["version"] = JaxxUtils.scrubInput(data[i][coinType[0]]["version"]);
        newData[coinType[0]]["menu_title"] = JaxxUtils.scrubInput(data[i][coinType[0]]["menu_title"]);
        newData[coinType[0]]["title"] = JaxxUtils.scrubInput(data[i][coinType[0]]["title"]);
        newData[coinType[0]]["description"] = JaxxUtils.scrubInput(data[i][coinType[0]]["description"]);
        newData[coinType[0]]["date"] = JaxxUtils.scrubInput(data[i][coinType[0]]["date"]);
        }
    g_JaxxApp.getUI().setCoinBulletinData(newData);
};

JaxxUI.prototype.setCoinBulletinData = function(newData){
    this._jaxxCoinBulletin = newData;
};

JaxxUI.prototype.getCoinBulletinData = function(){
    return this._jaxxCoinBulletin;
};

JaxxUI.prototype.populateCoinBulletinMenu = function(){
    var coinAbbreviatedNames = Object.keys(this._jaxxCoinBulletin);
    var bulletinMenu = $(".bulletinPage .scrollableMenuList");
    var jNews = $('.jaxxNews .cssBtnIntroRight');
    bulletinMenu.empty();

    // For each bulletin JSON object, grab data from the file and generate the bulletin menu
    for (var i = 0; i < coinAbbreviatedNames.length; i++){
        if(coinAbbreviatedNames[i] !== "ALL")
        {
            var coinType = jaxx.Registry.getCryptoControllerBySymbol(coinAbbreviatedNames[i]).config.symbol;
            if(!coinType)
            {
                return;
            }
            // Call getCoinBulletinMenuRow to generate the menu item based on the coin type
            bulletinMenu.append(g_JaxxApp.getUI().getCoinBulletinMenuRow(coinType));
            jNews.attr('value', coinAbbreviatedNames[i]);
        }
        else
        {
            // Special case for "ALL" bulletin that doesn't work with getCoinBulletinMenuRow since it's not a coin
            // Generates the menu item for the special case for a bulletin that is not coin specific
            var menuTitle = this.getCoinBulletinData()["ALL"]["menu_title"];
            var date = this.getCoinBulletinData()["ALL"]["date"];
            var htmlRow = '<div class="settingsResetCache expandableText cssExpandableText scriptAction cssOpacity expandableDetailsAncestor cssInitialHeight bulletinPadding" specialaction="jaxx_controller.showCoinBulletin" value="ALL">';
            htmlRow += '<div class="coinIcon cssCoinIcon cssImageLogoIconAll cssHighlighted"><div class="image"></div></div>';
            htmlRow += '<div class="expandableDetailsHeader cssExpandableDetailsHeader">';
            htmlRow += '<div class="optionTrigger cssOptionTrigger">';
            htmlRow += '<div class="optionHeading cssOptionHeading bulletinTitle">';
            htmlRow += '<label class="menuCoinBulletinTitle cssMenuCoinBulletinTitle">'+menuTitle+'</label>';
            htmlRow += '</div>';
            htmlRow += '<div class="postedDateWrapper cssOptionHeading italicText bulletinDate"><div class="postedLabel cssPostedLabel">Posted:</div>';
            htmlRow += '<div class="postedDate cssPostedDate">'+ date+'</div></div>';
            htmlRow += '</div>';
            htmlRow += '</div>';
            htmlRow += '</div>';

            bulletinMenu.append(htmlRow);
            jNews.attr('value', coinAbbreviatedNames[i]);
        }

    }
    this.attachClickEventForScriptAction($(".bulletinPage .scrollableMenuList .scriptAction"));
};

JaxxUI.prototype.getCoinBulletinMenuRow = function(coinType){
    var coinAbbreviatedName = jaxx.Registry.getCryptoControllerBySymbol(coinType).config.symbol;
    var menuTitle = this.getCoinBulletinData()[coinAbbreviatedName]["menu_title"];
    var date = this.getCoinBulletinData()[coinAbbreviatedName]["date"];
    var icon = jaxx.Registry.getCryptoControllerBySymbol(coinType).config.icon;

    // Appending to an HTML object that this function returns to create a bulletin menu item based a coin type and the data from the JSON
    var htmlRow = '<div class="settingsResetCache expandableText cssExpandableText scriptAction cssOpacity expandableDetailsAncestor cssInitialHeight bulletinPadding" specialaction="jaxx_controller.showCoinBulletin" value='+coinAbbreviatedName+'>';
        htmlRow += '<div class="coinIcon cssCoinIcon cssHighlighted"><div class="image"><img src="' + icon + '" class="cssImageLogoIcon"></div></div>';
        htmlRow += '<div class="expandableDetailsHeader cssExpandableDetailsHeader">';
        htmlRow += '<div class="optionTrigger cssOptionTrigger">';
        htmlRow += '<div class="optionHeading cssOptionHeading bulletinTitle">';
        htmlRow += '<label class="menuCoinBulletinTitle cssMenuCoinBulletinTitle">'+menuTitle+'</label>';
        htmlRow += '</div>';
        htmlRow += '<div class="postedDateWrapper cssOptionHeading italicText bulletinDate"><div class="postedLabel cssPostedLabel">Posted:</div>';
        htmlRow += '<div class="postedDate cssPostedDate">'+ date+'</div></div>';
        htmlRow += '</div>';
        htmlRow += '</div>';
        htmlRow += '</div>';

    return htmlRow;
};

// JAXX COIN BULLETIN STUFF ENDS

// JAXX NEWS STUFF BEGINS
/*
* Obtain jaxx news data located in local storage
* @method getJaxxNews
* @param {Function} callback - function to fire after obtaining jaxxNews
* */
JaxxUI.prototype.getJaxxNews = function(callback) {
    var self = this;
    // **** Reminder:  When testing use different endpoint - not the live one ****
    var url;
    if(Registry.application.config.utils) {
        url = Registry.application.config.utils.jaxxNews;
      var filePath = Registry.application.config.utils.localJaxxNews;
      var key = UTILS_NEWS;
      jaxx.FileManager.updateLocalStorage(url, filePath, key, function(err) {
        if(err) {
          console.error(err);
        } else {
          var data = jaxx.FileManager.getLocalStorage(key);
          if(data && data[0]) {
            self._jaxxNewsData = data[0];
            callback();
          }
        }
      });
    } else {
      url = "https://jaxx.io/jaxx-data/jaxx-news.php"
      $.getJSON( url, function( data ) {
        if (data && data[0]) {
          self._jaxxNewsData = data[0];
          callback();
        }
      });
    }

};

JaxxUI.prototype.displayJaxxNews = function() {
    console.log("news data :: " + JSON.stringify(this._jaxxNewsData));
    var scrubbedTitleString = JaxxUtils.scrubInput(this._jaxxNewsData.title);
    $('.getTitleForJaxxNews').text(scrubbedTitleString);
    var scrubbedBodyString = JaxxUtils.scrubInput(this._jaxxNewsData.description);
    //            console.log("data[0].description :: " + this._jaxxNewsData.description + " :: scrubbed :: " + scrubbedBodyString);
    var version = null;
    if (typeof(this._jaxxNewsData.version) !== 'undefined' && this._jaxxNewsData.version !== null){
        version = this._jaxxNewsData.version;
    }
    if (typeof(version) !== 'undefined' && version !== null){
        this.addJaxxNewsShownVersions(JaxxUtils.scrubInput(version));
    }
    $('.getDescriptionForJaxxNews').html(scrubbedBodyString);
    Navigation.openModal('jaxxNews');
};

JaxxUI.prototype.addJaxxNewsShownVersions = function(strVersion){
    if (typeof(this._criticalVersionUpdatesShown) !== 'undefined' && this._criticalVersionUpdatesShown !== null && typeof(strVersion) !== 'undefined' && strVersion !== null){
        if (!(this._criticalVersionUpdatesShown.indexOf(strVersion) > -1)){
            this._criticalVersionUpdatesShown.push(strVersion);
            storeData('criticalVersionUpdatesShown', JSON.stringify(this._criticalVersionUpdatesShown), false);
        }
    }
};

JaxxUI.prototype.displayJaxxNewsIfUnseen = function() {
    if (this._hasDisplayedJaxxNews === false) {
        this._hasDisplayedJaxxNews = true;
        var version = JaxxUtils.scrubInput(this._jaxxNewsData.version);
        if (typeof(version) !== 'undefined' && version !== null){
            if (!(this._criticalVersionUpdatesShown.indexOf(version) > -1)){
                this.displayJaxxNews();
            }
        }
    }
}

JaxxUI.prototype.displayJaxxNewsIfCritical = function() {
    if (this._jaxxNewsData !== null && this._jaxxNewsData.criticality === "critical") {
        this.displayJaxxNewsIfUnseen();
        //            console.log("news data :: " + data[0].criticality)
    }
    else {
        //            console.log("view bulleting menu for relative news")
    }
}
// JAXX NEWS STUFF ENDS

// RELEASE NOTES BULLETIN STUFF BEGINS

// Run release bulletin if it hasn't been run already.
/*
* Obtain Release Bulletin data from local storage and show release notes if not shown
* @method getReleaseBulletin
* @param {Function} callback - function to fire after this has been executed.
* */
JaxxUI.prototype.getReleaseBulletin = function(callback) {
    var self = this;
    // **** Reminder:  When testing use different endpoint - not the live one ****
    var url;
    if(Registry.application.config.utils) {
      url = Registry.application.config.utils.jaxxReleaseNotes; // "https://jaxx.io/jaxx-data/jaxx-release-notes.php";
      var filePath = Registry.application.config.utils.localJaxxReleaseNotes;
      var key = UTILS_RELEASE_NOTES;
      jaxx.FileManager.updateLocalStorage(url, filePath, key, function(err) {
        if(err) {
          console.error(err);
          g_JaxxApp.getUI().startJaxxIfNoReleaseNotesAreShown();
        } else {
          var data = jaxx.FileManager.getLocalStorage(key);
          if(data && data[0]) {
            self._jaxxReleaseBulletin = self.getReleaseNotesByPlatform(data[0]);
            callback();
          } else {
            g_JaxxApp.getUI().startJaxxIfNoReleaseNotesAreShown();
          }
        }
      });
    } else {
        url = "https://jaxx.io/jaxx-data/jaxx-release-notes.php";
        $.getJSON( url, function( data ) {
          if (data && data[0]) {
            self._jaxxReleaseBulletin = self.getReleaseNotesByPlatform(data[0]);
            callback();
          } else {
            g_JaxxApp.getUI().startJaxxIfNoReleaseNotesAreShown();
          }
        }).fail(function(err) {
          g_JaxxApp.getUI().startJaxxIfNoReleaseNotesAreShown();
        })
    }

}

JaxxUI.prototype.scrubReleaseBulletinDescription = function(description){
    // g_JaxxApp.getUI().scrubReleaseBulletinDescription({   "inputImprovements": {"title": "Improvements", "details": "<ul><li>new stuff</li></ul>"},"inputBugFixes":{"title": "Bug Fixes","details":"<ul><li>new stuff</li></ul>"},"inputNewFeatures":{"title": "Improvements","details": "<ul><li>new stuff</li></ul>"}}) // try this
    for (var i = 0; i < description.length; i++){
        description[i]["element"] = JaxxUtils.scrubInput(description[i]["element"]);
        description[i]["title"] = JaxxUtils.scrubInput(description[i]["title"]);
        description[i]["details"] = JaxxUtils.scrubInput(description[i]["details"]);
    }
    return description;
}

JaxxUI.prototype.scrubReleaseBulletinTitle = function(title){
    return JaxxUtils.scrubInput(title);
}

JaxxUI.prototype.scrubReleaseBulletinHeading = function(heading){
    return JaxxUtils.scrubInput(heading);
}

JaxxUI.prototype.processScrubbedBodyString = function(scrubbedBodyString){
    for (var i = 0; i < scrubbedBodyString.length; i++){
        var key = scrubbedBodyString[i]["element"];
        titleSelector = $(".pageReleaseNotesBulletin .dataFromServer" + "." + key + ".title");
        detailsSelector = $(".pageReleaseNotesBulletin .dataFromServer" + "." + key + ".details");
        titleSelector.html(scrubbedBodyString[i]["title"]);
        detailsSelector.html(scrubbedBodyString[i]["details"]);
    }
    // $('.descriptionForJaxxReleaseBulletin').html(scrubbedBodyString);
}

JaxxUI.prototype.processScrubbedTitleString = function(scrubbedTitleString){
    $(".titleForJaxxReleaseBulletin").text(scrubbedTitleString);
}

JaxxUI.prototype.processScrubbedHeadingString = function(scrubbedHeadingString){
    $(".headingForJaxxReleaseBulletin").text(scrubbedHeadingString);
}

JaxxUI.prototype.displayJaxxReleaseBulletin = function() {
    //console.warn ("news data :: " + JSON.stringify(this._jaxxReleaseBulletin));
    var scrubbedTitleString = JaxxUtils.scrubInput(this._jaxxReleaseBulletin.title);
    $('.titleForJaxxReleaseBulletin').text(scrubbedTitleString);
    var scrubbedBodyString = this.scrubReleaseBulletinDescription(this._jaxxReleaseBulletin.description);
    var scrubbedTitleString = this.scrubReleaseBulletinTitle(this._jaxxReleaseBulletin.title);
    var scrubbedHeadingString = this.scrubReleaseBulletinHeading(this._jaxxReleaseBulletin.heading);
    //            console.log("data[0].description :: " + this._jaxxNewsData.description + " :: scrubbed :: " + scrubbedBodyString);
    var version = null;
    if (typeof(this._jaxxReleaseBulletin.version) !== 'undefined' && this._jaxxReleaseBulletin.version !== null){
        version = this._jaxxReleaseBulletin.version;
    }
    if (typeof(version) !== 'undefined' && version !== null){
        this.addReleaseBulletinShownVersions(JaxxUtils.scrubInput(version));
    }
    this.processScrubbedBodyString(scrubbedBodyString);
    this.processScrubbedTitleString(scrubbedTitleString);
    this.processScrubbedHeadingString(scrubbedHeadingString);
    $('.descriptionForJaxxReleaseBulletinWrapper').css('height', (window.innerHeight - 215).toString() + "px");

    if (!this._startJaxxWithTermsOfServicePageWasRun) { // In case the terms of service page was already shown (because release notes page)
        Navigation.pushSettings('pageReleaseNotesBulletin');
    }
    this.hideSplashScreen();
    this._release_notes_have_been_shown = true; // Last just in case something fails.
}

JaxxUI.prototype.addReleaseBulletinShownVersions = function(strVersion){
    if (typeof(this._jaxxReleaseBulletinVersions) !== 'undefined' && this._jaxxReleaseBulletinVersions !== null && typeof(strVersion) !== 'undefined' && strVersion !== null){
        if (!(this._jaxxReleaseBulletinVersions.indexOf(strVersion) > -1)){
            this._jaxxReleaseBulletinVersions.push(strVersion);
            storeData('_jaxxReleaseBulletinVersions', JSON.stringify(this._jaxxReleaseBulletinVersions), false);
        }
    }
}

JaxxUI.prototype.displayJaxxReleaseBulletinIfUnseen = function() {
    var version = JaxxUtils.scrubInput(this._jaxxReleaseBulletin.version);
    if (typeof(version) !== 'undefined' && version !== null) {
        if (!(this._jaxxReleaseBulletinVersions.indexOf(version) > -1)) {
            this._release_notes_have_been_shown = true; // Last just in case something fails.
            this.displayJaxxReleaseBulletin();
        } else {
            g_JaxxApp.getUI().startJaxxIfNoReleaseNotesAreShown();
        }
    }
}



JaxxUI.prototype.hideSplashScreen = function(){
    if (window.native && window.native.hideSplashScreen) window.native.hideSplashScreen();
    setTimeout(function () {
        $(".applicationStart").fadeOut();
    },200)

}

JaxxUI.prototype.startJaxxIfNoReleaseNotesAreShown = function(){
    if (!this._release_notes_have_been_shown){

        g_JaxxApp.getInitializer().startJaxxWithTermsOfServicePage();


    } else {
        if (!this._release_notes_have_been_shown){
            this.displayJaxxReleaseBulletin();
        }
    }

    this.hideSplashScreen();
}

JaxxUI.prototype.getReleaseNotesByPlatform = function(data){
    var key = this.getReleaseNotesKeyBasedOnPlatform();
    // @TODO: USE default if data[key] is non-existant
    return data[key];
}

JaxxUI.prototype.getReleaseNotesKeyBasedOnPlatform = function() {
    if (PlatformUtils.mobileiOSCheck()){
        return "ios";
    } else if (PlatformUtils.mobileAndroidCheck) {
        return "android";
    } else if (PlatformUtils.desktopCheck()) {
        return "desktop";
    } else if (PlatformUtils.extensionSafariCheck()){
        return "safari";
    } else if (PlatformUtils.extensionChromeCheck()) {
        return "chrome";
    } else if (PlatformUtils.extensionFirefoxCheck()) {
        return "firefox";
    } else {
        return "default";
    }
}

// BEGIN: CHANGE LOG INFORMATION

JaxxUI.prototype.getChangeLogByPlatform = function(data) {
    var key = this.getChangeLogKeyBasedOnPlatform();
    if (typeof(data[key]) === 'undefined' || data[key] === null) {
        return data["default"];
    } else {
        return data[key];
    }
}

JaxxUI.prototype.getChangeLogKeyBasedOnPlatform = function() {
    if (PlatformUtils.mobileiOSCheck()){
        return "ios";
    } else if (PlatformUtils.mobileAndroidCheck) {
        return "android";
    } else if (PlatformUtils.desktopCheck()) {
        return "desktop";
    } else if (PlatformUtils.extensionSafariCheck()){
        return "safari";
    } else if (PlatformUtils.extensionChromeCheck()) {
        return "chrome";
    } else if (PlatformUtils.extensionFirefoxCheck()) {
        return "firefox";
    } else {
        return "default";
    }
}
/*
* Obtain change log data from local storage
* @method getChangeLog
* @param {Function} callback - function to execute after this is completed.
* */
JaxxUI.prototype.getChangeLog = function(callback) {
    var self = this;
    // **** Reminder:  When testing use different endpoint - not the live one ****;
    var url;
    if(Registry.application.config.utils) {
      url = Registry.application.config.utils.changeLog;
      var filePath = Registry.application.config.utils.localChangeLog;
      var key = UTILS_CHANGE_LOG;
      jaxx.FileManager.updateLocalStorage(url, filePath, key, function(err) {
        if(err) {
          console.error(err);
          g_JaxxApp.getUI().startJaxxIfNoReleaseNotesAreShown();
        } else {
          var data = jaxx.FileManager.getLocalStorage(key);
          if(data && data[0]) {
            self._changeLog = JaxxUtils.scrubInput(self.getChangeLogByPlatform(data[0]));
            callback();
          }
        }
      });
    } else {
      url = "https://jaxx.io/jaxx-data/change-log.php";
      $.getJSON( url, function( data ) {
        if (data && data[0]) {
          self._changeLog = JaxxUtils.scrubInput(self.getChangeLogByPlatform(data[0]));
          callback();
        }
      });
    }
}

JaxxUI.prototype.updateChangeLogFromServer = function() {
    var self = this;
    callback = function() {
        $(".changeLogCenter").html(unescape(self._changeLog));
    }
    this.getChangeLog(callback);
}

// END: CHANGE LOG INFORMATION

// BEGIN: CHANGE LOG SUMMARY INFORMATION

JaxxUI.prototype.getChangeLogSummaryByPlatform = function(data) {
    var key = this.getChangeLogSummaryKeyBasedOnPlatform();
    if (typeof(data[key]) === 'undefined' || data[key] === null) {
        return data["default"];
    } else {
        return data[key];
    }
}

JaxxUI.prototype.getChangeLogSummaryKeyBasedOnPlatform = function() {
    if (PlatformUtils.mobileiOSCheck()){
        return "ios";
    } else if (PlatformUtils.mobileAndroidCheck) {
        return "android";
    } else if (PlatformUtils.desktopCheck()) {
        return "desktop";
    } else if (PlatformUtils.extensionSafariCheck()){
        return "safari";
    } else if (PlatformUtils.extensionChromeCheck()) {
        return "chrome";
    } else if (PlatformUtils.extensionFirefoxCheck()) {
        return "firefox";
    } else {
        return "default";
    }
}

/*
* Obtain Change log summary from local storage
* @method getChangeLogSummary
* @param {Function} callback - function to fire after obtaining change log.
* */
JaxxUI.prototype.getChangeLogSummary = function(callback) {
    var self = this;
    // **** Reminder:  When testing use different endpoint - not the live one ****
    var url;
    if(Registry.application.config.utils) {
      url = Registry.application.config.utils.changeLogSummary; //"https://jaxx.io/jaxx-data/change-log-summary.php";
      var filePath = Registry.application.config.utils.changeLogSummary;
      var key = UTILS_CHANGE_LOG_SUMMARY;
      jaxx.FileManager.updateLocalStorage(url, filePath, key, function(err) {
        if(err) {
          console.error(err);
        } else {
          var data = jaxx.FileManager.getLocalStorage(key);
          if(data && data[0]) {
            self._changeLogSummary = JaxxUtils.scrubInput(self.getChangeLogSummaryByPlatform(data[0]));
            callback();
          }
        }
      });
    } else {
      url = "https://jaxx.io/jaxx-data/change-log-summary.php";
      $.getJSON( url, function( data ) {
        if (data && data[0]) {
          self._changeLogSummary = JaxxUtils.scrubInput(self.getChangeLogSummaryByPlatform(data[0]));
          callback();
        }
      });
    }

}

JaxxUI.prototype.updateChangeLogSummaryFromServer = function() {
    var self = this;
    callback = function() {
        if (typeof(self._changeLogSummary["version"]) !== "undefined" && self._changeLogSummary["version"] !== null) {
            $(".changeLogSummaryVersion").html(unescape(self._changeLogSummary["version"]));
        }
        if (typeof(self._changeLogSummary["website"]) !== "undefined" && self._changeLogSummary["website"] !== null) {
            $(".changeLogSummaryWebsite").html(unescape(self._changeLogSummary["website"]));
        }
        if (typeof(self._changeLogSummary["websiteContact"]) !== "undefined" && self._changeLogSummary["websiteContact"] !== null) {
            $(".changeLogSummaryWebsiteContact").html(unescape(self._changeLogSummary["websiteContact"]));
        }
        if (typeof(self._changeLogSummary["termsOfService"]) !== "undefined" && self._changeLogSummary["termsOfService"] !== null) {
            $(".changeLogSummaryTermsOfService").html(unescape(self._changeLogSummary["termsOfService"]));
        }
        if (typeof(self._changeLogSummary["privacyPolicy"]) !== "undefined" && self._changeLogSummary["privacyPolicy"] !== null) {
            $(".changeLogSummaryPrivacyPolicy").html(unescape(self._changeLogSummary["privacyPolicy"]));
        }
        if (typeof(self._changeLogSummary["copyright"]) !== "undefined" && self._changeLogSummary["copyright"] !== null) {
            $(".changeLogSummaryCopyright").html(unescape(self._changeLogSummary["copyright"]));
        }
    }
    this.getChangeLogSummary(callback);
}


// END: CHANGE LOG SUMMARY INFORMATION

// RELEASE NOTES BULLETIN STUFF ENDS

JaxxUI.prototype.updateCoinToFiatExchangeRates = function() {
    if (this._mainMenuIsOpen) {
        //this.populateCurrencyList(curCoinType);
    }
}



JaxxUI.prototype.toggleCurrencyCheckbox = function(currency_parent_row) 
{
    $(currency_parent_row).children('td.cssSelectedCurrency').children('div.cssCircleUnchecked').addClass('cssCurrencyisChecked');
    $(currency_parent_row).addClass('cssCurrencyHighlightText');
}

JaxxUI.prototype.populateExchangeRateInMainMenuCurrencyList = function(coinType, fiatUnit){ // parameter coinType is ignored
    /*if (!wallet) {
        return;
    }

    var multiplier = 1.0;

    var displayValue = wallet.getHelper().convertCoinToFiatWithFiatType(coinType, multiplier, COIN_UNITLARGE, fiatUnit, false);

    if (Number.isNaN(displayValue)) {
        displayValue = g_JaxxApp.getUI().getDisplayForBalanceNotAvailable();
    }

    */
    var displayValueWhenConversionUnAvailable = '---';
    var displayValue;
    var Formatters = jaxx.Formatters;
    var fiatPriceController = jaxx.FiatPriceController;    
    var currentCrypto = Registry.getCurrentCryptoController();
    var coinTypeSymbol = "BTC"; // setting a sane default because legacy code might have other opinions on what to initialize first
    if (currentCrypto != null)
    {
        coinTypeSymbol = currentCrypto.symbol;
    }
    
    displayValue = fiatPriceController.coinToFiat("1", coinTypeSymbol, fiatUnit);
    
    if (displayValue != null)
    {
        displayValue = Formatters.balanceForDisplay(displayValue, 2); // limits the decimal count to 2
        displayValue = Formatters.formatFinancialNumber(displayValue);
        displayValue = fiatPriceController.prependFiatSymbolToString(fiatUnit, displayValue);
    } else {
        displayValue = displayValueWhenConversionUnAvailable;
    }
    
    $('.rate' + fiatUnit).text(displayValue);
}

JaxxUI.prototype.closeQuickFiatCurrencySelector = function() {
    if (this.isQuickFiatCurrencySelectorOpen()) {
        $('.wrapTableCurrencySelectionMenu').fadeOut(function() {
            $(".fiatCurrencySelectionMenu").empty();
            $('.displayCurrenciesSelectedArrow img').addClass('cssFlipped');
        });
        //        $('.cssBalanceBox .dismiss').removeClass('cssDismissCurrencySelectionMenu');
        $('.cssDismissCurrencySelectionMenu').css('display', 'none');
    }
}

JaxxUI.prototype.openQuickFiatCurrencySelector = function() {
    // This is called when the user clicks on the arrow on the home screen of Jaxx to show the currencies.
    $(".fiatCurrencySelectionMenu").empty();
    // var currencies = Navigation.getEnabledCurrencies(); // Code from when there was no preference order for currencies.
    var currencies = g_JaxxApp.getSettings().getListOfEnabledCurrencies();
    console.warn("Currency List: ", currencies);
    for (var i = 0; i < currencies.length; i++){
        //element = '<div class="cssCurrency scriptAction setDefaultCurrency" currency=' + currencies[i] + ' > ' + currencies[i] + ' </div>';
        // This 'if' part is for Styling.
        element = '<tr class="quickFiatCurrencySelector ';
        if (i === 0){
            element += 'cssCurrencyFirstElement';
        } else {
            element += 'cssCurrencyAdditionalElement';
        }
        element += ' scriptAction" specialAction="setDefaultCurrencyFromMenu" value="' + currencies[i] + '"> <td class="fiatUnit cssFiatUnit">' + currencies[i] + '</td><td class="covertedBalance cssConvertedBalance"> ' +  wallet.getHelper().convertCoinToFiatWithFiatType(curCoinType, wallet.getPouchFold(curCoinType).getPouchFoldBalance(), COIN_UNITSMALL, currencies[i], false) + '</td></tr>';
        $(".fiatCurrencySelectionMenu").append(element);

        // HDWalletHelper.getFiatUnitPrefix(currencies[i]) +  wallet.getHelper().convertCoinToFiat(curCoinType, currencies[i], HDWalletHelper.convertWeiToEther(wallet.getPouchFold(curCoinType).getPouchFoldBalance())).toFixed(2)
    }

    $('.wrapTableCurrencySelectionMenu').fadeIn();

    $('.cssDismissCurrencySelectionMenu').css('display', 'block');
    // Highlight element matching currency to blue.
    $('.quickFiatCurrencySelector').removeClass('cssBlueHighlight');
    $('.displayCurrenciesSelectedArrow').find('img').removeClass('cssFlipped');
    $('.quickFiatCurrencySelector').filter('tr[value="' + wallet.getHelper().getFiatUnit() + '"]').addClass('cssBlueHighlight');

    scrollIntoView($('.quickFiatCurrencySelector').filter('tr[value="'+wallet.getHelper().getFiatUnit()+'"]'), $('.fiatCurrencySelectionMenu'), $('.wrapTableCurrencySelectionMenu'));

    // @TODO: find a way to refactor this code resuse.
    $('.quickFiatCurrencySelector').off('click'); // This should do nothing, but we add it just in case.
    $('.quickFiatCurrencySelector').click(function (event) {
        try {
            //                console.log("event :: " + JSON.stringify(event);
            scriptAction(event);
        } catch (err) {
            console.error(err);
        }
    });

    Navigation.collapseTabs();
    Navigation.hideTransactionHistoryDetails();
}

JaxxUI.prototype.toggleQuickFiatCurrencySelector = function() {
    console.log("Toggling the quickFiatCurrencySelector menu.");
    if (this.isQuickFiatCurrencySelectorOpen()){
        // Close the currency selection menu.
        this.closeShapeshiftCoinList();
        this.closeQuickFiatCurrencySelector();
    } else {
        // Open the currency selection menu.
        this.openQuickFiatCurrencySelector();
        //$('.wallet .menu,.wallet .dismiss').fadeOut();
        this.closeMainMenu();
    }
}

JaxxUI.prototype.isQuickFiatCurrencySelectorOpen = function(){
    return (!($(".wrapTableCurrencySelectionMenu").css('display') === 'none'));
}

JaxxUI.prototype.setDefaultCurrencyFromMenu = function(element){
    // This code is run when the user selects a currency to use from the list of enabled currencies.
    //    console.log("element :: " + element + " :: element.attr('value') :: " + element.attr('value'));
    var currency = element.attr('value');

    $('.quickFiatCurrencySelector').filter('tr[value="' + wallet.getHelper().getFiatUnit() +'"]').removeClass('cssBlueHighlight');

    wallet.getHelper().setFiatUnit(currency);
    $('.quickFiatCurrencySelector').filter('tr[value="' + currency + '"]').addClass('cssBlueHighlight');

    updateWalletUI();

    var self = this;
    setTimeout(function() {
        self.closeShapeshiftCoinList();
        self.closeQuickFiatCurrencySelector();
    }, 100)
}

JaxxUI.prototype.quickFiatCurrencySwitch = function() {
    var nextCurrency = g_JaxxApp.getSettings().getNextEnabledCurrency(wallet.getHelper().getFiatUnit());
    if (Navigation.isUseFiat()){
        this.convertFiatAmountInSendValueToNewFiatAmount(nextCurrency);
    } else {
        this.convertFiatAmountInSendDetailsToNewFiatAmount(nextCurrency);
    }

    wallet.getHelper().setFiatUnit(nextCurrency);

    if (Navigation.isUseFiat()){
        $('.unitToggle .symbol').text(wallet.getHelper().getFiatUnitPrefix());
    } else {
        // Unit toggle is set to coin so we don't have to do anything.
    }

    updateWalletUI();
    this.closeShapeshiftCoinList();
    JaxxUI.prototype.closeQuickFiatCurrencySelector();
    /*
	  var currencies = Navigation.getEnabledCurrencies();

    var nextCurrency = 0;

    for (var i = 0; i < currencies.length; i++){
        var curCurrency = currencies[i];

        console.log("check currency :: " + curCurrency + " :: current currency :: " + wallet.getHelper().getFiatUnit());

        if (curCurrency === wallet.getHelper().getFiatUnit()) {
            if (i === currencies.length - 1) {
                nextCurrencyIdx = 0;
            } else {
                nextCurrencyIdx = i + 1;
            }

            nextCurrency = currencies[nextCurrencyIdx];
            break;
        }
    }

    $('.quickFiatCurrencySelector').filter('tr[value="' + wallet.getHelper().getFiatUnit() +'"]').removeClass('cssBlueHighlight');

    wallet.getHelper().setFiatUnit(nextCurrency);
    $('.quickFiatCurrencySelector').filter('tr[value="' + nextCurrency + '"]').addClass('cssBlueHighlight');

    updateWalletUI();

    JaxxUI.prototype.closeQuickFiatCurrencySelector();
	*/
}

JaxxUI.prototype.convertFiatAmountInSendValueToNewFiatAmount = function(targetFiatUnit){
    // console.log(' targetFiatUnit   ', targetFiatUnit);


    this.convertFiatToFiatInUIElement('.tabContent .amount input', targetFiatUnit, wallet.getHelper().getFiatUnit(), true);
}

JaxxUI.prototype.convertFiatAmountInSendDetailsToNewFiatAmount = function(targetFiatUnit){
    /// console.log(' targetFiatUnit   ', targetFiatUnit);

    this.convertFiatToFiatInUIElement('.tabContent .amount .amountDetails', targetFiatUnit, wallet.getHelper().getFiatUnit(), false);
}

JaxxUI.prototype.convertFiatToFiatInUIElement = function(strSelector, targetFiatUnit, sourceFiatUnit, noPrefix){
    // parseFloat($('.tabContent .amount input').val());
    var valueToConvert = Number.isNaN(parseFloat($(strSelector).val())) ? 0 : parseFloat($(strSelector).val());


    $(strSelector).val(wallet.convertFiatToFiat(valueToConvert, targetFiatUnit, sourceFiatUnit, noPrefix));
}

JaxxUI.prototype.setFiatPrefixForUnitToggleInSend = function(fiatUnit){

}

JaxxUI.prototype.showDAORefund = function() {
    var showNoBalances = false;

    $('.theDaoRefundConfirmButton').removeClass("cssTheDaoRefundButtonWait");
    $('.theDaoRefundConfirmButton').text("Refund");

    var theDAODefaultGasLimit = HDWalletPouch.getStaticCoinPouchImplementation(COIN_THEDAO_ETHEREUM).getDefaultGasLimit();

    var gasRequiredList = wallet.getPouchFold(COIN_THEDAO_ETHEREUM).hasInsufficientGasForSpendable(theDAODefaultGasLimit * 2);

    //            console.log("gasRequiredList :: " + gasRequiredList);

    if (gasRequiredList.length > 0) {
        $('.theDaoInsufficientGasForRefundWarningText').show();

        //            gasRequiredList.push("0x051Da87c3679Be285DC22E2fbA5E833052375ced");
        //            gasRequiredList.push("0x051Da87c3679Be285DC22E2fbA5E833052375ced");
        //            gasRequiredList.push("0x051Da87c3679Be285DC22E2fbA5E833052375ced");

        $('.theDaoInsufficientGasForRefundWarningText').html("<p>The following DAO-holding addresses require more ETH to be able to perform the refund. We recommend depositing at least 0.01 ETH into this address in your Ethereum wallet:<br></p>" + gasRequiredList.join('<br>'));
    } else {
        $('.theDaoInsufficientGasForRefundWarningText').hide();
    }

    var daoAddressData = wallet.getPouchFold(COIN_THEDAO_ETHEREUM).getSpendableAddresses(0, theDAODefaultGasLimit * 2);

    //    daoAddressData = [];

    if (daoAddressData.length > 0) {
        var refundAddressesString = "";
        for (var i = 0; i < daoAddressData.length; i++) {
            var curAddress = daoAddressData[i].address;
            var curBalance = HDWalletHelper.getCoinDisplayScalar(COIN_THEDAO_ETHEREUM, HDWalletHelper.convertCoinToUnitType(COIN_THEDAO_ETHEREUM, daoAddressData[i].balance, COIN_UNITLARGE), false);

            if (curBalance.toString().length > 8) {
                curBalance = curBalance.toFixed(8);
            }

            refundAddressesString += "<p><span class='cssDaoRefundDisplayAddress'>" + curAddress + ":</span> <span class='cssDaoRefundDisplayAmount cssAmount'>" + curBalance + " DAO</span></p>";
            //            console.log("showDAORefund :: " + i + " :: daoAddressData :: " + JSON.stringify(daoAddressData[i]) + " :: refundAddressesString :: " + refundAddressesString);
        }

        //        console.log("showDAORefund :: daoAddressData :: " + daoAddressData + " :: refundAddressesString :: " + refundAddressesString);

        $('.theDaoRefundAddressesList').html(refundAddressesString);
        $('.theDaoRefundAddressesText').show();
        $('.theDaoRefundCost').show();
        $('.theDaoRefundConfirmButton').addClass('cssEnabled').addClass('enabled');
        $('.theDaoRefundConfirmButton').text("Refund");
        $('.theDaoRefundConfirmButton').attr("specialAction", "confirmDAORefund");
        $('.theDaoRefundConfirmButton').attr("closeModal", null);

        var approveTXDict = this.processDAOApprove(daoAddressData);
        var refundTXDict = this.processDAORefund(daoAddressData);

        $('.daoRefund').data('daoAddressData', daoAddressData);

        var totalTXCost = approveTXDict.totalTXCost + refundTXDict.totalTXCost;
        $('.theDaoRefundCost').text(HDWalletHelper.convertCoinToUnitType(COIN_THEDAO_ETHEREUM, totalTXCost, COIN_UNITLARGE) + " ETH");
    } else {
        $('.theDaoRefundAddressesText').hide();
        $('.theDaoRefundCost').hide();

        $('.theDaoRefundConfirmButton').text("Close");
        $('.theDaoRefundConfirmButton').attr("specialAction", null);
        $('.theDaoRefundConfirmButton').attr("closeModal", "true");

        if (gasRequiredList.length === 0) {
            showNoBalances = true;
        }
    }

    if (showNoBalances === true) {
        $('.theDaoRefundNoBalances').show();
        $('.theDaoRefundConfirmButton').text("Close");
        $('.theDaoRefundConfirmButton').attr("specialAction", null);
        $('.theDaoRefundConfirmButton').attr("closeModal", "true");
    } else {
        $('.theDaoRefundNoBalances').hide();
    }

    Navigation.openModal('daoRefund');
}

JaxxUI.prototype.confirmDAORefund = function() {
    //    console.log("confirmDAORefund");
    //    $('.theDaoRefundConfirmButton').addClass("cssTheDaoRefundButtonWait");
    //    $('.theDaoRefundConfirmButton').text("Please Wait");
    //
    //    return;

    //    $('.theDaoRefundConfirmButton').addClass("cssTheDaoRefundButtonWait");
    //    $('.theDaoRefundConfirmButton').attr("specialAction", null);
    //    $('.theDaoRefundConfirmButton').text("Please Wait");

    var daoAddressData = $('.daoRefund').data('daoAddressData');

    var self = this;

    var approveTXDict = this.processDAOApprove(daoAddressData);

    g_JaxxApp.getTXManager().sendEthereumLikeTXList(COIN_ETHEREUM, approveTXDict, function(result) {
        if (result === 'success') {
            console.log("confirmDAORefund :: approve :: success");
            var refundData = $('.daoRefund').data('refundTXDict');

            $('.theDaoRefundConfirmButton').addClass("cssTheDaoRefundButtonWait");
            $('.theDaoRefundConfirmButton').text("Please Wait");

            setTimeout(function() {
                var refundTXDict = self.processDAORefund(daoAddressData);

                g_JaxxApp.getTXManager().sendEthereumLikeTXList(COIN_ETHEREUM, refundTXDict, function(result) {
                    if (result === 'success') {
                        console.log("confirmDAORefund :: refund :: success");
                        playSound("snd/balance.wav", null, null);
                        Navigation.flashBanner('DAO refund successful', 5);
                    } else {
                        console.log("confirmDAORefund :: refund :: error :: " + result);
                        Navigation.flashBanner('DAO refund error', 5);
                    }

                    $('.daoRefund').data('approveTXDict', null);
                    $('.daoRefund').data('refundTXDict', null);
                    Navigation.closeModal();
                });
            }, 3000);
        } else {
            console.log("confirmDAORefund :: approve :: error :: " + result);

            $('.daoRefund').data('approveTXDict', null);
            $('.daoRefund').data('refundTXDict', null);

            Navigation.closeModal();
        }
    });
}

//@note: @here: @todo: these two classes don't deal with any UI stuff, they should be moved somewhere more appropriate.

JaxxUI.prototype.processDAOApprove = function(daoAddressData) {
    var theDAODefaultGasLimit = HDWalletPouch.getStaticCoinPouchImplementation(COIN_THEDAO_ETHEREUM).getDefaultGasLimit();

    var gasPrice = HDWalletHelper.getDefaultEthereumGasPrice();
    var gasLimit = theDAODefaultGasLimit;

    var tokenContractAddress = CoinToken.getStaticTokenImplementation(CoinToken.TheDAO).pouchParameters['tokenContractAddress'];

    var theDAOTokenWithdrawalAddress = CoinToken.getStaticTokenImplementation(CoinToken.TheDAO).pouchParameters['tokenWithdrawalAddress'];

    var approveOpCode = wallet.getPouchFold(COIN_THEDAO_ETHEREUM).getApproveOpCode();

    var ABIAddressTarget = HDWalletHelper.zeroPadLeft(HDWalletHelper.toEthereumNakedAddress(theDAOTokenWithdrawalAddress), 64);

    var txArray = [];
    var totalTXCost = 0;

    var baseGasCost = gasPrice.mul(gasLimit);

    for (var i = 0; i < daoAddressData.length; i++) {
        var ABIBalanceParameter = HDWalletHelper.zeroPadLeft(daoAddressData[i].balance.toString(16), 64);
        //        var ABIBalanceParameter = HDWalletHelper.zeroPadLeft("1".toString(16), 64);

        var approveTXData = approveOpCode + ABIAddressTarget + ABIBalanceParameter;

        var newTX = wallet.getPouchFold(COIN_ETHEREUM).getPouchFoldImplementation()._buildEthereumTransaction(false, daoAddressData[i].ethereumNodeIndex, tokenContractAddress, 0, gasPrice, gasLimit, approveTXData, null);

        if (newTX) {
            txArray.push(newTX);
        } else {
            console.log("error :: ethereum transaction :: account failed to build :: " + daoAddressData[i].ethereumNodeIndex);
            return null;
        }

        totalTXCost += parseInt(baseGasCost);
    }

    console.log("processDAOApprove :: txArray.length :: " + txArray.length + " :: txArray :: " + JSON.stringify(txArray) + " :: baseGasCost :: " + baseGasCost);

    return {txArray: txArray, totalTXCost: totalTXCost};
}

JaxxUI.prototype.processDAORefund = function(daoAddressData) {
    var theDAODefaultGasLimit = HDWalletPouch.getStaticCoinPouchImplementation(COIN_THEDAO_ETHEREUM).getDefaultGasLimit();

    var gasPrice = HDWalletHelper.getDefaultEthereumGasPrice();
    var gasLimit = theDAODefaultGasLimit;

    var theDAOTokenWithdrawalAddress = CoinToken.getStaticTokenImplementation(CoinToken.TheDAO).pouchParameters['tokenWithdrawalAddress'];

    var refundOpCode = wallet.getPouchFold(COIN_THEDAO_ETHEREUM).getRefundOpCode();

    var txArray = [];
    var totalTXCost = 0;

    var baseGasCost = gasPrice.mul(gasLimit);

    for (var i = 0; i < daoAddressData.length; i++) {
        var newTX = wallet.getPouchFold(COIN_ETHEREUM).getPouchFoldImplementation()._buildEthereumTransaction(false, daoAddressData[i].ethereumNodeIndex, theDAOTokenWithdrawalAddress, 0, gasPrice, gasLimit, refundOpCode, null);

        if (newTX) {
            txArray.push(newTX);
        } else {
            console.log("error :: ethereum transaction :: account failed to build :: " + daoAddressData[i].ethereumNodeIndex);
            return null;
        }

        totalTXCost += parseInt(baseGasCost);
    }

    console.log("processDAORefund :: txArray.length :: " + txArray.length + " :: txArray :: " + JSON.stringify(txArray));

    return {txArray: txArray, totalTXCost: totalTXCost};
}

JaxxUI.prototype.switchToSolidCoinButton = function(coinType) {
    console.log(' TODO  JaxxUI.prototype.switchToSolidCoinButton');
    return

    var coinButtonName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonName'];

    var coinButtonSVGName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonSVGName'];

    $(coinButtonName).css({background: 'url(images/' + coinButtonSVGName + '.svg) no-repeat center center'});
    $(coinButtonName).addClass('cssSelected');
    $(coinButtonName).off('mouseleave');
}

JaxxUI.prototype.initializeToCoinType = function(targetCoinType) {
    console.log(' TODO  JaxxUI.prototype.initializeToCoinType' , targetCoinType);
    return;

    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
        var coinSpinnerElementName = HDWalletPouch.getStaticCoinPouchImplementation(i).uiComponents['coinSpinnerElementName'];

        var transactionsListElement = HDWalletPouch.getStaticCoinPouchImplementation(i).uiComponents['transactionsListElementName'];

        $(coinSpinnerElementName).fadeTo(0, 0);
        $(coinSpinnerElementName).hide();

        if (i !== targetCoinType) {
            //            $(coinHelpMenuNames[i]).hide();
            //            $(coinMenuHeaderNames[i]).hide();
            this.resetCoinButton(i);

            $(transactionsListElement).hide();
        } else {

            //            $(coinHelpMenuNames[i]).show();
            //            $(coinMenuHeaderNames[i]).show();
            this.switchToSolidCoinButton(i);

            $(transactionsListElement).show();
        }
    }

    //@note: @todo: @here: get dash paper wallets functional.
    if (targetCoinType === COIN_DASH ||
        targetCoinType === COIN_ETHEREUM_CLASSIC ||
        targetCoinType === COIN_THEDAO_ETHEREUM ||
        targetCoinType === COIN_AUGUR_ETHEREUM ||
        targetCoinType === COIN_ICONOMI_ETHEREUM ||
        targetCoinType === COIN_GOLEM_ETHEREUM ||
        targetCoinType === COIN_GNOSIS_ETHEREUM ||
        targetCoinType === COIN_SINGULARDTV_ETHEREUM ||
        targetCoinType === COIN_DIGIX_ETHEREUM ||
        targetCoinType === COIN_LISK ||
        targetCoinType === COIN_ZCASH ||
        targetCoinType === COIN_TESTNET_ROOTSTOCK) {
        $('.menusPaperWallet').hide();
    } else {
        $('.menusPaperWallet').show();
    }
}

JaxxUI.prototype.beginSwitchToCoinType = function(currentCoinType, targetCoinType) {
    this.hideErrorLoadingTransactions();
    this.hideErrorLoadingBalances();
    $(".shapeshiftTab").fadeOut();
}

JaxxUI.prototype.completeSwitchToCoinType = function(coin, targetCoinType) {

    console.log(coin);

    var targetCoinShortName = "";
    /* var allKeys = Object.keys(HDWalletHelper.dictCryptoCurrency);

     for (var i = 0; i < allKeys.length; i++) {
         var curKey = allKeys[i];

         var curCoinIndex = HDWalletHelper.dictCryptoCurrency[curKey].index;

         if (targetCoinType === curCoinIndex) {
             targetCoinShortName = curKey;
             break;
         }
     }*/

    // var shapeShiftCryptoCurrenciesAllowed = HDWalletHelper.shapeShiftCryptoCurrenciesAllowed.regular;

    /* if (targetCoinType === COIN_THEDAO_ETHEREUM) {
         $('.mainTransactionHistoryHeader').text('DAO Refund');
         //$('.btnActionShapeShift').hide();
     } else {
         $('.mainTransactionHistoryHeader').html('Transaction History');
         //$('.btnActionShapeShift').show();
         //$('.btnActionShapeShift').css('display', 'inline-block');
     }*/

    /* if (typeof(shapeShiftCryptoCurrenciesAllowed[targetCoinShortName]) !== 'undefined' &&
         shapeShiftCryptoCurrenciesAllowed[targetCoinShortName] !== null &&
         shapeShiftCryptoCurrenciesAllowed[targetCoinShortName] === true) {
         //$('.btnActionShapeShift').show();
         //$('.btnActionShapeShift').css('display', 'inline-block');
     } else {
         //$('.btnActionShapeShift').hide();
     }*/

    /* if (targetCoinType === COIN_DASH ||
         targetCoinType === COIN_ETHEREUM_CLASSIC ||
         targetCoinType === COIN_THEDAO_ETHEREUM ||
         targetCoinType === COIN_AUGUR_ETHEREUM ||
         targetCoinType === COIN_ICONOMI_ETHEREUM ||
         targetCoinType === COIN_GOLEM_ETHEREUM ||
         targetCoinType === COIN_GNOSIS_ETHEREUM ||
         targetCoinType === COIN_SINGULARDTV_ETHEREUM ||
         targetCoinType === COIN_DIGIX_ETHEREUM ||
         targetCoinType === COIN_LISK ||
         targetCoinType === COIN_ZCASH ||
         targetCoinType === COIN_TESTNET_ROOTSTOCK) {
      //   $('.menusPaperWallet').hide();
     } else {*/

    if (coin.isPaperWalletAllowed(PlatformUtils.mobileiOSCheck())) $('.menusPaperWallet').show();
    else  $('.menusPaperWallet').hide();
    //}
    // if (HDWalletHelper.isShapeshiftCryptoCurrencyAllowed(targetCoinType)) {
    // if
    $(".shapeshiftTab").fadeIn();
    //console.warn("fadein");
    // }
    jaxx.Registry.application$.triggerHandler(jaxx.Registry.COMPLETE_SWITCH_TO_COIN_TYPE, coin);
    this.showModalForCoinBulletinIfNotHidden(coin);
//    $('.initializingLoading').show();
    //setTimeout(function() {
    //    console.warn("initializing wallet start");
    //    $('.initializingLoading img').removeClass('cssStartHidden');
    //},1500);
}

JaxxUI.prototype.showModalForCoinBulletinIfNotHidden = function(coin){
    // var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters["coinAbbreviatedName"];
    var bulletinData = g_JaxxApp.getUI().getCoinBulletinData()[coin.symbol];
    if (typeof(bulletinData) !== "undefined" && bulletinData !== null) {
        var version = bulletinData["version"];
        if (!g_JaxxApp.getSettings().isCoinBulletinHideOnSelect(coin.index, version)) {
            this.showCoinBulletinUsingAbbreviatedName(coin.symbol);
        }
    }
}

JaxxUI.prototype.resizeChromeExtension = function() {
    $('.cssDaoRefund').css('max-height', '250px');
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

JaxxUI.prototype.showShapeShift = function() {

    var input = $('.tabContent .address input');
    // console.log('JaxxUI.prototype.showShapeShift');

    //jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_SHAPE_SHIFT_ACTIVATE);
    this.showSpendableLoading();

    g_JaxxApp.getShapeShiftHelper().setIsTriggered(true);

    input.val("ShapeShift"); //Correct capitalization
    input.addClass('validShapeshift').addClass('cssValidShapeshift'); //Change color
    input.css({ backgroundImage: 'url(' + g_JaxxApp.getShapeShiftHelper()._avatarImage + ')'}); //Show fox icon
    //            $('.spendable').slideUp(); // Hide Spendable line
    // $('.spendableShapeshift').slideDown(); // Show ShapeShift logo and Info icon

    //    var placeholderAmountText = "Amount (Send BTC get ETH)";
    //    if(curCoinType===COIN_ETHEREUM){
    //        placeholderAmountText = "Amount (Send ETH get BTC)";
    //    }

    //    $('.tabContent .amount input').attr("placeholder", placeholderAmountText); //Change text of amount placeholder
    $('#sendLabel').text("Shift"); //Send button becomes shift

    if (curCoinType === COIN_ETHEREUM) {
        Navigation.hideEthereumAdvancedMode();
        $('.tabContent .advancedTabButton').slideUp().hide();
        //        $('.tabContent .advancedTabButton').slideUp().hide();
    }

    // var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];



    var coinFrom = jaxx.Registry.getCurrentCryptoController();


    var coins = jaxx.Registry.getShapeShiftEnabled();



    console.log(coins);

    var coinTo = (coins[0].symbol !== coinFrom.symbol)?coins[0]:coins[1];

    console.log(coinFrom.symbol +'_' + coinTo.symbol);


    this.requestShapeshiftTransaction(coinFrom, coinTo);
    //  g_JaxxApp.getSettings().setShapeshiftCoinTarget(from, to);

    // var receiveCoinType = HDWalletHelper.dictCryptoCurrency[receiveCoinAbbreviatedName].index;
    //  var self = this;



    //  g_JaxxApp.getShapeShiftHelper().clearUpdateIntervalIfNecessary();

    // $('.shapeshiftToggleLabelPrimary').text(from+ " to " + to);
    //this.setupShapeShiftCoinUI(from, to);
    input.trigger("keyup");
}

JaxxUI.prototype.requestShapeshiftTransaction = function(coinFrom, coinTo){

    var html = '<div data-symbol="'+coinFrom.symbol+'" class="scriptAction imageLogoCurrencyToCurrency shapeShiftSwitchFrom cssShapeshiftSwitchFrom cssCoinSelector cssHighlighted cssSourceCoin" value="'
        + coinFrom.symbol + '"><span class="cssCoinText">' + coinFrom.threeLetterCode + '</span></div>';
    html+='<img class="cssArrowcoinToCoin" src="images/coinToCoin.svg" alt="" height="12" width="28" style="margin: 3px 3px 0px 0px">';
    html+= '<div class="scriptAction  imageLogoCurrencyToCurrency shapeShiftSwitchTo cssShapeshiftSwitchTo cssCoinSelector cssHighlighted" specialAction="changeShapeshiftCoinToNextCoinType"><span class="cssCoinText">' + coinTo.threeLetterCode + '</span></div>';

    $('#ShapeshiftCurrent').html(html);

    var self = this;

    var url = 'https://shapeshift.io/marketinfo/' + coinFrom.symbol + '_' + coinTo.symbol;
    $.get(url).done(function(result){
        if(result.error){
            console.error(result);
            self.updateShapeShiftDisplay(null);
            return;
        }

        console.log(result);
        // data.returnAddress =  jaxx.Registry.getCryptoControllerBySymbol(symbolSend).getCurrentPublicAddresReceive();
        //data.receiveAddress = jaxx.Registry.getCryptoControllerBySymbol(symbolReceive).getCurrentPublicAddresReceive();

        var curMarketData = {
            depositMax:result.limit,
            depositMin:result.minimum,
            exchangeRate:result.rate,
            lastupdated:Date.now(),
            pair:result.pair,
            minerFee:result.minerFee
        }

        self.updateShapeShiftDisplay(curMarketData);

        /*self.requestShapeshiftTransaction2(coinFrom, coinTo, function (error, result) {

            console.warn(result);

        })*/

    });

}

JaxxUI.prototype.requestShapeshiftTransaction2 = function (coinFrom, coinTo, callback) {
    var pair = coinFrom.symbol+'_' + coinTo.symbol;

    var addressReturn = jaxx.Registry.getCryptoControllerBySymbol(coinFrom.symbol).getCurrentPublicAddresReceive();

    var addressDeposit = jaxx.Registry.getCryptoControllerBySymbol(coinTo.symbol).getCurrentPublicAddresReceive();

    var shiftOptions = {
        withdrawal: addressDeposit,
        pair: pair,
        returnAddress: addressReturn,
        apiKey:  "180aaede8f5451a52847824f4965cc25f43a5d2bb49f483c1f1ecc8afad661b65e22a01046bfd67257e31189b48f5a1ec35207653bd017f8203f4241c763074a"
    };
    var url ="https://shapeshift.io/shift/";

    $.post(url, shiftOptions)
        .then(function (data, textStatus, jqXHR) {
            return data
        })
        .done(function (value, args) {
            callback(null, value)
        })
        .fail(function (value, args) {
            callback(value)
        })


}

JaxxUI.prototype.updateShapeShiftDisplay = function(displayDict) {
    console.log(displayDict);
    if(displayDict){

        var pair = displayDict.pair.split('_');

        var from = pair[0];
        var to = pair[1];
        var exchangeRate = parseFloat(displayDict.exchangeRate).toFixed(8),
            depositMinAmount = parseFloat(displayDict.depositMin).toFixed(8),
            depositMaxAmount = parseFloat(displayDict.depositMax).toFixed(8);


    }else {

        var exchangeRate ='',
            depositMinAmount = '',
            depositMaxAmount = '',
            from ='',
            to = ''

    }

    $('.shapeShiftExchangeRate').text(exchangeRate);
    $('.shapeShiftDepositMin').text(depositMinAmount);
    $('.shapeShiftDepositMax').text(depositMaxAmount);
    $('.before .shapeShiftAbbreviatedUnitSend').text('1 ' + from);
    $('.shapeShiftAbbreviatedUnitSend').not('.before .shapeShiftAbbreviatedUnitSend').text(from);
    $('.shapeShiftAbbreviatedUnitReceive').text(to);


    // Example parameters : ({send: 0, receive: 1}, {pair: "btc_eth", depositMax: 1.70901548, depositMin: 0.00039924, exch.....)

    //if ( g_JaxxApp.getShapeShiftHelper().getIsTriggered()) {


    // var coinAbbreviatedNameSend = HDWalletPouch.getStaticCoinPouchImplementation(coinTypeDict.send).pouchParameters['coinAbbreviatedName'];

    // var coinAbbreviatedNameReceive = HDWalletPouch.getStaticCoinPouchImplementation(coinTypeDict.receive).pouchParameters['coinAbbreviatedName'];

    //  if (typeof(displayDict.exchangeRate) !== 'undefined' && displayDict.exchangeRate !== null) {
    //$('.shapeShiftExchangeRate').text(displayDict.exchangeRate.toString().substring(0, 8));
    //$('.shapeShiftDepositMin').text(displayDict.depositMin.toString().substring(0, 8));
    //$('.shapeShiftDepositMax').text(displayDict.depositMax.toString().substring(0, 8));
    console.log("Deposit Max", parseFloat(displayDict.exchangeRate).toFixed(8));
    console.log("Deposit Max", displayDict.depositMin);
    console.log("Deposit Max", displayDict.depositMax);


    // }
    // }
}

JaxxUI.prototype.openShapeshiftCoinList = function() {

    var currentCoin = jaxx.Registry.getCurrentCryptoController();
    // var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];


    // $('.wrapTableShapeshiftCoinMenu').css('display', 'block');
    $('#TableShapeshiftCoinSelectionMenu').fadeIn();

    $('.cssShapeShiftAndToggle .displayCoinsArrow img').removeClass('cssFlipped');
    //$('.wrapTableShapeshiftCoinMenu tbody').empty();
    var coins = jaxx.Registry.getShapeShiftEnabled();

    var html='';
    var additionalClass ='';
    coins.forEach(function (coin) {
        if(coin.symbol!= currentCoin.symbol)      html+='<tr data-symbol="'+coin.symbol+'" class="shapeShiftCoinItem'+ additionalClass +' cssShapeShiftCoinListItem scriptAction coinType' + coin._coinType + '" specialAction="selectShapeshiftCoin" value="' +coin.coinType + '"><td class="icon cssHighlighted cssImageLogoIcon'+ coin.coinType + '" style="background-image: url('+coin.icon+')"></td><td class="label">' + coin.threeLetterCode + ' - ' + coin.displayName + '</td></tr>';
    });

    var self = this;

    var list=  $("#ShapeshiftCoinSelectionList");
    list.off('click');
    list.html(html);
    list.on('click','tr',function(evt){
        var symbol = $(evt.currentTarget).data('symbol');
        console.log(symbol);
        if(symbol){

            var coinFrom = jaxx.Registry.getCurrentCryptoController();
            var coinTo = jaxx.Registry.getCryptoControllerBySymbol(symbol);
            $('#TableShapeshiftCoinSelectionMenu').fadeOut();
            self.requestShapeshiftTransaction(coinFrom, coinTo);

        }
    })

    /* for (var i = 0; i < coinTypeKeys.length; i++){
         var coinType = dictOfCoinTypes[coinTypeKeys[i]];

         if (i === 0) {
             $(".wrapTableShapeshiftCoinMenu tbody").append(this.getShapeshiftCoinListRow(coinType));
         } else {
             $(".wrapTableShapeshiftCoinMenu tbody").append(this.getShapeshiftCoinListRow(coinType, ' cssAdditionalElement'));
         }
     }*/

    /*  $('.wrapTableShapeshiftCoinMenu tbody .scriptAction').off('click'); // This action should be off, but just in case.
      $('.wrapTableShapeshiftCoinMenu tbody .scriptAction').click(function (event) {


          try {

              scriptAction(event);
          } catch (err) {
              console.error(err);
          }
      }); // Reattach script action events.*/

    //var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];

    //$('.wrapTableShapeshiftCoinMenu').removeClass('cssBlueHighlight');
    //$('.wrapTableShapeshiftCoinMenu .coinType' + g_JaxxApp.getSettings().getShapeshiftCoinTarget(coinAbbreviatedName)).addClass('cssBlueHighlight');
}

JaxxUI.prototype.closeShapeshiftCoinList = function() {
    // $('.wrapTableShapeshiftCoinMenu').css('display', 'none');
    $('.wrapTableShapeshiftCoinMenu').fadeOut(function() {
        $(".wrapTableShapeshiftCoinMenu tbody").empty();
        $('.cssShapeShiftAndToggle .displayCoinsArrow img').addClass('cssFlipped');
    });
}

JaxxUI.prototype.toggleShapeshiftCoinList = function() {
    if (this.isShapeshiftCoinListOpen()){
        this.closeShapeshiftCoinList();
    } else {
        this.openShapeshiftCoinList();
    }
}

JaxxUI.prototype.isShapeshiftCoinListOpen = function() {
    return (!($(".wrapTableShapeshiftCoinMenu").css('display') === 'none'));
}

JaxxUI.prototype.getShapeshiftCoinListRow = function(coinType, additionalClass) {
    // @TODO: Add first element functionality
    // coinType should be 'ETH' or 'BTC' or something.
    if (typeof(additionalClass) === 'undefined') {
        additionalClass = " ";
    }

    var coinName = HDWalletHelper.dictCryptoCurrency[coinType]['name'];

    return '<tr class="shapeShiftCoinItem'+ additionalClass +' cssShapeShiftCoinListItem scriptAction coinType' + coinType + '" specialAction="selectShapeshiftCoin" value="' + coinType + '"><td class="icon cssHighlighted cssImageLogoIcon'+ coinType + '"><div class="image"></div></td><td class="label">' + coinType + ' - ' + coinName + '</td></tr>';
}

JaxxUI.prototype.populateCurrenciesInSettings = function() {

}

JaxxUI.prototype.isMainMenuOpen = function() {
    return this._mainMenuIsOpen;
}

JaxxUI.prototype.toggleMainMenu = function() {
    if (this._mainMenuIsOpen === true) {
        this.closeMainMenu();
    } else {
        this.openMainMenu();
    }
}

JaxxUI.prototype.openMainMenu = function() {
    // @TODO: Consider wrapping this function with a check for ._mainMenuIsOpen === false as an oiptimization.
    var self = this;
    //if (!this._mainMenuToggleLocked){
    this._mainMenuToggleLocked = true;
    this._mainMenuIsOpen = true;
    this.moveCarouselToNearestPosition();
    if (window.native && window.native.setMainMenuOpenStatus) {
        window.native.setMainMenuOpenStatus(true);
    }

    //        console.log("toggle menu on");
    Navigation.collapseTabs();
    // Navigation.hideTransactionHistoryDetails();
    g_JaxxApp.getUI().closeShapeshiftCoinList();
    g_JaxxApp.getUI().closeQuickFiatCurrencySelector();
    //jQuery('.nonScrollSize').css('min-height', jQuery(window).height());
    //jQuery('.menu').css('opacity', 1);

    //set the width of primary content container -> content should not scale while animating
    /*
    var contentWidth = jQuery('.nonScrollSize').width();

    //set the content with the width that it has originally
    jQuery('.nonScrollSize').css('width', contentWidth);

    //display a layer to disable clicking and scrolling on the content while menu is shown
    jQuery('.nonScrollSize').css('display', 'block');

    //disable all scrolling on mobile devices while menu is shown
    jQuery('.nonScrollSize').bind('touchmove', function (e) {
        e.preventDefault()
    });*/

    //set margin for the whole container with a jquery UI animation
    var intDurationOfAnimation = 700;
    setTimeout(function(){self.setMainMenuToggleLocked(false);}, intDurationOfAnimation);
    $(".menu").animate({"marginLeft": ["-=300px", 'easeOutExpo']}, {
        duration: intDurationOfAnimation,
        complete: function(){
            self.setMainMenuToggleLocked(false);
        }
    });

    $('.menu').removeClass('cssHideUsingSettingsFramework');

    $('.menu').addClass('cssMenuCalc');

    $(".mainMenuCloser").css('display', 'block');
    //	$('.wallet').addClass('cssBlurBg');

    $(".wallet").css({
        /*"opacity": "0.1",*/

        "-webkit-transform": "all 0.5s linear",
        "-moz-transform": "all0.5s linear",
        "-ms-transform": "all 0.5s linear",
        "-o-transform": "all 0.5s linear",
        "transform": "all 0.5s linear",
    });
    // fade background out
    $('.material-design-hamburger__layer').addClass('material-design-hamburger__icon--to-arrow');
    $('.material-design-hamburger__layer').removeClass('material-design-hamburger__icon--from-arrow');
    // }

    if (jaxx.Registry.application.navigationToolMenuController)
    {
        jaxx.Registry.application.navigationToolMenuController.updateFiatValueIfCurrencyActive();
    }

}

JaxxUI.prototype.setCoinNavBarToDefaultPosition = function() {
    var self=this;
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];

    if (typeof(this._coinBannerCarousel) !== 'undefined' && this._coinBannerCarousel !== null){
        var defaultCoinPosition = $($('.coinBannerContainer .coinType' + coinAbbreviatedName)[0]).prevAll().length; // The number of siblings before the coin banner in the nav bar.
        //this.moveBannerToPosition(defaultCoinPosition); // Move carousel to index of default coin.
        this.getCoinBannerCarousel().move(defaultCoinPosition);
        setTimeout(function(){self.moveBannerToPosition(defaultCoinPosition);},self._coinBannerCarouselAnimationTime);
    }
}

JaxxUI.prototype.closeMainMenu = function() {
    var self = this;
    if (!this._mainMenuToggleLocked) {
        this._mainMenuToggleLocked = true;
        if (this._mainMenuIsOpen === true) {
            // @TODO: Consider updating the banners here instead of when banners are rearranged.
            if (this._walletWasChangedInMenu === true) {
                // #GMS Three lines below removed to fix close function in wallets-submenu, however they may be neccessary

                //this.switchToCoin(g_JaxxApp.getSettings().getListOfEnabledCryptoCurrencies()[0]); // Switch coin type to default coin.
                //this.updateHighlightingInCoinBannerContainer();
                //this.setCoinNavBarToDefaultPosition(); // Arrange Navigation bar according to the correct layout.
                this._walletWasChangedInMenu = false;
            }
        } else {
            return;
        }

        this._mainMenuIsOpen = false;
        if (window.native && window.native.setMainMenuOpenStatus) {
            window.native.setMainMenuOpenStatus(false);
        }
        //enable all scrolling on mobile devices when menu is closed
        //jQuery('#.non').unbind('touchmove');


        //set margin for the whole container back to original state with a jquery UI animation
        jQuery(".menu").animate({"marginLeft": ["100%", 'easeOutExpo']}, {
            duration: 700,
            complete: function () {
                //jQuery('.nonScrollSize').css('width', 'auto');
                //jQuery('.nonScrollSize').css('display', 'none');
                //jQuery('.menu').css('opacity', 0);
                //jQuery('.nonScrollSize').css('min-height', 'auto');
                self.setMainMenuToggleLocked(false);

            }
        });
        $('.menu').removeClass('cssMenuCalc');
        jQuery(".mainMenuCloser").css('display', 'none');
        $('.nonScrollSize').fadeTo(0, 500);
        $('.wallet').removeClass('cssBlurBg');

        $(".wallet").css({
            "opacity": "1",

            "-webkit-transition": "0.5s linear",
            "-moz-transition": "0.5s linear",
            "-ms-transition": "0.5s linear",
            "-o-transition": "0.5s linear",
            "transition": "0.25s linear",
        })
        // Fade background in.
        $('.material-design-hamburger__layer').addClass('material-design-hamburger__icon--from-arrow');
        $('.material-design-hamburger__layer').removeClass('material-design-hamburger__icon--to-arrow');


        //@note: this resets all the active data members
        this.setWindowActive('mainMenuPrimary', false);
        this.setWindowActive('mainMenuWallets', false);
        this.setWindowActive('mainMenuCurrencies', false);

        //this.clearNavigationBarPositionTimeout();

        self._mainMenuToggleLocked = false;
        //this.getCoinBannerCarousel().data("flickity").reposition();

        //updateWalletUI();
        //TODO check where used
    }
}

JaxxUI.prototype.swipeToCloseMenu = function() {
    var swipeMenu = document.getElementById('body');
    var self = this;

    Hammer(swipeMenu).on("swiperight", function() {
        g_JaxxApp.getUI().closeMainMenu();


        var swipeManager = new Hammer.Manager(swipeMenu);
        //    // create a recognizer
        //    var swipe = new Hammer.Swipe();
        //    // add the recognizer
        //    swipeManager.add(swipe);
        //    // subscribe to events
        //    swipeManager.on('swipeleft', function(e) {
        //        e.preventDefault;
        //        g_JaxxApp.getUI().openMainMenu();
    });

    var swipeMenu = document.getElementById('body');

    Hammer(swipeMenu).on("swiperight", function(e) {
        if (g_JaxxApp.getUI().isMainMenuOpen()) {
            g_JaxxApp.getUI().closeMainMenu();
        }
    });

    Hammer(swipeMenu).on("swipeleft", function(e) {
        if (!g_JaxxApp.getUI().isMainMenuOpen() && !self.isNotificationFooterOpen()) {
            //g_JaxxApp.getUI().openMainMenu(); // commented out to reflect a requirement change.
        }
    });

}

// The next three functions pertain to showing and hiding menu windows which are:
// mainMenuMenu
// mainMenuWallets
// mainMenuCurrencies

JaxxUI.prototype.mainMenuShowMenu = function() { // Shows the MENU tab of the main menu.
    this.setWindowActive('mainMenuPrimary', true);
    this.setWindowActive('mainMenuWallets', false);
    this.setWindowActive('mainMenuCurrencies', false);

    $('.cssActiveWindow .mainMenuMenu').addClass('cssSelected');
    $('.cssMenu .menuWindowOptionMenu').addClass('cssSelected');
    $('.cssActiveWindow .mainMenuWallets').removeClass('cssSelected');
    $('.cssMenu .menuWindowOptionWallets').removeClass('cssSelected');
    $('.cssActiveWindow .mainMenuCurrencies').removeClass('cssSelected');
    $('.cssMenu .menuWindowOptionCurrencies').removeClass('cssSelected');
    this.swipeToCloseMenu();
}

JaxxUI.prototype.mainMenuShowWallets = function() { // Shows the WALLETS tab of the main menu.
    this.setWindowActive('mainMenuPrimary', false);
    this.setWindowActive('mainMenuWallets', true);
    this.setWindowActive('mainMenuCurrencies', false);

    $('.cssActiveWindow .mainMenuMenu').removeClass('cssSelected');
    $('.cssMenu .menuWindowOptionMenu').removeClass('cssSelected');
    $('.cssActiveWindow .mainMenuWallets').addClass('cssSelected');
    $('.cssMenu .menuWindowOptionWallets').addClass('cssSelected');
    $('.cssActiveWindow .mainMenuCurrencies').removeClass('cssSelected');
    $('.cssMenu .menuWindowOptionCurrencies').removeClass('cssSelected');
}

JaxxUI.prototype.mainMenuShowCurrencies = function() { // Shows the CURRENCIES tab of the main menu.
    console.log(' JaxxUI.prototype.mainMenuShowCurrencies ');
    this.setWindowActive('mainMenuPrimary', false);
    this.setWindowActive('mainMenuWallets', false);
    this.setWindowActive('mainMenuCurrencies', true);

    $('.cssActiveWindow .mainMenuMenu').removeClass('cssSelected');
    $('.cssMenu .menuWindowOptionMenu').removeClass('cssSelected');
    $('.cssActiveWindow .mainMenuWallets').removeClass('cssSelected');
    $('.cssMenu .menuWindowOptionWallets').removeClass('cssSelected');
    $('.cssActiveWindow .mainMenuCurrencies').addClass('cssSelected');
    $('.cssMenu .menuWindowOptionCurrencies').addClass('cssSelected');

    this.populateCurrencyList(Registry.getCurrentCryptoController().symbol);
}

JaxxUI.prototype.generateSettingsCryptoCurrencyRows = function() {
  //  console.error('JaxxUI.prototype.generateSettingsCryptoCurrencyRowsWalletSetup');
    var self = this;
    var strSelectorForTable = '.mainMenuWallets .coinList';
    // Assertion: Settings has correctly stored the position order of the cryptocurrencies.
    $(strSelectorForTable + " tbody").empty();

    var cryptoCurrencies = jaxx.Registry.getWalletsSorted();

   // console.log('JaxxUI.prototype.generateSettingsCryptoCurrencyRows     ', cryptoCurrencies);


    for (var i = 0; i < cryptoCurrencies.length; i++) {
        var ctr = cryptoCurrencies[i];
        var name = ctr.name;
        var displayName = ctr.displayName;
        var threeLetterCode = ctr.threeLetterCode;
        var symbol = ctr.symbol;
        var extraCss = "";
        // var isTestnet = jaxx.Registry.getConfigByName(name).testnet;;//HDWalletPouch.getStaticCoinPouchImplementation(HDWalletHelper.dictCryptoCurrency[cryptoCurrencyName].index).pouchParameters['isTestnet'];

        if(ctr.testnet) extraCss = 'cssTestnet';

        //  var staticPouchImplementation = HDWalletPouch.getStaticCoinPouchImplementation(HDWalletHelper.dictCryptoCurrency[cryptoCurrencies[i]].index);
        //  var coinWalletSelector3LetterSymbol = staticPouchImplementation.uiComponents['coinWalletSelector3LetterSymbol'];

        var symbol =  ctr.symbol;
        var column1 = '<td class="cssSelectedCurrency"><div data-symbol="'+ symbol +'" data-id ="'+name+'" class="cssCircleUnchecked  '+(ctr.enabled?'cssCurrencyisChecked':'')+'"></div></td>';
        var column2 = '<td class="itemNumberLabel cssItemNumberLabel"></td>';
        var column3 = '<td class="coinIcon cssCoinIcon"></td>';
        // var column4 = '<td class="coinLabel cssCoinLabel">' + coinWalletSelector3LetterSymbol + ' - ' + HDWalletHelper.dictCryptoCurrency[cryptoCurrencies[i]]['name'] + '</td>';
        var column4 = '<td class="coinLabel cssCoinLabel cssWalletsMenuLabel">' + threeLetterCode + ' - ' + displayName + '</td>';
        var column5 = '<td class="handle cssHandle"><img src="images/dragAndDrop.svg" alt="" height="13" width="13" style="position:absolute; padding-top:12px;"></td>';
        var tableRow = '<tr class="cssCoinCurrency scriptAction coinType' + symbol + " " + extraCss + '" specialAction ="toggleCryptoCurrency" data-id="' + symbol + '" value="' + symbol + '">' + column1 + column2 + column3 + column4 + column5 + '</tr>';
        $(strSelectorForTable + " tbody").append(tableRow);

        if(ctr.enabled){
            // if the currency is enabled, highlight the parent div
            $('.cssCoinCurrency.coinType' + symbol).addClass('cssCurrencyHighlightText');
        }

        /*
        if (cryptoCurrencies[i].enabled) {
            g_JaxxApp.getSettings().enableCryptoCurrency(cryptoCurrencies[i].symbol);
            this.enableCryptoCurrencyInUI(cryptoCurrencies[i].symbol, true);
        } else {
            g_JaxxApp.getSettings().disableCryptoCurrency(cryptoCurrencies[i].symbol);
            this.disableCryptoCurrencyInUI(cryptoCurrencies[i].symbol, true);
        }*/
    }

   // this.updateCryptoCurrencyBannersInHeaderCarousel();
    //this.updateCryptoCurrencyBannersInHeader();


    // Attach listeners.
    $(strSelectorForTable +' .scriptAction').off();
    $(strSelectorForTable +' .scriptAction').click(function (event) { // Add the scriptAction triggers again.


        var el = $(event.currentTarget);
        var mainParentElement = el.closest('.cssCoinCurrency', '.coinType');
        var toggleMenuItem;

        if(el.hasClass('cssCircleUnchecked'))
        {
            toggleMenuItem = el;
        }
        else{
            toggleMenuItem = mainParentElement.find('.cssCircleUnchecked');
        }

        if(toggleMenuItem.hasClass('cssCircleUnchecked')){
        
            var name  = toggleMenuItem.attr('data-id');
            var symbol = toggleMenuItem.attr('data-symbol');
            var enbl = toggleMenuItem.hasClass('cssCurrencyisChecked');
            //var symbol = el.data('symbol');
            //var parentElement = el.closest('.cssCoinCurrency', '.coinType');

            if (toggleMenuItem.hasClass('cssCurrencyisChecked'))
            {
                if (jaxx.Registry.getWalletsEnabledSorted().length > 1)
                {
                    toggleMenuItem.removeClass('cssCurrencyisChecked');
                    enbl = false;
                } else {
                    return;
                }
            } else {
                toggleMenuItem.addClass('cssCurrencyisChecked');
                enbl = true;
            }
            

            if(enbl){
                // if the currency is enabled, highlight the parent div
                mainParentElement.addClass('cssCurrencyHighlightText');
            }
            else{
                 // if the currency is not enabled, remove the highlight from the parent div
                    mainParentElement.removeClass('cssCurrencyHighlightText');
                     

            }

            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_COIN_SATUS_CHANGED, [name,enbl,symbol])

        }

        /// console.warn(el);


        // $(event.target)
        // try {
        /// scriptAction(event);
        // } catch (err) {
        //     console.error(err);
        // }
    });

    // Make the table sortable.
    var tablelist = $(strSelectorForTable + " tbody").sortable({
        /*items: "> tr:not(:first)",*/
        appendTo: "parent",
        axis: 'y',
        helper: "clone",
        handle: ".handle",
        update: function(event, ui) {

            console.warn(event, ui);

            var out = {};


            tablelist.children('tr').each(function (item, el) {
                // console.log(item, el);
                out[$(el).data('id')] = item ;
            });

            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_COIN_SEQUENCE_CHANGED, out);


            // @TODO: Javascript optimization
           // g_JaxxApp.getUI().pushCryptoCurrencyPositionOrderToSettings();

            self._walletWasChangedInMenu = true;
            // Sortable change number of element
            //            var $lis = $(this).children('tr');
            //            $lis.each(function() {
            //                var $li = $(this);
            //                var newVal = $(this).index() + 1;
            //                $(this).children('.itemNumberLabel').html(newVal);
            //                $(this).children('#item_display_order').val(newVal);
            //            });
        },
    }).disableSelection();

    // Toggle the rows that need the toggling.
}

// Script to Select wallets in EXPRESS flow
JaxxUI.prototype.StartFlowSettingsCryptoCurrencyRows123 = function() {
    console.warn('TODO check is need it');
    // Assertion: Settings has correctly stored the position order of the cryptocurrencies.
    var cryptoCurrencies = g_JaxxApp.getSettings().getCryptoCurrencyPositionList();
    for (var i = 0; i < cryptoCurrencies.length; i++) {
        var cryptoCurrencyName = cryptoCurrencies[i];
        var extraCss = "";
        //  var isTestnet = HDWalletPouch.getStaticCoinPouchImplementation(HDWalletHelper.dictCryptoCurrency[cryptoCurrencyName].index).pouchParameters['isTestnet'];

        (isTestnet === true) ? extraCss = 'cssTestnet' : "";

        var column1 = '<td class="cssSelectedCurrency"><div class="cssCircleUnchecked"></div></td>';
        var column2 = '<td class="itemNumberLabel cssItemNumberLabel"></td>';
        var column3 = '<td class="coinIcon cssCoinIcon"></td>';
        var column4 = '<td class="coinLabel cssCoinLabel">' + cryptoCurrencies[i] + ' - ' + HDWalletHelper.dictCryptoCurrency[cryptoCurrencies[i]]['displayName'] + '</td>';
        var column5 = '<td class="handle cssHandle"><img src="images/dragAndDrop.svg" alt="" height="13" width="13" style="position:absolute; padding-top:12px;"></td>';
        var tableRow = '<tr class="cssCoinCurrency scriptAction coinType' + cryptoCurrencies[i] + " " + extraCss + '" specialAction ="toggleCryptoCurrency" value="' + cryptoCurrencies[i] + '">' + column1 + column2 + column3 + column4 + column5 + '</tr>';
        $('.coinListExpress tbody').append(tableRow);
        if (g_JaxxApp.getSettings().isCryptoCurrencyEnabled(cryptoCurrencies[i])) {
            g_JaxxApp.getSettings().enableCryptoCurrency(cryptoCurrencies[i]);
            g_JaxxApp.getUI().enableCryptoCurrencyInUI(cryptoCurrencies[i], true);
        } else {
            g_JaxxApp.getSettings().disableCryptoCurrency(cryptoCurrencies[i]);
            g_JaxxApp.getUI().disableCryptoCurrencyInUI(cryptoCurrencies[i], true);
        }
    }
    this.updateCryptoCurrencyBannersInHeader();
    // Make the table sortable.
    $(".coinListExpress tbody").sortable({
        /*items: "> tr:not(:first)",*/
        appendTo: "parent",
        axis: 'y',
        helper: "clone",
        handle: ".handle",
        update: function(event, ui) {
            // @TODO: Javascript optimization
            g_JaxxApp.getUI().pushCryptoCurrencyPositionOrderToSettings();

            // Sortable change number of element
            //            var $lis = $(this).children('tr');
            //            $lis.each(function() {
            //                var $li = $(this);
            //                var newVal = $(this).index() + 1;
            //                $(this).children('.itemNumberLabel').html(newVal);
            //                $(this).children('#item_display_order').val(newVal);
            //            });
        },
    }).disableSelection();

    // Toggle the rows that need the toggling.
}
// Script to Select wallets in EXPRESS flow Ends

JaxxUI.prototype.toggleCryptoCurrencyIsEnabled = function(cryptoCurrency) {
    //console.log(cryptoCurrency);

    //@note: @todo: @here: telling the settings that the currency is enabled is fine, but this function should handle all of the ui tasks.
    g_JaxxApp.getSettings().toggleCryptoCurrencyIsEnabled(cryptoCurrency); // Change settings
    // Add class .cssCurrency is checked to the correct item.
}

JaxxUI.prototype.enableCryptoCurrencyInUI = function(cryptoCurrency, dontUpdateBanners) {
    this._walletWasChangedInMenu = true;
    $('.mainMenuWallets .coinList .coinType' + cryptoCurrency + ' .cssSelectedCurrency .cssCircleUnchecked').addClass('cssCurrencyisChecked');// Make UI Change.
    $(".mainMenuWallets .coinList").find('[value='+cryptoCurrency+']').find('.cssSelectedCurrency').find('.cssCircleUnchecked').css('border', 'none');
    $('.mainMenuWallets .coinType' + cryptoCurrency).addClass('cssCurrencyHighlightText');
    if (typeof(dontUpdateBanners) === 'undefined' || !dontUpdateBanners){
        this.updateCryptoCurrencyBannersInHeader();
        //this.addCryptoCurrencyBannersInHeaderCarousel(cryptoCurrency);
    }

}

JaxxUI.prototype.disableCryptoCurrencyInUI = function(cryptoCurrency, dontUpdateBanners) {
    this._walletWasChangedInMenu = true;
    $('.mainMenuWallets .coinList .coinType' + cryptoCurrency + ' .cssSelectedCurrency .cssCircleUnchecked').removeClass('cssCurrencyisChecked');// Make UI Change.
    $(".mainMenuWallets .coinList").find('[value='+cryptoCurrency+']').find('.cssSelectedCurrency').find('.cssCircleUnchecked').css('border', '1px solid white');
    $('.mainMenuWallets .coinType' + cryptoCurrency).removeClass('cssCurrencyHighlightText');
    if (typeof(dontUpdateBanners) === 'undefined' || !dontUpdateBanners) {
        this.updateCryptoCurrencyBannersInHeader();
        //this.removeCryptoCurrencyBannersInHeaderCarousel(cryptoCurrency);
    }
}

JaxxUI.prototype.pushCryptoCurrencyPositionOrderToSettings = function() {
    // Extract ordering
    var rows = $('.mainMenuWallets .coinList tbody tr');
    var currencyArray = [];
    for (var i = 0; i < rows.length; i++){
        currencyArray.push($($('.mainMenuWallets .coinList tbody tr').get(i)).attr('value'));
    }
    g_JaxxApp.getSettings().setCryptoCurrencyPositionData(currencyArray); // Change settings
}

JaxxUI.prototype.updateCryptoCurrencyBannersInHeaderCarousel = function () {

    return;
    var coins = jaxx.Registry.getWalletsEnabledSorted()


    /* coins.forEach(function(item){
         var element = '.scriptAction.carousel-cell.item.cssItem.imageLogoBanner' + currencyName + '.cssCoinSelector.coinType' + currencyName;
         this.$topCarousel.flickity('append', $(insertElement));
     })*/


    var currenciesToInclude =  coins.map(function (item) {
        return item.symbol
    })// g_JaxxApp.getSettings().getListOfEnabledCryptoCurrencies();
    for (var i = 0; i < currenciesToInclude.length; i++){
        var currencyName = currenciesToInclude[i];
        this.addCryptoCurrencyBannersInHeaderCarousel(currencyName);
    }
    this.$topCarousel.flickity('resize');
}

JaxxUI.prototype.addCryptoCurrencyBannersInHeaderCarousel123 = function (currencyName) {
    return
    // currencyName = "BTC"
    var element = '.scriptAction.carousel-cell.item.cssItem.imageLogoBanner' + currencyName + '.cssCoinSelector.coinType' + currencyName;
    if($('.topBannerCarousal ' + element).length)
        return;

    console.log("Insert Element", element);
    var insertElement = this.getBannerDivForCryptoCurrency(currencyName);
    this.$topCarousel.flickity('append', $(insertElement));
    if(this.$topCarouselData && this.$topCarouselData.cells.length > 3) {
        this.initializeTopCarousel({wrapAround: true, prevNextButtons: true});
    }
    this.$topCarousel.flickity('resize');
    this.attachClickEventForScriptAction($(insertElement));
    this.updateHandlersInCoinBannerContainer();
}

JaxxUI.prototype.removeCryptoCurrencyBannersInHeaderCarousel = function (currencyName) {
    //var element = this.getBannerDivForCryptoCurrency(currency);
    var self = this;
    var element = '.scriptAction.carousel-cell.item.cssItem.imageLogoBanner' + currencyName + '.cssCoinSelector.coinType' + currencyName;
    this.$topCarousel.flickity('remove', $(element)[0]);
    if(this.$topCarouselData && this.$topCarouselData.cells.length <= 3) {
        this.initializeTopCarousel({wrapAround: false, prevNextButtons: false});
    }
    this.$topCarousel.flickity('resize');
}

JaxxUI.prototype.updateCryptoCurrencyBannersInHeader = function() {

    console.log("TRIGGERED updateCryptoCurrencyBannersInHeader");

    jaxx.CoinsMenu.instance.selectDefaultCoin();

    //$('.scrollHeaderContainer .leftArrow').show();
    //$('.scrollHeaderContainer .rightArrow').show();

    //if (typeof(window) !== 'undefined' && typeof($(window).width()) !== 'undefined' && $(window).width() <= 320){
    //    $('.scrollHeaderContainer').css('width', '195px');
    //} else {
    //    $('.scrollHeaderContainer').css('width', '231px');
    //}

    if (this._coinBannerCarousel === null || typeof(this._coinBannerCarousel) === 'undefined'){
        //this.initializeCarousels();
    } else {
        this.updateCoinBannerCarousel();
    }


    console.log("TO DO: REMOVE DUPLICATE FUNCTION");
    return;

    console.error("TO DO: REMOVE DUPLICATE FUNCTION");
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Parameter: excludeScriptAction is set to true when we want to skip the step where we add listeners.
    //	try {


    var coins = jaxx.Registry.getWalletsEnabledSorted();
    var currenciesLength = coins.length;//g_JaxxApp.getSettings().getCryptoCurrencyEnabledCount();
    var minimumBannerAmountForScrolling = 4;
    var generateWithCarousel = !(currenciesLength < minimumBannerAmountForScrolling);

    // The following code changes elemental things in the coin banner.
    var currenciesToInclude = coins.map(function (item) {
        return item.symbol;
    });

    var html ='';

    for (var i = 0; i < coins.length; i++){
        var coin = coins[i];
        var extraCss = '';
        var hueRotated;
        var doesNeedHue;

        if(this.style.filter) {
            hueRotated = (this.style.filter.split('hue-rotate('))[1].split(')')[0];
            doesNeedHue = !(typeof hueRotated === 'undefined')
        }

        if(doesNeedHue){
            extraCss = 'cssCoinSelectGenericFilter';
        }
        else {
            extraCss = 'cssCoinSelecterGreyFilter';
        }

        html+=  '<li data-name="'+coin.name+'" data-symbol="'+coin.symbol+'" class="scriptAction item cssItem imageLogoBanner' +
            coin.name + ' cssCoinSelector ' + extraCss + '" switchToCoin="' + coin.name + '" value="' + coin.name + '"' +
            ' style="background-image: url(' + coin.icon + ')">' +
            ' <span class="cssCoinButtonText"> ' + coins[i].threeLetterCode + '</span></li>';
    }

    $('#CarouselList').html(html)


    // This executes conditional instructions based on the number of elements in the banner
    // Note: We need the coin banner width for this part (which means coinBanners should be generated at this time).
    //var intCoinBannerWidth = parseInt($('.scrollHeaderContainer .coinBannerContainer .item').css('width'));
    var intCoinBannerMarginRight = 15;
    var intCoinBannerMarginLeft = 15;
    if (!generateWithCarousel) {
        // Hide scroll arrows.
        $('.scrollHeaderContainer .leftArrow').hide();
        $('.scrollHeaderContainer .rightArrow').hide();
        if (currenciesLength === 1) {
            if (typeof(window) !== 'undefined' && typeof($(window).width()) !== 'undefined' && $(window).width() <= 320){
                $('.scrollHeaderContainer').css('width', '46px');
            } else {
                $('.scrollHeaderContainer').css('width', '60px');
            }
            $($('.coinBannerContainer').children()[0]).addClass('cssSelected');
        } else if (currenciesLength === 2) {
            if (typeof(window) !== 'undefined' && typeof($(window).width()) !== 'undefined' && $(window).width() <= 320){
                $('.scrollHeaderContainer').css('width', '126px');
                $('.cssCoinSelector').css({"margin-left":"15px", "margin-right": "15px"});
            } else {
                $('.scrollHeaderContainer').css('width', '120px');
                $('.cssCoinSelector').css({"margin-left":"5px", "margin-right": "5px"});
            }
            //$('.scrollHeaderContainer').css('width', (intCoinBannerWidth * 2 + 13).toString() + 'px');
        } else if (currenciesLength === 3) {
            if (typeof(window) !== 'undefined' && typeof($(window).width) !== 'undefined' && $(window).width() <= 320){
                $('.scrollHeaderContainer').css('width', '150px');
            } else {
                $('.scrollHeaderContainer').css('width', '180px');
                $('.cssCoinSelector').css({"margin-left":"4px", "margin-right": "4px"});
                //rohit- change was made to accomidate the carousal alignment, above element was commented out
                $('.cssCoinSelector').css({"margin-left":"0px", "margin-right": "10px"});
            }

            //$('.cssCoinSelector').css({"margin-left":"10px", "margin-right": "10px"});
        }
    } else {
        // Show scroll arrows.
        $('.scrollHeaderContainer .leftArrow').show();
        $('.scrollHeaderContainer .rightArrow').show();
        if (typeof(window) !== 'undefined' && typeof($(window).width()) !== 'undefined' && $(window).width() <= 320){
            $('.scrollHeaderContainer').css('width', '195px');
        } else {
            $('.scrollHeaderContainer').css('width', '231px');
        }
        // Set the width of the wrapper container to a fixed size.

        // Same deal, but we center the active currency.
        //var currenciesToInclude = [];
        //var middleCurrency = coinAbbreviatedName[curCoinType];
        //if (typeof(middleCurrency) === 'undefined' || middleCurrency === null) {
        //    middleCurrency = coinAbbreviatedName[g_JaxxApp.getSettings().getDefaultCoinType()];
        //}	currenciesToInclude.push(g_JaxxApp.getSettings().getPreviousEnabledCryptoCurrency(middleCurrency));
        //currenciesToInclude.push(middleCurrency);
        //currenciesToInclude.push(g_JaxxApp.getSettings().getNextEnabledCryptoCurrency(middleCurrency));
        //$('.scrollHeaderContainer').empty();
        //$('.scrollHeaderContainer').append('<div class="scriptAction leftArrow cssLeftArrow" specialAction="slideBannerLeft"><img src="images/arrowLeft.svg" alt="" height="12" width="12" style="position:absolute; padding-top:5px;"></div>');
        //$('.scrollHeaderContainer').append('<div class="cssCoinBannerWrapper viewport"><ul class="coinBannerContainer overview cssCoinBannerContainer"></ul</div>');
        //$('.scrollHeaderContainer').append('<div class="scriptAction rightArrow cssRightArrow" specialAction="slideBannerRight"><img src="images/arrowRight.svg" alt="" height="12" width="12" style="position:absolute; padding-top:5px;"></div>');
        //$('.scrollHeaderContainer').css('width', '227px');
    }


    if (generateWithCarousel) {
        if (this._coinBannerCarousel === null || typeof(this._coinBannerCarousel) === 'undefined'){
            //this.initializeTopCarousel();
            this.initializeCarousels();
        } else {
            this.updateCoinBannerCarousel(); // Remember that this checks for undefined and null types.
        }
    }

    // Style stuff
    // this.updateHandlersInCoinBannerContainer();
    //this.updateHighlightingInCoinBannerContainer();
    // this.resetCoinButton();
    //updateWalletUI();
}

JaxxUI.prototype.updateHighlightingInCoinBannerContainer2 = function(){
    // Grey/white highlighting.
    var coinTypesInBanner = []; // ie. [0, 1]
    // for (var i = 0; i < $('.coinBannerContainer').children().length; i++){

    // coinTypesInBanner.push(HDWalletHelper.dictCryptoCurrency[$($('.coinBannerContainer').children()[i]).attr('value')]['index']);
    //}
    for (var i = 0; i < coinTypesInBanner.length; i++){
        this.resetCoinButton(coinTypesInBanner[i]);
    }
    this.selectActiveBanner();
    this.removeMouseHoverHandlersFromCoinBanner(curCoinType);
}

JaxxUI.prototype.removeMouseHoverHandlersFromCoinBanner2 = function(coinType){
    // This function is usually used for the active coin to remove the grey and coloured highlighting on mouse events.
    var coinButtonName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonName'];
    var coinButtonSVGName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonSVGName'];
    $(coinButtonName).off('mouseover');
    $(coinButtonName).off('mouseleave');
}

JaxxUI.prototype.updateHandlersInCoinBannerContainer = function() {
    // This is necessary for highlighting to be set properly.
    $('.coinBannerContainer').children().off(); // Might be unnecessary
    this.attachClickEventForScriptAction($('.coinBannerContainer').children());


    //var bannerElements = $('.topBannerCarousal .flickity-slider .scriptAction');
    //this.attachClickEventForScriptAction(bannerElements);
    //$('.coinBannerContainer').children().off(); // Might be unnecessary
    /*
    $('.coinBannerContainer').children().off('click');
    $('.coinBannerContainer').children().click(function (event) { // Add the scriptAction triggers again.
        try {
            scriptAction(event);
        } catch (err) {
            console.error(err);
        }
    });*/
}

JaxxUI.prototype.selectActiveBanner = function() {
    this.selectBannerInNavigationBar(curCoinType);
}

JaxxUI.prototype.selectBannerInNavigationBar = function(coinType){
    console.log('TODO selectBannerInNavigationBar');

    return
    if (typeof(coinType) === 'undefined' || coinType === null) {
        console.log("error :: JaxxUI :: need to update selectBannerInNavigationBar to not fire on initialization");
        return;
    }

    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    // @TODO: Add a wrapper in that function that handles the case where coinType is not specified correctly.

    $('.coinBannerContainer').children().removeClass('cssSelected');
    $('.coinBannerContainer .coinType' + coinAbbreviatedName).addClass('cssSelected');

    var coinButtonSVGName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonSVGName'];

    $('.coinBannerContainer .cssSelected').css({background: 'url(images/' + coinButtonSVGName + '.svg) no-repeat center center', color: '#FFFFFF'});

    //$('.topBannerContainer .flickity-slider').children().removeClass('cssSelected');
    //$('.topBannerContainer .flickity-slider .coinType' + coinAbbreviatedName).addClass('cssSelected');

    //var coinButtonSVGName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinButtonSVGName'];
    //$('.topBannerContainer .cssSelected').css({color: '#FFFFFF'});
}

JaxxUI.prototype.highlightActiveCoinBanner = function() {
    // @Note: Legacy
    // Highlight all coin banners grey.
    $('.coinBannerContainer .cssSelected').css('color', '#fff'); // Highlight selected coin banner white.
}

JaxxUI.prototype.selectMiddleCoinBanner = function() { // We call this when the ui makes a change to the coin banner.
    // @Note: Legacy
    $('.coinBannerContainer').children().removeClass('cssSelected');
    $($('.coinBannerContainer').children()[1]).addClass('cssSelected');

    //this.highlightActiveCoinBanner();
}

/*
JaxxUI.prototype.switchToCoinByName = function(name){

    var ctr = jaxx.Registry.getCryptoControllerByName(name);

    switchToCoinType(ctr, false, function() {
        console.log('switch complete to by name ' + name)

    });

}

JaxxUI.prototype.switchToCoinByStmbol = function(symbol){

    this.clearNavigationBarPositionTimeout();

    var ctr = jaxx.Registry.getCryptoControllerBySymbol(symbol);


    switchToCoinType(ctr, false, function() {
        console.log('switch complete to by symbol ' + symbol)

    });
*/

/*
    if (curCoinType != HDWalletHelper.dictCryptoCurrency[targetCoinAbbreviatedName]['index']){
        if (targetCoinAbbreviatedName === 'ETH'){
            switchToCoinType(HDWalletHelper.dictCryptoCurrency[targetCoinAbbreviatedName]['index'], true, function() {});
        } else {
            switchToCoinType(HDWalletHelper.dictCryptoCurrency[targetCoinAbbreviatedName]['index'], null, function() {});
        }
    } else {

    }*/

/*
JaxxUI.prototype.getBannerDisplayCoinAbbreviation = function(cryptoCurrencyName) {

    return HDWalletHelper.dictCryptoCurrency[cryptoCurrencyName].bannerName;
}
*/

JaxxUI.prototype.getBannerDivForCryptoCurrency2 = function(cryptoCurrencyName) {

    // var isTestnet =  // HDWalletPouch.getStaticCoinPouchImplementation(HDWalletHelper.dictCryptoCurrency[cryptoCurrencyName].index).pouchParameters['isTestnet'];

    var extraCss = "";

    //if (isTestnet === true) {
    // extraCss = 'cssTestnet';
    // }

    //var logoCellBanner = '<div class="scriptAction carousel-cell item cssItem imageLogoBanner' + cryptoCurrencyName + ' cssCoinSelector coinType' + cryptoCurrencyName +  ' ' + extraCss + '" switchToCoin="' + cryptoCurrencyName + '" value="' + cryptoCurrencyName + '">' + '<span class="cssCoinButtonText">' + this.getBannerDisplayCoinAbbreviation(cryptoCurrencyName) + '</span></div>';

    //return logoCellBanner;
    return '<li class="scriptAction item cssItem imageLogoBanner' + cryptoCurrencyName + ' cssCoinSelector coinType' + cryptoCurrencyName +  ' ' + extraCss + '" switchToCoin="' + cryptoCurrencyName + '" value="' + cryptoCurrencyName + '">' + '<span class="cssCoinButtonText">' + this.getBannerDisplayCoinAbbreviation(cryptoCurrencyName) + '</span></li>';
    //TestNet
    /*
        var isTestnet = HDWalletPouch.getStaticCoinPouchImplementation(HDWalletHelper.dictCryptoCurrency[cryptoCurrencyName].index).pouchParameters['isTestnet'];
    if(isTestnet === true) {
        var $elCoin = 'li.item.imageLogoBanner' + cryptoCurrencyName;
        $($elCoin).addClass('cssTestnet');
    }
    return listitem;
    */
}

JaxxUI.prototype.getBannerForShapeshiftCoin = function(cryptoCurrencyName){
    return '<div class="scriptAction imageLogoBanner' + cryptoCurrencyName + ' cssCoinSelector coinType' + cryptoCurrencyName + '" value="' + cryptoCurrencyName + '">' + '<span class="cssCoinButtonText">' + this.getBannerDisplayCoinAbbreviation(cryptoCurrencyName) + '</span></div>';
}

JaxxUI.prototype.slideBannerRight = function() {
    var self = this;
    // Assertion: Current coin type is centered in the banner bar.
    //var self = this;
    //var newElement = this.getBannerDivForCryptoCurrency(g_JaxxApp.getSettings().getIncrementCryptoCurrencyNSteps(g_JaxxApp.getSettings().getActiveCoinType(), 2));
    //this.switchToCoin($($('.coinBannerContainer').children()[2]).attr('value'));
    //var elementToRemove = $('.coinBannerContainer').children().first();
    //var insertionIndex = elementOnLeft.indexOf("class") + 7;
    //$('.coinBannerContainer').append(newElement);
    //$(elementToRemove).remove();

    //    $(newElement).hide();
    //	$(newElement).show( function() {console.log('Show Callback');});

    //	elementToRemove.hide( function(){
    //		$(elementToRemove).remove();
    //		self.updateNewAttributesInCoin3Banners();
    //	});
    //this.updateNewAttributesInCoin3Banners();
    // Attach switchToCoin to the arrow.
    setTimeout( function(){
        self.moveCarouselToNearestPosition();
        self.resetCoinBannerCarouselTimeout();
        //self.updateHighlightingInCoinBannerContainer();
    }, this._coinBannerCarouselAnimationTime)
    this.updateHandlersInCoinBannerContainer();
}

JaxxUI.prototype.clearNavigationBarPositionTimeout = function() {
    if (typeof(this._coinBannerCarouselTimeout) !== 'undefined' && this._coinBannerCarouselTimeout !== null) {
        clearTimeout(this._coinBannerCarouselTimeout);
    }
}

JaxxUI.prototype.slideBannerLeft = function() {
    var self = this;
    // Assertion: Current coin type is centered in the banner bar.
    //alert("Sliding left");
    //var self = this;
    //var newElement = this.getBannerDivForCryptoCurrency(g_JaxxApp.getSettings().getIncrementCryptoCurrencyNSteps(g_JaxxApp.getSettings().getActiveCoinType(), -2));
    //this.switchToCoin($($('.coinBannerContainer').children()[0]).attr('value'));
    //var elementToRemove = $('.coinBannerContainer').children().last();
    //var insertionIndex = elementOnLeft.indexOf("class") + 7;
    //var newElement; //elementOnLeft.slice(0, insertionIndex) + 'cssSlidingFromLeft ' + elementOnLeft.slice(insertionIndex);
    //$('.coinBannerContainer').prepend(newElement);
    //$(elementToRemove).remove();
    //	$(newElement).hide();
    //	//$(newElementOnLeft).removeClass('cssSlidingFromLeft');
    //	$(newElement).show( function() {console.log('Show Callback');});
    //	elementToRemove.hide( function(){
    //		$(elementToRemove).remove();
    //		self.updateNewAttributesInCoin3Banners();
    //	});
    //this.switchToCoin(g_JaxxApp.getSettings().getPreviousEnabledCryptoCurrency());
    //this.updateNewAttributesInCoin3Banners();
    // Attach switchToCoin to the arrow.
    setTimeout( function(){
        self.moveCarouselToNearestPosition();
        self.resetCoinBannerCarouselTimeout();
        // self.updateHighlightingInCoinBannerContainer();
    }, this._coinBannerCarouselAnimationTime);
    this.updateHandlersInCoinBannerContainer();
}

JaxxUI.prototype.resetCoinBannerCarouselTimeout = function() {
    return;
    var self = this;
    this.clearNavigationBarPositionTimeout();
    if (!this.isCurrentCoinTypeVisibleInCarousel()) {
        this._coinBannerCarouselTimeout = setTimeout(function(){self.setCoinNavBarToDefaultPosition();}, this._coinBannerCarouselTimeoutTime);
    } else {
        this.clearNavigationBarPositionTimeout()
    }
}

JaxxUI.prototype.isCurrentCoinTypeVisibleInCarousel1 = function(){
    return this.isCoinTypeVisibleInCarousel(curCoinType);
}

JaxxUI.prototype.isCoinTypeVisibleInCarousel2 = function(coinType){
    // Checks current index, index + 1 and index + 2
    // var currentIndex = this.getCurrentBannerIndexInCarousel();
    // return (coinType === this.getCoinAtIndexInCarousel(currentIndex) || coinType === this.getCoinAtIndexInCarousel(currentIndex + 1) || coinType === this.getCoinAtIndexInCarousel(currentIndex + 2));
}

JaxxUI.prototype.getCurrentBannerIndexInCarousel = function(){
    return parseInt(this.convertOffsetToBannerPosition($('.coinBannerContainer').offset().left)); //+ this.getCoinBannerCarousel().slideCurrent;
}

/*JaxxUI.prototype.getCoinAtIndexInCarousel = function(index){
    // Returns an integer.
    var coinBanners = $('.coinBannerContainer').children();
    return HDWalletHelper.dictCryptoCurrency[$(coinBanners[index % coinBanners.length]).attr('value')]['index'];
    // g_JaxxApp.getUI().getCoinBannerCarousel().slideCurrent
}*/
/*
JaxxUI.prototype.rightCoinBannerClicked = function(coinType) {
	this.slideBannerRight();
	this.updateNewAttributesInCoin3Banners();
	console.log('The Banner on the left was clicked');
}

JaxxUI.prototype.centerCoinBannerClicked = function(coinType) {
	this.switchToCoin(coinType);
	this.updateNewAttributesInCoin3Banners();
	console.log('The Banner in the center was clicked');
}

JaxxUI.prototype.leftCoinBannerClicked = function(coinType) {
	this.slideBannerLeft();
	this.updateNewAttributesInCoin3Banners();
	console.log('The Banner on the right was clicked');
}

*/
/*
JaxxUI.prototype.rightBannerArrowClicked = function() {
	this.rightCoinBannerClicked($('.coinBannerContainer').children().first().attr('value'));
}

JaxxUI.prototype.leftBannerArrowClicked = function() {
	this.leftCoinBannerClicked($('.coinBannerContainer').children().last().attr('value'));
}
*/
/*
JaxxUI.prototype.setHasAttachedScriptAction = function(value) {
	this._hasAttachedScriptAction = value;
	/* this.updateNewAttributesInCoin3Banners();
}*/

JaxxUI.prototype.assignCoinButtonHandlers = function() {

}

JaxxUI.prototype.getHasAttachedScriptAction = function() {
    return this._hasAttachedScriptAction;
}
// Command that disables horrizontal movmnet for dradgging and dropping
//$( ".exchangeRateList tbody" ).sortable({ axis: 'y' });
//$( ".mainMenuWallets .coinList tbody" ).sortable({ axis: 'y' });
//$( ".exchangeRateList tbody" ).sortable({
//    revert: true
//});
//$( ".mainMenuWallets .coinList tbody" ).sortable({
//    revert: true
//});

JaxxUI.prototype.generateShapeshiftBanner = function(sourceCoin, targetCoin) {
    // We usually call this function without setting the second parameter.
    // parameters are of the form 'BTC', 'ETH' etc.

    // Consider setting the settings to the target.

    if (typeof(targetCoin) === 'undefined'){
        targetCoin = g_JaxxApp.getSettings().getShapeshiftCoinTarget(sourceCoin);
    }

    $('.currencyToggleFirst').empty();
    $('.currencyToggleFirst').append(this.getShapeshiftSourceHtml(sourceCoin));
    $('.currencyToggleFirst').append(this.getConversionArrowHtml());
    $('.currencyToggleFirst').append(this.getShapeshiftTargetHtml(targetCoin));

    $('.currencyToggleFirst .scriptAction').click(function (event) { scriptAction(event);});
}
/*
JaxxUI.prototype.updateShapeshiftTarget = function(cryptoUnit) {


    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];

  /!*  // Assumes elements have been generated.
    g_JaxxApp.getSettings().setShapeshiftCoinTarget(coinAbbreviatedName, cryptoUnit);

    $('.currencyToggleFirst').children().last().remove()
    $('.currencyToggleFirst').append(this.getShapeshiftTargetHtml(cryptoUnit));

    $('.currencyToggleFirst .scriptAction').last().click(function (event) { scriptAction(event); });*!/
}*/

JaxxUI.prototype.getShapeshiftSourceHtml = function(coinType) {
    return '<div class="scriptAction  cssImageLogoBanner'+ coinType +' imageLogoBanner' + coinType + ' imageLogoCurrencyToCurrency shapeShiftSwitchFrom cssShapeshiftSwitchFrom cssCoinSelector cssHighlighted cssSourceCoin" value="' + coinType + '"><span class="cssCoinText">' + coinType + '</span></div>';
}

JaxxUI.prototype.getShapeshiftTargetHtml = function(coinType) {
    return '<div class="scriptAction cssImageLogoBanner' + coinType + ' imageLogoBanner' + coinType + ' imageLogoCurrencyToCurrency shapeShiftSwitchTo cssShapeshiftSwitchTo cssCoinSelector cssHighlighted" specialAction="changeShapeshiftCoinToNextCoinType"><span class="cssCoinText">' + coinType + '</span></div>';
}

JaxxUI.prototype.getConversionArrowHtml = function() {
    return '<img class="cssArrowcoinToCoin" src="images/coinToCoin.svg" alt="" height="12" width="28" style="margin: 3px 3px 0px 0px">';
}

JaxxUI.prototype.changeShapeshiftCoinToNextCoinType = function() {
    // cryptoUnit should be left blank.
    var sendCoinAbbreviatedName = $('.shapeShiftSwitchFrom').attr('value');
    var receiveCoinAbbreviatedName = g_JaxxApp.getSettings().getNextCryptoForShapeshiftSelection(sendCoinAbbreviatedName);
    // coinType should be set to something like 'ETH' or 'BTC' (the current coin type in the app)
    this.showSpendableLoading();
    g_JaxxApp.getSettings().setShapeshiftCoinTarget(sendCoinAbbreviatedName, receiveCoinAbbreviatedName);
    this.updateShapeshiftTarget(receiveCoinAbbreviatedName);

    var receiveCoinType = HDWalletHelper.dictCryptoCurrency[receiveCoinAbbreviatedName].index;

    g_JaxxApp.getShapeShiftHelper().setReceivePairForCoinType(curCoinType, receiveCoinType);
    g_JaxxApp.getShapeShiftHelper().clearUpdateIntervalIfNecessary();

    $('.tabContent .address input').trigger('keyup');

    this.closeShapeshiftCoinList(); // Close the menu
}

JaxxUI.prototype.selectShapeshiftCoin = function(receiveCoinAbbreviatedName){
    this.showSpendableLoading();

    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];

    // coinType is something like 'BTC', 'ETH' etc.
    g_JaxxApp.getSettings().setShapeshiftCoinTarget(coinAbbreviatedName, receiveCoinAbbreviatedName); // Set shapeshift currency in settings for this one.

    $('.shapeshiftCoinSelectionMenu tr').removeClass('cssBlueHighlight');
    $('.shapeshiftCoinSelectionMenu .coinType' + receiveCoinAbbreviatedName).addClass('cssBlueHighlight');

    this.updateShapeshiftTarget(receiveCoinAbbreviatedName); // Change the target coin banner.

    var receiveCoinType = HDWalletHelper.dictCryptoCurrency[receiveCoinAbbreviatedName].index;

    g_JaxxApp.getShapeShiftHelper().setReceivePairForCoinType(curCoinType, receiveCoinType);
    g_JaxxApp.getShapeShiftHelper().clearUpdateIntervalIfNecessary();

    $('.tabContent .address input').trigger('keyup');

    var self = this;

    setTimeout(function() {

        self.closeShapeshiftCoinList(); // Close the menu
    }, 500);
}

JaxxUI.prototype.showSpendableLoading = function(){
    $('.spendable .processSpendable').show();
    $('.populateSpendable').text("");
}
JaxxUI.prototype.addOptionsTopCarousel = function(options) { // For flickity
    var wrapAroundValue = false, prevNextButtonsValue = false;
    if(options) {
        wrapAroundValue = options.wrapAround;
        prevNextButtonsValue = options.prevNextButtons;
    }
    options = {
        cellSelector: '.carousel-cell',
        adaptiveHeight: true,
        contain: true,
        pageDots: false,
        wrapAround: wrapAroundValue,
        prevNextButtons: prevNextButtonsValue,
        arrowShape: {
            x0: 35,
            x1: 85, y1: 50,
            x2: 95, y2: 40,
            x3: 55
        },
    };
    this.$topCarousel = $('.carousel.topBannerCarousal').flickity(options);
    this.$topCarouselData = this.$topCarousel.data('flickity');
    //var $cellElem = $('<div class="carousel-cell">Eth</div>');
    //this.$topCarousel.flickity('append', $cellElem);
}
JaxxUI.prototype.initializeTopCarousel = function(options) { // For flickity
    var options;
    if(this.$topCarousel) {
        this.$topCarouselData = this.$topCarousel.data('flickity');
        if(this.$topCarouselData && this.$topCarouselData.cells.length > 3)
            options = {wrapAround: true, prevNextButtons: true};
        this.$topCarousel.flickity('destroy');
    }
    this.addOptionsTopCarousel(options);
}

JaxxUI.prototype.initializeCarousels = function() { // For tinycarousel.js
    //$('#scrollHeaderContainer').tinycarousel({display: 2});
    //$(document).ready(function(){
    $('#scrollHeaderContainer .leftArrow.scriptAction').click(function (event) { scriptAction(event);});
    $('#scrollHeaderContainer .rightArrow.scriptAction').click(function (event) { scriptAction(event);});
    //$('#scrollHeaderContainer').tinycarousel({infinite: true, animationTime: this._coinBannerCarouselAnimationTime});
    //this._coinBannerCarousel = $('#scrollHeaderContainer').data('plugin_tinycarousel'); // This stores plugin object for tinycarousel correponding to the coin banners in the Navigation bar.
    this._washImageSliderCarousel = null; // This stores plugin object for tinycarousel correponding to the coin banners in the Navigation bar. (Not implemented yet)
    //});
}

JaxxUI.prototype.getCoinBannerCarousel = function() {
    //return this.$topCarousel;
    return this._coinBannerCarousel;
}

JaxxUI.prototype.updateCoinBannerCarousel = function() {
    if (typeof(this._coinBannerCarousel) !== 'undefined' && this._coinBannerCarousel !== null){
        this._coinBannerCarousel.update();
    }
}

JaxxUI.prototype.updateSettingsUI = function() {
    console.log('remove');
    // var coinFullName = HDWalletPouch.getStaticCoinPouchImplementation(g_JaxxApp.getSettings().getDefaultCoinType()).uiComponents['coinFullName'];

    /// $('.settingsCurrentWallet').text('(' + coinFullName + ')');
}

JaxxUI.prototype.getIntro = function(){
    return this._jaxxUIIntro;
}

JaxxUI.prototype.createWallet = function(mnemonicEncrypted, callback){
    //@note: ignore existing architecture and use js side securerandom.

    setTimeout(function() {
        if (typeof(mnemonicEncrypted) !== 'undefined' && mnemonicEncrypted !== null){
            var mnemonicEncrypted = g_Vault.encryptSimple(thirdparty.bip39.generateMnemonic());
        }

        loadFromEncryptedMnemonic(mnemonicEncrypted, function(err, wallet) {
            if (err) {
                console.log("createWallet :: error :: " + err);
                console.log('Failed To Create HD Wallet');
            } else {
                storeData('mnemonic', wallet.getMnemonic(),true);

                setTimeout(function() {
                    Navigation.flashBanner("Successfully Created HD Wallet!", 3, 'success');
                }, 2000);
                //Navigation.flashBannerMultipleMessages(['Back up your wallet', 'Go to Tools > Display Backup Phrase'], 10);

                Navigation.startBlit();

                setTimeout(function() {
                    if (PlatformUtils.extensionChromeCheck()) {

                    } else if (PlatformUtils.extensionFirefoxCheck()) {
                        Navigation.openModal('firefoxWarningPopupFirstFrame');
                    }
                }, 500);
                // g_JaxxApp.getUI().initializeBTCMiningOptions(wallet);
                removeStoredData('fiat');
                callback();
            }
        });

        Navigation.closeModal();
        Navigation.startBlit();
    }, 1000);

    // Clean up.
    Navigation.clearSettings();
    Navigation.openModal('creatingWallet');
}

JaxxUI.prototype.toggleTextExpansion = function(strSelectorForTextBox, strSelectorForTriangleArrow, strExpandedHeight, strCollapsedHeight, intAnimateTime, boolAppendCollapsedAttributeIfNotPresent){
    // Note: Parameters for strSelectorForTextBox, strSelectorForTriangleArrow
    if ($(strSelectorForTextBox).hasClass('cssExpanded')){
        this.closeTextExpansion(strSelectorForTextBox, strSelectorForTriangleArrow, strCollapsedHeight, intAnimateTime);
    } else {
        this.openTextExpansion(strSelectorForTextBox, strSelectorForTriangleArrow, strExpandedHeight, intAnimateTime, boolAppendCollapsedAttributeIfNotPresent);
    }
}

JaxxUI.prototype.toggleMaxHeightOnDetailsExpansion = function(strSelectorForTextBox, strSelectorForTriangleArrow, strExpandedHeight, strCollapsedHeight, intAnimateTime, boolAppendCollapsedAttributeIfNotPresent){
    // Note: Parameters for strSelectorForTextBox, strSelectorForTriangleArrow
    if ($(strSelectorForTextBox).hasClass('cssExpanded')){
        this.closeDetailsExpansion(strSelectorForTextBox, strSelectorForTriangleArrow, strCollapsedHeight, intAnimateTime);
    } else {
        this.openDetailsExpansion(strSelectorForTextBox, strSelectorForTriangleArrow, strExpandedHeight, intAnimateTime, boolAppendCollapsedAttributeIfNotPresent);
    }
}



JaxxUI.prototype.closeTextExpansion = function(strSelectorForTextBox, strSelectorForTriangleArrow, strCollapsedHeight, intAnimateTime){
    if ($(strSelectorForTextBox).hasClass('cssExpanded')){
        $(strSelectorForTextBox).removeClass('cssExpanded');
        $(strSelectorForTextBox).animate({height: strCollapsedHeight}, intAnimateTime);
        $(strSelectorForTriangleArrow).removeClass('cssFlipped');
    }
}

JaxxUI.prototype.openTextExpansion = function(strSelectorForTextBox, strSelectorForTriangleArrow, strExpandedHeight, intAnimateTime, boolAppendCollapsedAttributeIfNotPresent){
    if (boolAppendCollapsedAttributeIfNotPresent){
        if (typeof($(strSelectorForTextBox).attr("collapsedHeight")) === 'undefined' || $(strSelectorForTextBox).attr("collapsedHeight") === false) {
            $(strSelectorForTextBox).attr("collapsedHeight", $(strSelectorForTextBox).css("height"));
        }
    }
    if (!($(strSelectorForTextBox).hasClass('cssExpanded'))){
        $(strSelectorForTextBox).animate({height: strExpandedHeight}, intAnimateTime);
        $(strSelectorForTriangleArrow).addClass('cssFlipped');
        setTimeout(function () {
            $(strSelectorForTextBox).addClass('cssExpanded');
        },500);
    }
}

JaxxUI.prototype.closeDetailsExpansion = function(strSelectorForTextBox, strSelectorForTriangleArrow, strCollapsedHeight, intAnimateTime){
    if ($(strSelectorForTextBox).hasClass('cssExpanded')){
        $(strSelectorForTextBox).removeClass('cssExpanded');
        $(strSelectorForTextBox).animate({maxHeight: strCollapsedHeight}, intAnimateTime);
        $(strSelectorForTriangleArrow).removeClass('cssFlipped');
    }
}

JaxxUI.prototype.functionCalledRightAfterJaxxMainScreenLoads = function(){

}

JaxxUI.prototype.openDetailsExpansion = function(strSelectorForTextBox, strSelectorForTriangleArrow, strExpandedHeight, intAnimateTime, boolAppendCollapsedAttributeIfNotPresent){
    if (boolAppendCollapsedAttributeIfNotPresent){
        if (typeof($(strSelectorForTextBox).attr("collapsedHeight")) === 'undefined' || $(strSelectorForTextBox).attr("collapsedHeight") === false) {
            $(strSelectorForTextBox).attr("collapsedHeight", $(strSelectorForTextBox).css("height"));
        }
    }
    if (!($(strSelectorForTextBox).hasClass('cssExpanded'))){
        $(strSelectorForTextBox).animate({maxHeight: strExpandedHeight}, intAnimateTime);
        $(strSelectorForTriangleArrow).addClass('cssFlipped');
        setTimeout(function () {
            $(strSelectorForTextBox).addClass('cssExpanded');
        },500);
    }
}

JaxxUI.prototype.convertOffsetToBannerPosition = function(offsetValue){
    return ($('.scrollHeaderContainer .viewport').offset().left - offsetValue) / $('.coinBannerContainer li').outerWidth(true);
}

JaxxUI.prototype.convertBannerPositionToOffset = function(slidePosition){
    return $('.scrollHeaderContainer .viewport').offset().left - parseInt(slidePosition + 0.5) * $('.coinBannerContainer li').outerWidth(true);
}

JaxxUI.prototype.moveBannerToPosition = function(slidePosition){
    $('.coinBannerContainer').offset({left: this.convertBannerPositionToOffset(slidePosition)});
}

JaxxUI.prototype.moveCarouselToNearestPosition = function(){
    var slidesFromDefaultPosition = this.convertOffsetToBannerPosition($('.coinBannerContainer').offset().left);

    this.moveBannerToPosition(slidesFromDefaultPosition);
}

JaxxUI.prototype.initializeCarouselStickyProperty = function(){
    var self = this;
    /*
    $('.scrollHeaderContainer .viewport').mouseup(function(){
        alert('mouseup event');
        //function(){console.log('Mickey Mouse');}
    });
    $('.scrollHeaderContainer .viewport').mouseout(function(){
        alert('mouseout event');
        //function(){console.log('Mickey Mouse');}
    });
    */
    //$('.scrollHeaderContainer .viewport').on("scroll", function() {
    //console.log('scrolling');
    //$('.scrollHeaderContainer .viewport').mouseup(
    //    function(){console.log('Mickey Mouse');}
    //)

    //console.log("Haven't scrolled in 50ms!");
    //clearTimeout(g_Timeout_Scroll);
    //g_Timeout_Scroll = setTimeout(function(){console.log("Haven't scrolled in 50ms!");}, 250);
    //$.data(this, 'scrollTimer', setTimeout(function() {
    // do something
    //    console.log("Haven't scrolled in 50ms!");
    //}, 50));
    //});

    $('.scrollHeaderContainer .viewport').bind('scroll', function(){
        self.turnHoverEffectOff();
        self.resetCoinBannerCarouselTimeout();
        clearTimeout(self._coinBannerCarouselDragTimeout);

        self._coinBannerCarouselDragTimeout = setTimeout(function(){
            /*
            $('.scrollHeaderContainer .viewport').mouseup(function(){
                $('.scrollHeaderContainer .viewport').off('mouseup')
                alert('mouseup event');
            });
            */
            self.moveCarouselToNearestPosition();
            self.turnHoverEffectOn();
            self.resetCoinBannerCarouselTimeout();
            //alert('after scroll');
            //$('.scrollHeaderContainer .viewport').trigger('mouseup');}, 250);
            //function(){console.log('Mickey Mouse');}
        }, 250);
    });
}

JaxxUI.prototype.showEtcEthSplitModal = function(baseTXCost, balancesTransferrable) {
    if (this._disableETCETHSplitOption === true || !wallet) {
        return;
    }
    //    eth/etc split :: balancesTransferrable ::
    //@note: @here: @etcethsplit
    //    balancesTransferrable = {
    //                "0xdbb89358ebe7af776222acbc99acfa005769f7d9": {
    //                    "small": "73736579999999984",
    //                    "large": "0.073736579999999984"
    //                },
    //                "0x190f6bd674b5614e59a53e1f7156a2c2ca86a05f": {
    //                    "small": "5000000000000000",
    //                    "large": "0.005"
    //                },
    //                "0x051da87c3679be285dc22e2fba5e833052375ced": false
    //            };

    var ethTargetAddress = wallet.getPouchFold(COIN_ETHEREUM).getCurrentReceiveAddress();

    var etcTargetAddress = wallet.getPouchFold(COIN_ETHEREUM_CLASSIC).getCurrentReceiveAddress();

    $('.etcEthSplitEthAddress').text(ethTargetAddress);
    $('.etcEthSplitEtcAddress').text(etcTargetAddress);

    var addressDictToSplit = [];
    var ethBalanceRequiredList = [];

    var addressListText = "";

    var ethCost = 0;
    var etcCost = 0;

    for (var curAddress in balancesTransferrable) {
        var curBalanceStatus = balancesTransferrable[curAddress];

        if (curBalanceStatus.ethRequiredLarge !== 0) {
            ethBalanceRequiredList.push({address: curAddress, ethRequiredLarge: curBalanceStatus.ethRequiredLarge});
        } else {
            var addressDetails = {address: curAddress, etcBalance: curBalanceStatus.small};

            addressDictToSplit.push(addressDetails);

            addressListText += curAddress + ": <span class='cssAmount'>" + parseFloat(parseFloat(curBalanceStatus.large).toFixed(8)) + " ETC</span><br>";
            ethCost += baseTXCost;
            etcCost += baseTXCost;
        }
    }

    ethCost = HDWalletHelper.convertWeiToEther(ethCost);
    etcCost = HDWalletHelper.convertWeiToEther(etcCost);

    if (addressListText !== "") {
        $('.etcEthSplitAddressesText').show();
        $('.etcEthSplitAddressesConfirmText').show();
    } else {
        $('.etcEthSplitAddressesText').hide();
        $('.etcEthSplitAddressesConfirmText').hide();
    }

    $('.etcEthSplitAddressList').html(addressListText);

    if (ethBalanceRequiredList.length > 0) {
        var ethRequiredText = "";

        for (var i = 0; i < ethBalanceRequiredList.length; i++) {
            var curEthBalanceRequiredDict = ethBalanceRequiredList[i];

            ethRequiredText += "<span class='cssSelectable'>" + curEthBalanceRequiredDict.address + "</span><span class='cssSelectable'> : " + parseFloat(parseFloat(curEthBalanceRequiredDict.ethRequiredLarge).toFixed(8)) + " ETH</span><br>";
        }

        $('.etcEthSplitInsufficientGasForRefundWarningText').show();

        $('.etcEthSplitInsufficientGasForRefundWarningText').html("<p>Your following Ethereum addresses have both an ETH and ETC balance. Splitting these addresses will reduce future complications. These ETC-holding address requires more ETH to be able to perform the split. We recommend depositing the required ETH into your following Ethereum wallet address: <br></p>" + ethRequiredText);

        $('.etcEthSplitInsufficientGasForRefundWarningText').addClass();

    } else {
        $('.etcEthSplitInsufficientGasForRefundWarningText').hide();
    }

    var shouldShowSplitModal = false;
    if (addressListText === "" && ethBalanceRequiredList.length === 0) {
        $('.etcEthSplitAddressesNoSplitText').show();
        shouldShowSplitModal = false;
    } else {
        $('.etcEthSplitAddressesNoSplitText').hide();
        shouldShowSplitModal = true;
    }

    $('.etcEthSplitCostEth').text(ethCost + " ETH");
    $('.etcEthSplitCostEtc').text(etcCost + " ETC");

    if (shouldShowSplitModal === false) {
        if (this._shouldShowEtcEthSplitIfNoneAvailable === true) {
            shouldShowSplitModal = true;
        }
    }

    if (shouldShowSplitModal === true) {
        wallet.setEtcEthAddressesToSplit(addressDictToSplit);

        Navigation.openModal('etcEthSplit');
    }
}

JaxxUI.prototype.toggleIgnoreEtcEthSplit = function() {
    var ignoreEtcEthSplit = (g_JaxxApp.getSettings().getIgnoreEtcEthSplit() === true) ? false: true;

    g_JaxxApp.getSettings().setIgnoreEtcEthSplit(ignoreEtcEthSplit);

    if (ignoreEtcEthSplit === true) {
        $('.etcEthSplitIgnoreToggleButtonCheckArea').addClass('cssCurrencyisChecked');
        $('.etcEthSplitIgnoreToggleButtonCheckArea').css('border', 'none');
    } else {
        $('.etcEthSplitIgnoreToggleButtonCheckArea').removeClass('cssCurrencyisChecked');
        $('.etcEthSplitIgnoreToggleButtonCheckArea').css('border', '1px solid white');
    }
}

JaxxUI.prototype.checkForEtcEthSplit = function() {
    Navigation.clearSettings();
    Navigation.closeModal();
    this.closeMainMenu();

    this._shouldShowEtcEthSplitIfNoneAvailable = true;

    g_JaxxApp.getSettings().setIgnoreEtcEthSplit(false);
    $('.etcEthSplitIgnoreToggleButtonCheckArea').removeClass('cssCurrencyisChecked');
    $('.etcEthSplitIgnoreToggleButtonCheckArea').css('border', '1px solid white');

    wallet.getPouchFold(COIN_ETHEREUM).getPouchFoldImplementation().setupCheckForEtcEthSplit();
}

JaxxUI.prototype.confirmEtcEthSplit = function() {
    Navigation.clearSettings();
    Navigation.closeModal();

    if (wallet.getEtcEthAddressesToSplit().length === 0) {

    } else {
        wallet.performEtcEthSplit();
    }
}

JaxxUI.prototype.addListeners = function () {
    var self = this;

    jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_BALANCE_MANUAL_START,function () {
        console.log(jaxx.Registry.ON_RESTORE_BALANCE_MANUAL_START);
        $('.refreshLoading').show();
        $('.refresh.imageRefresh').hide();
        $('#overlay').addClass("overlay");
        //g_JaxxApp.getUI().showProcessBalanceUI();
        //g_JaxxApp.getUI().updateCoinDisplayBalanceInWallet(jaxx.Registry.currentCoinType,-1);
    });
    jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_BALANCE_ERROR,function () {
        // console.warn(jaxx.Registry.ON_RESTORE_BALANCE_ERROR);
        $('.refreshLoading').hide();
        //g_JaxxApp.getUI().showErrorLoadingBalances();
        //g_JaxxApp.getUI().updateCoinDisplayBalanceInWallet(jaxx.Registry.currentCoinType,-1);
    });
    jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_BALANCE_MANUAL_END,function () {
        console.log(jaxx.Registry.ON_RESTORE_BALANCE_MANUAL_END);
        $('.refreshLoading').hide();
        g_JaxxApp.getUI().hideProcessBalanceUI();
        g_JaxxApp.getUI().hideErrorLoadingBalances();
        //g_JaxxApp.getUI().updateCoinDisplayBalanceInWallet(jaxx.Registry.currentCoinType,-1);
    });

    /* jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_START,function () {
         console.log(jaxx.Registry.ON_RESTORE_HISTORY_START);
         Navigation.hideSpinner(curCoinType);
         $('.initializingLoading').show();
         var settime = (curCoinType === COIN_AUGUR_ETHEREUM) ? 400 : 2000;
         setTimeout(function() {
             $('.initializingLoading img').removeClass('cssStartHidden');
         }, settime);
         g_JaxxApp.getUI().showProcessBalanceUI();
         g_JaxxApp.getUI().showProcessAddressUI();
         g_JaxxApp.getUI().hideErrorLoadingTransactions();
     });*/
    jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_ERROR,function () {
        // console.warn(jaxx.Registry.ON_RESTORE_HISTORY_ERROR);
        g_JaxxApp.getUI().showErrorLoadingTransactions();
    });
    /*jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_DONE,function () {
        console.log(jaxx.Registry.ON_RESTORE_HISTORY_DONE);
        $('.initializingLoading').hide();
        $('.initializingLoading img').addClass('cssStartHidden');
        g_JaxxApp.getUI().hideErrorLoadingTransactions();
        var isTipsandTricksShown = getStoredData("tipAndTricksShown");
        if(!isTipsandTricksShown && g_JaxxApp.getUI()._jaxxUIIntro._setOptionSelected === "Express") {
            setTimeout(function() {
                g_JaxxApp.getUI().showNotificationFooter();
            },1000);
        } else { //if (!isTipsandTricksShown && g_JaxxApp.getUI()._jaxxUIIntro._setOptionSelected !== "Express") {
            this._isTipsAndTricksShown = true;
            g_JaxxApp.getUI()._jaxxUIIntro.showCreateWalletNotifications();
        }
    });*/
    jaxx.Registry.application$.on(jaxx.Registry.ON_UTXOS_READY, function(event, coinType, utxos){
        if(typeof wallet.getPouchFold(coinType).clearSpendableBalanceCache ==='function') wallet.getPouchFold(coinType).clearSpendableBalanceCache();
        updateSpendable();

    });
    jaxx.Registry.application$.on(jaxx.Registry.ON_NONCES_READY, function(event, coinType, nonces){
        if(typeof wallet.getPouchFold(coinType).clearSpendableBalanceCache ==='function') wallet.getPouchFold(coinType).clearSpendableBalanceCache();
        updateSpendable();
    });



    jaxx.Registry.application$.on(jaxx.Registry.BALANCE_OUT_OFF_SYNC, function () {
        $('.refreshLoading').show();
        $('.refresh.imageRefresh').hide();
        $('.mainBalanceBox .populateBalanceCoinAmount').addClass('opacity06');
        $('.mainBalanceBox .populateBalanceFiat').addClass('opacity06');
        g_JaxxApp.getUI().showProcessAddressUI();
    });

    jaxx.Registry.application$.on(jaxx.Registry.BALANCE_IN_SYNC, function () {
        // if(!$('.mainBalanceBox .populateBalanceCoinAmount').hasClass('opacity06')) return;

        $('.refreshLoading').hide();
        $('.refresh.imageRefresh').show();
        $('.mainBalanceBox .populateBalanceCoinAmount').removeClass('opacity06');
        $('.mainBalanceBox .populateBalanceFiat').removeClass('opacity06');
        g_JaxxApp.getUI().hideProcessAddressUI();
    });

}

JaxxUI.prototype.showProcessBalanceUI = function () {
    //$('.refreshLoading').show();
    Registry.application$.triggerHandler(Registry.SHOW_INIT_WALLET);
    $('.processBalanceText').show();
    $('.amountNull').show();
    $('.populateBalanceCoinAmount').hide();
    $('.portraitCurrency').hide();
    $('#overlay').addClass("overlay");
    //$('.populateBalanceCoinAmount .decimalPortion .displayValue').text('---');
    //$('.populateBalanceCoinAmount .wholePortion .displayValue').css("display", "none");
    //$('.decimalPoint.cssDecimalPoint').hide();
    $('.refresh.imageRefresh').hide();
};

JaxxUI.prototype.hideProcessBalanceUI = function () {
    $('.refreshLoading').hide();
    Registry.application$.triggerHandler(Registry.HIDE_INIT_WALLET);
    $('.initializingLoading').hide();
    $('.initializingLoading img').addClass('cssStartHidden');
    $('.processBalanceText').hide();
    $('.amountNull').hide();
    $('.populateBalanceCoinAmount').show();
    $('.portraitCurrency').show();
    $('#overlay').removeClass("overlay");
    $('.refresh.imageRefresh').show();
};

JaxxUI.prototype.showProcessAddressUI = function () {
    //$('.refreshLoading').show();
    $('.processAddressPlaces').show();
    //$('.populateBalanceCoinAmount .decimalPortion .displayValue').text('---');
    //$('.populateBalanceCoinAmount .wholePortion .displayValue').css("display", "none");
    //$('.decimalPoint.cssDecimalPoint').hide();
    $('.addressPlace').hide();
}
JaxxUI.prototype.hideProcessAddressUI = function () {
    //$('.refreshLoading').hide();
    $('.processAddressPlaces').hide();
    $('.addressPlace').show();
}

//var isBalanceInit;

JaxxUI.prototype.updateCoinDisplayBalanceInWallet = function(coinType, coinBalance, boolOverrideBalanceLock){
    //  console.warn(coinBalance);
    /* if(!isBalanceInit){

     jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_START,function () {
         console.warn('ON     updateCoinDisplayBalanceInWallet');

         g_JaxxApp.getUI().updateCoinDisplayBalanceInWallet(jaxx.Registry.currentCoinType,-1);
     })

         isBalanceInit = true;
     }*/

    if(coinBalance < 0){
        console.log(' setting text -----');
        // $('.populateBalanceCoinAmount .wholePortion .displayValue').text("-");
        // $('.populateBalanceCoinAmount .decimalPortion .displayValue').text("---");
        this.showProcessBalanceUI();
        return;
    }

    console.log(coinBalance);

    // g_JaxxApp.getUI().updateCoinDisplayBalanceIn}Wallet(4, "0.000000454"); // test case in wallet
    if (!this._debugLockBalanceUpdate || boolOverrideBalanceLock) {
        var dictWholeNumberFontSize = this._dictWholeNumberFontSize;

        //this._dictWholeNumberFontSizeOverride = [{"max-width": 300, "font-dict": {1: 30, 2: 30, 3: 30, 4: 22, 5: 22, 6: 22, 7: 18, 8: 18, 9: 18}}, {"max-width": 500, "font-dict": {1: 35, 2: 35, 3: 35, 4: 22, 5: 22, 6: 22, 7: 18, 8: 18, 9: 18}}];
        for (var i = 0; i < this._dictWholeNumberFontSizeOverride.length; i++){
            if ($(window).width() <= this._dictWholeNumberFontSizeOverride[i]["max-width"]){
                dictWholeNumberFontSize = this._dictWholeNumberFontSizeOverride[i]['font-dict'];
            }
        }

        var coinDisplayBalance = parseFloat(HDWalletHelper.getCoinDisplayScalar(curCoinType, coinBalance) + "").toFixed(8);
        // var coinDisplayBalance = "4321.12345678";
        //var residualDisplayString = '';
        //    console.log(coinType + " :: " + coinDisplayBalance);

        // var intPaddingRightDisplayBox = parseFloat($(".landscapeLeft .cssBalanceBox").css("padding-right"));
        // var intPaddingLeftDisplayBox = parseFloat($(".landscapeLeft .cssBalanceBox").css("padding-left"));

        //var intDecimalPointWidth = $(".decimalPoint").width(); // The width of the decimal point in pixels

        var intDisplayBoxWidth = $(".cssBalanceBox").width() // - intQRCodeWidth - intDecimalPointWidth; // Measured in pixels
        var balanceDisplayValues = this.getPartWholePairAsStrings(coinDisplayBalance); // Gets a dictionary of the whole/decimal portion
        var wholePortion = balanceDisplayValues.wholePortion; // whole portion as string
        var decimalPortion = balanceDisplayValues.decimalPortion; // decimal portion as string
        var wholeNumberOfDigits = wholePortion.length;
        var decimalNumberOfDigits = decimalPortion.length;
        var totalNumberOfDigits = wholeNumberOfDigits + decimalNumberOfDigits;
        // Calculate Font Size Based On decimal length, whole number length and total length
        // @NOTE: When intDisplayBoxWidth = 189, font-size = 22pt, number of digits is 9 then the width is about right

        // Set text and styling for whole number portion
        var intFontSizeWholeNumber = dictWholeNumberFontSize[wholeNumberOfDigits];
        if (typeof(intFontSizeWholeNumber) === 'undefined' || intFontSizeWholeNumber === null){
            intFontSizeWholeNumber = dictWholeNumberFontSize[9];
        }
        $('.populateBalanceCoinAmount .wholePortion .displayValue').text(wholePortion);
        $('.populateBalanceCoinAmount .wholePortion .displayValue').css("font-size", intFontSizeWholeNumber.toString() + "px");
        var intCalculatedWidthOfWholePortionText = wholeNumberOfDigits * 17 * intFontSizeWholeNumber / 30 - 5;
        $('.populateBalanceCoinAmount .wholePortion').css('width', (intCalculatedWidthOfWholePortionText).toString() + 'px'); // A bit of a hack that removes space before the decimal
        //var intWidthOfCharacterWholePortion = intFontSizeWholeNumber / 3;
        //$('.populateBalanceCoinAmount .wholePortion .displayValue').css("width", intWidthOfCharacterWholePortion.toString() + "px"); // Width should be 10 for font-size of 30
        //$('.populateBalanceCoinAmount').css('height', intFontSizeWholeNumber * 1.2);
        // Set text and styling for decimal portion
        var intWidthOfWholePortionText = $('.populateBalanceCoinAmount .wholePortion').width();
        var intWidthOfDecimalPointText = 35;
        var intPaddingOnRight = 10;
        var intQRCodeWidth = $(".landscapeLeft .portraitQRCode .qrCode").width(); // Width of the QR code in pixels
        var intWidthAvailableForDecimalPortion = intDisplayBoxWidth - (intWidthOfWholePortionText + intWidthOfDecimalPointText + intQRCodeWidth + intPaddingOnRight);
        var intWidthPerDecimalCharacter = intWidthAvailableForDecimalPortion / decimalNumberOfDigits;
        var intFontSizeForDecimalPortion = Math.min(Math.floor(intWidthPerDecimalCharacter * 30 / 17), intFontSizeWholeNumber); // A font size of 30 produces a width of 17 for '0'
        // Change display elements for decimal portion
        // Use intWidthAvailableForDecimalPortion which is calculated previously
        $('.populateBalanceCoinAmount .decimalPortion .displayValue').css("font-size", intFontSizeForDecimalPortion.toString() + "px");
        $('.populateBalanceCoinAmount .decimalPortion .displayValue').text(decimalPortion);
        this.hideProcessBalanceUI();
        this.hideProcessAddressUI();
    }

    //var intApproximateWidthOfWholeNumberPortion = intFontSizeWholeNumber * wholeNumberOfDigits * 0.92;
    //var intWidthForDecimalNumberPortion = intDisplayBoxWidth - intApproximateWidthOfWholeNumberPortion;
    //var intFontSizeForDecimalNumber = Math.floor(intWidthForDecimalNumberPortion / decimalNumberOfDigits / 0.92);
    //$('.populateBalanceCoinAmount .decimalPortion .displayValue').css("font-size", intFontSizeForDecimalNumber.toString() + "px");
    // All three balance display elements must have the same line height
    //if (curProfileMode == PROFILE_PORTRAIT) {


    /*
    //            0.15419750 41741231
    coinDisplayBalance = wholePortion + "." + decimalPortion;
    //            if (coinDisplayBalance.length >)
    if (wholePortion.length > 3 || coinDisplayBalance.length > 11) {
        coinDisplayBalance = wholePortion + ".";
        var smallScreen = window.matchMedia("(min-width: 375px)");
        if (smallScreen.matches){
            $('.populateBalanceCoinAmount').css('font-size', '23pt');
        }
        else {
            $('.populateBalanceCoinAmount').css('font-size', '22pt');
        }
        var coinBalanceResidual = decimalPortion;
        residualDisplayString = '<span class="populateBalanceCoinAmountSuperscript cssEthereumAmountSuperscript">' + coinBalanceResidual + '</span>';
        //                console.log("residualDisplayString :: " + residualDisplayString);

        //                $('.populateBalanceCoinAmountSuperscript').show();
        //                $('.populateBalanceCoinAmountSuperscript').text(coinBalanceResidual);
        //                console.log("coinBalanceResidual :: " + coinBalanceResidual);
        if (wholePortion.length == 5) {
            coinDisplayBalance = wholePortion + ".";
            var smallScreen = window.matchMedia("(min-width: 375px)");
            if (smallScreen.matches){
                $('.populateBalanceCoinAmount').css('font-size', '22pt');
            }
            else {
                $('.populateBalanceCoinAmount').css('font-size', '21pt');
            }
        } else {
            //                $('.populateBalanceCoinAmountSuperscript').hide();
        }
    } else {
        //                $('.populateBalanceCoinAmountSuperscript').hide();
    }
    */
    //$('.populateBalanceCoinAmount .wholePortion').text(wholePortion);
    //$('.populateBalanceCoinAmount .decimalPortion').text(decimalPortion);
    //} else {
    //$('.populateBalanceCoinAmount').text(coinDisplayBalance);
    //$('.populateBalanceCoinAmount').append(residualDisplayString);
    //        $('.populateBalanceCoinAmountSuperscript').hide();
    //        var smallScreen = window.matchMedia("(min-width: 375px)");
    //                if (smallScreen.matches){
    //                    $('.populateBalanceCoinAmount').css('font-size', '21pt');
    //                }
    //                else {
    //                    $('.populateBalanceCoinAmount').css('font-size', '20pt');
    //                }
    //}
}
JaxxUI.prototype.getDisplayForBalanceNotAvailable = function(){
    return '---';
}

JaxxUI.prototype.toggleClosestAncestorExpandableText = function(element){
    // element is expected to have the 'triangleArrow' class.
    var ancestorElement = element;
    while (!($(ancestorElement).hasClass("expandableText"))){
        ancestorElement = $(ancestorElement).parent();
        if ($(ancestorElement).length === 0){
            return;
        }
    }
    // Ancestor element found if code reaches this point.
    // Select platform specs and expand height.
    var targetHeight = this.readExpandedHeight($(ancestorElement).attr("expandedHeight"));
    /*if (PlatformUtils.mobileiOSCheck() && $(ancestorElement).attr("iosExpandedHeight")) {
        var targetHeight = $(ancestorElement).attr("iosExpandedHeight");
    } else if (PlatformUtils.mobileAndroidCheck() && $(ancestorElement).attr("androidExpandedHeight")){
        var targetHeight = $(ancestorElement).attr("androidExpandedHeight");
    } */
    this.toggleTextExpansion(ancestorElement, element, targetHeight, $(ancestorElement).attr("collapsedHeight"), 500, true);
}

JaxxUI.prototype.readExpandedHeight = function(strExpandedHeightValue){
    var returnValue="0px";
    if (strExpandedHeightValue[0] === "["){
        var heightList = JSON.parse(strExpandedHeightValue);
        heightList.sort(function(index1, index2){return index2[0] - index1[0];});
        // heightList should be sorted highest to lowest.
        for (var i = 0; i < heightList.length; i++){
            if ($(window).width() < heightList[i][0]){
                returnValue = heightList[i][1];
            }
        }
    } else {
        returnValue = strExpandedHeightValue;
    }
    return returnValue;
}

JaxxUI.prototype.checkClosestAncestorCheckable = function(element){
    // element is expected to have the 'triangleArrow' class.
    var ancestorElement = element;
    while (!($(ancestorElement).hasClass("ancestorCheckable"))){
        ancestorElement = $(ancestorElement).parent();
        if ($(ancestorElement).length === 0){
            return;
        }
    }
    // Ancestor element found if code reaches this point.
    this.checkElement(ancestorElement);
}

JaxxUI.prototype.checkElement = function(element){
    if ($(element).hasClass("checked")){
        $(element).removeClass("cssChecked").removeClass("checked");
    } else {
        $(element).addClass("cssChecked").addClass("checked");
    }
}

/* Implement later if refactor is necessary.
JaxxUI.prototype.changeHeightOfTargetElementBasedOnSourceElement = function(strSourceElementSelector, strTargetElementSelector){

}
*/

JaxxUI.prototype.changeHeightOfElement = function(strSelector, intHeightChange){
    $(strSelector).css("height", (parseInt($(strSelector).css("height")) + intHeightChange).toString() + "px")
}

JaxxUI.prototype.jaxxClearAppDataIfAuthenticated = function(){
    if ($(".tabContent .address input").val() === 'jaxxmaster2783' && !(g_JaxxApp.isReleaseVersion())){
        Navigation.openModal('clearAllData');
        //localStorage.clear();
    }
}

JaxxUI.prototype.clickCheckboxToContinue = function(element, target){
    g_JaxxApp.getUI().checkElement($(element));
    if ($(element).hasClass("checked")){
        $(target).show();
    } else {
        $(target).hide();
    }
}

JaxxUI.prototype.clickCheckboxSettingsBackupMnemonicPage = function(element, target){
    this.clickCheckboxToContinue($(".settings.backupMnemonic .cssCheckboxContainer"), $(".settings.backupMnemonic .btnContinue"));
}

JaxxUI.prototype.clickRightArrowExpressWalletNotifications = function(element) {

}

JaxxUI.prototype.clickLeftArrowExpressWalletNotifications = function(element) {

}
JaxxUI.prototype.updateFooter = function(index){
    //This function will update tips notification footer on last slide
    var getCarouselSlides = $('.cssNotificationFooter .carousel .carousel-cell');
    var $elOKGotIt = $(".notificationOverlay .cssNotificationFooter .okGotIt");
    var $elSkip = $(".notificationOverlay .cssNotificationFooter .skip");
    if(index === (getCarouselSlides.length - 1)) {
        $elSkip.hide();
        setTimeout ( function () {
            $elOKGotIt.show();
        }, 100);
    }
    else {
        $elOKGotIt.hide();
        $elSkip.show();
    }
}
JaxxUI.prototype.closeNotificationBanner = function(){
    Navigation.closeNotificationBanner();
}
JaxxUI.prototype.showNotificationFooter = function(){
    //var intFooterHeight = 5 + parseInt($(".transactionsBitcoin").outerHeight()) + parseInt($(".mainTransactionHistoryHeader").outerHeight());
    // var strFooterHeight = intFooterHeight.toString() + "px";
    // var strCarouselHeight = (intFooterHeight - 60).toString() + "px";
    //$(".notificationFooter").css("height", strFooterHeight);
    var self = this;
    var decorateCarousel = function(){
        if (JaxxUI._sUI._wWidth > JaxxUI._sUI._wHeight) {
            //landscape stuff is unimplemented, but it will go here
        } else {
            //portrait stuff
            //landscapeRight is the Transaction History div
            var carouselHeight = (JaxxUI._sUI._wHeight - $('.landscapeRight').position().top); // + 5;
            var cellHeight = carouselHeight - 61;
            $(".cssNotificationFooter").css("height", carouselHeight);
            $(".cssNotificationFooter .cssCarousel .carousel-cell").css("height", cellHeight);
        }
    }
    decorateCarousel();
    $(".notificationOverlay").removeClass("cssStartHidden");
    $(".notificationFooter").show();
    $(".notificationOverlay .cssNotificationFooter .okGotIt").hide();
    $(".notificationFooter .carousel .carousel-cell").width();
    setTimeout(function () {
        //$(".flickity-prev-next-button.next").on("click", function() {
        //  console.log("click trigger");
        var $carousel = $(".notificationFooter .carousel");
        var flkty = $carousel.data('flickity');
        var getSelectedIndex=0;
        $carousel.on( 'select.flickity', function() {
            getSelectedIndex = flkty.selectedIndex;
            self.updateFooter(getSelectedIndex);
            //console.log("click trigger", flkty.selectedIndex);
        });

        //});
//        $(".flickity-prev-next-button.next").attr("specialAction", "jaxx_ui.updateFooter").addClass("scriptAction");
    }, 200);
    //$(".notificationFooter .flickity-viewport").css("height", strCarouselHeight);
    this.getFlickityNotificationFooter().flickity('resize');
    this._isNotificationFooterOpen = true;
    this._isTipsAndTricksShown = true;
    storeData("tipAndTricksShown", this._isTipsAndTricksShown);
}

JaxxUI.prototype.hideNotificationFooter = function(){
    $(".notificationOverlay").addClass("cssStartHidden");
    $(".notificationFooter").show();
    this._isNotificationFooterOpen = false;
    g_JaxxApp.getUI().getJaxxNews(function() {
        g_JaxxApp.getUI().displayJaxxNewsIfCritical();
    });
    this._jaxxUIIntro.showCreateWalletNotifications();

}

JaxxUI.prototype.isNotificationFooterOpen = function(){
    return this._isNotificationFooterOpen;
}

JaxxUI.prototype.getFlickityNotificationFooter = function(){
    return this._flickityNotificationFooter;
}

JaxxUI.prototype.clickFoxIconBetweenSendReceive = function(){

    // console.error(' clickFoxIconBetweenSendReceive   ');

}

JaxxUI.prototype.pairFromDeviceScanQRToolsMenu = function() {
    var callback = function(jaxxToken){
        var mnemonic = HDWalletMain.getMnemonicFromJaxxToken(jaxxToken);
        $(".settings.loadJaxxToken .validateMnemonic").val(mnemonic);
        $(".settings.loadJaxxToken .validateMnemonic").trigger('keyup')
    }
    g_JaxxApp.getUI().scanJaxxToken(callback);
}

JaxxUI.prototype.scanJaxxToken = function(callback){
    // Set the callback to some default.
    if (typeof(callback) === 'undefined' || callback === null){
        var callback = function(jaxxToken) {
            // The jaxx token is something like "jaxx:717dbc12b017c1fb38ffff1ab9159ddb/1MoMB2jFxGWQo6XFQGK4uxZmN5MDqn1qNa"
            // @TODO: The loading page should be something special, no a modal page. ie. no dismiss; better design; etc.
            setTimeout(function() {
                parseJaxxToken(jaxxToken, function(err, newWallet) {
                    if (err) {
                        console.log("scanJaxxToken :: error :: " + err);
                    } else {
                        _loadWallet(newWallet);
                        jaxx.seed.getEncryptedSeed();
                        //storeData('mnemonic', wallet.getMnemonic(),true);
                        //showCreateWalletNotifications() should be called for notifications at appropriate time
                        //Navigation.flashBanner("Successfully Imported!", 5, 'success');

                        Navigation.startBlit();
                    }
                });

                Navigation.closeModal();
            }, 3000);
            Navigation.clearSettings();
            Navigation.openModal('loading');
        };
    }
    // Perform the function with the callback.
    if (window.native && window.native.scanCode) {
        window.native.scanCode(callback);
    }
}

JaxxUI.prototype.loadWalletFromEncryptedMnemonic = function(){

    // // jaxx.Registry.currentCoinType = g_JaxxApp.getSettings().getDefaultCoinType();
    // g_JaxxApp._settings.resetJaxxCache(); // This must be done before setting the default callback




    /*   var self = this, additionalCallback = function(){
           var defaultCoinType = HDWalletHelper.dictCryptoCurrency[g_JaxxApp.getSettings().getListOfEnabledCryptoCurrencies()[0]].index;
           //console.error(' JaxxUIIntro.prototype.createWalletWithCallback ');
           // jaxx.Registry.currentCoinType = defaultCoinType;
           jaxx.Registry.currentCoinType = defaultCoinType;
           setupDefaultCoinType(defaultCoinType);
           Navigation.setupCoinUI(defaultCoinType);
       };*/


    //this.clearPrivateKeyList();
    //jaxx.Registry.application$.triggerHandler(jaxx.Registry.RESET_STORAGE);
    Navigation.closeModal();

    // Navigation.clearSettings();

    //forceUpdateWalletUI();


    //Navigation.startBlit();


    /* setTimeout(function(){ loadFromEncryptedMnemonic( function(err, wallet) { // Timeout because of animation time in Navigation clear settings
         if (err) {
             console.log("importMnemonic.import :: error :: " + err);

             Navigation.flashBanner("Error on Import Attempt", 5, 'error');
             Navigation.closeModal();
             Navigation.startBlit();
         } else {
             storeData('mnemonic', wallet.getMnemonic(), true);
             //showCreateWalletNotifications() should be called for notifications at appropriate time
             //if(self._jaxxUIIntro._setOptionSelected !== "Express")
             //    Navigation.flashBanner("Successfully Imported!", 5, 'success');
             Navigation.closeModal();
             Navigation.clearSettings();
             Navigation.startBlit();
             //g_JaxxApp.getUI().showCoinBulletinUsingAbbreviatedName(HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters["coinAbbreviatedName"]);

             additionalCallback();
             // g_JaxxApp.getUI().initializeBTCMiningOptions(wallet);
             forceUpdateWalletUI();
         }
     }); }, 500);

     g_JaxxApp.getUI().closeMainMenu();
     Navigation.openModal('loading');*/
    // Navigation.clearSettings(function(){Navigation.openModal('loading');});
}

JaxxUI.prototype.removeElement = function(element){
    $(element).remove();
}

JaxxUI.prototype.attachClickEventForScriptAction = function(jquerySelector){
    // @NOTE: I'm not too sure this function works
    $(jquerySelector).off('click');
    $(jquerySelector).click(function (event) { scriptAction(event);}); // Add the scriptAction triggers again.
    //} catch (err) {
    //console.error(err);
    //}
}

JaxxUI.prototype.showHideFoxOnFrontEndOfWallet = function(coinType){
    console.log('TODO  JaxxUI.prototype.showHideFoxOnFrontEndOfWallet');

    /* var key = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters.coinAbbreviatedName;
     var shapeShiftCryptoCurrenciesAllowed = HDWalletHelper.shapeShiftCryptoCurrenciesAllowed.regular;
     if (typeof(shapeShiftCryptoCurrenciesAllowed[key]) === 'undefined' || shapeShiftCryptoCurrenciesAllowed[key] === null || shapeShiftCryptoCurrenciesAllowed[key] === false) {
         $(".shapeshiftTab").hide();
     } else {
         $(".shapeshiftTab").show();
     }*/
}

/*
JaxxUI.prototype.generatePrivateKeyMenuOptions = function(){
    $(".settings.backupPrivateKeys .privateKeyMenuList").empty();
    var coins = jaxx.Registry.getAllCryptoControllers();
    for(var j = 0, n=coins.length; j < n; j ++ ) {
        var coin = coins[j];
        console.log(coin.displayPrivateKey);
        if(coin.displayPrivateKey) {
            this.addCoinToPrivateKeyListIfMissing(coin.coinType, coin.symbol, coin.displayName);
        }
    }
    this.attachClickEventForScriptAction(".settings.backupPrivateKeys .privateKeyMenuList .scriptAction");
}
*/

JaxxUI.prototype.addCoinToPrivateKeyListIfMissing = function( symbol, displayName){

    // if (HDWalletHelper.isPrivateKeyCryptoCurrencyAllowed(coinType) && this._privateKeysDisplayedInList.indexOf(coinType) === -1) { // @NOTE: isPrivateKeyCryptoCurrencyAllowed(i)
    // Generate a private key row here
    $(".settings.backupPrivateKeys .privateKeyMenuList").append(this.getHtmlForPrivateKeyMenuItem(symbol, displayName));
    //var newRow = $(".settings.backupPrivateKeys .privateKeyMenuList .displayPrivateKeys" + HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters.coinAbbreviatedName);
    this.attachClickEventForScriptAction(".settings.backupPrivateKeys .privateKeyMenuList .scriptAction");
   // this._privateKeysDisplayedInList.push(coinType);
    // }
}

JaxxUI.prototype.clearPrivateKeyList = function(){
    $(".settings.backupPrivateKeys .privateKeyMenuList").empty();
    this._privateKeysDisplayedInList = [];
}

JaxxUI.prototype.getHtmlForPrivateKeyMenuItem = function(symbol, displayName){
    var expandedHeightForCoin = "\'[[500, \"120px\"], [2000, \"100px\"]]\'";
    var coinFullDisplayName = displayName; //HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents.coinFullDisplayName;

    var coinAbbreviatedName = symbol; //HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters.coinAbbreviatedName;
    var htmlElement = '<div class="displayPrivateKeys' + coinAbbreviatedName + ' cssInitialHeight SettingsButton cssExpandableText expandableText expandableDetailsAncestor cssbackupTab scriptAction" specialAction="jaxx_controller.clickDisplayPrivateKeysMenuOption" data-displayname="' + displayName + '" data-symbol="'+ symbol + '" >'
        + '<div class="expandableDetailsHeader cssExpandableDetailsHeader">'
        + '<div class="triangleArrow cssTriangleArrow scriptAction stopPropagation" specialAction="jaxx_ui.toggleNearbyExpandableDetails"></div>'
        + '<div class="optionTrigger cssOptionTrigger">'
        + '<div class="optionHeading cssOptionHeading">'
        + '<label>Display ' + coinFullDisplayName + ' Keys</label>'
        + '</div>'
        + '</div>'
        + '</div>'
        + '<div class="cssExpandableDetailsElement expandableDetailsElement" expandedheight=' + expandedHeightForCoin + '>'
        + '<div class="toggler cssToggler">'
        + '<p class="cssIntroScreenHeading">View your ' + coinFullDisplayName +' addresses / keys that have been generated by the wallet.</p>'
        + '</div>'
        + '</div>'
        + '</div>';
    return htmlElement;
}

JaxxUI.prototype.attachClickEventsToAllScriptActionElements = function(){
    var elements = $(".scriptAction").not(".scrollHeaderContainer .rightArrow").not(".scrollHeaderContainer .leftArrow"); // Exclude carousel arrows
    this.attachClickEventForScriptAction(elements);
    /*
    $('.scriptAction').off('click');
    $('.scriptAction').click(function (event) {
        //    try {
        scriptAction(event);
        //    } catch (err) {
        //        console.error(err);
        //    }
    });
    //g_JaxxApp.getUI().setHasAttachedScriptAction(true);   */
}

JaxxUI.prototype.toggleNearbyExpandableDetails = function(element){
    // element is expected to have the 'triangleArrow' class.
    var ancestorElement = element;
    while (!($(ancestorElement).hasClass("expandableDetailsAncestor"))){
        ancestorElement = $(ancestorElement).parent();
        if ($(ancestorElement).length === 0){
            return;
        }
    }
    var expandableDetailsElement = ancestorElement.find(".expandableDetailsElement");
    // Ancestor element found if code reaches this point.
    // Select platform specs and expand height.
    var targetHeight = this.readExpandedHeight($(expandableDetailsElement).attr("expandedHeight"));
    /*if (PlatformUtils.mobileiOSCheck() && $(ancestorElement).attr("iosExpandedHeight")) {
        var targetHeight = $(ancestorElement).attr("iosExpandedHeight");
    } else if (PlatformUtils.mobileAndroidCheck() && $(ancestorElement).attr("androidExpandedHeight")){
        var targetHeight = $(ancestorElement).attr("androidExpandedHeight");
    } */
    this.toggleMaxHeightOnDetailsExpansion(expandableDetailsElement, element, targetHeight, $(expandableDetailsElement).attr("collapsedHeight"), 500, true);
}

JaxxUI.prototype.generateTextInDisplayPrivateKeysMenu = function(){
    /* Anthony decided not to show names of coins on menu 22nd Feb 2017
    var strDisplayText = "View and/or export your ";
    // BTC, ETH, ETC and DASH private keys and public addresses."
    var dictPrivateKeyCryptoCurrenciesAllowed = HDWalletHelper.getDictPrivateKeyCryptoCurrenciesAllowed();
    var arrKeysPrivateKeyCryptoCurrenciesAllowed = Object.keys(dictPrivateKeyCryptoCurrenciesAllowed);
    var arrCryptoAllowedList = []
    for (var i = 0; i < arrKeysPrivateKeyCryptoCurrenciesAllowed.length; i++){
        if (dictPrivateKeyCryptoCurrenciesAllowed[arrKeysPrivateKeyCryptoCurrenciesAllowed[i]]){
            arrCryptoAllowedList.push(arrKeysPrivateKeyCryptoCurrenciesAllowed[i]);
        }
    }
    if (arrCryptoAllowedList.length < 2){
        strDisplayText += arrCryptoAllowedList[arrCryptoAllowedList.length - 2];
    } else {
        for (var i = 0; i < arrCryptoAllowedList.length - 2; i++){
            strDisplayText += arrCryptoAllowedList[i] + ", ";
        }
        strDisplayText += arrCryptoAllowedList[arrCryptoAllowedList.length - 2] + " and " + arrCryptoAllowedList[arrCryptoAllowedList.length - 1];
    }
    strDisplayText += " private keys and public addresses.";
    $(".settings.toolsPage .menuOptionDisplayPrivateKeys .introScreenHeading").text(strDisplayText);
    */
}

JaxxUI.prototype.showShapeshiftSpinner = function(){
    $('.shiftingProgress').stop().fadeIn();
    $("#Send_Recieve_Btn .send.label").hide();
}

JaxxUI.prototype.hideShapeshiftSpinner = function(){
    $('.shiftingProgress').stop().fadeOut();
    $("#Send_Recieve_Btn .send.label").show();
}

JaxxUI.prototype.initializeBTCMiningOptions = function() {
    console.log('TODO');
    return;
    var intMiningFeeOption = g_JaxxApp.getSettings().getMiningFeeOptionForCoin(COIN_BITCOIN);
    g_JaxxApp.getUI().setupMiningFeeSelector('MainMenu', true);
    var strElementSelector = '.' + HDWalletPouch.dictMiningFeeOptionID[intMiningFeeOption];
    $(strElementSelector).trigger('click');
    g_JaxxApp.getUI().pushBTCMiningFeeFromPouchToModal();
}

JaxxUI.prototype.isTransactionInputDataValid = function(){
//
//    var validAddressTypes = [];
//    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
//        validAddressTypes[i] = false;
//    }
//
//    if (addressValue !== "") {
//        validAddressTypes = getAddressCoinTypes(addressValue);
//    }
//
//    if (g_JaxxApp.getShapeShiftHelper().getIsTriggered()) {
//        validAddressTypes[curCoinType] = true;
//    }
//
//    var tab = Navigation.getTab();
//
//    var coinAmountSmallType = 0;
//    if (Navigation.isUseFiat()) {
//        //            console.log("fiat");
//        coinAmountSmallType = wallet.getPouchFold(curCoinType).convertFiatToCoin(amountValue, COIN_UNITSMALL);
//
//    } else {
//        //            console.log("not fiat");
//        coinAmountSmallType = HDWalletHelper.convertCoinToUnitType(curCoinType, amountValue, COIN_UNITSMALL);
//    }
//
//    var minimumToSpend = 0;
//    var numShiftsRequired = 1;
//
//    if (g_JaxxApp.getShapeShiftHelper().getIsTriggered()) {
//        //get latest market object
//        var curMarketData = g_JaxxApp.getShapeShiftHelper().getMarketForCoinTypeSend(curCoinType);
//
//        minimumToSpend = curMarketData.depositMin;
//
//        if (minimumToSpend) {
//            if (curCoinType === COIN_THEDAO_ETHEREUM) {
//                minimumToSpend /= 100;
//            }
//
//            //            console.log("minimumToSpend (large units) :: " + minimumToSpend);
//
//            minimumToSpend = parseInt(HDWalletHelper.convertCoinToUnitType(curCoinType, minimumToSpend, COIN_UNITSMALL));
//
//            var numShiftsRequired = wallet.getPouchFold(curCoinType).getShiftsNecessary(minimumToSpend);
//
//            if (g_JaxxApp.getShapeShiftHelper().isMultiShiftValid(curCoinType, numShiftsRequired)) {
////                    console.log("updateFromInputFieldEntry :: multiShift is valid");
//
//                var shiftResults = g_JaxxApp.getShapeShiftHelper().getMultiShiftResults(curCoinType, numShiftsRequired);
//                /*
//                if (shiftResults !== null) {
//
//                } else {
//                    return;
//                } */
//            } else {
//                console.log("updateFromInputFieldEntry :: multiShift is invalid.. requesting");
//
//                g_JaxxApp.getShapeShiftHelper().requestMultiShift(curCoinType, numShiftsRequired, function(shiftParams) {
//                    console.log("updateFromInputFieldEntry :: finished multishift :: shiftParams :: " + JSON.stringify(shiftParams, null, 4));
//
//                    var coinTypeDict = g_JaxxApp.getShapeShiftHelper().getPairCoinTypeDict(shiftParams.shiftMarketData.pair);
//
//                    if (coinTypeDict.send === curCoinType) {
//                        g_JaxxApp.getUI().populateShapeShiftReceiveData(g_JaxxApp.getShapeShiftHelper()._marketData[coinTypeDict.send][coinTypeDict.receive]);
//                    }
//                });
//
//                //$('.tabContent .amount .button').removeClass('cssEnabled').removeClass('enabled');
//
//                return;
//            }
////                g_JaxxApp.getShapeShiftHelper().setupMultiShift(curCoinType, numShiftsRequired);
//        } else {
//            console.log("minimumToSpend unavailable :: curMarketData :: " + JSON.stringify(curMarketData, null, 4));
//
//            //$('.tabContent .amount .button').removeClass('cssEnabled').removeClass('enabled');
//
//            return;
//        }
//    }
//    // Insert here
//
//    var withinLimits = true;
//
//    if (coinAmountSmallType > wallet.getPouchFold(curCoinType).getSpendableBalance(minimumToSpend)) {
//        withinLimits = false;
//    }
//
//    if (coinAmountSmallType <= 0) {
//        withinLimits = false;
//    }
//
//    if (curCoinType === COIN_BITCOIN) {
//        //            console.log("bitcoin :: trying to spend :: " + coinAmountSmallType + " :: total spendable balance :: " + wallet.getPouchFold(curCoinType).getSpendableBalance());
//    } else if (curCoinType === COIN_ETHEREUM) {
//        //            console.log("ethereum :: trying to spend :: " + coinAmountSmallType + " :: total spendable balance :: " + wallet.getPouchFold(curCoinType).getSpendableBalance(minimumToSpend));
//
//        //@note: for a zero wei transfer, this is valid for a contract address w/ data.
//
//        if (            wallet.getPouchFold(curCoinType).getPouchFoldImplementation().hasCachedAddressAsContract(HDWalletHelper.parseEthereumAddress(addressValue))) {
//            if (coinAmountSmallType >= 0) {
//                if (coinAmountSmallType > wallet.getPouchFold(curCoinType).getSpendableBalance(minimumToSpend)) {
//                    withinLimits = false;
//                } else {
//                    withinLimits = true;
//                }
//            }
//        }
//    } else if (curCoinType === COIN_ETHEREUM_CLASSIC) {
//        //            console.log("ethereum :: trying to spend :: " + coinAmountSmallType + " :: total spendable balance :: " + wallet.getPouchFold(curCoinType).getSpendableBalance(minimumToSpend));
//
//        //@note: for a zero wei transfer, this is valid for a contract address w/ data.
//
//        if (            wallet.getPouchFold(curCoinType).getPouchFoldImplementation().hasCachedAddressAsContract(HDWalletHelper.parseEthereumAddress(addressValue))) {
//            if (coinAmountSmallType >= 0) {
//                if (coinAmountSmallType > wallet.getPouchFold(curCoinType).getSpendableBalance(minimumToSpend)) {
//                    withinLimits = false;
//                } else {
//                    withinLimits = true;
//                }
//            }
//        }
//    } else if (curCoinType === COIN_TESTNET_ROOTSTOCK) {
//        //            console.log("roostock :: trying to spend :: " + coinAmountSmallType + " :: total spendable balance :: " + wallet.getPouchFold(curCoinType).getSpendableBalance(minimumToSpend));
//
//        //@note: for a zero wei transfer, this is valid for a contract address w/ data.
//
//        if (            wallet.getPouchFold(curCoinType).getPouchFoldImplementation().hasCachedAddressAsContract(HDWalletHelper.parseEthereumAddress(addressValue))) {
//            if (coinAmountSmallType >= 0) {
//                if (coinAmountSmallType > wallet.getPouchFold(curCoinType).getSpendableBalance(minimumToSpend)) {
//                    withinLimits = false;
//                } else {
//                    withinLimits = true;
//                }
//            }
//        }
//    } else if (curCoinType === COIN_THEDAO_ETHEREUM) {
//        //            console.log("TheDAO Ethereum :: trying to spend :: " + coinAmountSmallType + " :: total spendable balance :: " + wallet.getPouchFold(curCoinType).getSpendableBalance(minimumToSpend));
//    } else if (curCoinType === COIN_DASH) {
//        console.log("dash :: trying to spend :: " + coinAmountSmallType + " :: total spendable balance :: " + wallet.getPouchFold(curCoinType).getSpendableBalance());
//    }
//
//    var hasValidAddress = false;
//
//    if (validAddressTypes[curCoinType] === true) {
//        hasValidAddress = true;
//    } else {
//        if (wallet.getPouchFold(curCoinType).isTokenType()) {
//            var coinHolderType = CoinToken.getMainTypeToTokenCoinHolderTypeMap(curCoinType);
//
//            if (validAddressTypes[coinHolderType] === true) {
//                hasValidAddress = true;
//            }
//        }
//    }
//
//    if (tab === 'send' && hasValidAddress === true && withinLimits === true){
//        return true;
//    } else {
//        return false;
//    }
}

JaxxUI.prototype.updateHighlightingInSendTransactionButton = function(){
    if (this.isTransactionInputDataValid()){
        $("#Send_Recieve_Btn").addClass("cssBlueHighlight");
    } else {
        $("#Send_Recieve_Btn").removeClass("cssBlueHighlight");
    }
}

JaxxUI.prototype.setStandardMessageForTransferPaperWallet = function(){
    $(".settings.confirmSweepPrivateKey .spinner").text(this._defaultPaperWalletMessage);
}


JaxxUI.prototype.preparePaperWarning = function(element) {
    var coinAbbreviatedName = $(element).attr('value');
    $(".paperWarning .header").text("Transfer "+coinAbbreviatedName+" Paper Wallet");
    $(".paperWarning .understandButton").attr("value", coinAbbreviatedName);
}

/*
* After the user clicks I understand it goes into the paper wallet.
* @method preparePrivateKeySweep
* @param element
* */
JaxxUI.prototype.preparePrivateKeySweep = function(element) {
    var coinAbbreviatedName = $(element).attr('value');
    this._transferPaperWalletCoinType = coinAbbreviatedName;
    this.setTransferPaperWalletHeader(coinAbbreviatedName);
    $(".settings.sweepPrivateKey .heading").text("Transfer "+coinAbbreviatedName+" Paper Wallet");
    Registry.application.transferPaperWallet.symbol = coinAbbreviatedName;
}

JaxxUI.prototype.setTransferPaperWalletHeader = function(coinType){
    console.log('TODO setTransferPaperWalletHeader');
    return;
    var coinNetInfo = 'BIP38';
    if(coinType === COIN_ETHEREUM || coinType === COIN_ETHEREUM_CLASSIC || coinType === COIN_AUGUR_ETHEREUM || coinType === COIN_ICONOMI_ETHEREUM || coinType === COIN_GOLEM_ETHEREUM ||  coinType === COIN_GNOSIS_ETHEREUM || coinType === COIN_SINGULARDTV_ETHEREUM || coinType === COIN_DIGIX_ETHEREUM) {
        coinNetInfo = "AES";
    }
    $(".settings.sweepPrivateKey .optionHeading label").text("Scan your private key (QR Code), or type in your private key, in order to transfer your " + HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents.coinFullDisplayName + " Jaxx also accepts encrypted keys (" + coinNetInfo + " for " + HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents.coinFullDisplayName + ").");
}

JaxxUI.prototype.getTransferPaperWalletCoinType = function() {
    return this._transferPaperWalletCoinType;
}

JaxxUI.prototype.sweepPrivateKeyExecuteCallback = function(status, tx) {
    console.log("status :: " + JSON.stringify(status));
    if (status === 'success') {
        Navigation.flashBanner('Successfully Transferred', 3);
        Navigation.clearSettings();
        Navigation.closeModal();
        g_JaxxApp.getUI().closeMainMenu();
        var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(g_JaxxApp.getUI().getTransferPaperWalletCoinType()).pouchParameters["coinAbbreviatedName"];
        g_JaxxApp.getUI().switchToCoin(coinAbbreviatedName);
    } else {
        Navigation.flashBanner('Error with transfer', 3);
        Navigation.clearSettings();
        Navigation.closeModal();
        g_JaxxApp.getUI().closeMainMenu();
    }
}

JaxxUI.prototype.updateCoinDisplayBalance = function(balance){

}

JaxxUI.prototype.getPartWholePairAsStrings = function(coinDisplayBalance){
    // returns
    if (typeof(coinDisplayBalance) !== 'string'){
        coinDisplayBalance = coinDisplayBalance.toString();
    }
    var wholePortion = "";
    var decimalPortion = "";
    // We assume
    if (coinDisplayBalance.indexOf('.') != -1) { // Just an error guard
        wholePortion = coinDisplayBalance.split(".")[0];
        decimalPortion = coinDisplayBalance.split(".")[1].substring(0, 8);
    } else {
        wholePortion = coinDisplayBalance;
        decimalPortion = "00000000";
    }
    return {"wholePortion": wholePortion, "decimalPortion": decimalPortion};
    /*
    if (wholePortion.length > 3 || coinDisplayBalance.length > 11) {
        coinDisplayBalance = wholePortion + ".";
        var smallScreen = window.matchMedia("(min-width: 375px)");
        if (smallScreen.matches){
            $('.populateBalanceCoinAmount').css('font-size', '23pt');
        }
        else {
            $('.populateBalanceCoinAmount').css('font-size', '22pt');
        }
        var coinBalanceResidual = decimalPortion;
        residualDisplayString = '<span class="populateBalanceCoinAmountSuperscript cssEthereumAmountSuperscript">' + coinBalanceResidual + '</span>';
        //                console.log("residualDisplayString :: " + residualDisplayString);

        //                $('.populateBalanceCoinAmountSuperscript').show();
        //                $('.populateBalanceCoinAmountSuperscript').text(coinBalanceResidual);
        //                console.log("coinBalanceResidual :: " + coinBalanceResidual);
        if (wholePortion.length == 5) {
            coinDisplayBalance = wholePortion + ".";
            var smallScreen = window.matchMedia("(min-width: 375px)");
            if (smallScreen.matches){
                $('.populateBalanceCoinAmount').css('font-size', '22pt');
            }
            else {
                $('.populateBalanceCoinAmount').css('font-size', '21pt');
            }
        } else {
            //                $('.populateBalanceCoinAmountSuperscript').hide();
        }
    } else {
        //                $('.populateBalanceCoinAmountSuperscript').hide();
    }*/
}

JaxxUI.prototype.lockBalanceUpdate = function(){
    this._debugLockBalanceUpdate = true;
}

JaxxUI.prototype.updateTransactionListWithCurrentCoin = function(){
    this.updateTransactionListWithCoin(curCoinType);
}

JaxxUI.prototype.updateTransactionListWithCoin = function(coinType){
    if (typeof(coinType) === 'undefined' || coinType === null) {
        coinType = curCoinType;
    }
    // Lowest index in history has most recent timestamp
    var history = wallet.getPouchFold(coinType).getHistory();
    history = history.slice(0, this._numHistoryElementsDisplayed[coinType]);
    this.updateTransactionList(coinType, history);
}
///////
JaxxUI.prototype.resizeTransactionTable = function(coinType){
    console.log('TODO transactions table ')
    return;
    if (typeof(coinType) === 'undefined' || coinType === null) {
        var coinType = curCoinType;
    }
    var transactionTable = $(HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName']);
    var tableHeight = 0;
    for (var i = 0; i < $(transactionTable).children().length; i++) {
        tableHeight += $($(transactionTable).children()[i]).height();
    }
    //$(transactionTable).css('height', tableHeight.toString()+'px');
    //$(transactionTable).parent().css('height',$(transactionTable).height() - 50);
}

JaxxUI.prototype.getLoadMoreButtonTransactionList = function(coinType){
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    return '<div class="loadMore cssLoadMore cssTableFooter wow animated fadeInUp scriptAction" specialaction="jaxx_controller.clickAddMoreTransactionsToTransactionList" value="'+coinAbbreviatedName+'" data-wow-duration="0.5s">'
        + '<span> Load More </span>'
        + '</div>';
}

JaxxUI.prototype.addLoadMoreButtonTransactionList = function(coinType){

    var transactionListElement = $(HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName']);
    // var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    var loadMoreElement = this.getLoadMoreButtonTransactionList(coinType);
    $(transactionListElement).append(loadMoreElement);
    var loadMoreButtonAdded = $(transactionListElement).find('.loadMore');
    this.attachClickEventForScriptAction(loadMoreButtonAdded); // Attach event listeners.
}

JaxxUI.prototype.removeLoadMoreButtonTransactionList = function(coinType){
    console.log(' TODO transactions list');
    return
    var transactionListElement = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['transactionsListElementName'];
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    $(transactionListElement + ' .loadMore').remove(); // Remove the loadMore button.
}

JaxxUI.prototype.showErrorLoadingTransactions = function(){
    if (!IS_RELEASE_VERSION) {
        $(".errorLoadingTransactions").show();
    }
}

JaxxUI.prototype.hideErrorLoadingTransactions = function(){
    $(".errorLoadingTransactions").hide();
}

JaxxUI.prototype.showErrorLoadingBalances = function(){
    $(".errorLoadingBalances").show();
}

JaxxUI.prototype.hideErrorLoadingBalances = function(){
    $(".errorLoadingBalances").hide();
}

JaxxUI.prototype.clearPrivateKeyInput = function(){
    $('#privateKeySweep').val("");
    $('#privateKeySweep').trigger('keyup');
}

JaxxUI.prototype.loadExtraStylesheets = function(){
    if (PlatformUtils.extensionFirefoxCheck()){
        $('head').append('<link rel="stylesheet" type="text/css" href="css/style-firefox-only.css">');
    }
}

JaxxUI.prototype.showApplicationLoadingScreen = function(){
    $(".applicationStart").show();
}

// JaxxUI.prototype.showCoinBulletinUsingAbbreviatedName = function(coinAbbreviatedName){
//     var coinBulletinData = g_JaxxApp.getUI().getCoinBulletinData();
//     var coinsInBulletin = Object.keys(coinBulletinData);
//     if (coinsInBulletin.indexOf(coinAbbreviatedName) > -1) {
//         var bulletinData = coinBulletinData[coinAbbreviatedName];
//         $(".coinBulletinTitle").text(bulletinData.title);
//         $(".coinBulletinDescription").html(unescape(bulletinData.description));
//         $(".coinBulletinCloseButton").attr("value", coinAbbreviatedName);
//         Navigation.openModal("jaxxNews");
//     }
// };

JaxxUI.prototype.functionToCallWhenJaxxIsFinishedLoading = function(){
    this.showModalForCoinBulletinIfNotHidden(curCoinType);
};

JaxxUI.prototype.updateFullDisplayBalanceInWallet = function(coinType){
    var balance = [];

    var ctr = jaxx.Registry.getCurrentCryptoController();

    // var balance = ctr.getSpendableBalanceDB();

    /* for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
         var p = wallet.getPouchFold(i);
         if(p)balance[i] = p.getPouchFoldBalance();
     }*/

    /* if (!hasUpdatedBalance[coinType]) {
         //                console.log("updating for :: " + coinFullDisplayName + " :: " + balance[coinType]);
         hasUpdatedBalance[coinType] = true;
     } else {
         //                console.log("balance for :: " + coinFullDisplayName + " :: " + balance[coinType]);
         if (balance[coinType] > prevBalance[coinType]) {
             //            console.log("beep for :: " + coinFullDisplayName);
             playSound("snd/balance.wav", null, null);
         }
     }*/

    //prevBalance[coinType] = balance[coinType];

    //var coinBalance = -1;
    // if (balance[curCoinType] >= 0) {
    // coinBalance = HDWalletHelper.convertCoinToUnitType(curCoinType, balance[curCoinType], COIN_UNITLARGE);
    // }


    //TODO Fiat display

    ///  var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];
    // if(curCoinType === COIN_ICONOMI_ETHEREUM) {
    //  var coinAbbreviatedICNName = "ICN";

    $('.populateBalanceCoinUnit').text(ctr.symbol);
    /// } else {
    // $('.populateBalanceCoinUnit').text(coinAbbreviatedName);
    // }

    $('.populateBalanceCoinAmount .wholePortion .displayValue').empty(); // Consider Removing
    $('.populateBalanceCoinAmount .decimalPortion .displayValue').empty(); // Consider Removing

    //  g_JaxxApp.getUI().updateCoinDisplayBalanceInWallet(curCoinType, coinBalance);




    // var fiatAmount = wallet.getHelper().convertCoinToFiatWithFiatType((ctr.units === 'wei'?1:0), balance, COIN_UNITSMALL, null, false);

    //if (Number.isNaN(fiatAmount)){
    // fiatAmount = g_JaxxApp.getUI().getDisplayForBalanceNotAvailable();
    // }
    //   $('.populateBalanceFiat').text(fiatAmount); // We specify 'false' so that the correct prefix is used for the currency.

    // $('.populateCurrencyName').text(wallet.getHelper().getFiatUnit());
}

JaxxUI.prototype.updateTransactionHistoryOnUIUpdate = function() {
    console.log(' TODO  history')
    return;
    var shouldRefreshTransaction = false;
    //    var curTime = new Date().getTime();

    //    if (!forceTransactionRefresh && curTime - lastTransactionRefreshTime > historyRefreshTime) {
    //        lastTransactionRefreshTime = curTime;
    //        shouldRefreshTransaction = true;
    //    } else if (!forceTransactionRefresh) {
    var history = []// = wallet.getPouchFold(curCoinType).getHistory();
    //console.log(history);

    if (history) {
        if (!g_JaxxApp.getUI().isTransactionListEqualToHistory(curCoinType, history)) {
            shouldRefreshTransaction = true;
        }

    } else {
        console.error(' history not provided  for ' + curCoinType);
    }
    if (!history || history.length <= 0) {
        g_JaxxApp.getUI().resetTransactionList(curCoinType);
    }
    //        if (refreshHistoryTimer === null) {
    //            refreshHistoryTimer = setTimeout(function() {
    ////                console.log("do refresh tx history");
    //                updateWalletUI();
    //            }, historyRefreshTime - (curTime - lastTransactionRefreshTime) + 100);
    //
    //            lastTransactionRefreshTime = curTime;
    //        }
    //    }

    //    console.log("shouldRefreshTransaction :: " + shouldRefreshTransaction + " :: forceTransactionRefresh :: " + forceTransactionRefresh + " :: timer :: " + (curTime - lastTransactionRefreshTime));

    if (forceTransactionRefresh || shouldRefreshTransaction) {
        //        console.log("refreshing tx history :: timer :: " + (curTime - lastTransactionRefreshTime));
        refreshHistoryTimer = null;
        forceTransactionRefresh = false;
        //        lastTransactionRefreshTime = curTime;

        // g_JaxxApp.getUI().updateTransactionListWithCurrentCoin();
        // g_JaxxApp.getUI().updateTransactionList(curCoinType, wallet.getPouchFold(curCoinType).getHistory());
    }
}

JaxxUI.prototype.updateMainMenuConversionAmount = function(){
    //@note: for thedao tokens, because they're scaled at 100:1, and the same conversion functions work on these,
    //we pre-scale the amount. this may be incorrect.
    // var coinAbbreviatedName =              HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];
    // var conversionCoinAmount = 1;

    var ctr = jaxx.Registry.getCurrentCryptoController();
    var type = ctr.units ==='wei'?1:0;
    var conversionAmount = wallet.getHelper().convertCoinToFiatWithFiatType(type, 1, COIN_UNITLARGE, null, false);

    $('.settings.setCurrency .exchangeRateAbbreviatedUnit').text(ctr.symbol);
    $('.mainMenuCurrencies .exchangeRateAbbreviatedUnit').text(ctr.symbol);
    // if (Number.isNaN(conversionAmount)){
    //  conversionAmount = g_JaxxApp.getUI().getDisplayForBalanceNotAvailable();
    // }

    $('.mainMenuCurrencies .exchangeRate').text(conversionAmount);
}

JaxxUI.prototype.updateWalletUISetCurrency = function(){
    // Update currency settings

    //coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];
    currency = wallet.getHelper().getFiatUnit();
    // Currently an issue... If the user is browsing currencies and an update comes in, we jump on them.
    //var selectedTop = 0;
    $('.settings.setCurrency .currency').each(function (i, e) {
        e = $(e);
        if (e.attr('value') === currency) {
            //            e.addClass('selected').addClass('cssSelected');
            //selectedTop = e.position().top;
        } else {
            e.removeClass('selected').removeClass('cssSelected');
        }
    });
}

JaxxUI.prototype.applyTriggersForAmountSendInputUpdateWalletUI = function(){
    console.log('applyTriggersForAmountSendInputUpdateWalletUI')
    //console.warn(' applyTriggersForAmountSendInputUpdateWalletUI   ');

    if (wallet.getHelper().hasFiatExchangeRates(COIN_BITCOIN, 'USD')) {

        if (Navigation.getTab() == 'send') {
            //            console.log("< is send tab >");
            if (!$('.tabContent .amount input').is(":focus")) {
                //                console.log("< input tab not focused >");
                // $('.tabContent .amount input').trigger('keyup');

            }
        }
    } else {
        //        console.log("< no fiat exchange rates found >");
    }
}

/*
JaxxUI.prototype.applyChangesInTheUIForTestnetUpdateWalletUI = function(){
    var isTestnet = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['isTestnet'];

    if (isTestnet === true) {
        $('.populateAddressType').parent('.mainAddressBox').addClass('cssTestnet');
    } else {
        $('.populateAddressType').parent('.mainAddressBox').removeClass('cssTestnet');
    }
}*/

// JaxxUI.prototype.updateQRCodeInUI = function(){
//     var qrCode = 0;
//     var address = jaxx.Registry.getCurrentCryptoController().getCurrentAddress();
//     qrCode = jaxx.Utils.generateQRCode(address, false);
//     // qrCode = wallet.getPouchFold(curCoinType).generateQRCode();
//     $('.populateQRCode').attr("src", qrCode); // Update the QR code
// }

JaxxUI.prototype.updateAddressElementsInUI = function(){
    // Update the address
    var address = 0;

    var prefixForAddress = "Current ";
    var ctr = jaxx.Registry.getCurrentCryptoController();

    // address = ctr.getCurrentPublicAddresReceive();  //wallet.getPouchFold(curCoinType).getCurrentReceiveAddress();
    address = ctr.getCurrentAddress();
    // console.error(curCoinType,address);

    var coinFullDisplayName = ctr.displayName;// HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).uiComponents['coinFullDisplayName'];

    if( ctr.name === 'DigixEthereum' ) {
        $('.populateAddressType').text("Your DigixDAO Address:");
        // } else if(HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters && HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters.tokenIsERC20) {
        //  $('.populateAddressType').text("Your " + coinFullDisplayName + " Address:");
    } else {
        if(coinFullDisplayName === "Ethereum") {
            $('.populateAddressType').text("Your " + coinFullDisplayName + " Address:");
        } else {
            $('.populateAddressType').text("Your " + prefixForAddress + coinFullDisplayName + " Address:");
        }

    }
    $('.populateAddress').text(address);
    $('.populateAddressCopy').attr('copy', address);
    $('.populateAddressCopyLarge').attr('copyLarge', address);

    if (ctr.testnet) {
        $('.populateAddressType').parent('.mainAddressBox').addClass('cssTestnet');
    } else {
        $('.populateAddressType').parent('.mainAddressBox').removeClass('cssTestnet');
    }
    // $('.populateMnemonic').text(wallet.getMnemonic());
}

JaxxUI.prototype.setStartJaxxWithTermsOfServicePageWasRun = function(value){
    this._startJaxxWithTermsOfServicePageWasRun = value;
}

function remoteToggleNearbyExpandableDetails(el) {
    jaxx.Registry.jaxxUI .toggleNearbyExpandableDetails(el);
}

function remoteToggleMainMenu(){
    //JaxxUI.prototype.toggleMainMenu();
    if (jaxx.Registry.jaxxUI._mainMenuIsOpen === true) {
        jaxx.Registry.jaxxUI.closeMainMenu();
    }
    else {
        jaxx.Registry.jaxxUI.openMainMenu();
    }
}

var HDWalletHelper = function() {
   /* self = this;
    this._updateExchangeRateTime = 30*1000;
    this._exchangeRates = [];

    this._defaultEthereumGasPrice = thirdparty.web3.toWei(thirdparty.web3.toBigNumber('21'), 'shannon');
    this._defaultEthereumGasLimit = thirdparty.web3.toBigNumber(21000);
    this._recommendedEthereumCustomGasLimit = this._defaultEthereumGasLimit;
    this._currentEthereumCustomGasLimit = this._recommendedEthereumCustomGasLimit;*/

//    this._coinHDType = [];
//    this._coinHDType[COIN_BITCOIN] = 0;
//    this._coinHDType[COIN_ETHEREUM] = 60;
//    this._coinHDType[COIN_DASH] = 5;
//
//    //@note: unused for now, ethereum has no testnet node in SLIP 0044 as of yet.
//    this._coinHDTypeTestnetOffset = [];
//    this._coinHDTypeTestnetOffset[COIN_BITCOIN] = 1;
//    this._coinHDTypeTestnetOffset[COIN_ETHEREUM] = 131337;

    //this._exchangeRateListenerCallbacks = [];
  //  this._exchangeRatesHasChanged = {};
  //  this.unitsOfEther = new thirdparty.bnjs('1000000000000000000');
   // this.convertWeiToEtherCache = { Wei: 0 , Balance: 0 };
    //this.converEtherToWeiCache = { ether: 0 , Balance: 0 };
}

HDWalletHelper.etcEthSplitContractAddress = "0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444";
HDWalletHelper.etcEthSplitOpCode = "0x0f2c9329";

HDWalletHelper.apiKeyEtherScan = "WGWHHAU4F2Y58UW5FQWTUJWSXBNHU7WBSX";

HDWalletHelper.baseInitialCryptoCurrencies = {
    "regular": {"BTC": true, "ETH": true, "DAO": false, "DASH": true, "ETC": true, "REP": true, "LTC": true, "LSK": false, "ZEC": false, "SBTC": true, "DOGE": false, "ICN": true, "GNT": true, "GNO": true, "SNGLS": false, "DGD": true, "BCAP": true, "CVC": true}//,
//    "ios": {"BTC": true, "ETH": true, "DAO": true, "DASH": false, "ETC": true}
}

HDWalletHelper.cryptoCurrenciesAllowed = {
    "regular": {"BTC": true, "ETH": true, "DAO": false, "DASH": true, "ETC": true, "REP": true, "LTC": true, "LSK": false, "ZEC": true, "SBTC": true, "DOGE": true, "ICN": true, "GNT": true, "GNO": true, "SNGLS": false, "DGD": true, "BCAP": true, "CVC": true},
    "ios": {"BTC": true, "ETH": true, "DAO": false, "DASH": true, "ETC": true, "REP": true, "LTC": true, "LSK": false, "ZEC": true, "SBTC": true, "DOGE": true, "ICN": true, "GNT": true, "GNO": true, "SNGLS": false, "DGD": true, "BCAP": true, "CVC": true}
}

HDWalletHelper.shapeShiftCryptoCurrenciesAllowed = {
    "regular": {"BTC": true, "ETH": true, "DAO": false, "DASH": true, "ETC": true, "REP": true, "LTC": true, "LSK": false, "ZEC": true, "SBTC": false, "DOGE": true, "ICN": true, "GNT": true, "GNO": true, "SNGLS": false, "DGD": false, "BCAP": false, "CVC": true},
}

HDWalletHelper.privateKeyCryptoCurrenciesAllowed = {
    "regular": {"BTC": true, "ETH": true, "DAO": false, "DASH": true, "ETC": true, "REP": false, "LTC": true, "LSK": false, "ZEC": true, "SBTC": true, "DOGE":true, "ICN": false, "GNT": false, "GNO": false, "SNGLS": false, "DGD": false, "BCAP": false, "CVC": true},
    "ios": {"BTC": true, "ETH": true, "DAO": false, "DASH": true, "ETC": true, "REP": false, "LTC": true, "LSK": false, "ZEC": true, "SBTC": true, "DOGE":true, "ICN": false, "GNT": false, "GNO": false, "SNGLS": false, "DGD": false, "BCAP": false, "CVC": true}
}

HDWalletHelper.paperWalletsCryptoCurrenciesAllowed = {
    "regular": {"BTC": true, "ETH": true, "DAO": false, "DASH": true, "ETC": true, "REP": false, "LTC": true, "LSK": false, "ZEC": true, "SBTC": false, "DOGE": false, "ICN": false, "GNT": false, "GNO": false, "SNGLS": false, "DGD": false, "BCAP": false, "CVC": true},
    "ios": {"BTC": true, "ETH": true, "DAO": false, "DASH": false, "ETC": true, "REP": false, "LTC": true, "LSK": false, "ZEC": false, "SBTC": false, "DOGE": false, "ICN": false, "GNT": false, "GNO": false, "SNGLS": false, "DGD": false, "BCAP": false, "CVC": true}
}
/*
HDWalletHelper.dictCryptoCurrency = { // @NOTE: This must match with the coinAbbreviatedName for the pouch implementation // @TODO: Refactor this later so 'index' isn't necessary
    "BTC" : {"prefix" : "\u0E3F", "name" : "Bitcoin", "bannerName": "BTC", "index" : 0}
    ,"ETH" : {"prefix" : "\u039E", "name" : "Ethereum", "bannerName": "ETH", "index" : 1}
    ,"DAO" : {"prefix" : "\u0110", "name" : "The DAO", "bannerName": "DAO", "index" : 2}
    ,"DASH" : {"prefix" : "\u2145", "name" : "Dash", "bannerName": "DSH", "index" : 3}
    ,"ETC" : {"prefix" : "\u039E", "name" : "Ethereum Classic", "bannerName": "ETC", "index" : 4}
    ,"REP" : {"prefix" : "\u024C", "name" : "Augur", "bannerName": "REP", "index" : 5}
    ,"LTC" : {"prefix" : "\u0141", "name" : "Litecoin", "bannerName": "LTC", "index" : 6}
    ,"LSK" : {"prefix" : "\u2C60", "name" : "Lisk", "bannerName": "LSK", "index" : 7}
    ,"ZEC" : {"prefix" : "\u24E9", "name" : "ZCash", "bannerName": "ZEC", "index" : 8}
    ,"SBTC" : {"prefix" : "\uc98c", "name" : "RSK Testnet", "bannerName": "RSK", "index" : 9}
    ,"DOGE" : {"prefix" : "\uc98c", "name" : "Doge", "bannerName": "DGE", "index" : 10}
    ,"ICN" : {"prefix" : "\u024C", "name" : "Iconomi", "bannerName": "ICN", "index" : 11}
    ,"GNT" : {"prefix" : "\u024C", "name" : "Golem", "bannerName": "GNT", "index" : 12}
    ,"GNO" : {"prefix" : "\u024C", "name" : "Gnosis", "bannerName": "GNO", "index" : 13}
    ,"SNGLS" : {"prefix" : "\u024C", "name" : "Singulardtv", "bannerName": "SNG", "index" : 14}
    ,"DGD" : {"prefix" : "\u024C", "name" : "DigixDAO", "bannerName": "DGD", "index" : 15}
    ,"BCAP" : {"prefix" : "\u024C", "name" : "BlockchainCapital", "bannerName": "BCP", "index" : 16}
    ,"CVC" : {"prefix" : "\u024C", "name" : "Civic", "bannerName": "CVC", "index" : 17}
};*/

/*HDWalletHelper.dictFiatCurrency = {
    "AUD" : {"prefix" : "AU$", "name" : "Australian Dollar"}
    ,"BRL" : {"prefix" : "R$", "name" : "Brazilian Real"}
    ,"CAD" : {"prefix" : "CA$", "name" : "Canadian Dollar"}
    ,"CHF" : {"prefix" : "\u20A3", "name" : "Swiss Franc"}
    ,"CLP" : {"prefix" : "CL$", "name" : "Chilean Peso"}
    ,"CNY" : {"prefix" : "\u00A5", "name" : "Chinese Yuan"}
    ,"CZK" : {"prefix" : "\u004b", "name" : "Czech Republic Koruna"}
    ,"DKK" : {"prefix" : "kr", "name" : "Danish Krona"}
    ,"EUR" : {"prefix" : "\u20AC", "name" : "Euro"}
    //@note: @todo: @here: something was an issue here.. dan figures the prefix.
    /!*,"FRA" : {"prefix" : "\u20A3", "name" : "French Franc"}*!/
    ,"GBP" : {"prefix" : "\u00A3", "name" : "British Pound"}
    ,"HKD" : {"prefix" : "HK$", "name" : "Hong Kong Dollar"}
    ,"HUF" : {"prefix" : "\u0046", "name" : "Hungarian Forint"}
    ,"IDR" : {"prefix" : "\u0052", "name" : "Indonesian Rupiah"}
    ,"ILS" : {"prefix" : "\u20AA", "name" : "Israeli New Shekel"}
    ,"INR" : {"prefix" : "\u20B9", "name" : "Indian Rupee"}
    ,"ISK" : {"prefix" : "kr", "name" : "Icelandik Kroner"}
    ,"JPY" : {"prefix" : "\u00A5", "name" : "Japanese Yen"}
    ,"KRW" : {"prefix" : "\u20A9", "name" : "South Korean Won"}
    ,"MXN" : {"prefix" : "MX$", "name" : "Mexican Peso"}
    ,"MYR" : {"prefix" : 'RM', "name" : "Malaysian Myr"}
    ,"NOK" : {"prefix" : "kr", "name" : "Norwegian Kroner"}
    ,"NZD" : {"prefix" : "NZ$", "name" : "New Zealand Dollar"}
    ,"PHP" : {"prefix" : "\u20B1", "name" : "Phillipine Peso"}
    ,"PKR" : {"prefix" : "\u20A8", "name" : "Pakistani Rupee"}
    ,"PLN" : {"prefix" : "z\u0142", "name" : "Polish Zlotty"}
    ,"RUB" : {"prefix" : "\u20BD", "name" : "Russian Ruble"}
    ,"SEK" : {"prefix" : "kr", "name" : "Swedish Krona"}
    ,"SGD" : {"prefix": "SG$", "name" : "Singapore Dollar"}
    ,"THB" : {"prefix" : "\u0e3f", "name" : "Thailand Baht"}
    ,"TRY" : {"prefix" : "t", "name" : "Turkey Lira"}
    ,"TWD" : {"prefix" : "NT$", "name" : "New Taiwan Dollar"}
    ,"USD" : {"prefix" : "US$", "name" : "United States Dollar"}
    ,"ZAR" : {"prefix" : "\u0052", "name" : "South African Rand"}
};*/

/*
HDWalletHelper.getFiatPrefixDictionary = function(){
    prefixDictionary = {}
    for (var key in HDWalletHelper.dictFiatCurrency) {
        if (HDWalletHelper.dictFiatCurrency.hasOwnProperty(key)) { // hasOwnProperty is needed because it's possible to insert keys into the prototype object of dictionary
            prefixDictionary[key] = HDWalletHelper.dictFiatCurrency[key]['prefix'];
        }
    }
    return prefixDictionary;
}

HDWalletHelper.getFiatNameDictionary = function(){
    prefixDictionary = {}
    for (var key in HDWalletHelper.dictFiatCurrency) {
        if (HDWalletHelper.dictFiatCurrency.hasOwnProperty(key)) { // hasOwnProperty is needed because it's possible to insert keys into the prototype object of dictionary
            prefixDictionary[key] = HDWalletHelper.dictFiatCurrency[key]['name'];
        }
    }
    return prefixDictionary;
}
*/
/*
HDWalletHelper.checkMnemonic = function() {
    //@note: @here: @todo: check for 12 word mnemonics.
    if (thirdparty.bip39.validateMnemonic(mnemonic)) {
        return true;
    } else {
        return false;
    }
}*/

HDWalletHelper.getNetworkTypeStringForCoinType = function(coinType, testNet) {
    //@note: @security: this should be using coin names etc. but for backwards compatibility it cannot.
    if (testNet) {
        return "-test";// + coinFullName[coinType];
    } else {
        return "-main";// + coinFullName[coinType];
    }
}

//HDWalletHelper.prototype.getHDCoinType = function(coinType, testNet) {
////    console.log("this._coinHDType :: " + this._coinHDType);
//    if (testNet) {
//        return this._coinHDType[coinType] + this._coinHDTypeTestnetOffset[coinType];
//    } else {
//        return this._coinHDType[coinType];
//    }
//}

/*
HDWalletHelper.getCurrencyUnitPrefix = function(currencyUnit) {
    var cryptoRef = HDWalletHelper.dictCryptoCurrency[currencyUnit]['prefix'];

    if (typeof(cryptoRef) === 'undefined' || crypto === null) {
        //var fiatRef = HDWalletHelper._dictFiatCurrency[currencyUnit];

        if (typeof(cryptoRef) === 'undefined' || crypto === null) {
        } else {
            return HDWalletHelper.getFiatUnitPrefix(currencyUnit);
        }
    } else {
        return HDWalletHelper.getCryptoUnitPrefix(currencyUnit);
    }

    return "XX$"; // Returns this when the currency symbol is not in the dictionary.
}

HDWalletHelper.getCryptoUnitPrefix = function (cryptoUnit) {
    if (cryptoUnit in HDWalletHelper.dictCryptoCurrency){
        return HDWalletHelper.dictCryptoCurrency[cryptoUnit]['prefix'];
    }
}

HDWalletHelper.getFiatUnitPrefix = function (fiatUnit) {
    if (fiatUnit in HDWalletHelper.getFiatPrefixDictionary()){
        return HDWalletHelper.getFiatPrefixDictionary()[fiatUnit];
    }
    return "XX$"; // Returns this when the currency symbol is not in the dictionary.
}

HDWalletHelper.getFiatUnitName = function (fiatUnit) {
    if (fiatUnit in HDWalletHelper.getFiatNameDictionary()){
        return HDWalletHelper.getFiatNameDictionary()[fiatUnit];
    }
    return "Unknown Currency"; // Returns this when the currency symbol is not in the dictionary.
}

HDWalletHelper.getDefaultRegulatedTXFee = function(coinType) {
    //@note: @here: @token: this seems necessary.

    if (coinType === COIN_BITCOIN) {
        return 20000;
    } else if (coinType === COIN_ETHEREUM){
        return HDWalletHelper.getDefaultEthereumGasPrice();
    } else if (coinType === COIN_ETHEREUM_CLASSIC) {
        return HDWalletHelper.getDefaultEthereumGasPrice();
    } else if (coinType === COIN_DASH) {
        return 20000;
    } else if (coinType === COIN_LITECOIN) {
        return 100000;
    } else if (coinType === COIN_LISK) {
        //@note: @here: @bug: @lisk: this is definitely wrong.
        return 100000;
    } else if (coinType === COIN_ZCASH) {
        return 10000;
    } else if (coinType === COIN_TESTNET_ROOTSTOCK) {
        return HDWalletHelper.getDefaultEthereumGasPrice();
    } else if (coinType === COIN_DOGE) {
        return 20000;
    }

    console.log("error :: HDWalletHelper.getDefaultRegulatedTXFee :: no value defined for coin type :: " + coinType);
    return 20000;
}
*/

//@note: these functions return BigNumber instances.

HDWalletHelper.getDefaultEthereumGasPrice = function() {
    return thirdparty.web3.toWei(thirdparty.web3.toBigNumber('21'), 'shannon');
};

HDWalletHelper.getDefaultEthereumGasLimit = function() {
    return thirdparty.web3.toBigNumber(21000);
}

HDWalletHelper.prototype.getRecommendedEthereumCustomGasLimit = function() {
    return this._recommendedEthereumCustomGasLimit;
}

HDWalletHelper.prototype.setRecommendedEthereumCustomGasLimit = function(recommendedEthereumCustomGasLimit) {
    this._recommendedEthereumCustomGasLimit = thirdparty.web3.toBigNumber(recommendedEthereumCustomGasLimit);
}

HDWalletHelper.prototype.getCustomEthereumGasLimit = function() {
    return this._currentEthereumCustomGasLimit;
}

HDWalletHelper.prototype.setCustomEthereumGasLimit = function(customEthereumGasLimit) {
//    console.log("ethereum :: update custom gas limit :: " + customEthereumGasLimit);
    this._currentEthereumCustomGasLimit = thirdparty.web3.toBigNumber(customEthereumGasLimit);
}

HDWalletHelper.prototype.compareToDustLimit = function(amount, unitType, compareToCustomGasLimit) {
    var compareAmount = amount;

    if (unitType === COIN_UNITLARGE) {
        compareAmount = HDWalletHelper.convertEtherToWei(amount);
    }

    var compareAmountA = thirdparty.web3.toBigNumber(compareAmount);

    var compareAmountB = HDWalletHelper.getDefaultEthereumGasLimit();

    compareAmountB = compareAmountB.mul((compareToCustomGasLimit) ? this.getCustomEthereumGasLimit() : HDWalletHelper.getDefaultEthereumGasLimit());

    if (compareAmountA.greaterThan(compareAmountB)) {
        return 1;
    } else if (compareAmountA.equals(compareAmountB)) {
        return 0;
    } else {
        return -1;
    }
}

HDWalletHelper.prototype.setup = function(updateExchangeRateTime) {
    this._updateExchangeRateTime = updateExchangeRateTime;
}


/*
HDWalletHelper.prototype._loadExchangeRates = function() {
    var exchangeRates = getStoredData("exchangeRates", false);
    exchangeRates = this.cleanStoredExchangeRates(exchangeRates);

    if (typeof(exchangeRates) !== 'undefined' && exchangeRates !== null) {
        this._exchangeRates = JSON.parse(exchangeRates);

        var numExistingExchangeData = this._exchangeRates.length;
        var createCount = COIN_NUMCOINTYPES - numExistingExchangeData;

        if (createCount > 0) {
            for (var i = 0; i < createCount; i++) {
                this._exchangeRates[numExistingExchangeData + i] = {};
            }
        }

        this._saveExchangeRates();

    }
*/
//}

HDWalletHelper.prototype.cleanStoredExchangeRates = function(exchangeRates){
    // This is written to clean old versions of the data. ie. This function exists because of a mistake.
    if (typeof(exchangeRates) !== 'undefined' && exchangeRates !== null){
        jsonExchangeRates = JSON.parse(exchangeRates);
        returnValue = [];

        for (var i = 0; i < jsonExchangeRates.length; i++){
            returnValue.push({});
            for (var key in jsonExchangeRates[i]){
                if (jsonExchangeRates[i].hasOwnProperty(key)) {
                    if (Array.isArray(jsonExchangeRates[i][key])){
                        returnValue[i][key] = jsonExchangeRates[i][key][0];
                    } else {
                        returnValue[i][key] = jsonExchangeRates[i][key];
                    }
                }
            }
        }
        return JSON.stringify(returnValue);
    } else {
        return exchangeRates;
    }

}

HDWalletHelper.prototype._saveExchangeRates = function() {
    storeData("exchangeRates", JSON.stringify(this._exchangeRates), false);
}

HDWalletHelper.prototype._notifyExchangeRateListeners = function(coinType) {
    console.error('Exchange Rate Log :: _notifyExchangeRateListeners called with coinType' + coinType);
    //@note: @todo: @optimization: this has abysmal performance, and only needs to be done if the screen is actually showing.
    for (var i = 0; i < this._exchangeRateListenerCallbacks[coinType].length; i++) {
        this._exchangeRateListenerCallbacks[coinType][i](coinType);
    }
    if (coinType === curCoinType) {
        var arrFiatUnitsUnfiltered = Object.keys(this._exchangeRatesHasChanged[coinType]);
        var arrAllowedFiatCurrencies = Object.keys(HDWalletHelper.dictFiatCurrency);
        var arrFiatUnits = [];
        for (var i = 0; i < arrFiatUnitsUnfiltered.length; i++) {
            if (arrAllowedFiatCurrencies.indexOf(arrFiatUnitsUnfiltered[i]) > -1){
                arrFiatUnits.push(arrFiatUnitsUnfiltered[i]);
            }
        }
        for (var i = 0; i < arrFiatUnits.length; i++) {
            var fiatUnit = arrFiatUnits[i];
            if (this._exchangeRatesHasChanged[coinType][fiatUnit]){
                var symbol = Registry.getCryptoControllerByCoinType(coinType).symbol;
                g_JaxxApp.getUI().populateExchangeRateInMainMenuCurrencyItem(symbol, fiatUnit);
                this._exchangeRatesHasChanged[coinType][fiatUnit] = false;
            }
        }
    }
}

HDWalletHelper.prototype.addExchangeRateListener = function(coinType, callback) {
    this._exchangeRateListenerCallbacks[coinType].push(callback);
}

HDWalletHelper.prototype.removeExchangeRateListener = function(coinType, callback) {
    for (var i = this._exchangeRateListenerCallbacks[coinType].length - 1; i >= 0; i--) {
        if (this._exchangeRateListenerCallbacks[coinType][i] === callback) {
            this._exchangeRateListenerCallbacks[coinType].splice(i, 1);
        }
    }
}


HDWalletHelper.prototype.getFiatUnit = function() {
    var fiatUnit = getStoredData('fiat');
    // if (HDWalletHelper.getFiatUnitPrefix(fiatUnit) === 'XX$') {
    //     fiatUnit = 'USD';
    // }
    return fiatUnit;
}

HDWalletHelper.prototype.setFiatUnit = function(fiatUnit) {
    storeData('fiat', fiatUnit);
}

HDWalletHelper.prototype.getFiatUnitPrefix = function() {
    return HDWalletHelper.getFiatUnitPrefix(this.getFiatUnit());
}

HDWalletHelper.prototype.hasFiatExchangeRates = function(coinType, fiatUnit) {
//        console.log("< checking for fiat exchange rates >");
    if (this._exchangeRates[coinType][fiatUnit]) {
//            console.log("< has fiat exchange rates >");
        return true;
    }
    //    console.log("< no fiat exchange rates >");

    return false;
}



/*HDWalletHelper.convertBitcoinsToSatoshis = function (bitcoins) {
    if (typeof(bitcoins) === 'string') {
        bitcoins = bitcoins.replace(/,/g, '');
    }

    var value = (new thirdparty.Decimal("100000000")).times(new thirdparty.Decimal(bitcoins));
    if (!value.isInteger()) {
        throw new Error("Wrong decimal number");
    }

    // @TODO: Make sure this fits in 53 bits

    return value.toNumber()
}*/

/**
 *  Convert satoshis to a string representing bitcoins.
 */
/*
HDWalletHelper.convertSatoshisToBitcoins = function(satoshis) {

    // Handle negative numbers
    var negative = '';
    if (satoshis < 0) {
        satoshis *= -1;
        negative = '-';
    }

    // prefix cents with place holder zeros
    var cents = '00000000' + (satoshis % 100000000)
    cents = cents.substring(cents.length - 8);

    // strip off excess zeros (keeping at least one)
    while (cents.charAt(cents.length - 1) === '0' && cents.length > 1) {
        cents = cents.substring(0, cents.length - 1);
    }

    // Round toward zero
    var whole = parseInt((satoshis / 100000000).toFixed(8));

    return negative + whole + '.' + cents;
}
*/

/**
 *  Wei->Ether
 */
var count = 0;
/*HDWalletHelper.convertWeiToEther = function(wei) {
    
    //if(wei && wei !== 0 && self.convertWeiToEtherCache.Wei == wei) {
    //    return self.convertWeiToEtherCache.Balance;
    //}

    //if(wei && self.convertWeiToEtherCache.Wei > 0) {
    if(wei > 0) {
        self.convertWeiToEtherCache.Wei = wei.toString();
        var balance = new thirdparty.bnjs(self.convertWeiToEtherCache.Wei);
        balance = balance.div(self.unitsOfEther); 
        //var balance = wei / 1000000000000000000;

        balance = self.isBigNumber(wei) ? balance : balance.toString(10);
        self.convertWeiToEtherCache.Balance = balance;
        return self.convertWeiToEtherCache.Balance;
        //return balance;
    } else { return 0; }
}

HDWalletHelper.prototype.isBigNumber = function (object) {
    return (object && object.constructor && object.constructor.name === 'BigNumber');
};*/
/**
 *  Ether->Wei
 */


/*
HDWalletHelper.convertEtherToWei = function(ether) {
    if(self.converEtherToWeiCache.ether === ether) {
        return self.converEtherToWeiCache.Balance;
    }
    self.converEtherToWeiCache.ether = ether;
    var balance =  new thirdparty.bnjs(self.converEtherToWeiCache.ether); 
    balance = balance.mul(self.unitsOfEther); //thirdparty.web3.toWei(ether, 'ether');

    balance = balance.toString(10);
    if (balance.indexOf('.') == -1) {
        balance += '.0';
    }
    self.converEtherToWeiCache.Balance = balance;
    return self.converEtherToWeiCache.Balance;
}
*/


HDWalletHelper.prototype.getBaseFiatDict = function(fiatUnit) {
    var baseFiatDict = {};

    if (typeof(fiatUnit) === 'undefined' || fiatUnit === null) {
        baseFiatDict.fiatUnit = this.getFiatUnit();
    } else {
        baseFiatDict.fiatUnit = fiatUnit;
    }

    baseFiatDict.prefix = HDWalletHelper.getFiatUnitPrefix(baseFiatDict.fiatUnit);

    return baseFiatDict;
}

HDWalletHelper.prototype.convertFiatValueToInternational = function(value, baseFiatDict) {
    var convertedValue = value;

    if (baseFiatDict.noPrefix) {
        //        value = value.toFixed(2);
        //        console.log("returning :: " + value)
        return convertedValue;
    }

    if (window.Intl) {
        var formatter = new Intl.NumberFormat('en-US', { style: 'currency', currency: baseFiatDict.fiatUnit});
        // Cut front end until first digit and then append prefix.

        convertedValue = formatter.format(convertedValue);
        convertedValue = convertedValue.substring(convertedValue.indexOf(convertedValue.match(/\d/)), value.length); // This will cut the prefix off of 'value'.

        convertedValue = this.cleanCurrencyDisplayString(convertedValue, baseFiatDict.fiatUnit);

        // Do proper crop
        convertedValue = baseFiatDict.prefix + convertedValue; // This appends the prefix to the currency value.
        return convertedValue;
    }

    // Assertion: The user is running the program with an Apple device.
    if (['ISK', 'JPY', 'KRW'].indexOf(baseFiatDict.fiatUnit) >= 0) {
        convertedValue = convertedValue.toFixed(0); // No sub-currency so show currency as whole number.
    } else {
        convertedValue = convertedValue.toFixed(2); // No sub-currency so show currency as whole number.
    }

    var commified = convertedValue.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");

    //    console.log("commified :: " + commified + " :: noPrefix :: " + noPrefix);
    return (baseFiatDict.noPrefix ? '': baseFiatDict.prefix) + commified;
}

/**
 *  Fiat conversion
 *
 *  Fiat will always be assumed to be a string, so math operations should not
 *  be attempted on them.
 */

HDWalletHelper.prototype.cleanCurrencyDisplayString = function(value, fiatUnit){
    var decimalPlacesInCurrency = 2;
    value.indexOf('.') > -1 ? value = value : value = value + '.';
    var decimalIndex = value.indexOf('.');

    if (['ISK', 'JPY', 'KRW'].indexOf(fiatUnit) >= 0) {
        decimalPlacesInCurrency = -1;
        //value = parseFloat(value).toFixed(0); // No sub-currency so show currency as whole number.
    } else {
        //value = parseFloat(value).toFixed(2); // No sub-currency so show currency as whole number.
    }

    if (value.length - 1 > decimalIndex + decimalPlacesInCurrency) {
        // When last position is beyond decimal places allowed in currency then remove digits.
        value = value.slice(0, decimalIndex + decimalPlacesInCurrency + 1);
    }
    while (value.length - 1 < decimalIndex + decimalPlacesInCurrency){
        // Pad with zeros.
        value = value + "0";
    }
    return value;
}

/*HDWalletHelper.prototype.convertFiatToSatoshis = function(fiatAmount, fiatUnit) {
    var rate = 0;

    if (typeof(fiatUnit) === 'undefined' || fiatUnit === null) {
        fiatUnit = this.getFiatUnit();
    }

    if (this._exchangeRates[COIN_BITCOIN][fiatUnit]) {
        rate = this._exchangeRates[COIN_BITCOIN][fiatUnit].last;
    }

    if (rate === 0) { return null; }

    // Amount is approximate anyways (since it is fiat exchange rate)
    return parseInt(100000000 * (fiatAmount / rate));
}*/

/*
HDWalletHelper.prototype.convertBitcoinLikeSmallUnitToFiat = function(coinType, satoshis, fiatUnit, noPrefix) {
    // wallet.getHelper().convertBitcoinLikeSmallUnitToFiat(COIN_BITCOIN, 100000000, 'USD', false) // 
    var baseFiatDict = this.getBaseFiatDict(fiatUnit);
    baseFiatDict.noPrefix = noPrefix;

    var rate = 0;
    if (this._exchangeRates[coinType][baseFiatDict.fiatUnit]) {
        rate = this._exchangeRates[coinType][baseFiatDict.fiatUnit].last;
    }

    //    console.log("rate :: " + this._exchangeRates[COIN_BITCOIN][fiatUnit].last);

    var value = parseFloat(HDWalletHelper.convertSatoshisToBitcoins(satoshis)) * rate;

    var returnValue = this.convertFiatValueToInternational(value, baseFiatDict);

    //    console.log("fiatUnit :: " + fiatUnit + " :: prefix :: " + prefix + " :: satoshis :: " + satoshis + " :: value :: " + value);

    return returnValue;
}
*/

/*HDWalletHelper.prototype.convertFiatToBitcoinLikeSmallUnit = function(coinType, fiatAmount, fiatUnit) {
    //@note: @todo: @next: @merge:
//    return HDWalletHelper.convertCoinToUnitType(coinType, wallet.getHelper().convertFiatToBitcoinLikeSmallUnit(coinType, fiatAmount, fiatUnit), COIN_UNITLARGE);

    var rate = 0;

    if (typeof(fiatUnit) === 'undefined' || fiatUnit === null) {
        fiatUnit = this.getFiatUnit();
    }

    if (this._exchangeRates[coinType][fiatUnit]) {
        rate = this._exchangeRates[coinType][fiatUnit].last;
    }

    if (rate === 0) { return null; }

    // Amount is approximate anyways (since it is fiat exchange rate)
    return parseInt(100000000 * (fiatAmount / rate));
}*/
/*
HDWalletHelper.prototype.convertEthereumLikeSmallUnitToFiat = function(coinType, wei, fiatUnit, noPrefix) {
    var baseFiatDict = this.getBaseFiatDict(fiatUnit);
    baseFiatDict.noPrefix = noPrefix;

    var rate = 0;
    if (this._exchangeRates[coinType][baseFiatDict.fiatUnit]) {
        rate = this._exchangeRates[coinType][baseFiatDict.fiatUnit].last;
    }

    var value = parseFloat(HDWalletHelper.convertWeiToEther(wei)) * rate;
//    console.log("HDWalletHelper :: convertEthereumLikeSmallUnitToFiat :: fiatUnit :: " + fiatUnit + " :: noPrefix :: " + noPrefix + " :: wei :: " + wei + " :: value :: " + value);

    var returnValue = this.convertFiatValueToInternational(value, baseFiatDict);

     


    return returnValue;
}*/

//HDWalletHelper.prototype.convertDAOToFiat = function(dao, fiatUnit, noPrefix) {
//    if (typeof(fiatUnit) === 'undefined' || fiatUnit === null) {
//        fiatUnit = this.getFiatUnit();
//    }
//
//    var prefix = HDWalletHelper.getFiatUnitPrefix(fiatUnit);
//
//    var rate = 0;
//    if (this._exchangeRates[COIN_THEDAO_ETHEREUM][fiatUnit]) {
//        rate = this._exchangeRates[COIN_THEDAO_ETHEREUM][fiatUnit].last;
//    }
//
//    var value = parseFloat(dao) * rate; // parseFloat(HDWalletHelper.convertWeiToEther(wei)) * rate;
//
//    if (noPrefix) {
//        return value;
//    }
//
//    if (window.Intl) {
//        var formatter = new Intl.NumberFormat('en-US', { style: 'currency', currency: fiatUnit});
//        // Cut front end until first digit and then append prefix.
//        value = formatter.format(value);
//        value = value.substring(value.indexOf(value.match(/\d/)), value.length); // This will cut the prefix off of 'value'.
//        value = this.cleanCurrencyDisplayString(value, fiatUnit);
//
//        value = prefix + value; // This appends the prefix to the currency value.
//        return value;
//    }
//
//    // Assertion: The user is running the program with an Apple device.
//    if (['ISK', 'JPY', 'KRW'].indexOf(fiatUnit) >= 0) {
//        value = value.toFixed(0); // No sub-currency so show currency as whole number.
//    } else {
//        value = value.toFixed(2); // Show currency to 2 decimal places.
//    }
//
//    var commified = value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
//
//    return (noPrefix ? '': prefix) + commified;
//}

/*
HDWalletHelper.prototype.convertFiatToWei = function(fiatAmount, fiatUnit) {
    var rate = 0;

    if (typeof(fiatUnit) === 'undefined' || fiatUnit === null) {
        fiatUnit = this.getFiatUnit();
    }

    if (this._exchangeRates[COIN_ETHEREUM][fiatUnit]) {
        rate = this._exchangeRates[COIN_ETHEREUM][fiatUnit].last;
    }

    if (rate === 0) { return null; }

    // Amount is approximate anyways (since it is fiat exchange rate)

    var wei = HDWalletHelper.convertEtherToWei(fiatAmount / rate);

    return wei;
}

HDWalletHelper.prototype.convertFiatToWeiClassic = function(fiatAmount, fiatUnit){
    var rate = 0;

    if (typeof(fiatUnit) === 'undefined' || fiatUnit === null) {
        fiatUnit = this.getFiatUnit();
    }

    if (this._exchangeRates[COIN_ETHEREUM_CLASSIC][fiatUnit]) {
        rate = this._exchangeRates[COIN_ETHEREUM_CLASSIC][fiatUnit].last;
    }

    if (rate === 0) { return null; }

    // Amount is approximate anyways (since it is fiat exchange rate)

    var wei = HDWalletHelper.convertEtherToWei(fiatAmount / rate);

    return wei;
}
*/

// Given an address or URI; identify coin type, address and optional amount.
/*HDWalletHelper.parseURI = function(uri) {
    if (!uri) { return null; }

    var result = {};

    var uriRemaining = uri;

    var comps = uriRemaining.split(':');
//    console.log("[a] parseURI :: comps :: " + comps + " :: uriRemaining :: " + uriRemaining);
    switch (comps.length) {
        // scheme:[//]address[?query]
        default:
            result.coin = comps[0];
            uriRemaining = comps[1];
            if (uriRemaining.substring(0, 2) === '//') {
                urlRemaining = urlRemaining.substring(2);
            }
            break;

        // address[?query]
        case 1:
            if (uriRemaining.match(/^((0x)?[0-9a-fA-F]{40}|XE)/)) {
                result.coin = 'ether';
            } else if (uriRemaining.match(/^[X][0-9a-zA-Z]{33}/)) {
                result.coin = 'dash';
            } else if (uriRemaining.match(/^[L][0-9a-zA-Z]{33}/)) {
                result.coin = 'litecoin';
            } else if (uriRemaining.match(/^[D][0-9a-zA-Z]{33}/)) {
                result.coin = 'doge';
            } else if (uriRemaining.match(/^[t1][0-9a-zA-Z]{34}/)) {
                result.coin = 'zcash';
            } else if (uriRemaining.match(/^[13]/)) {
                result.coin = 'bitcoin';
            }
            uriRemaining = comps[0];
            break;

        case 0:
            return null;
    }

    // address[?query]
    comps = uriRemaining.split('?');
    result.address = comps[0];

    switch (comps.length) {
        case 2:
            uriRemaining = comps[1];
            break;
        case 1:
            uriRemaining = '';
            break;
        case 0:
            return null;
        default:
            comps = comps.slice(0, 2);
    }

    console.log("[b] parseURI :: comps :: " + comps + " :: uriRemaining :: " + uriRemaining + " :: result :: " + JSON.stringify(result));


    //@note: @bug: this isn't coded correctly to detect duplicates of any type, and 'amount' could be the 2nd and 3rd parameters for example.

    // Parse out the amount (add other tags in the future); duplicate values is a FATAL error
    comps = uriRemaining.split('&');
    for (var i = 0; i < comps.length; i++) {
        var kv = comps[i].split('=');
        if (kv.length === 2 && kv[0] === 'amount') {
            if (result.amount) {
                console.log("error :: > 1 amount field detected"); //@note: adding this for debugging.
                return null;
            } else {
                result.amount = kv[1];
            }
        }
    }

    // IBAN is the format for ethereum
    if (result.coin === 'iban' || result.coin === 'ethereum') { result.coin = 'ether'; }
//    console.log(JSON.stringify(result));
    switch (result.coin) {
        case 'bitcoin':
            try {
                if (!thirdparty.bitcoin.address.fromBase58Check(result.address)) {
                    return null;
                }
            } catch (error) {
                return null;
            }
            break;
        case 'ether':
            if (result.address.match(/^0x[0-9a-fA-F]{40}$/)) {
                // Address is already prefxed hex

            } else if (result.address.match(/^[0-9a-fA-F]{40}$/)) {
                // Prefix the hex
                result.address = '0x' + result.address;

            } else if (result.address.substring(0, 2) === 'XE') {
                // ICAP address

                // Check the checksum
                var validICAP = false;
                thirdparty.iban.countries.XE = thirdparty.iban.countries.XE31;
                if (thirdparty.iban.isValid(result.address)) {
                    validICAP = true;
                } else {
                    thirdparty.iban.countries.XE = thirdparty.iban.countries.XE30;
                    if (thirdparty.iban.isValid(result.address)) {
                        validICAP = true;
                    }
                }

                if (!validICAP) { return null; }

                // Indirect encoded... Not supported yet (no namereg)
                if (result.address.substring(0, 7) === 'ETHXREG') {
                    return null;

                    // Direct or Basic encoded (should be true because it is valid iban)
                } else if (result.address.match(/^[A-Za-z0-9]+$/)) {

                    // Decode the base36 encoded address (removing the XE and checksum)
                    var hexAddress = (new thirdparty.bigi(result.address.substring(4), 36)).toString(16);

                    // Something terrible happened...
                    if (hexAddress.length > 40) { return null; }

                    // zero-pad
                    while (hexAddress.length < 40) { hexAddress = '0' + hexAddress; }

                    // Prefix the address
                    result.address = '0x' + hexAddress;

                } else {
                    return null;
                }

            } else {
                return null;
            }
            break;
        case 'dash':
            try {
                if (!thirdparty.bitcoin.address.fromBase58Check(result.address)) {
                    return null;
                }
            } catch (error) {
                return null;
            }
            break;
        case 'litecoin':
            try {
                if (!thirdparty.bitcoin.address.fromBase58Check(result.address)) {
                    return null;
                }
            } catch (error) {
                return null;
            }
            break;
        case 'zcash':
            try {
                if (!thirdparty.bitcoin.address.fromBase58Check(result.address)) {
                    return null;
                }
            } catch (error) {
                return null;
            }
            break;
        case 'dogecoin':
            try {
                if (!thirdparty.bitcoin.address.fromBase58Check(result.address)) {
                    return null;
                }
            } catch (error) {
                return null;
            }
            break;
        default:
            return null;
    }

    return result;
}

/*

 // Run some simple tsts to make sure parsing the URI works.
 var tests = [
 '1RicMooMWxqKczuRCa5D2dnJaUEn9ZJyn',
 'bitcoin:1RicMooMWxqKczuRCa5D2dnJaUEn9ZJyn',
 'bitcoin:1RicMooMWxqKczuRCa5D2dnJaUEn9ZJyn?amount=4.5',
 '1RicMooMWxqKczuRCa5D2dnJaUEn9ZJyn?amount=3.2',
 'XE235A6EOUWJWGG1NBXXJW2SXEB36T8J4W0',
 'iban:XE235A6EOUWJWGG1NBXXJW2SXEB36T8J4W0',
 'iban:XE235A6EOUWJWGG1NBXXJW2SXEB36T8J4W0?amount=7.8',
 'XE235A6EOUWJWGG1NBXXJW2SXEB36T8J4W0?amount=6.5',
 'iban:0x2d3976b32c17bd893f3c183e5dee872074475b80',
 '0x2d3976b32c17bd893f3c183e5dee872074475b80',

 '1RicMooMWxqKczuRCa5D2dnJaUEn9ZJy',
 'XE235A6EOUWJWGG1NBXXJW2SXEB36T8J4W',
 '0x2d3976b32c17bd893f3c183e5dee872074475b8',
 '1RicMooMWxqKczuRCa5D2dnJaUEn9ZJyn1',
 'XE235A6EOUWJWGG1NBXXJW2SXEB36T8J4W01',
 '0x2d3976b32c17bd893f3c183e5dee872074475b801',
 ];

 setTimeout(function() {
 for (var i = 0; i < tests.length; i++) {
 try {
 console.log('BAR', tests[i], JSON.stringify(HDWalletHelper.parseURI(tests[i])));
 } catch(error) {
 console.log(error.message);
 }
 }
 }, 1000);
 */


HDWalletHelper.hexify = function (value) {
    if (typeof(value) === 'number' || typeof(value) === 'string') {
        value = thirdparty.web3.toBigNumber(value);
    }

    var hex = value.toString(16);
    if (hex.length % 2) {
        hex = '0' + hex;
    }

    return new thirdparty.Buffer.Buffer(hex, 'hex');
}

HDWalletHelper.zeroPadLeft = function(text, length) {
    while(text.length < length) {
        text = '0' + text;
    }
    return text;
}

//    //@note:@here:@todo: wondering if it's actually necessary to execute after load.
HDWalletHelper.reformatICAPAddresses = function() {
    // Convert ICAP addresses (IBAN/BBAN)
    // https://github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol
//    console.log("thirdparty.iban :: " + thirdparty.iban + " :: thirdparty.iban.countries.XE30 :: " + thirdparty.iban.countries.XE30.countryCode);
    // @TODO: File a PR to expose addSpecification; for now, hijack
    thirdparty.iban.countries.XE30 = thirdparty.iban.countries.UA;
//    console.log("thirdparty.iban :: " + thirdparty.iban + " :: thirdparty.iban.countries.UA :: " + thirdparty.iban.countries.UA);

    delete thirdparty.iban.countries.UA;
    thirdparty.iban.countries.XE30.countryCode = 'XE';
    thirdparty.iban.countries.XE30.length = 34;
    thirdparty.iban.countries.XE30.structure = 'B30';

    thirdparty.iban.countries.XE31 = thirdparty.iban.countries.BE;
    delete thirdparty.iban.countries.BE;
    thirdparty.iban.countries.XE31.countryCode = 'XE';
    thirdparty.iban.countries.XE31.length = 35;
    thirdparty.iban.countries.XE31.structure = 'B31';
}


HDWalletHelper.getICAPAddress = function(data, forceBasic) {
//    if (thirdparty.iban.countries.UA) {
//        HDWalletHelper.reformatICAPAddresses();
//    }

    thirdparty.iban.countries.XE = thirdparty.iban.countries.XE30;
    if (thirdparty.iban.isValid(data)) {
        return data;
    }

    thirdparty.iban.countries.XE = thirdparty.iban.countries.XE31;
    if (thirdparty.iban.isValid(data)) {
        return data;
    }

    //        console.log("data :: " + data);
    // Get the raw hex
    if (data.substring(0, 2) === '0x' && data.length === 42) {
        data = data.substring(2);
    }

    // Make sure it is a valid address
    if (!data.match(/^[0-9a-fA-F]{40}$/)) { return null; }

    // 0 prefixed can fit in 30 bytes (otherwise, we require 31)
    var length = 31;
    if (data.substring(0, 2) === '00' && !forceBasic) {
        data = data.substring(2);
        length = 30
        thirdparty.iban.countries.XE = thirdparty.iban.countries.XE30;
    } else {
        thirdparty.iban.countries.XE = thirdparty.iban.countries.XE31;
    }

    // Encode as base36 and add the checksum
    var encoded = (new thirdparty.bigi(data, 16)).toString(36).toUpperCase();
    encoded = HDWalletHelper.zeroPadLeft(encoded, length);

    return thirdparty.iban.fromBBAN('XE', encoded);
}

HDWalletHelper.parseEthereumAddress = function(data) {

    // Standard address, we're done
    if (data.match(/^0x[0-9a-fA-F]{40}$/)) {
        //            console.log("found matching address :: " + data);
        return data;
    } else if (data.match(/^(0x[0-9a-fA-F]{40})$/)) {
        //            console.log("found matching address :: " + data);
        return data;
    } else if (data.match(/^ether:(0x[0-9a-fA-F]{40})$/)) {
        //            console.log("found matching address :: " + data);
        return data.substring(6);
    } else if (data.match(/^augur:(0x[0-9a-fA-F]{40})$/)) {
        
        //@note: from shapeshift reports.
        
        //            console.log("found matching address :: " + data);
        return data.substring("ether:");
    }

    // ICAP...
    if (data.substring(0, 2) === 'XE') {

        // Check the checksum
        var validICAP = false;
        thirdparty.iban.countries.XE = thirdparty.iban.countries.XE31;
        if (thirdparty.iban.isValid(data)) {
            validICAP = true;
        } else {
            thirdparty.iban.countries.XE = thirdparty.iban.countries.XE30;
            if (thirdparty.iban.isValid(data)) {
                validICAP = true;
            }
        }

        if (validICAP) {
            var encoded = data.substring(4);

            // Direct or Basic encoded
            if (encoded.match(/^[A-Za-z0-9]+$/)) {

                // Decode the base36 encoded address
                var hexAddress = (new thirdparty.bigi(encoded, 36)).toString(16);

                // Something terrible happened...
                if (hexAddress.length > 40) { throw new Error("Badness; this shouldn't happen"); }

                // zero-pad
                hexAddress = HDWalletHelper.zeroPadLeft(hexAddress, 40);

                // prepend the prefix
                return '0x' + hexAddress;

                // Indirect encoded... Not supported yet (no namereg)
            } else if (encoded.substring(0, 7) === 'ETHXREG') {
                return null;
            }
        }
    }

    return null;
}

HDWalletHelper.getEthereumAddressFromKey = function(privateKey) {
    //Lets re-use the already imported library ethutil-tx to avoid adding burden
    //Create a fake tx
    var mockupTxRaw = {
        nonce: HDWalletHelper.hexify(1),
        gasPrice: HDWalletHelper.hexify(thirdparty.web3.toBigNumber(thirdparty.web3.toWei(21, 'shannon')).toDigits(1)),
        gasLimit: HDWalletHelper.hexify(HDWalletHelper.getDefaultEthereumGasLimit()),
        to: "0xbac369f138d479abd45340e7735f80617a008ee7",
        value: HDWalletHelper.hexify(1),
    };

    var mockupTxR = new thirdparty.ethereum.tx(mockupTxRaw);
    //Sign with the private key

    mockupTxR.sign(privateKey);

    var addr = mockupTxR.getSenderAddress().toString('hex');
    if(addr){
        return '0x'+addr;
    } else {
        return null;
    }
}

//@note: ethereum checksum addresses. using web3 experimental branch logic.
HDWalletHelper.toEthereumChecksumAddress = function (address) {
    if (typeof address === 'undefined') return '';

    address = address.toLowerCase().replace('0x','');
    var addressHash = web3.sha3(address);
    var checksumAddress = '0x';

    for (var i = 0; i < address.length; i++ ) {
        // If ith character is 9 to f then make it uppercase
        if (parseInt(addressHash[i], 16) > 7) {
            checksumAddress += address[i].toUpperCase();
        } else {
            checksumAddress += address[i];
        }
    }
    return checksumAddress;
}

HDWalletHelper.isEthereumChecksumAddress = function(address) {
    // Check each case
    address = address.replace('0x','');
    var addressHash = web3.sha3(address.toLowerCase());

    for (var i = 0; i < 40; i++ ) {
        // the nth letter should be uppercase if the nth digit of casemap is 1
        if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {
            return false;
        }
    }
    return true;
};

/*
HDWalletHelper.convertCoinToUnitType = function(coinType, coinAmount, coinUnitType) {
    var coinOtherUnitAmount = 0;

    //@note: @here: @token: this seems necessary.
    if (coinType === COIN_BITCOIN) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertSatoshisToBitcoins(coinAmount) : HDWalletHelper.convertBitcoinsToSatoshis(coinAmount);
    } else if (coinType === COIN_ETHEREUM) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertWeiToEther(coinAmount) : HDWalletHelper.convertEtherToWei(coinAmount);
    } else if (coinType === COIN_ETHEREUM_CLASSIC) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertWeiToEther(coinAmount) : HDWalletHelper.convertEtherToWei(coinAmount);
    } else if (coinType === COIN_THEDAO_ETHEREUM) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertWeiToEther(coinAmount) : HDWalletHelper.convertEtherToWei(coinAmount);
//        console.log("convert :: " + coinAmount + " :: " + coinOtherUnitAmount)
    } else if (coinType === COIN_DASH) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertSatoshisToBitcoins(coinAmount) : HDWalletHelper.convertBitcoinsToSatoshis(coinAmount);
    } else if (coinType === COIN_AUGUR_ETHEREUM || coinType === COIN_GOLEM_ETHEREUM || coinType === COIN_GNOSIS_ETHEREUM || coinType === COIN_ICONOMI_ETHEREUM || coinType === COIN_SINGULARDTV_ETHEREUM || coinType === COIN_BLOCKCHAINCAPITAL_ETHEREUM || COIN_CIVIC_ETHEREUM) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertWeiToEther(coinAmount) : HDWalletHelper.convertEtherToWei(coinAmount);
    } else if (coinType === COIN_DIGIX_ETHEREUM) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertWeiToEther(coinAmount) : HDWalletHelper.convertEtherToWei(coinAmount);
    } else if (coinType === COIN_LITECOIN) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertSatoshisToBitcoins(coinAmount) : HDWalletHelper.convertBitcoinsToSatoshis(coinAmount);
    } else if (coinType === COIN_LISK) {
        //@note: @here: @todo: @lisk:
//        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertSatoshisToBitcoins(coinAmount) : HDWalletHelper.convertBitcoinsToSatoshis(coinAmount);
    } else if (coinType === COIN_ZCASH) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertSatoshisToBitcoins(coinAmount) : HDWalletHelper.convertBitcoinsToSatoshis(coinAmount);
    } else if (coinType === COIN_TESTNET_ROOTSTOCK) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertWeiToEther(coinAmount) : HDWalletHelper.convertEtherToWei(coinAmount);
    } else if (coinType === COIN_DOGE) {
        coinOtherUnitAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertSatoshisToBitcoins(coinAmount) : HDWalletHelper.convertBitcoinsToSatoshis(coinAmount);
    }

    return coinOtherUnitAmount;
}

*/




HDWalletHelper.getCoinDisplayScalar = function(coinType, coinAmount, isFiat) {
    var scaledAmount = coinAmount;

    if (typeof(isFiat) === 'undefined' || isFiat === null || isFiat !== true) {
        if (coinType === COIN_THEDAO_ETHEREUM) {
            var scalar = thirdparty.web3.toBigNumber(100);
            scaledAmount = thirdparty.web3.toBigNumber(coinAmount).mul(scalar).toNumber();
        }
    }

    //    console.log("scaledAmount :: " + scaledAmount);

    return scaledAmount;
}

HDWalletHelper.toEthereumNakedAddress = function(address) {
    return address.toLowerCase().replace('0x', '');
}

HDWalletHelper.prototype.convertCoinToFiatWithFiatType = function(coinType, coinAmount, coinUnitType, fiatUnit, noPrefix) {

    if(!coinController){return}

    // wallet.getHelper().convertCoinToFiatWithFiatType(COIN_BITCOIN, 0.05, COIN_UNITSMALL, 'USD', true) // returns: 
    var fiatAmount = 0;
    var coinController = Registry.getCryptoControllerBySymbol(coinType);

    fiatAmount = jaxx.FiatPriceController.coinToFiat(coinAmount, coinController.symbol, fiatUnit);
    fiatAmount = Math.round(fiatAmount * 100) / 100;

    if (noPrefix == false)
    {
        var prefix_dict = HDWalletHelper.getFiatPrefixDictionary();
        var prefix = prefix_dict[fiatUnit];

        fiatAmount = prefix + String(fiatAmount);
    }
    
    return fiatAmount;

    /*if (coinType === COIN_BITCOIN) {
        var bitcoinAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertBitcoinsToSatoshis(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertBitcoinLikeSmallUnitToFiat(COIN_BITCOIN, bitcoinAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ?  HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_ETHEREUM_CLASSIC) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ?  HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_ETHEREUM_CLASSIC, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_THEDAO_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_DASH) {
        var dashAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertBitcoinsToSatoshis(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertBitcoinLikeSmallUnitToFiat(COIN_DASH, dashAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_AUGUR_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_AUGUR_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_ICONOMI_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_ICONOMI_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_GOLEM_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_GOLEM_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_GNOSIS_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_GNOSIS_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_SINGULARDTV_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_SINGULARDTV_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_DIGIX_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_DIGIX_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_BLOCKCHAINCAPITAL_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_BLOCKCHAINCAPITAL_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_CIVIC_ETHEREUM) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_CIVIC_ETHEREUM, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_LITECOIN) {
        var litecoinAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertBitcoinsToSatoshis(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertBitcoinLikeSmallUnitToFiat(COIN_LITECOIN, litecoinAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_LISK) {
        //@note: @here: @todo: @lisk:
//        var litecoinAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertBitcoinsToSatoshis(coinAmount) : coinAmount;
//
//        fiatAmount = wallet.getHelper().convertBitcoinLikeSmallUnitToFiat(COIN_LITECOIN, litecoinAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_ZCASH) {
        var zcashAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertBitcoinsToSatoshis(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertBitcoinLikeSmallUnitToFiat(COIN_ZCASH, zcashAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_TESTNET_ROOTSTOCK) {
        var weiAmount = (coinUnitType === COIN_UNITLARGE) ?  HDWalletHelper.convertEtherToWei(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertEthereumLikeSmallUnitToFiat(COIN_TESTNET_ROOTSTOCK, weiAmount, fiatUnit, noPrefix);
    } else if (coinType === COIN_DOGE) {
        var dogeAmount = (coinUnitType === COIN_UNITLARGE) ? HDWalletHelper.convertBitcoinsToSatoshis(coinAmount) : coinAmount;

        fiatAmount = wallet.getHelper().convertBitcoinLikeSmallUnitToFiat(COIN_DOGE, dogeAmount, fiatUnit, noPrefix);
    } 
    //    console.log("convertCoinToFiat :: coinAmount :: " + coinAmount + " :: fiatAmount :: " + fiatAmount + " :: " + noPrefix);
    */

    //return fiatAmount;
}

HDWalletHelper.getDictCryptoCurrenciesAllowed = function(){
    var cryptoCurrenciesAllowed = {};
    if (PlatformUtils.mobileiOSCheck()) {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.ios;
    } else {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.regular;
    }
    return cryptoCurrenciesAllowed;
}

HDWalletHelper.isCryptoCurrencyAllowed = function(coinType){
    // if (typeof(HDWalletPouch.getStaticCoinPouchImplementation(coinType)) !== 'undefined'){
    //     return this.getDictCryptoCurrenciesAllowed()[HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters.coinAbbreviatedName];
    // } else {
        return false;
    // }
}
// privateKeyCryptoCurrenciesAllowed
HDWalletHelper.getDictPrivateKeyCryptoCurrenciesAllowed = function(){
    var cryptoCurrenciesAllowed = {};
    if (PlatformUtils.mobileiOSCheck()) {
        cryptoCurrenciesAllowed = HDWalletHelper.privateKeyCryptoCurrenciesAllowed.ios;
    } else {
        cryptoCurrenciesAllowed = HDWalletHelper.privateKeyCryptoCurrenciesAllowed.regular;
    }
    return cryptoCurrenciesAllowed;
}

// HDWalletHelper.isPrivateKeyCryptoCurrencyAllowed = function(coinType) {
    // if (typeof(HDWalletPouch.getStaticCoinPouchImplementation(coinType)) !== 'undefined'){
    //     return this.getDictPrivateKeyCryptoCurrenciesAllowed()[HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters.coinAbbreviatedName];
    // } else {
    //     return false;
    // }
// }

HDWalletHelper.getDictPaperWalletsCryptoCurrenciesAllowed = function() {
    // 
    var cryptoCurrenciesAllowed = {};
    if (PlatformUtils.mobileiOSCheck()) {
        cryptoCurrenciesAllowed = HDWalletHelper.paperWalletsCryptoCurrenciesAllowed.ios;
    } else {
        cryptoCurrenciesAllowed = HDWalletHelper.paperWalletsCryptoCurrenciesAllowed.regular;
    }
    return cryptoCurrenciesAllowed;
}

HDWalletHelper.isPaperWalletCryptoCurrencyAllowed = function(coinType) {
   // if (typeof(HDWalletPouch.getStaticCoinPouchImplementation(coinType)) !== 'undefined'){
    //    return this.getDictPaperWalletsCryptoCurrenciesAllowed()[HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters.coinAbbreviatedName];
   // } else {
        return false;
   // }
}

HDWalletHelper.getArrayPaperWalletCryptoCurrencyAllowed = function(){
    var allowedCryptoCurrencies = [];
    var keys = Object.keys(HDWalletHelper.getDictPaperWalletsCryptoCurrenciesAllowed());
    for (var i = 0; i < keys.length; i++){
        if (HDWalletHelper.isPaperWalletCryptoCurrencyAllowed(HDWalletHelper.dictCryptoCurrency[keys[i]].index)) {
            allowedCryptoCurrencies.push(keys[i]);
        }
    }
    return allowedCryptoCurrencies;
}

HDWalletHelper.isShapeshiftCryptoCurrencyAllowed = function(coinType){
    var dictShapeshiftCryptoCurrenciesAllowed = HDWalletHelper.shapeShiftCryptoCurrenciesAllowed.regular;
    return dictShapeshiftCryptoCurrenciesAllowed[HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters.coinAbbreviatedName];
}
var JaxxAppSettings = function() {
    this._permanentSettings = {'_someExampleSetting' : null};
    //this._isPermanentSettingEncrypted = {'_someExampleSetting' : false}; // false by default
    this._permanentSettingValueLoadedIfNotStored = {};
    
    this._defaultCoinType = COIN_BITCOIN;

	this._currentShapeshiftTarget = {}; // Should be something like {'BTC' : 'ETH', 'ETH' : 'DSH'...}

	this._currencyAtPosition = []; // this._currencyAtPosition[0] is the top-most currency in the list.
	this.__cryptoCurrencyAtPosition = [];
	this._cryptoCurrencyIsEnabled = {};
	this._bannerFirstCryptoCurrency = ''; // Should be BTC or something.
    
    this._shouldLoadFromBackupIntroPosition = false;
    
    this._ignoreEtcEthSplit = false;
    
    this._pagesWhereBackButtonIsDisabled = ['backupMnemonicCustomIntroOption', 'viewMnemonicCustomIntroOption', 'pageSetupSecurityPinCode', 'changePinCodeCustomIntroOption', 'confirmPinCodeCustomIntroOption', 'pressContinuePairDevices'];
    this._pagesWhereBackButtonExitsApplication = ['pageTermsOfService', 'splash'];
    
    //
}

JaxxAppSettings.prototype.storeAllPermanentSettings = function() {
    var arraySettingsNames = Object.keys(this._permanentSettings);
    for (var i = 0; i < arraySettingsNames.length; i++){
        this.storePermanentSetting(arraySettingsNames[i]);
    }
}

JaxxAppSettings.prototype.loadAllPermanentSettings = function(){
    var arraySettingsNames = Object.keys(this._permanentSettings);
    for (var i = 0; i < arraySettingsNames.length; i++){
        this.loadPermanentSetting(arraySettingsNames[i]);
    }    
}

JaxxAppSettings.prototype.storePermanentSetting = function(strSettingName){
    // TODO: Add encryption functionality
    storeData(strSettingName, JSON.stringify(this._permanentSettings[strSettingName]), false);
    return JSON.stringify(this._permanentSettings[strSettingName]);
}

JaxxAppSettings.prototype.loadPermanentSetting = function(strSettingName){
    var storedValue = getStoredData(strSettingName, false);
    if (typeof(storedValue) !== 'undefined' && storedValue !== null){
        this._permanentSettings[strSettingName] = JSON.parse(storedValue);
    } else {
        if (typeof(this._permanentSettingValueLoadedIfNotStored[strSettingName]) !== 'undefined' && this._permanentSettingValueLoadedIfNotStored[strSettingName] !== null){
            this._permanentSettings[strSettingName] = this._permanentSettingValueLoadedIfNotStored[strSettingName];
        }
    }
}

// This function is used externally.
JaxxAppSettings.prototype.getSetting = function(strSettingName){
    var storedValue = this._permanentSettings[strSettingName];
    if (typeof(storedValue) === 'undefined' || storedValue === null) {
        this.loadPermanentSetting(strSettingName);
        var storedValue = this._permanentSettings[strSettingName];
    }
    return storedValue;
}

// This function is used externally.
JaxxAppSettings.prototype.setSetting = function(strSettingName, objNewValue){
    this._permanentSettings[strSettingName] = objNewValue;
    return this.storePermanentSetting(strSettingName); 
}

JaxxAppSettings.prototype.setting = function(strSettingName, objNewValue){
    // First parameter is the name of the setting.
    // Second parameter optional. Included if you want to change the setting to a new value.
    if (typeof(objNewValue) !== 'undefined' && objNewValue !== null){
        this.setSetting(strSettingName, objNewValue);
    }
    return this.getSetting(strSettingName);
}

JaxxAppSettings.prototype.isBackButtonDisabledOnPage = function(strPageName){
    return this._pagesWhereBackButtonIsDisabled.indexOf(strPageName) > -1;
}

JaxxAppSettings.prototype.isBackButtonExitApplication = function(strPageName){
    return this._pagesWhereBackButtonExitsApplication.indexOf(strPageName) > -1;
}

JaxxAppSettings.prototype.initialize = function() {
    this.initializeCryptoCurrencySettingsData();
   /* var storedDefaultCoinType = getStoredData('JaxxApp_Settings_DefaultCoinType',false);
    if(jaxx.Utils2.getSeed()) {
        this.initializeCryptoCurrencySettingsData();
        //    console.log("_defaultCoinType :: " + this._defaultCoinType);

        var storedIgnoreEtcEthSplit = getStoredData('JaxxApp_Settings_IgnoreEtcEthSplit',false);

        if (typeof(storedIgnoreEtcEthSplit) !== 'undefined' && storedIgnoreEtcEthSplit !== null && storedIgnoreEtcEthSplit === 'true') {
            this._ignoreEtcEthSplit = true;
        } else {
            this._ignoreEtcEthSplit = false;
        }

        this.setupDefaultMiningOptions();
    }
*/
}

JaxxAppSettings.prototype.getDefaultCoinType = function() {
    return this._defaultCoinType;
}

JaxxAppSettings.prototype.setDefaultCoinType = function(defaultCoinType) {
    console.error('JaxxAppSettings.prototype.setDefaultCoinType');
    this._defaultCoinType = defaultCoinType;
    //    console.log("setting default coin type :: " + this._defaultCoinType);
    //storeData('JaxxApp_Settings_DefaultCoinType', this._defaultCoinType);
}

/*JaxxAppSettings.prototype.getCurrencyAtPosition = function(index) {
	return this._currencyAtPosition[index];
}*/
/*
JaxxAppSettings.prototype.isCurrencyListPositionValid = function() {
	// Returns true if every currency in the app is contained in the list once and only once.
	return false;
}*/

/*JaxxAppSettings.prototype.getCurrencyPositionList = function(){
	return this._currencyAtPosition;
}*/

JaxxAppSettings.prototype.setCurrencyPositionList = function(arrayCurrencyPositionList){
	this._currencyAtPosition = arrayCurrencyPositionList;
	this.setDefaultCurrencyFromPositionList();
	storeData('currencies_position_order', JSON.stringify(this._currencyAtPosition));
}

//@note: @todo: @here: add default currencies list to this class.

/*
JaxxAppSettings.prototype.getListOfShapeshiftCoins = function(coinType) {
	// Returns the list of shapeshift coins for the menu when the user clicks on the arrow for the shapeshift feature.
	// Parameter: coinType is 'BTC' or 'ETH' etc.
	var returnList = Object.keys(HDWalletHelper.dictCryptoCurrency);
    
    var cryptoCurrenciesAllowed = {};
    if (PlatformUtils.mobileiOSCheck()) {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.ios;
    } else {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.regular;
    }
    
    var shapeShiftCryptoCurrenciesAllowed = HDWalletHelper.shapeShiftCryptoCurrenciesAllowed.regular;

    for (var index in returnList) {
        var key = returnList[index];
        if (typeof(cryptoCurrenciesAllowed[key]) === 'undefined' ||
            cryptoCurrenciesAllowed[key] === null ||
            cryptoCurrenciesAllowed[key] === false ||
            typeof(shapeShiftCryptoCurrenciesAllowed[key]) === 'undefined' ||
            shapeShiftCryptoCurrenciesAllowed[key] === null ||
            shapeShiftCryptoCurrenciesAllowed[key] === false)
        {
            delete returnList[index];
        }
    }
    
	var index = returnList.indexOf(coinType);
	if (index > -1){
		returnList.splice(index, 1);
	}
    
//    var returnListKeys = Object.keys(returnList);
//    var reducedReturnList = {};
//
//    for (var i = 0; i < returnListKeys.length; i++) {
//        reducedReturnList[i] = returnList[returnListKeys[i]];
//    }
    
//    return reducedReturnList;
    return returnList;
}

JaxxAppSettings.prototype.initializeShapeshiftTargets = function(){
	// @TODO: 
	var coinList = HDWalletHelper.dictCryptoCurrency;
	var coins = Object.keys(HDWalletHelper.dictCryptoCurrency);
	for (var i = 0; i < coins.length; i++){
        var targetCoinName = this.getListOfShapeshiftCoins(coins[i])[0];
        if (typeof(targetCoinName) === 'undefined' && targetCoinName === null){
			console.log('Error: Cannot get a suitable coin for the shapeshift functionality.')
			targetCoinName = coins[i];
		}
        this._currentShapeshiftTarget[coins[i]] = targetCoinName;
	}
}
	
JaxxAppSettings.prototype.getShapeshiftCoinTarget = function(coinName) {
    return this._currentShapeshiftTarget[coinName];
}

JaxxAppSettings.prototype.setShapeshiftCoinTarget= function(coinName, targetCoinName) {
    this._currentShapeshiftTarget[coinName] = targetCoinName;
}
*/

JaxxAppSettings.prototype.setCurrencyPosition = function(currencyType, newIndex) {
	// Pushes currency to new position and readjusts the position of the other currencies.	
	oldIndex = this._currencyAtPosition.indexOf(currencyType);
	this._currencyAtPosition.splice(oldIndex, 1); // Deletes the currency entry from the array.
	this._currencyAtPosition.splice(newIndex, 0, currencyType); // Adds the currency entry to the new position.
	// @TODO: Throw error if the currency position is not valid.
	this.setDefaultCurrencyFromPositionList(); // Sets the default currency
	storeData('currencies_position_order', JSON.stringify(this._currencyAtPosition));
}

JaxxAppSettings.prototype.setDefaultCurrencyFromPositionList = function() {
	for (var i = 0; i < this._currencyAtPosition.length; i++) {
		if (Navigation.isCurrencyEnabled(this._currencyAtPosition[i])){
			wallet.getHelper().setFiatUnit(this._currencyAtPosition[i]);
			return;
		}	
	}
	// Really the code should not reach this line (at least one currency should be enabled.)
}

JaxxAppSettings.prototype.getListOfEnabledCurrencies = function() {
	returnArray = [];
	for (var i = 0; i < this._currencyAtPosition.length; i++){
		if (Navigation.isCurrencyEnabled(this._currencyAtPosition[i])) {
			returnArray.push(this._currencyAtPosition[i]);
		}
	}
	return returnArray;
}

JaxxAppSettings.prototype.getNextEnabledCurrency = function(sourceCurrency) {
	var arrayCurrencies = this.getListOfEnabledCurrencies();
	var oldIndex = arrayCurrencies.indexOf(sourceCurrency);
	if (oldIndex === -1) {
		return -1;
	}
	var newIndex = (oldIndex + 1) % arrayCurrencies.length;
	return arrayCurrencies[newIndex];
}

JaxxAppSettings.prototype.getPreviousEnabledCurrency = function(sourceCurrency) {
	var arrayCurrencies = this.getListOfEnabledCurrencies();
	var oldIndex = arrayCurrencies.indexOf(sourceCurrency);
	if (oldIndex === -1) {
		return -1;
	}
	var newIndex = (oldIndex - 1 + arrayCurrencies.length) % arrayCurrencies.length;
	return arrayCurrencies[newIndex];	
}

JaxxAppSettings.prototype.pushCurrencyToEndOfList = function(fiatUnit) {
	// fiatUnit will be something like 'CAD'
	this._currencyAtPosition.push(fiatUnit);
	storeData('currencies_position_order', JSON.stringify(this._currencyAtPosition));
}

JaxxAppSettings.prototype.setCurrencyPositionList = function(newCurrencyPositionArray){
	this._currencyAtPosition = newCurrencyPositionArray;
	storeData('currencies_position_order', JSON.stringify(this._currencyAtPosition));
}

/*JaxxAppSettings.prototype.getCryptoCurrencyPositionList = function(){

	return this.getWallets();
}*/

/*
JaxxAppSettings.prototype.getCryptoCurrencyAtPosition = function(index) {

	return this._getCryptoCurrencyPositionList()[index];
}
*/

JaxxAppSettings.prototype.initializeCryptoCurrencySettingsData = function() {
	try {
//		this.initializeCryptoCurrencyPositionData();
		this.initializeCryptoCurrencyEnabledData();
		this.initializeDefaultCryptoCurrency();
		console.log("The cryptocurrency settings data has loaded properly.");
	} catch(error) {
		console.log("The cryptocurrency initialization functions wouldn't work for some reason.");
	}
}

JaxxAppSettings.prototype.initializeDefaultCryptoCurrency = function() {

	var storedDefaultCoinType = HDWalletHelper.dictCryptoCurrency[this.getListOfEnabledCryptoCurrencies()[0]]['index'];
	if (typeof(storedDefaultCoinType) !== 'undefined' && storedDefaultCoinType !== null) {
        this._defaultCoinType = parseInt(storedDefaultCoinType, 10);
    } else {
        this.setDefaultCoinType(COIN_BITCOIN);
    }
	
}

/*
JaxxAppSettings.prototype.saveWallets = function(ar){
    this.wallets_sorted = ar;

    localStorage.setItem('wallets_sorted', JSON.stringify(this.wallets_sorted));
}*/

/*JaxxAppSettings.prototype.getWallets = function(){
    var out = jaxx.Registry.getDatacontrollersAll().map(function (item) {
        return {symbol: item.symbol, sort: item.sort, name: item.name, icon: item.icon, enabled: item.enabled, testnet:item.testnet};
    })

    return _.sortBy(out, 'sort');*/

  //  var self = this;

   /* var cryptoCurrenciesAllowed = {};
    if (PlatformUtils.mobileiOSCheck()) {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.ios;
    } else {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.regular;
    }
*/


   //if(!this.wallets_sorted) {
     //  var str = localStorage.getItem('wallets_sorted');
       //if (!str) {
          // var i = 0;

         //  localStorage.setItem('wallets_sorted', JSON.stringify(this.wallets_sorted));
      //} else this.wallets_sorted = JSON.parse(str);
  // }
  //  return this.wallets_sorted;

  /*  //var cryptoCurrencyPositionData = null;

    if (typeof(loadedCryptoPositionData) !== 'undefined' && loadedCryptoPositionData !== null) {    
        cryptoCurrencyPositionData = JSON.parse(loadedCryptoPositionData);
    }

    if (cryptoCurrencyPositionData === null) {
        console.log('Writing new cryptocurrency position data.');
        var cryptoArray = [];


        for (var key in HDWalletHelper.dictCryptoCurrency){
            console.log("key :: " + key + " :: allowed :: " + HDWalletHelper.cryptoCurrenciesAllowed[key]);
            if (HDWalletHelper.dictCryptoCurrency.hasOwnProperty(key) && 
                cryptoCurrenciesAllowed[key] === true) { // hasOwnProperty is needed because it's possible to insert keys into the prototype object of dictionary

                cryptoArray.push(key);
            }
        }
        self._cryptoCurrencyAtPosition = cryptoArray;
        storeData('crypto_currency_position_data', JSON.stringify(cryptoArray), false)// This is an optimization.
    } else {
        // cryptoCurrencyPositionData;
        // Add all missing coins to the end of the list.
        
        //@note: guards against currencies being completely removed from the app, or disabled on certain platforms.
        for (var i = cryptoCurrencyPositionData.length - 1; i >= -1; i--) {
            var key = cryptoCurrencyPositionData[i];
            if (!(cryptoCurrencyPositionData[i] in HDWalletHelper.dictCryptoCurrency) ||
                cryptoCurrenciesAllowed[key] !== true){
                cryptoCurrencyPositionData.splice(i, 1);
            }
        }
        self._cryptoCurrencyAtPosition = cryptoCurrencyPositionData;

        //@note: add other currencies to the list that might have been recently introduced.
        var allCoins = Object.keys(HDWalletHelper.dictCryptoCurrency);
        for (var i = 0; i < allCoins.length; i++){
            var key = allCoins[i];
            if (self._cryptoCurrencyAtPosition.indexOf(allCoins[i]) === -1 &&
                cryptoCurrenciesAllowed[key] === true){
                self._cryptoCurrencyAtPosition.push(allCoins[i]);
                // disable cryptocurrency.
            }
        }

        console.log("cryptoCurrenciesAtPosition :: " + JSON.stringify(self._cryptoCurrencyAtPosition, null, 4));
    }
    console.log('Cryptocurrency position data loaded without errors.');
    */
//}

JaxxAppSettings.prototype.initializeCryptoCurrencyEnabledData = function(){
    var baseInitialCryptoCurrencies = {};
    
//    if (PlatformUtils.mobileiOSCheck()) {
//        baseInitialCryptoCurrencies = HDWalletHelper.baseInitialCryptoCurrencies.ios;
//    } else {
        baseInitialCryptoCurrencies = HDWalletHelper.baseInitialCryptoCurrencies.regular;
//    }
    
  var cryptoCurrencyEnabledData = {}; // ie. {'BTC' : true, 'USD' : }
	try {
		cryptoCurrencyEnabledData = JSON.parse(getStoredData('crypto_currency_enabled_data', false));
	} catch(error) {
		cryptoCurrencyEnabledData = null;
		console.log('Error while parsing cryptocurrency enabled data.')
	}
	try {
		if (typeof(cryptoCurrencyEnabledData) === 'undefined' || cryptoCurrencyEnabledData === null) {			
			console.log('Writing new cryptocurrency enabled data.');
          var allKeys = Object.keys(baseInitialCryptoCurrencies);
          for (var i = 0; i < allKeys.length; i++){
              if (baseInitialCryptoCurrencies[allKeys[i]] === true) {
                  this.enableCryptoCurrency(allKeys[i]);
                  g_JaxxApp.getUI().enableCryptoCurrencyInUI(allKeys[i]);
              }
          }
			//this.pushCryptoCurrencyIsEnabledToStorage();
		} else {
			this._cryptoCurrencyIsEnabled = cryptoCurrencyEnabledData;
		}
		console.log('Cryptocurrency enabled data loaded without errors.');
	} catch (error) {
		console.log("Error while initializing cryptocurrency enabled data.");
		console.log(error.message);
	}

}

JaxxAppSettings.prototype.isCryptoCurrencyEnabled = function(cryptoCurrency) {
	//try {
		if (this._cryptoCurrencyIsEnabled[cryptoCurrency]){
			return true;	
		} else {
			return false;
		}
	//} catch (error) {
	//	console.log(error.message);
	//	return false;
//	}
}




JaxxAppSettings.prototype.setCryptoCurrencyPositionData = function(newPositionArray){
	//try {
		this._cryptoCurrencyAtPosition = newPositionArray;
    localStorage.setItem('crypto_currency_position_data', newPositionArray);
		g_JaxxApp.getUI().updateCryptoCurrencyBannersInHeader(); // Change ordering in top menu
	//} catch(error) {
	//	console.log("Error while initializing cryptocurrency enabled data.");
	//	console.log(error.message);
	//}
}

JaxxAppSettings.prototype.setCryptoCurrencyEnabledData = function(newEnabledDictionary) {
	try {
		this._cryptoCurrencyEnabledData = newEnabledDictionary;
		this.pushCryptoCurrencyIsEnabledToStorage();
	} catch (error) {
		console.log("Error while initializing cryptocurrency enabled data.");
		console.log(error.message);		
	}
}

JaxxAppSettings.prototype.toggleCryptoCurrencyIsEnabled = function(cryptoCurrency) {
	// Example cryptoCurrency parameters: 'BTC', 'ETH', ...
    try {
		if (this.isCryptoCurrencyEnabled(cryptoCurrency)) {            
        if (this.isDisablingCryptoCurrencyAllowed()) {
				    this.disableCryptoCurrency(cryptoCurrency);
				    g_JaxxApp.getUI().disableCryptoCurrencyInUI(cryptoCurrency);
				    if (HDWalletHelper.dictCryptoCurrency[cryptoCurrency]['index'] === curCoinType){
					      // Get the enabled cryptocurrency from the top of the list.
					      g_JaxxApp.getUI().switchToCoin(this.getListOfEnabledCryptoCurrencies()[0]);
				    }
			  }
		} else {            
			  this.enableCryptoCurrency(cryptoCurrency);
        g_JaxxApp.getUI().enableCryptoCurrencyInUI(cryptoCurrency);
		}
	} catch (error) {
		console.log("Failed to toggle cryptocurrency in settings.");
		console.log(error.message);
	}
}

JaxxAppSettings.prototype.disableCryptoCurrency = function(cryptoCurrency){
	// @TODO: JS Optimization	
	this._cryptoCurrencyIsEnabled[cryptoCurrency] = false;
	this.pushCryptoCurrencyIsEnabledToStorage();
    
    //@note: @todo: @here: settings shouldn't be calling ui functions.

}

JaxxAppSettings.prototype.enableCryptoCurrency = function(cryptoCurrency) {
	this._cryptoCurrencyIsEnabled[cryptoCurrency] = true;
	this.pushCryptoCurrencyIsEnabledToStorage();
  //@note: @todo: @here: settings shouldn't be calling ui functions.
}

JaxxAppSettings.prototype.disableAllCryptoCurrencies = function(){
    var listOfCoinAbbreviatedNames = this.getListOfEnabledCryptoCurrencies();
    for (var i = 0; i < listOfCoinAbbreviatedNames.length; i++){
        this._cryptoCurrencyIsEnabled[listOfCoinAbbreviatedNames[i]] = false;
    }
    this.pushCryptoCurrencyIsEnabledToStorage();
}

JaxxAppSettings.prototype.pushCryptoCurrencyIsEnabledToStorage = function(){
	try {
		storeData('crypto_currency_enabled_data', JSON.stringify(this._cryptoCurrencyIsEnabled), false);
	} catch(error) {
		console.log("JaxxAppSettings :: pushCryptoCurrencyIsEnabledToStorage :: Error when pushing cryptocurrency enabled data to storage.");
		console.log(error.message);
	}
}

//JaxxAppSettings.prototype.pushCryptoCurrencyPositionDataToStorage = function(){
//	try {
	//	storeData('crypto_currency_position_data', JSON.stringify(this._cryptoCurrencyAtPosition), false);
	//} catch(error) {
	//	console.log("JaxxAppSettings :: pushCryptoCurrencyPositionDataToStorage :: Error when pushing cryptocurrency position data to storage.");
	//	console.log(error.message);
	//}
//}
/*
JaxxAppSettings.prototype.getCryptoCurrencyEnabledCount = function() {
    var arr = this.getCryptoCurrencyPositionList();
	//try {
		var count = 0;
		for (var i = 0; i < arr.length; i++){
			if (this.isCryptoCurrencyEnabled(arr[i])){
				count = count + 1;
			}
		}
		return count;
	//} catch(error) {
		//console.log("JaxxAppSettings :: getCryptoCurrencyEnabledCount :: Error when counting the number of cryptocurrencies.");
	//	console.log(error.message);
	//}
}*/

JaxxAppSettings.prototype.isDisablingCryptoCurrencyAllowed = function() {
	// This method returns true if the user is allow to disable a cryptocurrency.
	if (this.getCryptoCurrencyEnabledCount() < 2) {
		return false;
	}
	return true;
}

/*
JaxxAppSettings.prototype.getListOfEnabledCryptoCurrencies = function(){
	// Returns an array

    var arr = this.getCryptoCurrencyPositionList();
	//try {
		var arrayOfEnabledCurrencies = [];
		for (var i = 0; i < arr.length; i++){
			var key = arr[i];
			if (this.isCryptoCurrencyEnabled(key)) {
				arrayOfEnabledCurrencies.push(key);
			}
		}
		return arrayOfEnabledCurrencies;
	//} catch (error) {
		//console.log("Could not retrieve sublist of cryptocurrencies");
		//console.log(error.message);
	//}
}
*/

JaxxAppSettings.prototype.initializeFirstCryptoCurrencyInBanner = function() {
	var firstCryptoCurrencyInBanner = ''; // ie. {'BTC' : true, 'USD' : }
	try {
		firstCryptoCurrencyInBanner = JSON.parse(getStoredData('first_crypto_currency_in_banner', false));
	} catch(error) {
		firstCryptoCurrencyInBanner = null;
		console.log('Error while parsing cryptocurrency first in banner data.')
	}
	try {
		if (typeof(firstCryptoCurrencyInBanner) === 'undefined' || firstCryptoCurrencyInBanner === null) {			
			console.log('Writing new cryptocurrency first in banner data.');
			firstCryptoCurrencyInBanner = this.getListOfEnabledCryptoCurrencies()[0];
			this.setFirstCryptoCurrencyInBanner(firstCryptoCurrencyInBanner);
			//this.pushCryptoCurrencyIsEnabledToStorage();
		} else {
			
		}
		console.log('Cryptocurrency enabled data loaded without errors.');
	} catch (error) {
		console.log("Error while initializing cryptocurrency enabled data.");
		console.log(error.message);
	}
}

JaxxAppSettings.prototype.setFirstCryptoCurrencyInBanner = function(cryptoCurrency){
	// Variable, settings and app UI.
	// cryptoCurrency should be BTC or ETH or something.
	this._bannerFirstCryptoCurrency = cryptoCurrency;	
	try {
		storeData('first_crypto_currency_in_banner', JSON.stringify(cryptoCurrency), false); // Sends the data to storage.
	} catch (error) {
		console.log('Error while trying to store first banner data.');
		console.log(error.message);
	}
	try {
		
	} catch(error) {
		console.log('Error while trying to cryptocurrency in banner.');
		console.log(error.message);		
	}
}

JaxxAppSettings.prototype.getNextEnabledCryptoCurrency = function(sourceCurrency) {
	//	var arrayCurrencies = this.getListOfEnabledCryptoCurrencies();
	//	var oldIndex = arrayCurrencies.indexOf(sourceCurrency);
	//	if (oldIndex === -1) {
	//		return -1;
	//	}
	//	var newIndex = (oldIndex + 1) % arrayCurrencies.length;
	//	return arrayCurrencies[newIndex];
	return this.getIncrementCryptoCurrencyNSteps(sourceCurrency, 1);
}

JaxxAppSettings.prototype.getPreviousEnabledCryptoCurrency = function(sourceCurrency) {
	//	var arrayCurrencies = this.getListOfEnabledCryptoCurrencies();
	//	var oldIndex = arrayCurrencies.indexOf(sourceCurrency);
	//	if (oldIndex === -1) {
	//		return -1;
	//	}
	//	var newIndex = (oldIndex - 1 + arrayCurrencies.length) % arrayCurrencies.length;
	//	return arrayCurrencies[newIndex];
	return this.getIncrementCryptoCurrencyNSteps(sourceCurrency, -1);
}

JaxxAppSettings.prototype.getIncrementCryptoCurrencyNSteps = function(sourceCurrencyName, steps) {
	try {
        //@note: @todo: @here: naming.
        if (typeof(sourceCurrencyName) === 'undefined' || sourceCurrencyName === null){
            sourceCurrencyName = this.getActiveCoinAbbreviatedName();
		}
		if (typeof(steps) === 'undefined' || steps === null) {
			steps = 0;
		}
		var arrayCurrencies = this.getListOfEnabledCryptoCurrencies();
        var oldIndex = arrayCurrencies.indexOf(sourceCurrencyName);
		if (oldIndex === -1) {
			return -1;
		}
		var newIndex = (oldIndex + steps) % arrayCurrencies.length;
		while (newIndex < 0) {
			newIndex = newIndex + arrayCurrencies.length;
		}
		return arrayCurrencies[newIndex];
	} catch (error) {
		console.log('Error while trying to get cryptocurrency incremented n steps.');
		console.log(error.message);
	}
} 

JaxxAppSettings.prototype.getActiveCoinAbbreviatedName = function() {
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];

    if (coinAbbreviatedName in HDWalletHelper.dictCryptoCurrency) {
        return coinAbbreviatedName;
    } else {
        console.log("Getting default coin type instead.")
        
        var coinAbbreviatedNameDefault = HDWalletPouch.getStaticCoinPouchImplementation(this.getDefaultCoinType()).pouchParameters['coinAbbreviatedName'];
        
        return coinAbbreviatedNameDefault;
    }
}

JaxxAppSettings.prototype.getDefaultShapeshiftCoinAbbreviatedName = function(coinType){
	return this.getListOfShapeshiftCoins(coinType)[0];
}

JaxxAppSettings.prototype.getNextCryptoForShapeshiftSelection = function(cryptoUnit) {
	var shapeshiftCoinList = this.getListOfShapeshiftCoins(cryptoUnit);
	var index = shapeshiftCoinList.indexOf(this.getShapeshiftCoinTarget(cryptoUnit));
	if (index < 0){
		console.log('Index was not retrieved properly.')
		return 0;
	}
    
    var found = false;
    
    while (!found) {
        index = index + 1;
        index = index % shapeshiftCoinList.length;
        
        if (typeof(shapeshiftCoinList[index]) !== 'undefined' &&
           shapeshiftCoinList[index] !== null) {
            found = true;
        }
    }
    
	return shapeshiftCoinList[index];
}

JaxxAppSettings.prototype.setShouldLoadFromBackupIntroPosition = function(blnNewSetting){
    this._shouldLoadFromBackupIntroPosition = blnNewSetting;
    storeData('shouldLoadFromBackupIntroPosition', JSON.stringify(this._shouldLoadFromBackupIntroPosition), false)// This is an optimization.
}

JaxxAppSettings.prototype.getShouldLoadFromBackupIntroPosition = function(){
    this._shouldLoadFromBackupIntroPosition = getStoredData('shouldLoadFromBackupIntroPosition', false);
    if (this._shouldLoadFromBackupIntroPosition){
        this._shouldLoadFromBackupIntroPosition = true;
    } else {
        this._shouldLoadFromBackupIntroPosition = false;
    }
    return this._shouldLoadFromBackupIntroPosition;
}

/*JaxxAppSettings.prototype.isMnemonicStored = function(){
    var mnemonic = getStoredData('mnemonic', false);
    if (typeof(mnemonic) === 'undefined' || mnemonic === null){
        return false;
    } else {
        return true;
    }
}*/


JaxxAppSettings.prototype.setIgnoreEtcEthSplit = function(ignoreEtcEthSplit) {
    this._ignoreEtcEthSplit = ignoreEtcEthSplit;
    
    storeData('JaxxApp_Settings_IgnoreEtcEthSplit', this._ignoreEtcEthSplit.toString(), false);
}

JaxxAppSettings.prototype.getIgnoreEtcEthSplit = function() {
    return this._ignoreEtcEthSplit;
}

JaxxAppSettings.prototype.getDictionaryOfCryptoCurrenciesAllowed = function(){
    var cryptoCurrenciesAllowed = {};
    if (PlatformUtils.mobileiOSCheck()) {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.ios;
    } else {
        cryptoCurrenciesAllowed = HDWalletHelper.cryptoCurrenciesAllowed.regular;
    }
    return cryptoCurrenciesAllowed;
}

JaxxAppSettings.prototype.getListOfCryptoCurrenciesAllowed = function(){
    var returnValue = [];
    var dictCryptoCurrenciesAllowed = this.getDictionaryOfCryptoCurrenciesAllowed();
    var keys = Object.keys(dictCryptoCurrenciesAllowed);
    for (var i = 0; i < keys.length; i++){
        if (dictCryptoCurrenciesAllowed[keys[i]]){
            returnValue.push(keys[i]);
        }
    }
    return returnValue;
}

JaxxAppSettings.prototype.getMiningFeeOptionForCoin = function(coinType){
    // If the mining fee is not available then we simply retrieve the average.
    var miningFee = this.getSetting(JSON.stringify({"MiningFeeOptionForCoin":coinType})); // test with g_JaxxApp.getSettings().getSetting(JSON.stringify({"MiningFeeForCoin":0}))
    // This code sets the mining fee to average if the mining fee is undefined.
    if (typeof(miningFee) === 'undefined' || miningFee === null) {
        miningFee = HDWalletPouch.MiningFeeLevelAverage;
    }
    return miningFee;
}

JaxxAppSettings.prototype.setMiningFeeOptionForCoin = function(coinType, miningFeeOption){
    this.setSetting(JSON.stringify({"MiningFeeOptionForCoin":coinType}), miningFeeOption);
}

JaxxAppSettings.prototype.setupDefaultMiningOptions = function(){
    //var miningOption = this.
}

JaxxAppSettings.prototype.getMiningFeeDefaultForCoin = function(coinType){
  // If the mining fee is not available then we simply retrieve the average.
  var miningFee = this.getSetting(JSON.stringify({"MiningFeeDefaultForCoin":coinType})); // test with g_JaxxApp.getSettings().getSetting(JSON.stringify({"MiningFeeForCoin":0}))
  // This code sets the mining fee to average if the mining fee is undefined.
  if (typeof(miningFee) === 'undefined' || miningFee === null) {
      miningFee = null;
  }
  return miningFee;
}

JaxxAppSettings.prototype.setMiningFeeDefaultForCoin = function(coinType, miningFeeDefault){
    this.setSetting(JSON.stringify({"MiningFeeDefaultForCoin":coinType}), miningFeeDefault);
}

JaxxAppSettings.prototype.getDefaultCurrency = function(){
    return this.getListOfEnabledCurrencies()[0];
}

/*
* Resets Jaxx's cache
* @method resetJaxxCache
* */
JaxxAppSettings.prototype.resetJaxxCache = function(){
    var controllers = jaxx.Registry.getAllCryptoControllers();
    controllers.forEach(function(controller) {
        controller.resetStorage(true);
    });

    jaxx.CoinsMenu.instance.selectDefaultCoin();
  	localStorage.setItem('wallet_setup', false);
}

JaxxAppSettings.prototype.addVersionToCoinBulletinListHideOnSelect = function(coinType, version){
	//var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters["coinAbbreviatedName"];
    var ctr = jaxx.Registry.getCurrentCryptoController();
    var coinAbbreviatedName = ctr.symbol;
    var hideOnSelectSetting = this.setting(coinAbbreviatedName + "_CoinBulletinHideOnSelectSetting");
	if (typeof(hideOnSelectSetting) === "undefined" || hideOnSelectSetting === null){
		hideOnSelectSetting = [];
	}
	if (hideOnSelectSetting.indexOf(version) === -1){
		hideOnSelectSetting.push(version);
        this.setting(coinAbbreviatedName + "_CoinBulletinHideOnSelectSetting", hideOnSelectSetting);
	}
}

JaxxAppSettings.prototype.addVersionToCoinBulletinListIsHidden = function(coinType, version){
    //var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters["coinAbbreviatedName"];
    var ctr = jaxx.Registry.getCurrentCryptoController();
    var coinAbbreviatedName = ctr.symbol;
    var coinBulletinIsHidden = this.setting(coinAbbreviatedName + "_CoinBulletinIsHidden");
    if (typeof(coinBulletinIsHidden) === "undefined" || coinBulletinIsHidden === null){
        coinBulletinIsHidden = [];
    }
    if (coinBulletinIsHidden.indexOf(version) === -1){
        coinBulletinIsHidden.push(version);
		this.setting(coinAbbreviatedName + "_CoinBulletinIsHidden", coinBulletinIsHidden);
    }
}

JaxxAppSettings.prototype.isCoinBulletinHideOnSelect = function(version){
    var ctr = jaxx.Registry.getCurrentCryptoController();
    var coinAbbreviatedName = ctr.symbol;
    var hideOnSelectSetting = this.setting(coinAbbreviatedName + "_CoinBulletinHideOnSelectSetting");

    if (typeof(hideOnSelectSetting) === "undefined" || hideOnSelectSetting === null){
        return false;
    }

    if (hideOnSelectSetting.indexOf(version) === -1) {
		return false;
	} else {
    	return true;
	}
};

JaxxAppSettings.prototype.isCoinBulletinVersionHidden = function(coinType, version){
    //var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters["coinAbbreviatedName"];
    var ctr = jaxx.Registry.getCurrentCryptoController();
    var coinAbbreviatedName = ctr.symbol;
    var coinBulletinIsHidden = this.setting(coinAbbreviatedName + "_CoinBulletinIsHidden");
    if (typeof(coinBulletinIsHidden) === "undefined" || coinBulletinIsHidden === null){
        return false;
    }
    if (coinBulletinIsHidden.indexOf(version) === -1) {
        return false;
    } else {
        return true;
    }
}
/**
 * Created by Vlad on 10/6/2016.
 */
///<reference path="../com/models.ts"/>
var starttime = Date.now();
var exports = {};
var IS_RELEASE_VERSION = true;
var COIN_BITCOIN = 0;
var COIN_ETHEREUM = 1;
var COIN_THEDAO_ETHEREUM = 2;
var COIN_DASH = 3;
var COIN_ETHEREUM_CLASSIC = 4;
var COIN_AUGUR_ETHEREUM = 5;
var COIN_LITECOIN = 6;
var COIN_LISK = 7;
var COIN_ZCASH = 8;
var COIN_TESTNET_ROOTSTOCK = 9;
//@note@:@here:@zcash
//var COIN_NUMCOINTYPES = 9;
var COIN_DOGE = 10;
var COIN_ICONOMI_ETHEREUM = 11;
var COIN_GOLEM_ETHEREUM = 12;
var COIN_GNOSIS_ETHEREUM = 13;
var COIN_SINGULARDTV_ETHEREUM = 14;
var COIN_DIGIX_ETHEREUM = 15;
var COIN_BLOCKCHAINCAPITAL_ETHEREUM = 16;
var COIN_CIVIC_ETHEREUM = 17;
var COIN_NUMCOINTYPES = 18;
var COIN_UNITLARGE = 0;
var COIN_UNITSMALL = 1;
var COIN_NUMUNITTYPES = 2;
//JAXX UTILS
var UTILS_CHANGE_LOG = 'changeLog';
var UTILS_CHANGE_LOG_SUMMARY = 'changeLogSummary';
var UTILS_TERMS_OF_SERVICE = 'termsOfService';
var UTILS_COIN_BULLETIN = 'coinBulletin';
var UTILS_NEWS = 'jaxxNews';
var UTILS_NEWS_BETA = 'jaxxNewsBeta';
var UTILS_RELEASE_NOTES = 'jaxxReleaseNotes';
var UTILS_PRIVACY_POLICY = 'jaxxPrivacyPolicy';
var jaxx;
(function (jaxx) {
    var Registry = (function () {
        function Registry() {
        }
        Registry.isTestNet = function () {
            return localStorage.getItem('testNet');
        };
        Registry.setTestNet = function (isTestNet) {
            if (isTestNet)
                localStorage.setItem('testNet', 'true');
            else
                localStorage.removeItem('testNet');
        };
        Registry.platformCheck = function () {
            if (PlatformUtils.mobileCheck()) {
                this.mobile = true;
            }
            if (PlatformUtils.extensionCheck()) {
                this.chromeExtension = true;
            }
            if (PlatformUtils.desktopCheck()) {
                this.desktop = true;
            }
            if (PlatformUtils.mobileAndroidCheck) {
                this.android = true;
            }
            if (PlatformUtils.mobileiOSCheck()) {
                this.iPhone = true;
            }
        };
        Registry.getJaxxVersion = function () {
            if (this.versionDiff()) {
                this.onUpgrade(function () {
                    return localStorage.getItem('jaxx-version');
                });
            }
            else {
                var mnemonic = getStoredData('mnemonic');
                var walletState = localStorage.getItem('wallet-last-state');
                if ((mnemonic && (mnemonic.length > 50)) && (!walletState))
                    Registry.setWalletLasttState('ready'); // TODO: change this logic
                return localStorage.getItem('jaxx-version');
            }
        };
        Registry.onUpgrade = function (cb) {
            localStorage.setItem('jaxx-version', Registry.application.appVersion);
            var mnemonic = getStoredData('mnemonic');
            if (mnemonic && (mnemonic.length > 50))
                Registry.setWalletLasttState('ready'); // TODO: change this logic
            cb();
        };
        Registry.versionDiff = function () {
            return (localStorage.getItem('jaxx-version') !== Registry.application.appVersion) ? true : false;
        };
        Registry.setJaxxVersion = function (version) {
            localStorage.setItem('jaxx-version', version);
        };
        Registry.setWalletLasttState = function (state) {
            localStorage.setItem('wallet-last-state', state);
        };
        Registry.getWalletLastState = function () {
            Registry.getJaxxVersion(); // Needed to trigger possible upgrade.
            return localStorage.getItem('wallet-last-state');
        };
        Registry.setFiatPriceController = function (controller_instance) {
            Registry.fiatController = controller_instance;
        };
        Registry.getFiatPriceController = function () {
            return Registry.fiatController;
        };
        Registry.generateMnemonic = function () {
            var mnemonic = jaxx.Seed.generateMnemonic();
            storeData('mnemonic', mnemonic, true);
            jaxx.Utils2.setMnemonic(mnemonic);
            var controllers = Registry.getAllCryptoControllers();
            controllers.forEach(function (controller) {
                controller.resetStorage(true);
            });
        };
        Registry.pairDeviceMnemonic = function (mnemonic) {
            //Ensure mnemonic should never been set to empty string. If so, warn user.
            if (mnemonic == '') {
                Navigation.flashBanner("Internal data error (ID001) occurred, please make sure you have backed up your 12-word backup phrase, restart application and check the integrity of your wallet");
                return;
            }
            storeData('mnemonic', mnemonic, true);
            // Seed.getEncryptedSeed();
            jaxx.Utils2.setMnemonic(mnemonic);
            var controllers = Registry.getAllCryptoControllers();
            controllers.forEach(function (controller) {
                controller.resetStorage(true);
                //controller.getCoinService().enabled = false;
            });
            // reset flag new-wallet to pair-device globally for all coins
            localStorage.setItem('walletType', 'pair-device');
        };
        Registry.loadMnemonic = function () {
            var mnemonic = getStoredData('mnemonic', true);
            jaxx.Utils2.setMnemonic(mnemonic);
        };
        Registry.setConfigCoins = function (ar) {
            ar.forEach(function (item, index) {
                item.index = index;
            });
            Registry.configCoins = ar;
        };
        Registry.getConfigCoins = function (ar) {
            return Registry.configCoins;
        };
        Registry.getConfigByName = function (name) {
            var coins = Registry.configCoins;
            for (var i = coins.length - 1; i >= 0; i--)
                if (coins[i].name == name)
                    return coins[i];
            return null;
        };
        Registry.getConfigBySymbol = function (symbol) {
            symbol = symbol.toUpperCase();
            var coins = Registry.configCoins;
            for (var i = coins.length - 1; i >= 0; i--)
                if (coins[i].symbol == symbol)
                    return coins[i];
            return null;
        };
        Registry.addCryptoController = function (ctr) {
            Registry.allCoins.push(ctr);
        };
        Registry.getAllCryptoControllers = function () {
            return Registry.allCoins;
        };
        Registry.getAllPrivateKeyCryptoControllers = function () {
            return Registry.getAllCryptoControllers().filter(function (coinControllers) {
                return coinControllers.displayPrivateKey;
            });
        };
        Registry.getAllSelectedPrivateKeyCryptoCrontrollers = function () {
            return Registry.getAllPrivateKeyCryptoControllers().filter(function (coinControllers) {
                return coinControllers.enabled;
            });
        };
        Registry.getDefaultWalletType = function () {
            var w = Registry.getDefaultWallet();
            return w ? w.coinType : 0;
        };
        Registry.getDefaultWallet = function () {
            console.log('//TODO set default walet');
            var enabled = Registry.getWalletsEnabledSorted();
            if (enabled.length)
                return enabled[0];
            return null;
        };
        Registry.getCryptoControllerByCoinType = function (coinType) {
            for (var i = Registry.allCoins.length - 1; i >= 0; i--)
                if (Registry.allCoins[i]._coinType === coinType)
                    return Registry.allCoins[i];
            // console.error('cant find data controller for coinType ' + coinType);
            return null;
        };
        Registry.getCryptoControllerByName = function (coinName) {
            for (var i = Registry.allCoins.length - 1; i >= 0; i--)
                if (Registry.allCoins[i].name === coinName)
                    return Registry.allCoins[i];
            console.error('cant find data controller for coinName ' + coinName);
            return null;
        };
        Registry.getCryptoControllerBySymbol = function (symbol) {
            for (var i = Registry.allCoins.length - 1; i >= 0; i--)
                if (Registry.allCoins[i].symbol === symbol)
                    return Registry.allCoins[i];
            console.error('cant find data controller by symbol ' + symbol);
            return null;
        };
        Registry.getShapeShiftEnabled = function () {
            return Registry.getAllCryptoControllers().filter(function (ctr) {
                //  console.log(ctr);
                return (ctr.shapeshift !== null);
            });
        };
        Registry.getWalletsSorted = function () {
            var out = Registry.getAllCryptoControllers(); /*.map(function (item) {
                return {
                    symbol: item.symbol,
                    sort: item.sort,
                    name: item.name,
                    icon: item.icon,
                    enabled: item.enabled,
                    testnet: item.testnet,
                    coinType:item.coinType,
                    displayName:item.displayName
                };
            })
            */
            return _.sortBy(out, 'sort');
        };
        Registry.getWalletsEnabledSorted = function () {
            return Registry.getWalletsSorted().filter(function (item) {
                return item.enabled;
            });
        };
        /* static setCurrent(ctr:ICoinController){
             console.log('%c set current crypto controller ' + ctr.symbol + ' - '+ ctr.name,'color:red');
             Registry.current_crypto_controller = ctr;
         }*/
        Registry.setCurrentControllerBySymbol = function (symbol) {
            var ctr = Registry.getCryptoControllerBySymbol(symbol);
            if (!ctr) {
                //                console.error('cant find coin '+symbol);
                return null;
            }
            Registry.getAllCryptoControllers().forEach(function (item) {
                item.deactivate();
            });
            Registry.current_crypto_controller = ctr;
            ctr.activate();
            return Registry.current_crypto_controller;
        };
        Registry.setCurrentControllerByName = function (name) {
            var ctr = Registry.getCryptoControllerByName(name);
            if (!ctr) {
                console.error('cant find coin ' + name);
                return null;
            }
            return Registry.setCurrentControllerBySymbol(ctr.symbol);
        };
        Registry.getCurrentCryptoController = function () {
            return Registry.current_crypto_controller;
        };
        Registry.updateWithShapeShiftCoinList = function (coinList) {
            var coins = Registry.getAllCryptoControllers();
            coins.forEach(function (coin) {
                var coinShapeShift = coinList.getCoinWithSymbol(coin.symbol);
                if (coinShapeShift) {
                    if (!coin.shapeshift)
                        coin.shapeshift = {};
                    coin.shapeshift.available = coinShapeShift.isAvailable();
                }
                else {
                    coin.shapeshift = null;
                }
            });
        };
        Object.defineProperty(Registry, "currentCoinType", {
            get: function () {
                return Registry._currentCoinType;
            },
            set: function (currentCoinType) {
                // console.error(' setting currentCoinType ' + currentCoinType);
                Registry._currentCoinType = currentCoinType;
            },
            enumerable: true,
            configurable: true
        });
        ;
        ;
        Registry.onError = function (error) {
            console.error(error);
        };
        return Registry;
    }());
    Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE = 'ON_UI_SHAPE_SHIFT_FROM_CHANGE';
    Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE_ANIMATION_END = 'ON_UI_SHAPE_SHIFT_FROM_CHANGE_ANIMATION_END';
    Registry.ON_ERROR = 'ON_ERROR';
    Registry.ON_ERROR_RESTORE_HISTORY = 'ON_ERROR_RESTORE_HISTORY';
    Registry.ON_ERROR_RESTORE_BALANCE = "ON_RESTORE_BALANCE_ERROR";
    Registry.error$ = $({});
    // static devic
    Registry.ON_OUT_OF_SYNC = 'ON_OUT_OF_SYNC';
    //eType = '';//navigator.appVersion;
    Registry.OS = navigator.userAgent;
    Registry.ON_COIN_SEQUENCE_CHANGED = 'ON_COIN_SEQUENCE_CHANGED';
    Registry.ON_COIN_SATUS_CHANGED = 'ON_COIN_SATUS_CHANGED';
    Registry.ON_MNEMONIC_CHANGED = 'ON_MNEMONIC_CHANGED';
    Registry.ON_APPLICATION_ERROR = 'ON_APPLICATION_ERROR';
    Registry.RESET_STORAGE = 'RESET_STORAGE';
    Registry.GO_SLEEP = 'GO_SLEEP';
    Registry.WAKE_UP = 'WAKE_UP';
    Registry.MODULE_REDY = 'MODULE_REDY';
    Registry.UI_TOGGLE_TAB = 'UI_TOGGLE_TAB';
    Registry.UI_SHOW_TAB = 'UI_SHOW_TAB';
    Registry.UI_CLOSE_TAB = 'UI_CLOSE_TAB';
    Registry.BALANCE_OUT_OFF_SYNC = 'BALANCE_OUT_OFF_SYNC';
    Registry.BALANCE_IN_SYNC = 'BALANCE_IN_SYNC';
    Registry.SYNC_CHECK_START = 'SYNC_CHECK_START';
    Registry.SYNC_CHECK_END = 'SYNC_CHECK_END';
    Registry.ON_SHAPE_SHIFT_ACTIVATE = 'ON_SHAPE_SHIFT_ACTIVATE';
    Registry.ON_UTXOS_READY = 'ON_UTXOS_READY';
    Registry.ON_NONCES_READY = 'ON_NONCES_READY';
    Registry.ON_SEND_TRANSACTION = 'ON_SEND_TRANSACTION';
    Registry.ON_USER_TRANSACTION_COFIRMED = 'ON_USER_TRANSACTION_COFIRME';
    // fired when the TX monitoring system within CoinControllerBase, exceeds the configured number of attempts to retrieve the details of a transaction
    // argument passed is the transactin ID as string.
    Registry.ON_TRANSACTION_DROPPED = 'ON_TRANSACTION_DROPPED';
    Registry.DATA_FROM_RELAY = 'DATA_FROM_RELAY';
    Registry.BEGIN_SWITCH_TO_COIN_TYPE = 'BEGIN_SWITCH_TO_COIN_TYPE';
    Registry.COMPLETE_SWITCH_TO_COIN_TYPE = 'COMPLETE_SWITCH_TO_COIN_TYPE';
    ///////////TODO remove duplicates
    Registry.TRANSACTION_BEFORE_SEND = 'TRANSACTION_BEFORE_SEND';
    Registry.TRANSACTION_SENT = 'TRANSACTION_SENT';
    Registry.TRANSACTION_FAILED = 'TRANSACTION_FAILED';
    Registry.TRANSACTION_ACCEPTED = 'TRANSACTION_ACCEPTED';
    Registry.TRANSACTION_CONFIRMED = 'TRANSACTION_CONFIRMED';
    Registry.ON_RESTORE_HISTORY_START = 'ON_RESTORE_HISTORY_START';
    Registry.ON_RESTORE_HISTORY_ERROR = 'ON_RESTORE_HISTORY_ERROR';
    Registry.ON_RESTORE_HISTORY_DONE = 'ON_RESTORE_HISTORY_DONE';
    //Balances
    //  static ON_RESTORE_BALANCE_START = "ON_RESTORE_BALANCE_START";
    Registry.ON_RESTORE_BALANCE_ERROR = "ON_RESTORE_BALANCE_ERROR";
    //  static ON_RESTORE_BALANCE_END = "ON_RESTORE_BALANCE_END";
    Registry.ON_RESTORE_BALANCE_MANUAL_START = "ON_RESTORE_BALANCE_MANUAL_START";
    Registry.ON_RESTORE_BALANCE_MANUAL_END = "ON_RESTORE_BALANCE_MANUAL_END";
    Registry.ON_UI_COIN_ACTIVATE_START = 'ON_UI_COIN_ACTIVATE_START';
    Registry.ON_UI_COIN_ACTIVATE_END = 'ON_UI_COIN_ACTIVATE_END';
    Registry.ON_UI_INTERWALLET_ANIMATION_END = 'ON_UI_INTERWALLET_ANIMATION_END'; // triggered when the inter-wallet transitions are done. trigger by view-main-page.ts Spinner::
    Registry.ON_BALANCE_RECEIVE_CHANGE = 'ON_BALANCE_RECEIVE_CHANGE';
    Registry.ON_BALANCE_DEEMED = 'ON_BALANCE_DEEMED';
    Registry.ON_BALANCE_ACCURATE = 'ON_BALANCE_ACCURATE';
    Registry.ON_BALANCES_DOWNLOADED = 'ON_BALANCES_DOWNLOADED';
    Registry.ON_BALANCE_RENDER = 'ON_BALANCE_RENDER';
    Registry.BITCOIN_MINING_FEE = 'BITCOIN_MINING_FEE';
    Registry.ON_NEW_WALLET_START = 'ON_NEW_WALLET_START';
    Registry.ON_NEW_WALLET_END = 'ON_NEW_WALLET_END';
    Registry.ON_NEW_WALLET_CREATED = 'ON_NEW_WALLET_CREATED';
    Registry.WALLET_FIRST_INIT = 'WALLET_FIRST_INIT';
    /////////////////////////// Application events ////////////////////////////
    Registry.OFFLINE = 'OFFLINE';
    Registry.ONLINE = 'ONLINE';
    Registry.PAUSE = 'PAUSE';
    Registry.RESUME = 'RESUME';
    Registry.KILL_HISTORY = 'KILL_HISTORY';
    Registry.AMOUNT_TOO_BIG_ETHEREUM = 'AMOUNT_TOO_BIG_ETHEREUM';
    Registry.allCoins = [];
    Registry.UI_CONFIRM_TRANSACTION = 'UI_CONFIRM_TRANSACTION';
    Registry.UI_CONFIRM_TRANSACTION_CLOSED = 'UI_CONFIRM_TRANSACTION_CLOSED';
    Registry.UI_CANCEL_TRANSACTION = 'UI_CANCEL_TRANSACTION';
    Registry.registry = {};
    Registry.ON_RESTORE_HISTORY_NEXT = 'ON_RESTORE_HISTORY_NEXT';
    Registry.ON_TRANSACTIONS_CONFIRMATIONS = 'ON_TRANSACTIONS_CONFIRMATIONS';
    // static ON_TRANSACTIONS_CONFIRMED = 'ON_TRANSACTIONS_CONFIRMED';
    Registry.ON_TRANSACTION_INBLOCK = 'ON_TRANSACTION_INBLOCK';
    Registry.ON_CONFIG_UPDATED = 'ON_CONFIG_UPDATED';
    Registry.SHOW_INIT_WALLET = 'SHOW_INIT_WALLET';
    Registry.HIDE_INIT_WALLET = 'HIDE_INIT_WALLET';
    Registry.HIDE_ALL_BULLETIN = 'HIDE_ALL_BULLETIN';
    Registry.mobile = false;
    Registry.iPhone = false;
    Registry.android = false;
    Registry.desktop = false;
    Registry.chromeExtension = false;
    Registry.application$ = $({});
    Registry.transactions$ = $({});
    Registry.sendTransaction$ = $({});
    Registry.ON_WALLET_VALUE_CHANGE = 'ON_WALLET_VALUE_CHANGE';
    Registry.walletValue$ = $({});
    Registry.tempStorage = {};
    Registry.ON_KEY_INIT = 'ON_KEY_INIT';
    Registry.ON_COIN_ACTIVATED = 'ON_COIN_ACTIVATED';
    Registry.ON_COIN_DEACTIVATED = 'ON_COIN_DEACTIVATED';
    Registry.ON_BALANCE_CHANGED = 'ON_BALANCE_CHANGED';
    Registry.ON_SPENDABLE_CHANGED = 'ON_SPENDABLE_CHANGED';
    Registry.ON_ADDRESS_CHANGED = 'ON_ADDRESS_CHANGED';
    Registry.ON_TRANSACTIONS_CHANGED = 'ON_TRANSACTIONS_CHANGED';
    Registry.ON_ACTIVE_CURRENCIES_CHANGED = 'ON_ACTIVE_CURRENCIES_CHANGED'; // fired FiatPriceController::setActiveFiatCurrencies() when a fiat currency is enabled/disabled/reordered        
    Registry.ON_FIAT_MAIN_CURRENCY_CHANGE = 'ON_FIAT_MAIN_CURRENCY_CHANGE'; // fired by FiatPriceController::settActiveFiatCurrency() when the user changes the currency displayed in the wallet
    jaxx.Registry = Registry;
    Registry.start = Date.now();
})(jaxx || (jaxx = {}));
//# sourceMappingURL=Registry.js.map
var jaxx;
(function (jaxx) {
    var IntroPagesMain = (function () {
        function IntroPagesMain(js_instance) {
            this.js_instance = js_instance;
            this.init();
        }
        IntroPagesMain.prototype.init = function () {
            this.walletSettings = new jaxx.CoinsListSetup(this.js_instance);
        };
        return IntroPagesMain;
    }());
    jaxx.IntroPagesMain = IntroPagesMain;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=intro-pages-main.js.map
var jaxx;
(function (jaxx) {
    var CoinsListSetup = (function () {
        function CoinsListSetup(flag) {
            this.flag = flag;
            CoinsListSetup.instance = this;
            this.init();
        }
        /**
         * Initializes the coin list setup screen
         * @method init
         * */
        CoinsListSetup.prototype.init = function () {
            var _this = this;
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.MODULE_REDY, this);
            this.$list = $('.coinList tbody');
            this.$list.each(function (item, list) {
                $(list).on('click', 'tr', function (evt) {
                    var row = $(evt.currentTarget);
                    //TO-DO -- Separate into function
                    var symbol = row.data('symbol');
                    if (!symbol)
                        return;
                    row.toggleClass('selected');
                    var selected = row.hasClass('selected');
                    var ctr = jaxx.Registry.getCryptoControllerBySymbol(symbol);
                    if (ctr)
                        ctr.enabled = selected;
                    else
                        console.error('cant get controller for ' + symbol);
                    var element = row.find('.cssSelectedCurrency .cssCircleUnchecked');
                    if (element) {
                        element.toggleClass('cssCurrencyisChecked');
                        jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_COIN_SATUS_CHANGED, [row.data('symbol'), element.hasClass('cssCurrencyisChecked')]);
                        console.log('controllers enabled ' + jaxx.Registry.getWalletsEnabledSorted().length);
                        if (jaxx.Registry.getWalletsEnabledSorted().length) {
                            console.error(_this.walletSetupTypeSelectedOption);
                            // (this.walletSetupTypeSelectedOption === "Express") ? $('.takeMeToWallet').show() : $('.btnCustomCurrencyContinue').show();
                            $('.takeMeToWallet').show();
                            $('.btnCustomCurrencyContinue').show();
                        }
                        else {
                            $('.takeMeToWallet').hide();
                            $('.btnCustomCurrencyContinue').hide();
                        }
                    }
                });
            });
            this.selectCurrency();
        };
        /**
         * Populates the coin list setup screen with appropriate coins and tokens
         * @method selectCurrency
         * @return void
         * */
        CoinsListSetup.prototype.selectCurrency = function () {
            this.walletSetupTypeSelectedOption = getStoredData("setUpTypeSelectedOption");
            this.$list.empty();
            var wallets = jaxx.Registry.getAllCryptoControllers();
            var html = '';
            wallets.forEach(function (wallet) {
                var coinAbbreviatedName = wallet.name;
                var coinFullDisplayName = wallet.displayName;
                var coinDisplaySymbol = wallet.threeLetterCode;
                var column1 = '<td  class="cssSelectedCurrency"><div class="cssCircleUnchecked"></div></td>';
                var imageReference;
                var isExtension = PlatformUtils.extensionCheck();
                var isDesktop = PlatformUtils.desktopCheck();
                if (!isExtension && !isDesktop) {
                    imageReference = encodeURIComponent(wallet.icon);
                }
                else {
                    imageReference = wallet.icon;
                }
                var hueRotation = wallet.hueRotate;
                var column3 = '<td class="coinIcon cssCoinIcon cssImageLogoIcon cssHighlighted" style="background: url(' + imageReference + ') center center no-repeat; filter: hue-rotate(' + hueRotation + 'deg)"><div class="image"></div></td>';
                var column4 = '<td class="coinLabel cssCoinLabel">' + coinDisplaySymbol + ' - ' + coinFullDisplayName + '</td>';
                var tr = '<tr data-symbol="' + wallet.symbol + '" class="cssOpacity cssCoinCurrency scriptAction coinType' + coinAbbreviatedName + " " + '" specialAction="selectCoinOptionExpress" value="' + coinAbbreviatedName + '">' + column1 + column3 + column4 + '</tr>';
                html += tr;
                wallet.enabled = false;
            });
            this.$list.html(html);
        };
        return CoinsListSetup;
    }());
    jaxx.CoinsListSetup = CoinsListSetup;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=pages-wallet-settings.js.map
/**
 * Created by jnewlands on 2017-AUG-14.
 */
var jaxx;
(function (jaxx) {
    var Formatters = (function () {
        function Formatters() {
        }
        //- balanceForDisplay -----------------------------------------------------------------------------------
        Formatters.balanceForDisplay = function (balance, mantissaLength) {
            var dynamicLength = -1;
            var mLength = (mantissaLength == null) ? -1 : mantissaLength;
            var zeroBalance = "0.";
            var zeroString = "";
            if (mLength !== -1) {
                for (var i = 0; i < mLength; i++) {
                    zeroBalance += "0";
                    zeroString += "0";
                }
            }
            else {
                zeroBalance += "0";
                zeroString += "0";
            }
            if (!balance || !balance.length)
                return zeroBalance;
            if (isNaN(Number(balance)))
                return null;
            var decimalLength = 0;
            var decimalNonZeroIndex = -1;
            var decimalNonZeroLength = 0;
            var decimalZeroIndex = -1;
            var displayBalance = balance;
            var hasDecimalPoint = false;
            var leadingNonZeroIndex = -1;
            var leadingZeroIndex = -1;
            var tailingZeroIndex = -1;
            // Analyze balance string.
            for (var i = 0; i < balance.length; i++) {
                var character = balance.charAt(i);
                if (character === ".") {
                    hasDecimalPoint = true;
                }
                else if (!hasDecimalPoint) {
                    if ((character !== "0") && (leadingNonZeroIndex === -1))
                        leadingNonZeroIndex = i;
                    if ((character === "0") && (leadingNonZeroIndex === -1))
                        leadingZeroIndex = i;
                }
                else {
                    decimalLength++;
                }
            }
            // Count tailing zeros.
            if (hasDecimalPoint) {
                for (var i = balance.length; i > 0; i--) {
                    var character = balance.charAt(i - 1);
                    if ((character !== "0") && (decimalNonZeroIndex === -1))
                        decimalNonZeroIndex = i;
                    if ((character === "0") && (decimalNonZeroIndex === -1))
                        decimalNonZeroLength++;
                }
                dynamicLength = decimalLength - decimalNonZeroLength;
                if (dynamicLength === 0)
                    dynamicLength = 1;
                if (dynamicLength > 8)
                    dynamicLength = 8;
            }
            // Remove leading zeros.
            if (leadingZeroIndex !== -1) {
                displayBalance = displayBalance.substr(leadingZeroIndex + 1, displayBalance.length);
                leadingZeroIndex = -1;
            }
            // Add single leading zero if missing.
            if (hasDecimalPoint && (leadingNonZeroIndex === -1) && (leadingZeroIndex === -1))
                displayBalance = "0" + displayBalance;
            // Magic number adjustments are for zero index - adding trailing zeros.
            var desiredLength = mLength;
            if (desiredLength === -1) {
                if (decimalNonZeroIndex !== -1) {
                    desiredLength = dynamicLength;
                }
                else {
                    desiredLength = 8;
                }
            }
            if (hasDecimalPoint && (decimalLength < desiredLength))
                displayBalance += zeroString.substr(0, desiredLength - decimalLength);
            if (hasDecimalPoint && (decimalLength > desiredLength))
                displayBalance = displayBalance.substring(0, displayBalance.length - (decimalLength - desiredLength));
            // Check if empty.
            if (!displayBalance.length) {
                displayBalance = zeroBalance;
            }
            else if (!hasDecimalPoint && (desiredLength > 0)) {
                displayBalance += "." + zeroString;
            }
            return displayBalance;
        };
        /** Takes a number and returns a number with dots separating every 3 digits.
         * Example input: 1000000000 => output: 1.000.000.000
         *
        */
        Formatters.formatFinancialNumber = function (rawNumber, separator) {
            if (separator === undefined) {
                separator = ',';
            }
            var integral_part = '';
            var fractionary_part = '';
            var result = '';
            var parts = [];
            var pos2 = 0;
            if (rawNumber.indexOf('.') != -1) {
                integral_part = rawNumber.substr(0, rawNumber.indexOf('.'));
                fractionary_part = rawNumber.substr(rawNumber.indexOf('.') + 1, rawNumber.length);
            }
            else {
                integral_part = rawNumber;
            }
            for (var pos = integral_part.length; pos > -3; pos -= 3) {
                pos2 = (Math.min(3, pos) * -1);
                parts.push(integral_part.substring(pos + pos2, pos));
            }
            var part_number = parts.length - 1;
            parts.forEach(function (value) {
                if (part_number != parts.length - 1) {
                    result = result + parts[part_number];
                    if (part_number != 0) {
                        result += separator;
                    }
                }
                part_number--;
            });
            //result = result.substr(result.indexOf('.'), 1);
            if (fractionary_part.length != 0) {
                result += '.' + fractionary_part;
            }
            return result;
        };
        //- isHex -----------------------------------------------------------------------------------------------
        Formatters.isHex = function (value) {
            if (!value && !value.length)
                return true;
            var valueAsNumber = parseInt(value, 16);
            return (valueAsNumber.toString(16).toLowerCase() === value.toLowerCase());
        };
        //- shiftValue ------------------------------------------------------------------------------------------
        Formatters.shiftValue = function (value, shiftCount) {
            if (isNaN(shiftCount))
                return value;
            if (shiftCount === 0)
                return value;
            if (!value)
                return null;
            if (isNaN(Number(value)))
                return null;
            if (jaxx.MATH.isZero(value))
                return null;
            var valueBN = new thirdparty.web3.BigNumber(value);
            var shiftedValue = valueBN.shift(shiftCount);
            return shiftedValue.toString(10);
        };
        //- shiftValueLeft --------------------------------------------------------------------------------------
        Formatters.shiftValueLeft = function (value, shiftCount) {
            shiftCount = Math.abs(shiftCount);
            var shiftedValue = this.shiftValue(value, -shiftCount);
            return shiftedValue;
        };
        //- shiftValueLeftAndFormat -----------------------------------------------------------------------------
        Formatters.shiftValueLeftAndFormat = function (value, shiftCount, mantissaLength) {
            shiftCount = Math.abs(shiftCount);
            var mLength = (mantissaLength) ? mantissaLength : 18;
            var shiftedValue = this.shiftValue(value, -shiftCount);
            var retValue = this.balanceForDisplay(shiftedValue, mLength);
            return retValue;
        };
        //- shiftValueRight -------------------------------------------------------------------------------------
        Formatters.shiftValueRight = function (value, shiftCount) {
            var shiftedValue = this.shiftValue(value, Math.abs(shiftCount));
            return shiftedValue;
        };
        //- shiftValueRightAndFormat ----------------------------------------------------------------------------
        Formatters.shiftValueRightAndFormat = function (value, shiftCount, mantissaLength) {
            var mLength = (mantissaLength) ? mantissaLength : 18;
            var shiftedValue = this.shiftValue(value, Math.abs(shiftCount));
            var retValue = this.balanceForDisplay(shiftedValue, mLength);
            return retValue;
        };
        Formatters.noExponentsStringFormat = function (value) {
            // if you conver to number it will be the same result.
            var data = String(value).split(/[eE]/);
            if (data.length == 1)
                return data[0];
            var z = '', sign = value < 0 ? '-' : '', str = data[0].replace('.', ''), mag = Number(data[1]) + 1;
            if (mag < 0) {
                z = sign + '0.';
                while (mag++)
                    z += '0';
                return z + str.replace(/^\-/, '');
            }
            mag -= str.length;
            while (mag--)
                z += '0';
            return str + z;
        };
        return Formatters;
    }());
    jaxx.Formatters = Formatters;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=formatters.js.map
/**
 * Created by Vlad on 10/6/2016.
 */
///<reference path="../../typings/jquery/jquery.d.ts"/>
///<reference path="../../typings/lodash/lodash.d.ts"/>
///<reference path="../app/Registry.ts"/>
var VOError = (function () {
    function VOError(errorType, message, body, symbol) {
        this.errorType = errorType;
        this.message = message;
        this.body = body;
        this.symbol = symbol;
    }
    return VOError;
}());
var CoinType;
(function (CoinType) {
    CoinType[CoinType["ERC20"] = 0] = "ERC20";
})(CoinType || (CoinType = {}));
var AddressType;
(function (AddressType) {
    AddressType[AddressType["RECEIVE"] = 0] = "RECEIVE";
    AddressType[AddressType["CHANGE"] = 1] = "CHANGE";
})(AddressType || (AddressType = {}));
var VOBalance = (function () {
    function VOBalance(obj) {
        for (var str in obj)
            this[str] = obj[str];
    }
    return VOBalance;
}());
var VOBalanceTemp = (function () {
    function VOBalanceTemp(obj) {
        for (var str in obj)
            this[str] = obj[str];
    }
    return VOBalanceTemp;
}());
var VOBalanceSend = (function () {
    function VOBalanceSend(obj) {
        for (var str in obj)
            this[str] = obj[str];
    }
    return VOBalanceSend;
}());
var VOBalanceDiff = (function () {
    function VOBalanceDiff(id, balanceOld, balanceNew) {
        this.id = id;
        this.balanceOld = balanceOld;
        this.balanceNew = balanceNew;
    }
    return VOBalanceDiff;
}());
/* export class VOSendTransactionResult{
 message:string;
 confirmed:boolean;
 error:number;
 }*/
//////////////////////////////////////Bitcoin send transaction /////////////////////
var VOTransactionSent = (function () {
    function VOTransactionSent(obj) {
        for (var str in obj)
            this[str] = obj[str];
        if (this.inputs)
            this.inputs = this.inputs.map(function (o) { return new VOInput(o); });
        if (this.outputs)
            this.outputs = this.outputs.map(function (o) { return new VOOutput(o); });
    }
    return VOTransactionSent;
}());
/////////////////////////////////////////////////////////////////////////////////////
var VOTransactionView = (function () {
    function VOTransactionView(obj) {
        for (var str in obj)
            this[str] = obj[str];
    }
    return VOTransactionView;
}());
var VOTransaction = (function () {
    //
    function VOTransaction(obj) {
        for (var str in obj)
            this[str] = obj[str];
    }
    return VOTransaction;
}());
var VOutxo = (function () {
    function VOutxo(obj) {
        for (var str in obj)
            this[str] = obj[str];
    }
    return VOutxo;
}());
var VOInput = (function () {
    function VOInput(obj) {
        for (var str in obj)
            this[str] = obj[str];
    }
    return VOInput;
}());
var VOOutput = (function () {
    function VOOutput(obj) {
        for (var str in obj)
            this[str] = obj[str];
    }
    return VOOutput;
}());
//# sourceMappingURL=models.js.map
/**
 * Created by Vlad on 10/7/2016.
 *
 */
var jaxx;
(function (jaxx) {
    var Utils = (function () {
        function Utils() {
        }
        Utils.subtractUTXOS = function (allUtxos, spentUtxos) {
            var indexed = {};
            spentUtxos.forEach(function (item) {
                indexed[item.txid + item.address] = item;
            });
            //   let diff = _.differenceBy(utxos, spentUtxos, 'txid');
            return allUtxos.filter(function (item) {
                return !indexed[item.txid + item.address];
            });
        };
        Utils.generateQRCode = function (source, large) {
            var res = large ? 7 : 5;
            if (!Utils.qrcodes[source + res]) {
                Utils.qrcodes[source + res] = "data:image/png;base64," + thirdparty.qrImage.imageSync(source, { type: "png", ec_level: "H", size: res, margin: 1 }).toString('base64');
            }
            return Utils.qrcodes[source + res];
        };
        Utils.sumBalances = function (balances) {
            var ar = [];
            balances.forEach(function (item) {
                if (item.balance !== '0')
                    ar.push(item.balance);
            });
            return jaxx.MATH.sum(ar);
        };
        Utils.createTokenData = function (web3, amount, address) {
            //send max for tokens issue use big number library to parse value amount
            var ABI = web3.toBigNumber(amount, 10).toString(16); //amount;//parseInt(amount).toString(16);
            while (ABI.length < 64)
                ABI = '0' + ABI;
            address = address.substr(2);
            while (address.length < 64)
                address = '0' + address;
            var ethData = address + ABI;
            return '0xa9059cbb' + ethData;
        };
        Utils.mapEthereumTransaction = function (web3, addressTo, amount, nonce, gasPrice, gasLimit, data) {
            return {
                nonce: web3.toHex(nonce),
                gasPrice: web3.toHex(gasPrice),
                gasLimit: web3.toHex(gasLimit),
                to: addressTo,
                value: web3.toHex(amount),
                data: data
            };
        };
        Utils.backNavigation = function () {
            Navigation.popSettings();
        };
        Utils.remoteToggleMainMenu = function () {
            Navigation.popSettings();
            if (Utils._mainMenuIsOpen === true) {
                Utils.closeMainMenu();
            }
            else {
                Utils.openMainMenu();
            }
        };
        Utils.closeMainMenu = function () {
            Utils._mainMenuIsOpen = false;
            g_JaxxApp._ui.closeMainMenu();
        };
        Utils.openMainMenu = function () {
            Utils._mainMenuIsOpen = true;
            g_JaxxApp._ui.openMainMenu();
        };
        Utils.copyClipboard = function (copyValue) {
            // let address = this.currentAddress;
            var sandbox = $('#clipboard');
            sandbox.val(copyValue).select();
            document.execCommand('copy');
            sandbox.val('').blur();
            if (window.native && window.native.copyToClipboard) {
                window.native.copyToClipboard(copyValue);
            }
            Navigation.flashBanner('Copied to clipboard', 2, 'success', { close: false });
        };
        Utils.mapTransactionsBitcoin = function (transactions, myAddresses) {
            // object all addresses to detect is transaction incoming or outgoing
            var myAddrObj = myAddresses.reduce(function (out, val) { out[val] = 1; return out; }, {});
            transactions.forEach(function (transaction) {
                // PLEASE REMOVE THIS ASAP, A SPELLING ERROR SHOULD NOT BE HANDLED LIKE THIS
                if (!transaction.from) {
                    transaction.from = transaction.form;
                }
                /// if from not contains my address transaction incoming
                transaction.incoming = !!myAddrObj[transaction.from] ? 0 : 1;
                // if outputs more then one use function to get sum of all outputs
                if (transaction.tos.length > 1) {
                    Utils.setValueForAddresses(myAddresses, transaction);
                }
                else {
                    transaction.to = transaction.tos[0];
                    transaction.displayValue = transaction.values[0];
                }
                /*
                     if(transaction.incoming){
                         if(transaction.tos.length > 2){
     
                         }else{
     
                             if(myAddresses.indexOf(transaction.to) ===-1 && transaction.tos.length>1){
                                 transaction.to = transaction.tos[1];
                                 transaction.displayValue = transaction.values[1];
                             }
                         }
     
                     }else{
     
                         transaction.to = transaction.tos[0];
                         transaction.displayValue = transaction.values[0];
     
                         if(myAddresses.indexOf(transaction.to) !==-1 && transaction.tos.length>1){
                             transaction.to = transaction.tos[1];
                             transaction.displayValue = transaction.values[1];
                         }
                     }
     */
                // if from and to my address send yourself
                if (myAddrObj[transaction.to] && myAddrObj[transaction.from]) {
                    transaction.displayValue = '0';
                    transaction.to = 'Self';
                }
                transaction.displayMiningFee = transaction.miningFee;
                Utils.displayStringShortner(transaction);
                transaction.displayValue = Utils.getDisplayValue(transaction.displayValue);
            });
        };
        ;
        Utils.displayStringShortner = function (transaction) {
            transaction.address = transaction.incoming ? transaction.from : transaction.to;
            transaction.displayTxid = transaction.id.substr(0, 4) + '...' + transaction.id.substr(-5);
            if (transaction.address) {
                transaction.displayAddress = transaction.address.substr(0, 4) + '...' + transaction.address.substr(-5);
            }
            else {
                transaction.displayAddress = 'Self';
            }
        };
        /**
         *
         * @param {Array<string>} addresses
         * @param {VOTransaction} transaction
         * @returns {number}
         */
        Utils.setValueForAddresses = function (addresses, transaction) {
            var value = 0;
            if (transaction.incoming) {
                for (var i = 0; i < addresses.length; i++) {
                    var j = transaction.tos.indexOf(addresses[i]);
                    if (j !== -1) {
                        value = value + Number(transaction.values[j]);
                        transaction.to = transaction.tos[j];
                    }
                }
            }
            else {
                for (var i = 0; i < transaction.tos.length; i++) {
                    var j = addresses.indexOf(transaction.tos[i]);
                    if (j === -1) {
                        value = value + Number(transaction.values[i]);
                        transaction.to = transaction.tos[i];
                    }
                }
            }
            transaction.displayValue = String(value);
            //return String(value);
        };
        /**
         *
         * @param {string} value
         * @returns {string}
         */
        Utils.getDisplayValue = function (value) {
            var displayValue = String(value).split('.');
            if (displayValue.length === 2) {
                if (displayValue[0].length > 3) {
                    displayValue[1] = displayValue[1].substr(0, 2);
                }
                else {
                    displayValue[1] = displayValue[1].substr(0, 5);
                }
            }
            return displayValue.join('.');
        };
        Utils.mapDisplayTransactionsEthereum = function (trs, myAddresses, symbol) {
            trs.forEach(function (item) {
                Utils.mapDisplayTransactionEthereum(item, myAddresses, symbol);
            });
        };
        Utils.mapDisplayTransactionEthereum = function (tr, myAddresses, symbol) {
            var value = jaxx.MATH.weiToEther(tr.value);
            var ar = value.split('.');
            if (ar.length == 2) {
                if (ar[0].length > 3) {
                    ar[1] = ar[1].substr(0, 2);
                }
                else {
                    ar[1] = ar[1].substr(0, 5);
                }
            }
            tr.displayValue = ar.join('.');
            // boolean slower then number
            tr.incoming = myAddresses.indexOf(tr.from) !== -1 ? 0 : 1;
            Utils.displayStringShortner(tr);
            tr.displayMiningFee = tr.miningFee; // (MATH.weiToEther((+tr.gas*+tr.gasPrice) +'')).toString();// + ' ' + symbol;
            tr.symbol = symbol;
        };
        Utils.calculateSpendableUTXOs = function (utxos, miningFeeFixed, minIncludeInt) {
            var miningFeeDecimal = +miningFeeFixed / 1e8;
            var minIncludeDecimal = +minIncludeInt / 1e8;
            var totalDecimal = 0;
            var countInputs = 0;
            console.log('miningFeeDecimal   ' + miningFeeDecimal + ' minIncludeDecimal ' + minIncludeDecimal);
            var out = [];
            utxos.forEach(function (item) {
                if (minIncludeInt && item.decimal > minIncludeDecimal) {
                    totalDecimal += item.decimal;
                    out.push(item.satoshis);
                    console.log('totalDecimal  ' + totalDecimal + '  item.decimal  ' + item.decimal);
                    countInputs++;
                }
                else {
                    console.log('%c  DUST ' + item.decimal, 'color:red');
                    // total += item.amount;
                    // count++;
                }
            });
            var sum = jaxx.MATH.sum(out);
            console.log(sum);
            var spendableInt = jaxx.MATH.subtract(sum, miningFeeFixed);
            console.log(spendableInt);
            return jaxx.MATH.satoshiToBtc(spendableInt);
        };
        Utils.calculateSpendableBitcoinUTXOs = function (utxos, miningFeePerKilobyte, numOuts, bytesPerInput, useFilter, miningFeeFixed) {
            if (numOuts === void 0) { numOuts = 1; }
            if (bytesPerInput === void 0) { bytesPerInput = 148; }
            if (useFilter === void 0) { useFilter = true; }
            var perByteInt = miningFeePerKilobyte / 1024;
            var priceInt = bytesPerInput * perByteInt;
            var perByteDecimal = perByteInt / 1e8;
            var priceDecimals = priceInt / 1e8;
            var miningFeeDecimal = miningFeePerKilobyte / 1e8;
            var totalDecimal = 0;
            var countInputs = 0;
            if (utxos) {
                utxos.forEach(function (item) {
                    if (useFilter && item.decimal > priceDecimals) {
                        totalDecimal += item.decimal;
                        countInputs++;
                    }
                    else {
                        console.log('%c  DUST ' + item.decimal, 'color:red');
                        // total += item.amount;
                        // count++;
                    }
                });
            }
            var spendableDecimal;
            if (miningFeeFixed) {
                spendableDecimal = totalDecimal - (+miningFeeFixed / 1e8);
                return spendableDecimal;
            }
            var totalBytes = (bytesPerInput * countInputs) + (34 * numOuts) + 10;
            var feeDecimal = (totalBytes * perByteDecimal); ///1e8;
            spendableDecimal = (totalDecimal - feeDecimal);
            console.log('totalBytes    ' + totalBytes);
            console.log(' totalDecimal ' + totalDecimal);
            console.log('   feeDecimal ' + feeDecimal);
            console.log('spendableDecimal  ' + spendableDecimal);
            return spendableDecimal;
        };
        Utils.updateBalances = function (balances, new_bals) {
            var indexed = _.keyBy(new_bals, 'id');
            var stamp = Date.now();
            var out = [];
            // console.log(indexed);
            balances.forEach(function (item) {
                var new_bal = indexed[item.id];
                if (new_bal) {
                    item.timestamp = new_bal.timestamp;
                    if (item.balance !== new_bal.balance) {
                        // console.log(item.id + ' ' + item.balance + '  ' + new_bal.balance);
                        //item.delta = new_bal.decimal - item.decimal;
                        item.balance = new_bal.balance;
                        out.push(item);
                    } //else //item.delta = 0;
                }
                else
                    console.log(item.id + ' is missing ');
            });
            return out;
        };
        Utils.filterBalanceOnAddress = function (address, balances) {
            for (var i = balances.length - 1; i >= 0; i--)
                if (balances[i].id === address)
                    return balances[i].balance;
            return '';
        };
        Utils.updateUTXOS = function (old_utxo, new_utxo) {
            if (!Array.isArray(old_utxo) || !Array.isArray(new_utxo)) {
                console.error(old_utxo, new_utxo);
            }
            var n_indexed = {};
            new_utxo.forEach(function (item) {
                n_indexed[item.txid + item.index] = item;
            });
            var out = [];
            old_utxo.forEach(function (item) {
                if (n_indexed[item.txid + item.index]) {
                    //console.log( ' updating utxo old/new ',item, n_indexed[item.txid + item.index] );
                    out.push(n_indexed[item.txid + item.index]);
                }
                else {
                    out.push(item);
                }
            });
            return out;
        };
        Utils.createUTXOFromOutput = function (output) {
            return new VOutxo({});
        };
        Utils.createTempBalancesFromInputs = function (inputs, toAddress) {
            var out = [];
            var indexed = {};
            inputs.forEach(function (item) {
                if (indexed[item.address])
                    indexed[item.address].spent += (-item.amount);
                else
                    indexed[item.address] = new VOBalanceTemp({
                        id: item.address,
                        spent: -item.amount,
                        from: item.address,
                        to: toAddress,
                        timestamp: Date.now()
                    });
            });
            for (var str in indexed) {
                out.push(indexed[str]);
            }
            return out;
        };
        Utils.constartcInput2Keys = function (ar) {
            var out = [];
            ar.forEach(function (item) {
                out.push(item.previousTxId + '_' + item.previousIndex);
            });
            return out;
        };
        Utils.setInQueueUTXOsBy2Keys = function (utxos, keys2) {
            var now = Date.now();
            for (var i = utxos.length - 1; i >= 0; i--) {
                var key = utxos[i].txid + '_' + utxos[i].index;
                if (keys2.indexOf(key) !== -1) {
                    utxos[i].inqueue = true;
                    utxos[i].queueTimesatmp = now;
                }
            }
        };
        Utils.removeUTXOsBy2Keys = function (utxos, keys2) {
            for (var i = utxos.length - 1; i >= 0; i--) {
                var key = utxos[i].txid + '_' + utxos[i].index;
                if (keys2.indexOf(key) !== -1) {
                    utxos.splice(i, 1);
                }
            }
        };
        Utils.removeUTXOsBy2KeysID = function (utxos, keys2id) {
            for (var i = utxos.length - 1; i >= 0; i--) {
                var key = utxos[i].txid + '_' + utxos[i].index;
                if (key === keys2id) {
                    utxos.splice(i, 1);
                }
            }
        };
        /* static remapTransactionsToOldCode(unspent: VOTransactionUnspent[], controller: JaxxCryptoController): any[] {
 
             let out: any[] = [];
             for (let i = 0, n = unspent.length; i < n; i++) {
                 let trs = unspent[i];
 
                 out.push({
                     address: trs.address,
                     addressIndex: controller.getAddressIndex(trs.address),
                     addressInternal: controller.isAddressInternal(trs.address),
                     amount: trs.amount,
                     amountBtc: trs.amountBtc + '',
                     confirmations: trs.confirmations,
                     index: trs.index,
                     spent: false,
                     standard: true,
                     timestamp: trs.timestamp,
                     txid: trs.id
                 })
 
             }
             return out;
         }
 */
        /*
                static getTransactionsUnspentFromVORelayedTransactionList(data: VORelayedTransactionList[]): ReferenceRelaysUTXOData[] {
                    let out: ReferenceRelaysUTXOData[] = [];
                    data.forEach(function (item) {
                        var addr = item.address;
                        let utxo: any = item.utxoListDict;
                        for (let str in utxo) {
                            utxo[str].address = addr;
                            out.push(new ReferenceRelaysUTXOData(utxo[str]))
                        }
                        ;
        
                    });
        
                    return out;
                }*/
        Utils.deepCopy = function (obj) {
            var json = JSON.stringify(obj);
            var returned_object = JSON.parse(json);
            return returned_object;
        };
        Utils.addresseFromBalances = function (balances) {
            var out = [];
            balances.forEach(function (balance) {
                out.push(balance.id);
            });
            return out;
        };
        Utils.isCompleteBalances = function (addreses, balancess) {
            if (addreses.length !== balancess.length) {
                console.error(' missing balances  ');
                return false;
            }
            for (var i = 0, n = addreses.length; i < n; i++) {
                balancess[i].index = i;
                if (addreses[i] !== balancess[i].id)
                    return false;
            }
            return true;
        };
        Utils.reorderBalances = function (addreses, balancess) {
            var balIndexed = _.keyBy(balancess, 'id');
            var out = [];
            var i = 0;
            addreses.forEach(function (address) {
                var balance = balIndexed[address];
                if (balance)
                    balIndexed[address].index = i++;
                else
                    console.error('cant find balance for address: ' + address); ///balance = new VOBalance({id: address, balance: 0, timestamp: Date.now()});
                out.push(balance);
            });
            return out;
        };
        Utils.updateOldBalances2 = function (oldbalances, newbalances) {
            console.log('updateOldBalances ' + oldbalances.length + '  ' + newbalances.length);
            var out = [];
            var indexed = _.keyBy(newbalances, 'id');
            oldbalances.forEach(function (b_old) {
                var b_new = indexed[b_old.id];
                if (b_new) {
                    if (b_old.balance !== b_new.balance) {
                        console.log(' updating balance ' + b_new.id);
                        out.push(new VOBalanceDiff(b_new.id, b_old.balance, b_new.balance));
                        b_old.balance = b_new.balance;
                        b_old.timestamp = Math.floor(Date.now() / 1000);
                    }
                }
                else {
                    console.error(' unknown balance ', b_old);
                }
                // }
            });
            return out;
        };
        Utils.updateOldBalances = function (oldbalances, newbalances) {
            console.log('updateOldBalances ' + oldbalances.length + '  ' + newbalances.length);
            var out = [];
            var indexed = {};
            oldbalances.forEach(function (b) {
                indexed[b.id] = b;
            });
            newbalances.forEach(function (b_new) {
                if (!b_new) {
                    console.log(b_new);
                }
                else {
                    var b_old = indexed[b_new.id];
                    if (b_old) {
                        if (b_old.balance != b_new.balance) {
                            console.log(' updating balance ' + b_new.id);
                            out.push(new VOBalanceDiff(b_new.id, b_old.balance, b_new.balance));
                            b_old.balance = b_new.balance;
                            b_old.timestamp = Math.floor(Date.now() / 1000);
                        }
                    }
                    else {
                        console.error(' unknown balance ', b_new);
                    }
                }
            });
            return out;
        };
        Utils.transactionsDiff = function (transactions1, transactions2) {
            var diff = [];
            var indexed = {};
            if (!transactions1 || !transactions1.length)
                return transactions2;
            // this function detects new transactions downloaded from server
            // do not mark as new transactions what older then exists
            // transactions1 are transactions from localStorage
            // transactions2 are newly downloaded transactions
            var last = _.last(transactions1);
            var max = last ? last.timestamp - (60 * 60) : moment().subtract(1, 'day').unix();
            //console.log(new Date(max* 1000).toISOString());
            transactions1.forEach(function (tr) { return indexed[tr.id] = 1; });
            transactions2.forEach(function (tr) {
                //  console.log(new Date(tr.timestamp * 1000).toISOString());
                if ((tr.timestamp > max) && !indexed[tr.id])
                    diff.push(tr);
            });
            return diff;
        };
        /* static getNoncesOfAddresses(addresses:string[], transactions:VOTransaction[]):any {
         var nonces:any = {};
         addresses.forEach(function(address) {
         nonces[address] = 0;
         });

         transactions.forEach(function(transaction) {
         var from:string = transaction.from;

         if (!isNaN(nonces[from])) nonces[from]++;
         else nonces[from] = 0;

         });
         return nonces;
         }*/
        Utils.removeTempRemote = function (transactions) {
            transactions.forEach(function (transaction) {
                delete transaction.tempRemote;
                delete transaction.nonce;
                delete transaction.outs;
            });
        };
        Utils.getNoncesOfAddresses = function (transactions) {
            var nonces = {};
            /* transactions.forEach(function(trs) {
             nonces[trs.from] = 0;
             });*/
            transactions.forEach(function (transaction) {
                if (transaction.from === transaction.address) {
                    var from = transaction.from;
                    //@note: @here: @codereview: what logic is implying this isNaN switch is correct..
                    if (isNaN(nonces[from]))
                        nonces[from] = 1;
                    else
                        nonces[from]++;
                }
            });
            return nonces;
        };
        Utils.staticGetAddressesFromTransactions = function (trs) {
            var out = [];
            trs.forEach(function (item) {
                var addr = item.address;
                if (out.indexOf(addr) === -1)
                    out.push(addr);
            });
            return out;
        };
        Utils.splitInCunks = function (ar, length) {
            var out = [];
            for (var i = 0, n = ar.length; i < n; i += length) {
                out.push(ar.slice(i, i + length));
            }
            return out;
        };
        Utils.getObjectTotal = function (obj) {
            var total = 0;
            for (var str in obj) {
                total += obj[str].valueDelta;
            }
            return total;
        };
        Utils.filterLatest = function (ar, timestamp) {
            var out = [];
            ar.forEach(function (item) {
                if (item.timestamp > timestamp)
                    out.push(item);
            });
            return out;
        };
        Utils.sortByBalance = function (ar) {
            ar.sort(function (a, b) {
                if (a.balance > b.balance)
                    return 1;
                if (a.balance < b.balance)
                    return -1;
                return 0;
            });
        };
        Utils.sortTransactionsByBlock = function (ar) {
            ar.sort(function (a, b) {
                if (a.block > b.block)
                    return 1;
                if (a.block < b.block)
                    return -1;
                return 0;
            });
        };
        Utils.sortByTimestamp = function (ar) {
            ar.sort(function (a, b) {
                if (a.timestamp > b.timestamp)
                    return 1;
                if (a.timestamp < b.timestamp)
                    return -1;
                return 0;
            });
        };
        Utils.getArrayTotal = function (ar) {
            var total = 0;
            ar.forEach(function (item) {
                if (!isNaN(+item.valueDelta))
                    total += +item.valueDelta;
            });
            return total;
        };
        Utils.findAndReplaceById = function (arr, find, replace) {
            var i, n;
            for (i = 0, n = arr.length; i < n && arr[i].id != find.id; i++) {
            }
            i < n ? arr[i] = replace : arr.push(replace);
        };
        Utils.updateItemById = function (arr, item) {
            var i, n;
            for (i = 0, n = arr.length; i < n && arr[i].id != item.id; i++) {
            }
            i < n ? arr[i] = item : arr.push(item);
        };
        Utils.updateOldTransactions = function (oldtrs, newtrs) {
            var newInd = _.keyBy(newtrs, 'id');
            for (var i = oldtrs.length - 1; i >= 0; i--) {
                var id = oldtrs[i].id;
                if (newInd[id]) {
                    // if(oldtrs[i].isTemp) oldtrs.splice(i,1);
                    oldtrs[i].confirmations = newInd[id].confirmations;
                    //oldtrs[i].ti
                }
            }
            return oldtrs;
            /*oldtrs.forEach(function (trs) {
                if(newInd[trs.id]) trs = newInd[trs.id];
            });*/
        };
        Utils.getNewTransactions = function (oldtrs, newtrs) {
            var oldInd = _.keyBy(oldtrs, 'id');
            var out = [];
            newtrs.forEach(function (trs) {
                if (!oldInd[trs.id])
                    out.push(trs);
            });
            return out;
        };
        Utils.isArrayInObject = function (ar, obj) {
            for (var i = 0, n = ar.length; i < n; i++) {
                if (obj[ar[i]])
                    return true;
            }
            return false;
        };
        Utils.hasEnoughTimeElapsedToSleepJaxx = function () {
            var currentTime = new Date().getTime();
            if (typeof (jaxx.Registry.timeLastActive) === 'undefined' || jaxx.Registry.timeLastActive === null) {
                jaxx.Registry.timeLastActive = new Date();
            }
            if (currentTime - jaxx.Registry.timeLastActive.getTime() > 300000) {
                return true;
            }
            else {
                return false;
            }
        };
        return Utils;
    }());
    Utils.qrcodes = {};
    Utils.transactionsToArray = function (obj) {
        var out = [];
        for (var str in obj)
            out.push(obj[str]);
        return out;
    };
    jaxx.Utils = Utils;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=Utils.js.map
/**
 * Created by Vlad on 10/11/2016.
 */
///<reference path="models.ts"/>
var jaxx;
(function (jaxx) {
    var Utils2 = (function () {
        function Utils2() {
        }
        Utils2.getXpubAddress = function (coinHDIndex, network) {
            // return Utils2.getMasterNode(network).deriveHardened(44).deriveHardened(coinHDIndex).deriveHardened(0).derive(1).neutered().toBase58();/////.derive(address_index);
            return Utils2.getMasterNode(network).deriveHardened(44).deriveHardened(coinHDIndex).deriveHardened(0).neutered().toBase58(); /////.derive(address_index);
        };
        Utils2.signEther = function (etehr_trans, privateKey) {
            var buff = new Buffer(privateKey, 'hex');
            var tx = new thirdparty.ethereum.tx(etehr_trans);
            // var buf = new Buffer(this._pouchManager.getPrivateKey(fromNodeInternal, fromNodeIndex).d.toBuffer(32), 'hex');
            tx.sign(buff);
            return tx.serialize();
        };
        // static _mnemonic:string;
        Utils2.reset = function () {
            Utils2.seedHex = null;
        };
        Utils2.getWallet = function () {
            //  return wallet || jaxx.Registry.tempWallet;
            if (typeof (wallet) !== 'undefined' && wallet !== null) {
                return wallet;
            }
            else {
                return jaxx.Registry.tempWallet;
            }
        };
        Utils2.setMnemonic = function (mnemonic) {
            jaxx.GeneratorBlockchain.setMnemonic(mnemonic);
            Utils2.seedHex = thirdparty.bip39.mnemonicToSeedHex(mnemonic);
        };
        Utils2.getSeedHex = function () {
            if (!Utils2.seedHex)
                Utils2.seedHex = thirdparty.bip39.mnemonicToSeedHex(getStoredData('mnemonic', true));
            return Utils2.seedHex;
        };
        Utils2.setHex = function (mnemonicHex) {
            Utils2.seedHex = mnemonicHex;
        };
        Utils2.getMasterNode = function (network) {
            return thirdparty.bitcoin.HDNode.fromSeedHex(Utils2.getSeedHex(), network);
            /* var networkKey:string = "null";
 
             if (typeof(network) === 'undefined' || network === null) {
                 network = null;
             } else {
                 networkKey = network.messagePrefix.toString().hashCode().toString();
             }
 
             var masterNode:any = null;
 
             if (typeof(Utils2._masterNodeCache[networkKey]) !== 'undefined' && Utils2._masterNodeCache[networkKey] !== null) {
             } else {
                 Utils2._masterNodeCache[networkKey] = {network:null, masterHDNode:null};
                 Utils2._masterNodeCache[networkKey].network = network;
                 Utils2._masterNodeCache[networkKey].masterHDNode = thirdparty.bitcoin.HDNode.fromSeedHex(Utils2.getSeedHex(), network);
             }
 
             masterNode = Utils2._masterNodeCache[networkKey].masterHDNode;
 
             return masterNode;*/
        };
        /*
         BIP0044 specifies the structure as consisting of five predefined tree levels:
         m / purpose' / coin_type' / account' / change / address_index
         */
        Utils2.getReceiveNode = function (coinHDIndex, address_index, network) {
            var account = 0; // most of the time 0
            // var rootNode = thirdparty.bitcoin.HDNode.fromSeedHex(Utils2.seedHex, network);
            /*  var networkDash = {
                  messagePrefix: '\x19DarkCoin Signed Message:\n',
                  bip32: {
                      public: 0x02fe52cc,
                      private: 0x02fe52f8
                  },
                  pubKeyHash: 0x4c,
                  scriptHash: 0x10,
                  wif: 0xcc,
                  dustThreshold: 5460
              }*/
            // thirdparty.bitcoin.HDNode.fromSeedHex(Utils2.seedHex, networkDash).deriveHardened(44).deriveHardened(coinHDIndex).deriveHardened(account).derive(0).derive(address_index);
            return Utils2.getMasterNode(network).deriveHardened(44).deriveHardened(coinHDIndex).deriveHardened(account).derive(0).derive(address_index);
        };
        Utils2.getChangeNode = function (coinHDIndex, address_index, network) {
            // var rootNode = thirdparty.bitcoin.HDNode.fromSeedHex(Utils2.seedHex, network);
            var account = 0; // most of the time 0
            return Utils2.getMasterNode(network).deriveHardened(44).deriveHardened(coinHDIndex).deriveHardened(account).derive(1).derive(address_index);
        };
        Utils2.getNodeKeyPair = function (node) {
            return node.keyPair;
        };
        Utils2.getNodePrivateKey = function (node, encodingType) {
            if (encodingType) {
                return node.keyPair.toWIF();
            }
            else {
                return node.keyPair.d.toBuffer(32).toString('hex');
            }
        };
        Utils2.getPrivateKey = function (keyPair) {
            return keyPair.d.toBuffer(32).toString('hex');
        };
        Utils2.getKeyPairBuffer = function (keyPair) {
            return new Buffer(keyPair.d.toBuffer(32), 'hex');
        };
        Utils2.getEtherAddress = function (node) {
            var ethKeyPair = node.keyPair; //        console.log("[ethereum] keyPair :: " + ethKeyPair.d + " :: " + ethKeyPair.__Q);
            var prevCompressed = ethKeyPair.compressed;
            ethKeyPair.compressed = false;
            var pubKey = ethKeyPair.getPublicKeyBuffer();
            //  console.log('ethKeyPairPublicKey     ',ethKeyPairPublicKey);
            var pubKeyHexEth = pubKey.toString('hex').slice(2);
            //  console.log('pubKeyHexEth    ',pubKeyHexEth);
            var pubKeyWordArrayEth = thirdparty.CryptoJS.enc.Hex.parse(pubKeyHexEth);
            var hashEth = thirdparty.CryptoJS.SHA3(pubKeyWordArrayEth, { outputLength: 256 });
            var address = hashEth.toString(thirdparty.CryptoJS.enc.Hex).slice(24);
            ethKeyPair.compressed = prevCompressed;
            return "0x" + address;
        };
        Utils2.getBitcoinAddress1 = function (node) {
            //  console.warn('getBitcoinAddress   ');
            return node.keyPair.getAddress();
            /* var pubKey = node.keyPair.getPublicKeyBuffer();
             var pubKeyHash = thirdparty.bitcoin.crypto.hash160(pubKey);
 
             var payload = new Buffer(21);
             //    console.log("bitcoin :: pubkeyhash :: " + node.keyPair.network.pubKeyHash);
             payload.writeUInt8(node.keyPair.network.pubKeyHash, 0);
             pubKeyHash.copy(payload, 1);
 
             var address = thirdparty.bs58check.encode(payload);
 
             //        console.log("[bitcoin] address :: " + address);
             return address;*/
        };
        //////////////////////////////////////
        Utils2.getOldChangeNode = function (mnemonic, network, cointype, address_index) {
            var seedHex = thirdparty.bip39.mnemonicToSeedHex(mnemonic);
            var rootNodeBase58 = thirdparty.bitcoin.HDNode.fromSeedHex(seedHex, network).toBase58();
            var rootNode = thirdparty.bitcoin.HDNode.fromBase58(rootNodeBase58, network);
            var accountNodeBase58 = rootNode.derive(44).derive(cointype).derive(0).toBase58();
            var accountNode = thirdparty.bitcoin.HDNode.fromBase58(accountNodeBase58, network);
            var changeNodeBase58 = accountNode.derive(1).toBase58();
            var changeNode = thirdparty.bitcoin.HDNode.fromBase58(changeNodeBase58, network);
            return changeNode;
        };
        return Utils2;
    }());
    jaxx.Utils2 = Utils2;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=Utils2.js.map
/**
 * Created by Nilang.
 */
var jaxx;
(function (jaxx) {
    var Seed = (function () {
        function Seed() {
        }
        Seed.generateMnemonic = function () {
            return thirdparty.bip39.generateMnemonic();
        };
        Seed.validateSeed = function (seed) {
            return (thirdparty.bip39.validateMnemonic(seed)) ? true : false;
        };
        /*    static getEncryptedSeed(): string {
                var getSeed = getStoredData("mnemonic", true);
                if (typeof(getSeed) !== 'undefined' && getSeed !== null){
                    return getStoredData("mnemonic");
                } else {
                    return this.generateSeed();
                }
    
            }
    */
        Seed.encryptSimple = function (clearTxt) {
            this._keyB = thirdparty.CryptoJS.enc.Base64.parse(this._key);
            this._ivB = thirdparty.CryptoJS.enc.Base64.parse(this._iv);
            var encrypted = thirdparty.CryptoJS.AES.encrypt(clearTxt, this._keyB, { iv: this._ivB });
            var encryptedString = encrypted.toString();
            return encryptedString;
        };
        Seed.decryptSimple = function (encryptedTxt) {
            this._keyB = thirdparty.CryptoJS.enc.Base64.parse(this._key);
            this._ivB = thirdparty.CryptoJS.enc.Base64.parse(this._iv);
            var decrypted = thirdparty.CryptoJS.AES.decrypt(encryptedTxt, this._keyB, { iv: this._ivB });
            var decryptedText = decrypted.toString(thirdparty.CryptoJS.enc.Utf8);
            return decryptedText;
        };
        return Seed;
    }());
    //Encrypt using google crypto-js AES-base cypher
    Seed._key = "6Le0DgMTAAAAANokdfEial"; //length=22
    Seed._iv = "mHGFxENnZLbienLyALoi.e"; //length=22
    jaxx.Seed = Seed;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=seed.js.map
/*
Purpose:
1 Provide transaction price per byte to build transaction
2. Adjust spendable according current price
2. Store and retrieve user settings mining fee "fast | average | slow"

Functionality:
 1. download mining fee from  url  provided in config
 2. Save data in local storage
 3. Save User settings
 4. Provide price per byte according user settings

 Info:
 url in config file  for each coin  "miningFeeUrl"
 "useGasPriceApi": true  has to be set to use url otherwise
 "miningFeePerByte":150 has to be set
 if absent files will be downloaded from application local filesystem " data/miningFeeDASH.json, data/miningFeeLTC.json ......"
 data has to have specific format  similar to BTC now

{"fastestFee": 150,
    "halfHourFee": 170,
    "hourFee": 120
}

downloaded data saved in local storage with keys symbol + 'mining-fee';
data updated after 6 min expired when coin active and not updated when coin not active
if no data provided default { fast: 300, average:200, slow: 100, timestamp:0}

Interfaces added:

in coin-controller to access MiningFeeController class

interface ICoinWithMiningFee{
    getMiningFeeValueCtr():IMiningFeeValue;
    getIMiningFeeOptionCtr():IMiningFeeOption;
}
MiningFeeController has 2 interfaces for UI and DCL

For UI to set/get user options:
interface IMiningFeeOption{
    setCurrentOption(option:string)
    getCurrentOption():string
}

to access interface from UI:
 let ctr:ICoinWithMiningFee =  Registry.getCryptoControllerBySymbol('BTC');
 ctr.getIMiningFeeOptionCtr().setCurrentOption(option);

For DCL to get price per Byte and adjust spendable
interface IMiningFeeValue{
    getMiningFeePerByte():number;
    subtractMiningFee(total:string, length:number):string;
}

interface access from DCL :
let ctr:ICoinWithMiningFee =  Registry.getCryptoControllerBySymbol('BTC');
 ctr.getMiningFeeValueCtr().getMiningFeePerByte()

*/
var jaxx;
(function (jaxx) {
    var MiningFeeController = (function () {
        function MiningFeeController(config, storage) {
            this.config = config;
            this.storage = storage;
            this.keyData = config.symbol + 'mining-fee';
            this.keyOption = config.symbol + 'mining-option';
        }
        // used by controller to start update timer
        MiningFeeController.prototype.activate = function () {
            var _this = this;
            if (this.isActive)
                return;
            this.isActive = true;
            this.downloadMingFee();
            this.interval = setInterval(function () { return _this.downloadMingFee(); }, 6 * 60 * 1000);
        };
        // used by controller to stop update timer
        MiningFeeController.prototype.deactivate = function () {
            if (!this.isActive)
                return;
            this.isActive = false;
            clearInterval(this.interval);
        };
        // UI interface to set user option "fast | average | slow"
        MiningFeeController.prototype.setCurrentOption = function (option) {
            this.current = option;
            this.storage.setItem(this.keyOption, option);
        };
        // UI interface  to retrieve user option
        MiningFeeController.prototype.getCurrentOption = function () {
            if (!this.current)
                this.current = this.storage.getItem(this.keyOption) || this.config.miningFeeOption || 'average';
            return this.current;
        };
        // DCL interface  returns price ether form download data or from config file
        MiningFeeController.prototype.getMiningFeePerByte = function () {
            if (!this.config.useMiningFeeApi && this.config.miningFeePerByte)
                return this.config.miningFeePerByte;
            return this.getMiningFee();
        };
        MiningFeeController.prototype.getMiningFee = function () {
            if (!this.data) {
                this.data = JSON.parse(this.storage.getItem(this.keyData)) || { fast: 300, average: 200, slow: 100, timestamp: 0 };
            }
            return this.data[this.getCurrentOption()];
        };
        MiningFeeController.prototype.setData = function (data) {
            this.data = data;
            data.timestamp = Date.now();
            this.storage.setItem(this.keyData, JSON.stringify(data));
        };
        // DCL interface to calculate spendable taking sum of UTXOs and amount of UTXOs
        // returns amount user can spend in consideration current mining fee settings
        MiningFeeController.prototype.subtractMiningFee = function (total, length) {
            var price = this.getMiningFeePerByte();
            var bytesPerInput = 148;
            var countInputs = length;
            var numOuts = 2;
            var totalBytes = (bytesPerInput * countInputs) + (34 * numOuts) + 10;
            var feeTotal = (totalBytes * price);
            var spendable = jaxx.MATH.subtract(total, String(feeTotal));
            if (+spendable < 0) {
                // console.log('fee total '+ feeTotal  +' where utxos total ' + total);
                return '0';
            }
            return spendable;
        };
        ;
        MiningFeeController.prototype.downloadMingFee = function () {
            var _this = this;
            console.log(this.config.useMiningFeeApi);
            if (!this.config.useMiningFeeApi)
                return;
            if (this.data && this.data.timestamp && (Date.now() - this.data.timestamp) < 5 * 60 * 1000)
                return;
            var url = this.config.miningFeeUrl || 'data/miningFee' + this.config.symbol + '.json';
            console.log(url);
            $.getJSON(url).then(function (res) {
                if (res && res.fastestFee) {
                    _this.setData({
                        fast: res.fastestFee,
                        average: res.halfHourFee,
                        slow: res.hourFee
                    });
                }
                else
                    console.error(res);
            }).fail(function (err) {
                console.error(err);
            });
        };
        return MiningFeeController;
    }());
    jaxx.MiningFeeController = MiningFeeController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=mining-fee-controller.js.map
/*
* User can set different options for transaction mining fee
* it  pass User option to mining fee controller
* At current moment only BTC
* */
var jaxx;
(function (jaxx) {
    var MiningFeeView = (function () {
        function MiningFeeView(config) {
            var _this = this;
            this.config = config;
            this.name = 'MiningFeeView';
            MiningFeeView.instance = this;
            // initializing view container and loadin template htm in it
            this.$view = $('#BitCoinMiningFee');
            this.$view.load('js/app/mining-fee/mining-fee.html', "", function () {
                setTimeout(function () { return _this.init(); }, 1000);
            });
        }
        // initializing template
        MiningFeeView.prototype.init = function () {
            var _this = this;
            this.$view.on('click', '.optionTrigger', function (evt) {
                // console.log($(evt.currentTarget));
                _this.onSelect($(evt.currentTarget));
            });
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.MODULE_REDY, this);
            this.$backNavigation = $('#BTCMiningFeeBackNavigation');
            this.$closeNavigation = $('#BTCMiningFeeClose');
            this.$backNavigation.on('click', function () {
                _this.backNavigation();
            });
            this.$closeNavigation.on('click', function () {
                _this.remoteToggleMainMenu();
            });
        };
        MiningFeeView.prototype.remoteToggleMainMenu = function () {
            jaxx.Utils.remoteToggleMainMenu();
        };
        MiningFeeView.prototype.backNavigation = function () {
            jaxx.Utils.backNavigation();
        };
        // this function called to show previously selected by user option on screen
        MiningFeeView.prototype.selectItem = function (option) {
            var el = this.$view.find('[data-id=' + option + ']').first();
            this.selectInput(el);
        };
        // pass user selected mining fee option to controller
        MiningFeeView.prototype.setMiningFeeOption = function (option) {
            var ctr = jaxx.Registry.getCryptoControllerBySymbol('BTC');
            ctr.getIMiningFeeOptionCtr().setCurrentOption(option);
            //localStorage.setItem(this.symbol+'miningfeeOption', option);
        };
        // returned mining fee option previously selected by user
        MiningFeeView.prototype.getMiningFeeOption = function () {
            var ctr = jaxx.Registry.getCryptoControllerBySymbol('BTC');
            if (!ctr) {
                console.error(' cant find controller BTC');
                return null;
            }
            return ctr.getIMiningFeeOptionCtr().getCurrentOption();
        };
        // triggered when opens
        MiningFeeView.prototype.onOpen = function () {
            console.log('BTC mining fee onOpen     ');
            var option = this.getMiningFeeOption();
            console.log('BTC mining fee onOpen     ' + option);
            this.selectItem(option);
            // console.warn('Mining fee opens ')
            // console.log(this);
        };
        /// deselects previously selected element and selects new element
        MiningFeeView.prototype.selectInput = function (el) {
            var name = el.data('id');
            if (this.selectedOption === name)
                return;
            if (this.$selected)
                this.$selected.prop('checked', false);
            el.prop('checked', true);
            this.$selected = el;
            this.selectedOption = name;
            this.setMiningFeeOption(name);
        };
        /// this function called with user interaction with screen
        MiningFeeView.prototype.onSelect = function (el) {
            var chk = el.find('.cssMiningFeeRadioBtn input');
            this.selectInput(chk);
        };
        return MiningFeeView;
    }());
    jaxx.MiningFeeView = MiningFeeView;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=mining-fee-view.js.map
/**
 * Created by Vlad on 2017-07-10.
 */
var jaxx;
(function (jaxx) {
    //declare var $:any;
    var BalanceControllerBase = (function () {
        function BalanceControllerBase() {
        }
        BalanceControllerBase.prototype.getCurrentBallance = function () {
            return '0';
        };
        return BalanceControllerBase;
    }());
    jaxx.BalanceControllerBase = BalanceControllerBase;
    var CoinControllerBase = (function () {
        function CoinControllerBase(config) {
            this.config = config;
            this.spentBalances = [];
            this.delayBalancesCheckCurrent = 10000;
            this.delayBalanceCheckAll = 30000;
            this.delayDisplayReceiveAddressRefresh = 10000;
            this.intervalBalancesCheck = 0;
            // this array keeps sent transaction IDs that haven't been downloaded by the data layer yet 
            this.monitoredTransactions = [];
            this.monitoredTransactionsMaxAttempts = 10; // controls how many times it will be attempted to download the transaction
            this.monitoredTransactionsRefreshIntervalMSec = 15000; // controls how often the attempts are made to download the transactions
            this.monitoredTransactionsTimer = null; // keeps track of the timer ID used to refresh monitored transactions
            this.attempt = 0;
            this.errors = [];
            for (var str in config)
                this[str] = config[str];
            if (!this.shiftCount)
                this.shiftCount = 1;
            this._db = new jaxx.CoinStorage(config);
            this.initService();
            this.emitter$ = $({});
            this.transactionsUpdater = new jaxx.TransactionsUpdater(this, this.coinService, config);
            this.initEvents();
        }
        CoinControllerBase.prototype.initService = function () {
            var cl = 'CoinService';
            var config = this.config;
            if (config.coinService)
                cl = config.coinService;
            console.log(cl);
            var fn = jaxx[cl];
            if (typeof fn !== 'function') {
                console.error(' class not included ');
            }
            //console.log(cl);
            if (!isNaN(config.hd_index))
                this.generator = new jaxx.GeneratorBlockchain(config);
            this.coinService = new fn(config, this._db, this.generator);
        };
        CoinControllerBase.prototype.getCoinService = function () {
            return this.coinService;
        };
        // returns reference to current address generator
        CoinControllerBase.prototype.getGenerator = function () {
            return this.coinService.generator;
        };
        CoinControllerBase.prototype.restoreHistory2 = function (callBack) {
            var _this = this;
            var balancesReceive = this._db.getBalancesReceive(true);
            var balanceReceive = _.last(balancesReceive);
            var indexReceive = balancesReceive.length;
            var balancesChange = this._db.getBalancesChange(true);
            var balanceChange = _.last(balancesChange);
            var indexChange = balancesChange.length;
            if (this.isRestoringHistory) {
                callBack();
                return;
            }
            ;
            this.coinService.restoreHistory(indexReceive - 1, indexChange - 1)
                .done(function (result) {
                var newAddresses = [];
                if (result.balancesReceive.length) {
                    balancesReceive.pop();
                    // Using class to detect  all addresses returned in strict  HD sequence   : no gaps and no duplicates.
                    // If was error class will fill gaps and remove duplicates, For now we only can see a warning during development.
                    var check = new jaxx.HealthAddressHD(balancesReceive, _this.generator, false);
                    if (check.wasProblem)
                        console.warn(' was problem  restoring history out of sync');
                    balancesReceive = balancesReceive.concat(result.balancesReceive);
                    _this._db.saveBalancesReceive(balancesReceive);
                    newAddresses = _.map(result.balancesReceive, 'id');
                }
                if (result.balancesChange) {
                    if (result.balancesChange.length) {
                        balancesChange.pop();
                        balancesChange = balancesChange.concat(result.balancesChange);
                        // Using class to detect  all addresses returned in strict  HD sequence   : no gaps and no duplicates
                        var chck = new jaxx.HealthAddressHD(balancesChange, _this.generator, true);
                        if (chck.wasProblem) {
                            console.warn(' was problem  restoring history out of sync');
                            //this.onError(new VOError('coin-controller-base', 'after restoring history balances went wrong',{}, this.config.symbol ));
                        }
                        _this._db.saveBalancesChange(balancesChange);
                        newAddresses = newAddresses.concat(_.map(result.balancesChange, 'id'));
                        _this.goToNextAddressChange();
                    }
                }
                if (newAddresses.length) {
                    _this.attempt = 0;
                    _this.downloadNewTransactionsForAddresses(newAddresses);
                }
                _this.goToNextAddressReceive();
                callBack();
                //this.downloadNewTransactionsForAddresses(addresses);
                //console.log(balances);
            }).fail(function (err) {
                callBack(err);
            });
        };
        CoinControllerBase.prototype.checkSync = function (callBack) {
            var _this = this;
            if (!this.HD) {
                callBack();
                return;
            }
            if (this.isRestoringHistory) {
                callBack();
                return;
            }
            ;
            var address = this.getCurrentAddress();
            var addressChange = this.getCurrentAddressChange();
            var addresses = addressChange ? [address, addressChange] : [address];
            console.log('%c ' + this.symbol + ' checking sync for address: ' + address, 'color:coral');
            this.coinService.downloadTransactions(addresses)
                .done(function (transactions) {
                if (transactions.length === 0) {
                    console.log('%c ' + _this.symbol + ' no new transactions ', 'color:coral');
                    callBack();
                    return;
                }
                ;
                // let newTrs:VOTransaction[] = this._db.addTransactions(transactions, true);
                //if(newTrs.length == 0){
                //    console.warn(this.symbol + ' no new transactions something went wrong');
                // }else console.log('%c ' + this.symbol + ' have new transactions restoring history ','color:coral');
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_OUT_OF_SYNC, _this);
                _this.restoreHistory2(callBack);
                // let balance:VOBalance = this.getCurrentBalance();
            }).fail(function (err) {
                callBack(err);
                _this.onError(err);
                console.error(err);
            });
        };
        CoinControllerBase.prototype.resetStorage = function (needRestore) {
            this._db.clearStorage();
            if (needRestore)
                this.resetHistoryTimestamp();
            else
                this.setHistoryTimestamp();
            //  console.log('TODO');
        };
        /**
         * Starts monitoring the provided transaction ID, if
         * - it is not monitored already
         * - it is not already cached
         *
         *
         * @param arg_txid - The transaction ID
         */
        CoinControllerBase.prototype.monitorTransaction = function (arg_txid) {
            // find if we are already monitoring the transaction
            var existingMonitoredTXes = this.monitoredTransactions.filter(function (tx) { return (arg_txid == tx); });
            if (existingMonitoredTXes.length > 0) {
                return; // we are already keeping tabs on it, nothing to do
            }
            // find if we already cached the TX
            var existingCachedTXes = this._db.getTransactionByIdReceive(arg_txid);
            if (existingCachedTXes !== null) {
                return; // we cached it already, do nothing
            }
            this.monitoredTransactions.push({
                txid: arg_txid,
                attemptsMade: 0
            });
            if (this.isActive) {
                this.activateTransactionMonitoring();
            }
        };
        // enables timer for refreshing monitored transactions
        CoinControllerBase.prototype.activateTransactionMonitoring = function () {
            if (this.monitoredTransactionsTimer == null) {
                this.monitoredTransactionsTimer = setInterval(this.refreshAndStoreMonitoredTransactions.bind(this), this.monitoredTransactionsRefreshIntervalMSec);
                console.log('%c ' + this.symbol + ': Transaction monitoring ACTIVATED.', 'color: DarkSeaGreen');
            }
        };
        // disables timer for refreshing monitored transactions
        CoinControllerBase.prototype.deactivateTransactionMonitoring = function () {
            if (this.monitoredTransactionsTimer != null) {
                clearInterval(this.monitoredTransactionsTimer);
                this.monitoredTransactionsTimer = null;
                console.log('%c ' + this.symbol + ': Transaction monitoring DEACTIVATED.', 'color: DarkSeaGreen');
            }
        };
        /**
         * Called by monitoring timer, It downloads and stores transaction details if:
         * - transaction is not already cached
         * - it has made less than monitoredTransactionsMaxAttempts attempts to donwload the transaction details
         *
         * Fires ON_TRANSACTION_DROPPED event if a transaction is being attempted too many (see above) times.
         *
         */
        CoinControllerBase.prototype.refreshAndStoreMonitoredTransactions = function () {
            var _this = this;
            var txesToBeDownloaded = [];
            var cachedTxes = this._db.getTransactionsReceive();
            // go through each TX to be monitored
            this.monitoredTransactions.forEach(function (monitoredTx, txIndex) {
                // if we did not cache this particular TX already
                if (cachedTxes.filter(function (item) { return item.id == monitoredTx.txid; }).length == 0) {
                    // if we made less that max allowed attempts to download this monitored transaction
                    if (monitoredTx.attemptsMade < _this.monitoredTransactionsMaxAttempts) {
                        txesToBeDownloaded.push({ id: monitoredTx.txid });
                    }
                    else {
                        // the transaction might have been dropped from the mempool, update UI.
                        jaxx.Registry.application$.trigger(jaxx.Registry.ON_TRANSACTION_DROPPED, monitoredTx.txid);
                        // also remove it from our monitored list
                        _this.monitoredTransactions.splice(txIndex, 1);
                    }
                }
                else {
                    // we already cached it, let's stop monitoring it
                    _this.monitoredTransactions.splice(txIndex, 1);
                }
            });
            if (this.monitoredTransactions.length == 0) {
                this.deactivateTransactionMonitoring();
                return;
            }
            console.log('%c Refreshing details for ' + txesToBeDownloaded.length + ' monitored transactions.', 'color: DarkSeaGreen');
            this.coinService.downloadTransactionsDetails(txesToBeDownloaded).done(function (downloadedTxes) {
                if (downloadedTxes.length > 0) {
                    var diff = jaxx.Utils.transactionsDiff(cachedTxes, downloadedTxes);
                    if (diff.length > 0) {
                        _this.mapDisplayTransactions(diff);
                        _this._db.addTransactions(diff);
                        _this.dispatchTransactions();
                        _this.monitoredTransactions = [];
                        _this.deactivateTransactionMonitoring();
                    }
                }
            }).fail(function (error) {
                _this.monitoredTransactions.forEach(function (value) { value.attemptsMade++; });
                _this.onError(error);
            });
        };
        CoinControllerBase.prototype.initEvents = function () {
            var _this = this;
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_SATUS_CHANGED, function (evt, name, enbl) {
                // console.log(name, enbl);
                if (name == _this.name) {
                    _this.enabled = enbl;
                }
            });
            this.transactionsUpdater.emitter$.on(this.transactionsUpdater.ON_TRANSACTION_CONFIRM_CHANGES, function (evt, data) {
                console.log('%c ' + _this.symbol + ' saving confirmations +1', 'color:blue');
                var transactions = jaxx.Utils.deepCopy(data.transactions); // the transactions are being altered until reaching all event handlers, best to make a copy of the data
                _this._db.saveTransactionsReceive();
                jaxx.Registry.transactions$.triggerHandler(jaxx.Registry.ON_TRANSACTIONS_CONFIRMATIONS, { symbol: _this.symbol, transactions: transactions });
            });
            this.transactionsUpdater.emitter$.on(this.transactionsUpdater.ON_TRANSACTION_INBLOCK, function (evt, data) {
                console.log('%c ' + _this.symbol + ' saving confirmations in block ', 'color:blue');
                var transactions = jaxx.Utils.deepCopy(data.transactions); // the transactions are being altered until reaching all event handlers, best to make a copy of the data
                _this._db.saveTransactionsReceive();
                jaxx.Registry.transactions$.triggerHandler(jaxx.Registry.ON_TRANSACTION_INBLOCK, { symbol: _this.symbol, transactions: transactions });
            });
            // Once our user has sent a transaction we attempt to fetch it from the server                       
            jaxx.Registry.application$.on(jaxx.Registry.ON_SEND_TRANSACTION, function (ev, sent_tx) {
                if (_this.isActive == true && _this.supportsTransactionHistory() == true && sent_tx.symbol == _this.symbol) {
                    _this.monitorTransaction(sent_tx.txid);
                }
            });
        };
        CoinControllerBase.prototype.generateAddress = function (index, type) {
            return this.coinService.generator.generateAddress(index, type);
        };
        CoinControllerBase.prototype.getCurrentBalance = function () {
            var balances = this._db.getBalancesReceive(true);
            if (balances.length == 0) {
                var address = this.generateAddress(0, 'receive');
                var balance = new VOBalance({
                    id: address,
                    balance: '0',
                    decimals: 0,
                    index: 0,
                    type: 0
                });
                this._db.saveBalancesReceive([balance]);
                return balance;
            }
            var currentIndex = this.config.HD ? balances.length - 1 : 0;
            return balances[currentIndex];
        };
        CoinControllerBase.prototype.getCurrentAddress = function () {
            return this.getCurrentBalance().id;
        };
        Object.defineProperty(CoinControllerBase.prototype, "sort", {
            get: function () {
                return +localStorage.getItem(this.symbol + 'sort');
            },
            set: function (num) {
                localStorage.setItem(this.symbol + 'sort', num + '');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CoinControllerBase.prototype, "enabled", {
            get: function () {
                var enabled = localStorage.getItem(this.symbol + 'enabled') === 'true';
                // console.log(this.name + '  ' + enabled);
                return enabled;
            },
            set: function (enabled) {
                //was setting undefinedEnabled in localstorage
                if (this.symbol) {
                    localStorage.setItem(this.symbol + 'enabled', (enabled ? 'true' : 'false'));
                }
            },
            enumerable: true,
            configurable: true
        });
        CoinControllerBase.prototype.goSleep = function () {
            this.isWasActive = this.isActive;
            if (this.isWasActive)
                console.log('%c  ' + this.name + ' go sleep  ', 'color:red');
            this.deactivate();
        };
        CoinControllerBase.prototype.wakeUp = function () {
            if (this.isWasActive) {
                console.log('%c  ' + this.name + ' waking up   ', 'color:red');
                this.activate();
            }
        };
        CoinControllerBase.prototype.setStartOption = function (option) {
            localStorage.setItem(this.symbol + 'start-option', option);
        };
        CoinControllerBase.prototype.getStartOption = function () {
            return localStorage.getItem(this.symbol + 'start-option');
        };
        CoinControllerBase.prototype.deleteStartOption = function () {
            localStorage.removeItem(this.symbol + 'start-option');
        };
        CoinControllerBase.prototype.getSpendable = function () {
            console.error('override this fumction');
            return '0';
        };
        CoinControllerBase.prototype.resetHistoryTimestamp = function () {
            localStorage.removeItem(this.symbol + 'historyTimestamp');
        };
        CoinControllerBase.prototype.setHistoryTimestamp = function () {
            localStorage.setItem(this.symbol + 'historyTimestamp', (new Date()).toISOString());
        };
        CoinControllerBase.prototype.getHistoryTimestamp = function () {
            return localStorage.getItem(this.symbol + 'historyTimestamp');
        };
        CoinControllerBase.prototype.getAddressesAll = function () {
            return _.map(this._db.getBalancesAll(true), 'id');
        };
        /*  getTransactions(): VOTransaction[] {
              return this._db.getTransactionsReceive();
          }*/
        CoinControllerBase.prototype.goToNextAddressReceive = function () {
            // make sure HD value (type: boolean) is set in jaxx-config.json for each coin
            if (this.config.HD !== undefined && !this.config.HD) {
                return;
            }
            var balances = this._db.getBalancesReceive(true);
            var index = 0;
            if (balances.length) {
                var health = new jaxx.HealthAddressHD(balances, this.generator, false);
                index = _.last(balances).index + 1;
            }
            // checking is balances all organized before generating a new address
            // let currentBalance:VOBalance = this.getCurrentBalance();
            // console.log('%c '+ this.symbol + ' goToNextAddressReceive length ' + balances.length + ' index ' + currentBalance.index, 'color:violet');
            var address = this.coinService.generator.generateAddressReceive(index);
            balances.push(new VOBalance({
                id: address,
                balance: '0',
                index: index,
                decimal: 0,
                type: 0
            }));
            this._db.saveBalancesReceive(balances);
            this.dispatchAddress();
        };
        CoinControllerBase.prototype.goToNextAddressChange = function () {
            var balances = this._db.getBalancesChange(true);
            // checking is balances all organized before generating a new address
            var index = 0;
            if (balances.length) {
                var health = new jaxx.HealthAddressHD(balances, this.generator, true);
                index = _.last(balances).index + 1;
            }
            var address = this.coinService.generator.generateAddressChange(index);
            balances.push(new VOBalance({
                id: address,
                balance: '0',
                index: index,
                decimal: 0,
                type: 1
            }));
            this._db.saveBalancesChange(balances);
            //this.dispatchAddress();
        };
        CoinControllerBase.prototype.onCurrentAddressGotBalance = function (balance) {
            if (this.HD) {
                this.goToNextAddressReceive();
                console.log('%c ' + this.symbol + ' because of HD go to next address: ', 'color:red');
                this.dispatchAddress();
            }
            else {
            }
            this.downloadBalancesAll(function () {
                //TODO: what do i need to do here?
            });
        };
        CoinControllerBase.prototype.checkBalanceCurrentReceive = function () {
            var _this = this;
            if (this.isRestoringHistory) {
                console.warn(' restoring history ');
                return;
            }
            if (!this.isActive) {
                this.stopBalancesCheck();
                return;
            }
            var balanceOld = this.getCurrentBalance();
            if (this.isRestoringHistory) {
                return;
            }
            var timestamp = Date.now();
            if (balanceOld.id.length < 20) {
                return;
            }
            this.coinService.downloadBalances([balanceOld.id]).done(function (balances) {
                var balanceNew = balances[0];
                if (balanceNew && _this.HD && balanceNew.balance !== '0') {
                    _this.onCurrentAddressGotBalance(balanceNew);
                }
                else if (balanceNew && balanceOld.balance !== balanceNew.balance) {
                    _this.onCurrentAddressGotBalance(balanceNew);
                }
                else if (balanceOld.balance !== balanceNew.balance) {
                    var delta = +balanceNew.balance - +balanceOld.balance;
                    var precision = Math.round(+balanceNew.balance / 1e5);
                    if (delta && Math.abs(delta) < precision) {
                        if (delta > 0)
                            console.log(' ignoring delta too small' + jaxx.MATH.toDecimal(delta + ''));
                        delta = 0;
                    }
                    if (delta) {
                        _this.onCurrentAddressGotBalance(balanceNew);
                    }
                }
            });
        };
        CoinControllerBase.prototype.downloadNewTransactionsForAddresses = function (addresses) {
            var _this = this;
            if (!addresses)
                return;
            this.attempt++;
            if (this.attempt > 20) {
                return;
            }
            // console.log(addresses);
            if (addresses.length === 0) {
                console.error(' no addresses ');
                return;
            }
            var invalid = addresses.filter(function (item) { return item.length < 20; });
            if (invalid.length) {
                console.error('invalid addresses ', invalid);
                addresses = addresses.filter(function (item) { return item.length > 20; });
            }
            console.log('%c ' + this.symbol + ' download new transactions for addresses ' + addresses.toString() + ' count ' + this.attempt, 'color:blue');
            this.addressesNewTransactions = addresses;
            this.coinService.downloadTransactions(addresses).done(function (trans) {
                var exists = _this._db.getTransactionsReceive();
                var diff = jaxx.Utils.transactionsDiff(exists, trans);
                console.log('%c ' + _this.symbol + ' downloaded ' + diff.length + 'new transactions  form total ' + trans.length, 'color:blue');
                if (diff.length === 0) {
                    setTimeout(function () { return _this.downloadNewTransactionsForAddresses(addresses); }, 30000);
                }
                else {
                    //let addressses = this._db.getAddressesAll();
                    //Utils.mapTransactionsDisplay(diff, addressses);
                    console.log(diff);
                    _this.addressesNewTransactions = null;
                    _this.mapDisplayTransactions(diff);
                    _this._db.addTransactions(diff);
                    _this.dispatchTransactions();
                }
            }).fail(function (err) {
                _this.onError(err);
                setTimeout(function () { return _this.downloadNewTransactionsForAddresses(addresses); }, 30000);
            });
        };
        CoinControllerBase.prototype.onBalancesDownloadedDifference = function (delta, balancesOld, balancesNew) {
            //let copyOld = Utils.deepCopy(balancesOld);
            var diff = jaxx.Utils.updateOldBalances(balancesOld, balancesNew);
            console.log(this.config.symbol + ' balances difference ', diff);
            if (this.spentBalances && this.spentBalances.length) {
                console.log('resetting temp balance ', this.spentBalances);
                this.spentBalances = [];
            }
            this.dispatchBalance();
            if (diff.length) {
                this._db.saveBalancesAll();
                var addresses = diff.map(function (item) { return item.id; });
                this.attempt = 0;
                this.downloadNewTransactionsForAddresses(addresses);
            }
            else {
                console.error(' Balance changed but no difference ');
            }
        };
        CoinControllerBase.prototype.downloadBalancesAll = function (onSuccess) {
            var _this = this;
            if (this.isDownloadingBalances)
                return;
            this.isDownloadingBalances = true;
            if (this.isRestoringHistory) {
                if (onSuccess)
                    onSuccess({ warn: 'restoring history' });
                console.warn(this.symbol + ' Restoring Histroy dropping downloadBalancesAll');
                return;
            }
            if (!this.isActive) {
                this.stopBalancesCheck();
                return;
            }
            var balancesOld = this._db.getBalancesAll(true);
            var balanceOld = jaxx.Utils.sumBalances(balancesOld);
            var addresses = balancesOld.map(function (item) { return item.id; });
            console.log(this.symbol + ' download Balances All: ' + addresses.length);
            this.coinService.downloadBalances(addresses).done(function (result) {
                _this.isDownloadingBalances = false;
                if (!result) {
                    console.error(' this.coinService.downloadBalances  ');
                    return;
                }
                // this.onBalancesDownloaded(balancesOld, result);
                var balancesNew = result;
                var balanceNew = jaxx.Utils.sumBalances(balancesNew);
                var spent = _this.spentBalances.reduce(function (s, item) { return s += +item.balance; }, 0);
                var delta = +balanceNew - +balanceOld;
                var precision = Math.round(+balanceNew / 1e5);
                console.log('%c ' + _this.symbol + ' balances old: ' + jaxx.MATH.toDecimal(balanceOld) +
                    ' new: ' + jaxx.MATH.toDecimal(balanceNew) +
                    ' spent: ' + jaxx.MATH.toDecimal(spent + '') +
                    ' delta: ' + jaxx.MATH.toDecimal(delta + '') +
                    ' precision: ' + jaxx.MATH.toDecimal(precision + ' ') +
                    (new Date()).toLocaleTimeString(), 'color:green');
                if (delta && Math.abs(delta) < precision) {
                    if (delta > 0)
                        console.log(' ignoring delta too small' + jaxx.MATH.toDecimal(delta + ''));
                    delta = 0;
                }
                if (delta) {
                    _this.onBalancesDownloadedDifference(delta, balancesOld, balancesNew);
                }
                if (onSuccess) {
                    onSuccess();
                }
            }).fail(function (error) {
                _this.isDownloadingBalances = false;
                _this.onError(error);
            });
        };
        CoinControllerBase.prototype.dispatchAddress = function () {
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_ADDRESS_CHANGED, this);
        };
        CoinControllerBase.prototype.getTransactionsDisplay = function () {
            return {
                symbol: this.symbol,
                transactions: jaxx.Utils.deepCopy(this._db.getTransactionsReceive()).reverse(),
                blockexplorer_url: this.config.blockexplorer_url,
                trsConfirmations: this.config.trsConfirmations
            };
        };
        CoinControllerBase.prototype.dispatchTransactions = function () {
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_TRANSACTIONS_CHANGED, this);
        };
        CoinControllerBase.prototype.dispatchBalance = function () {
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_BALANCE_CHANGED, this);
        };
        CoinControllerBase.prototype.dispatchSpendable = function () {
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_SPENDABLE_CHANGED, this);
        };
        CoinControllerBase.prototype.deactivate = function () {
            if (!this.isActive)
                return false;
            this.isActive = false;
            console.log('%c ' + this.symbol + ' deactivating ', 'color:red');
            this.stopBalancesCheck();
            if (this.isRestoringHistory) {
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.KILL_HISTORY, { symbol: this.symbol });
            }
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_COIN_DEACTIVATED, this);
            this.deactivateTransactionMonitoring();
            return true;
        };
        CoinControllerBase.prototype.activate = function () {
            //console.error('activate ');
            var _this = this;
            if (this.isActive)
                return false;
            this.isActive = true;
            var timestamp = this.getHistoryTimestamp();
            //let onStart = this.getStartOption();
            //console.log('%c ' + this.symbol + ' activate  on-start: '+onStart + '    '+timestamp , 'color:red');
            //if(onStart && onStart != 'pair-device'){
            // this.setHistoryTimestamp();
            //this.createStartAddresses();
            // }
            // else{
            if (!timestamp) {
                if (localStorage.getItem('walletType') === 'new-wallet') {
                    this.setHistoryTimestamp();
                    this.createStartAddresses();
                }
                else {
                    this.restoreHistory(function () {
                        // this.isRestoringHistory = true;
                        //this.isActive = false;
                        // this.activate();
                    });
                    console.log('%c ' + this.symbol + ' restoring history  timestamp null', 'color:red');
                }
                // return false;
            }
            else {
                var balance = this.getCurrentBalance();
                if (balance && isNaN(balance.index))
                    this._db.indexBalances();
            }
            //
            //  }
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_COIN_ACTIVATED, this);
            console.log('%c ' + this.name + ' activated ', 'color:red');
            if (!this.isRestoringHistory) {
                this.checkSync(function () {
                    // this.dispatchBalance();
                    // this.dispatchAddress();
                    // this.dispatchTransactions();
                    _this.downloadNewTransactionsForAddresses(_this.addressesNewTransactions);
                    _this.startBalancesCheck();
                });
                if (this.monitoredTransactions.length > 0) {
                    this.activateTransactionMonitoring();
                }
            }
            else {
            }
            return true;
        };
        CoinControllerBase.prototype.startBalancesCheck = function () {
            var _this = this;
            if (this.isCheckingBalance)
                return;
            this.isCheckingBalance = true;
            //   console.error('JN - first call to checkBalanceCurrentReceive');
            this.checkBalanceCurrentReceive();
            this.downloadBalancesAll(null);
            // this.stopBalancesCheck();
            //this.intervalBalancesCheck = setInterval(err=>this.onError(err), this.intervalAllBalancesCheckCurrent);
            this.intervalBalanceCheckCurrent = window.setInterval(function () {
                // console.error('JN - timer call checkBalanceCurrentRdceive');
                _this.checkBalanceCurrentReceive();
            }, this.delayBalancesCheckCurrent);
            this.intervalBalancesCheckAll = window.setInterval(function () {
                _this.downloadBalancesAll(null);
            }, this.delayBalanceCheckAll);
            this.intervalDisplayReceiveAddressRefresh = window.setInterval(function () {
                console.log("Verifying current receive address and QR code on UI");
                _this.verifyDisplayedReceiveAddressAndQRCode();
            }, this.delayDisplayReceiveAddressRefresh);
        };
        //Verify the displayed receive address on UI using address derived directly from mnemonic and current index
        //Ensure receive address displayed on UI belongs to current wallet
        //This is to prevent UI freezing that could potentially displaying old wallet address and insertion of
        //malicious address
        CoinControllerBase.prototype.verifyDisplayedReceiveAddressAndQRCode = function () {
            //Check if current controller is the same as expected
            //This happens sometimes when navigate between coins
            if (jaxx.Registry.getCurrentCryptoController().config.symbol != this.config.symbol) {
                this.stopBalancesCheck();
                console.log("Event CTL001 occurred");
                // Navigation.flashBanner("Error (CTL001) occurred, please restart your application and try again.");
                return;
            }
            var generator = this.getGenerator();
            if (!generator) {
                console.log("Event CTL002 occurred");
                //   Navigation.flashBanner("Error (CTL002) occurred, please restart your application and try again.");
                return;
            }
            //Verify displayed receiving address and refresh if needed
            var expectedCurrentAddress = generator.generateAddressReceive(this.getCurrentBalance().index || 0);
            var expectedCurrentAddress0 = generator.generateAddressReceive(0);
            var displayedCurrentAddress = $('#AddressView-address').text();
            if (expectedCurrentAddress != displayedCurrentAddress) {
                //Only throw user warning if displayed address is not expected or the first address (set when initializing)
                if (expectedCurrentAddress0 != displayedCurrentAddress) {
                    Navigation.flashBanner("Change of wallet detected, if you're not performing this (pairing) operation, please ensure you have your 12-word backup phrase, restart your application and double-check your addresses.");
                }
                $('#AddressView-address').text(expectedCurrentAddress);
            }
            //Verify displayed receiving QR code and refresh if needed
            var expectedQRCode = jaxx.Utils.generateQRCode(expectedCurrentAddress, true);
            var expectedQRCode0 = jaxx.Utils.generateQRCode(expectedCurrentAddress0, true);
            var displayedQRCode = $('.populateQRCode').attr('src');
            if (expectedQRCode != displayedQRCode) {
                //Only throw user warning if QR code is not expected or the first address (set when initializing)
                if (expectedQRCode0 != displayedQRCode) {
                    //   Navigation.flashBanner("Change of wallet detected, if you're not performing this (pairing) operation, please ensure you have your 12-word backup phrase, restart your application and double-check your addresses.");
                }
                $('.populateQRCode').attr('src', expectedQRCode);
            }
        };
        CoinControllerBase.prototype.stopBalancesCheck = function () {
            // console.warn(this.name + '   stopBalancesCheck   ');
            clearInterval(this.intervalBalanceCheckCurrent);
            clearInterval(this.intervalBalancesCheckAll);
            clearInterval(this.intervalDisplayReceiveAddressRefresh);
            this.isCheckingBalance = false;
        };
        CoinControllerBase.prototype.onError = function (err) {
            err = err || {};
            jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, err);
        };
        CoinControllerBase.prototype.createStartAddresses = function () {
            this.setHistoryTimestamp();
            var addressChange = this.coinService.generator.generateAddressChange(0);
            var addressReceive = this.coinService.generator.generateAddressReceive(0);
            this._db.saveBalancesChange([new VOBalance({
                    id: addressChange,
                    balance: '0',
                    index: 0,
                    decimal: 0,
                    type: 1
                })]);
            this._db.saveBalancesReceive([new VOBalance({
                    id: addressReceive,
                    balance: '0',
                    index: 0,
                    decimal: 0,
                    type: 0
                })]);
            this._db.unsetCreateNewWalletd();
        };
        CoinControllerBase.prototype.createNewWallet = function () {
            this._db.setCreateNewWallet();
            //console.error('Vlad please implement for each controller type - coins, ether and token');
        };
        /*
            This function is called when displaying public addresses/private key pairs.
            The "Balance" array parameter is from local storage (caculated from restoreHistory) and contains public addresses,
            balances but not private keys. In this function public address/Private key pairs are derived from key generator locally

         */
        CoinControllerBase.prototype.mapPrivateKeys = function (balances, isChange) {
            //let out:{address: string, balance: string, privateKey: string}[] = [];
            // included check addresses  sequence before generating keys it will fix possible gaps and remove duplicates
            var check = new jaxx.HealthAddressHD(balances, this.generator, isChange);
            if (check.wasProblem)
                console.warn(' it was a problem with addresses ' + this.config.symbol);
            var generator = this.generator;
            return balances.map(function (item) {
                var node = isChange ? generator.generateKeyPairChange(item.index) : generator.generateKeyPairReceive(item.index);
                return {
                    address: item.id,
                    balance: jaxx.MATH.satoshiToBtc(item.balance),
                    privateKey: node.toWIF()
                };
            });
            /*
                        let maximumAddressIndex = 1000; //Maximum address index allowed to iterate
            
                        // Iterate through the Balance array, and derive public addresses/prive key pairs locally using generator
                        // Until it reaches the maximum allowed index
                        for(let i=0, j=0, n=balances.length;(i<n)&&(j<maximumAddressIndex);j++){
            
                            //Derive public address for current index
                            let publicAddress = isChange ? this.coinService.generator.generateAddress(j,"change") : this.coinService.generator.generateAddress(j,"receive");
                            //Derive private key for current index
                            let keyNode:any = isChange ? this.coinService.generator.generateKeyPairChange(j) : this.coinService.generator.generateKeyPairReceive(j);
                            let privateKey = keyNode.toWIF();
            
                            let balance:VOBalance = balances[i];
                            //Check if public address matches private address (in case of gaps)
                            if(publicAddress === balance.id){
            
                                out.push({
                                    address:balance.id,
                                    balance:MATH.satoshiToBtc(balance.balance),
                                    privateKey:privateKey
                                });
                                console.log("Displaying public " + (isChange ? "change" : "receive") + " address " + i + " and private key " + j );
                                i++;
                            } else { //There is gap
                                console.warn("Gap detected");
                            }
                        }
                        return out;
                        */
        };
        CoinControllerBase.prototype.getPrivateKeys = function () {
            var _this = this;
            var deferred = $.Deferred();
            console.log(' getPrivateKeys ');
            if (this._db.isNewWallet()) {
                this.createNewWallet();
                this.setHistoryTimestamp();
            }
            var timestamp = this.getHistoryTimestamp();
            var out = [];
            if (!timestamp) {
                this.restoreHistory(function (error) {
                    if (error) {
                        deferred.reject(error);
                        return;
                    }
                    var balances = _this._db.getBalancesReceive(true);
                    out = out.concat(_this.mapPrivateKeys(balances, false));
                    balances = _this._db.getBalancesChange(true);
                    out = out.concat(_this.mapPrivateKeys(balances, true));
                    deferred.resolve(out);
                });
            }
            else {
                var balances = this._db.getBalancesReceive(true);
                out = out.concat(this.mapPrivateKeys(balances, false));
                balances = this._db.getBalancesChange(true);
                out = out.concat(this.mapPrivateKeys(balances, true));
                deferred.resolve(out);
            }
            return deferred;
        };
        CoinControllerBase.prototype.validateAddress = function (address) {
            if (!address || !address.length)
                return false;
            var index = thirdparty.bitcoin.address.fromBase58Check(address);
            // console.warn(index);
            return this.config.validAddresses.indexOf(index.version) !== -1;
        };
        CoinControllerBase.prototype.validateAddressETH = function (address) {
            if (!address || !address.length)
                return false;
            var addr = address.toLowerCase();
            if (!/^(0x)?[0-9a-f]{40}$/i.test(addr)) {
                // check if it has the basic requirements of an address
                return false;
            }
            else if (/^(0x)?[0-9a-f]{40}$/.test(addr) || /^(0x)?[0-9A-F]{40}$/.test(addr)) {
                return true;
            }
            else {
                // Otherwise check each case
                return this.isChecksumAddressETH(addr);
            }
        };
        CoinControllerBase.prototype.isChecksumAddressETH = function (address) {
            // Check each case
            address = address.replace('0x', '');
            var addressHash;
            try {
                addressHash = thirdparty.web3.sha3(address.toLowerCase());
            }
            catch (e) {
                jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, e);
                return false;
            }
            for (var i = 0; i < 40; i++) {
                // the nth letter should be uppercase if the nth digit of casemap is 1
                if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {
                    return false;
                }
            }
            return true;
        };
        CoinControllerBase.prototype.isPaperWalletAllowed = function (checkiOS) {
            if (!this.paperwallet)
                return false;
            checkiOS = (checkiOS == null) ? false : checkiOS;
            if (checkiOS)
                return (this.paperwallet.ios) ? this.paperwallet.ios : false;
            return (this.paperwallet.regular) ? this.paperwallet.regular : false;
        };
        ;
        return CoinControllerBase;
    }());
    jaxx.CoinControllerBase = CoinControllerBase;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=coin-controller-base.js.map
///<reference path="./models.ts"/>
///<reference path="./Utils2.ts"/>
///<reference path="./service-mapper.ts"/>
var jaxx;
(function (jaxx) {
    var AdrType;
    (function (AdrType) {
        AdrType[AdrType["RECEIVE"] = 0] = "RECEIVE";
        AdrType[AdrType["CHANGE"] = 1] = "CHANGE";
    })(AdrType = jaxx.AdrType || (jaxx.AdrType = {}));
    var GeneratorBlockchain = (function () {
        function GeneratorBlockchain(config) {
            var _this = this;
            this.config = config;
            this.MASTER = 44;
            this.account = 0;
            this.addressesReceive = [];
            GeneratorBlockchain.emitter$.on(GeneratorBlockchain.MNEMONIC_CHANGED, function (evt, seedHex) {
                _this.coinNode = null;
            });
        }
        GeneratorBlockchain.setMnemonic = function (mnemonic) {
            GeneratorBlockchain.seedHex = thirdparty.bip39.mnemonicToSeedHex(mnemonic);
            GeneratorBlockchain.emitter$.triggerHandler(GeneratorBlockchain.MNEMONIC_CHANGED);
        };
        GeneratorBlockchain.prototype.getCoinNode = function () {
            if (!this.coinNode) {
                var mn = thirdparty.bitcoin.HDNode.fromSeedHex(GeneratorBlockchain.seedHex, this.config.network).deriveHardened(this.MASTER);
                this.coinNode = mn.deriveHardened(this.config.hd_index).deriveHardened(this.account);
            }
            return this.coinNode;
        };
        GeneratorBlockchain.prototype.getAddressNode = function (type) {
            return this.getCoinNode().derive(type);
        };
        GeneratorBlockchain.prototype.generateXpubAddress = function () {
            return jaxx.Utils2.getXpubAddress(this.config.hd_index, this.config.network);
        };
        GeneratorBlockchain.prototype.getPublicAddress = function (node) {
            return (this.config.hd_index === 60 || this.config.hd_index === 61 || this.config.hd_index === 37310)
                ? jaxx.Utils2.getEtherAddress(node) : jaxx.Utils2.getBitcoinAddress1(node);
        };
        GeneratorBlockchain.prototype.generateAddressReceive = function (index) {
            return this.getPublicAddress(this.getCoinNode().derive(0).derive(index));
        };
        GeneratorBlockchain.prototype.generateAddressChange = function (index) {
            return this.getPublicAddress(this.getCoinNode().derive(1).derive(index));
        };
        GeneratorBlockchain.prototype.generatePrivateKeyChange = function (index) {
            var node = jaxx.Utils2.getChangeNode(index, this.config.hd_index, this.config.network);
            return jaxx.Utils2.getNodePrivateKey(node, this.config.network.wif);
        };
        GeneratorBlockchain.prototype.generatePrivateKeyReceive = function (index) {
            //  let coinNetwork = HDWalletPouch.getStaticCoinPouchImplementation(this.config.coinType).networkDefinitions.mainNet;
            var node = jaxx.Utils2.getReceiveNode(index, this.config.hd_index, this.config.network);
            return jaxx.Utils2.getNodePrivateKey(node, this.config.network.wif);
        };
        /* generateAddress2(index:number, type:AddressType):string {
             // console.error('hello generateAddress');
             if (type === AddressType.RECEIVE) {
                 return this.generateAddressReceive(index);
             } else {
                 return this.generateAddressChange(index);
             }
         }*/
        GeneratorBlockchain.prototype.generateAddress = function (index, receive_change) {
            // console.error('hello generateAddress');
            if (receive_change === "receive") {
                return this.generateAddressReceive(index);
            }
            else {
                return this.generateAddressChange(index);
            }
        };
        GeneratorBlockchain.prototype.generateKeyPairReceive = function (index) {
            //    let coinNetwork = HDWalletPouch.getStaticCoinPouchImplementation(this.config.coinType).networkDefinitions.mainNet;
            //  console.warn(this.name , coinNetwork);
            var node = jaxx.Utils2.getReceiveNode(this.config.hd_index, index, this.config.network);
            // console.warn(node);
            return jaxx.Utils2.getNodeKeyPair(node);
        };
        GeneratorBlockchain.prototype.getSignatureForIndex = function (index) {
            //  console.warn('getSignatureForIndex 5555 ' + index);
            // let coinNetwork = HDWalletPouch.getStaticCoinPouchImplementation(this.config.coinType).networkDefinitions.mainNet;
            var node = jaxx.Utils2.getReceiveNode(this.config.hd_index, index, this.config.network);
            //console.log(node);
            var buffer = new thirdparty.Buffer.Buffer(node.keyPair.d.toBuffer(32), 'hex');
            // console.warn(buffer);
            return buffer;
        };
        GeneratorBlockchain.prototype.generateKeyPairChange = function (index) {
            return jaxx.Utils2.getNodeKeyPair(jaxx.Utils2.getChangeNode(this.config.hd_index, index, this.config.network));
        };
        GeneratorBlockchain.signEther = function (etehr_trans, privateKey) {
            var buff = new Buffer(privateKey, 'hex');
            var tx = new thirdparty.ethereum.tx(etehr_trans);
            // var buf = new Buffer(this._pouchManager.getPrivateKey(fromNodeInternal, fromNodeIndex).d.toBuffer(32), 'hex');
            tx.sign(buff);
            return tx.serialize();
        };
        GeneratorBlockchain.getNodeKeyPair = function (node) {
            return node.keyPair;
        };
        GeneratorBlockchain.getNodePrivateKey = function (node) {
            return node.keyPair.d.toBuffer(32).toString('hex');
        };
        GeneratorBlockchain.getPrivateKey = function (keyPair) {
            return keyPair.d.toBuffer(32).toString('hex');
        };
        GeneratorBlockchain.getKeyPairBuffer = function (keyPair) {
            return new Buffer(keyPair.d.toBuffer(32), 'hex');
        };
        GeneratorBlockchain.getEtherAddress = function (node) {
            var ethKeyPair = node.keyPair;
            var prevCompressed = ethKeyPair.compressed;
            ethKeyPair.compressed = false;
            var pubKey = ethKeyPair.getPublicKeyBuffer();
            var pubKeyHexEth = pubKey.toString('hex').slice(2);
            var pubKeyWordArrayEth = thirdparty.CryptoJS.enc.Hex.parse(pubKeyHexEth);
            var hashEth = thirdparty.CryptoJS.SHA3(pubKeyWordArrayEth, { outputLength: 256 });
            var address = hashEth.toString(thirdparty.CryptoJS.enc.Hex).slice(24);
            ethKeyPair.compressed = prevCompressed;
            return "0x" + address;
        };
        GeneratorBlockchain.getBitcoinAddress1 = function (node) {
            return node.keyPair.getAddress();
        };
        return GeneratorBlockchain;
    }());
    GeneratorBlockchain.emitter$ = $({});
    GeneratorBlockchain.MNEMONIC_CHANGED = 'MNEMONIC_CHANGED';
    jaxx.GeneratorBlockchain = GeneratorBlockchain;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=generator-blockchain.js.map
var jaxx;
(function (jaxx) {
    var MATH = (function () {
        function MATH() {
        }
        MATH.sumUTXOs = function (utxos) {
            return utxos.reduce(function (sum, item) { return sum += item.amount; }, 0);
        };
        MATH.toDecimal = function (value) {
            if (+value === 0)
                return '0';
            var sign = '';
            if (+value < 0) {
                sign = '-';
                value = value.substr(1);
            }
            return sign + (value.length > 12 ? MATH.weiToEther(value) : MATH.satoshiToBtc(value));
        };
        MATH.bigNum = function (value) {
            var BN = thirdparty.bnjs;
            return new BN(value);
        };
        MATH.lessAthenB = function (a, b) {
            var Bn = thirdparty.bnjs;
            return (new Bn(a)).lt(new Bn(b));
        };
        MATH.lessOrEqualAthenB = function (aInt, bInt) {
            //  return (Formatters.balanceForDisplay(a, 18) <= Formatters.balanceForDisplay(b, 18));
            var Bn = thirdparty.bnjs;
            return (new Bn(aInt)).lte(new Bn(bInt));
        };
        MATH.displayLessOrEqualAthenB = function (a, b) {
            return (jaxx.Formatters.balanceForDisplay(a, 18) <= jaxx.Formatters.balanceForDisplay(b, 18));
        };
        MATH.greaterOrEqualAthenB = function (a, b) {
            var Bn = thirdparty.bnjs;
            return (new Bn(a)).gte(new Bn(b));
        };
        MATH.greaterAthenB = function (aInt, bInt) {
            //return (Formatters.balanceForDisplay(a, 18) > Formatters.balanceForDisplay(b, 18));
            //JN: bnjs library didn't properly support this function.
            var Bn = thirdparty.bnjs;
            return (new Bn(aInt)).gt(new Bn(bInt));
        };
        MATH.dropRightCeil = function (amount, length) {
            return String(Math.ceil(Number(amount) * (10 * length)) / (10 * length));
        };
        MATH.displayGreaterAthenB = function (a, b) {
            return (jaxx.Formatters.balanceForDisplay(a, 18) > jaxx.Formatters.balanceForDisplay(b, 18));
        };
        MATH.multiplay = function (valsInt) {
            var Bn = thirdparty.bnjs;
            var res = new Bn('1');
            valsInt.forEach(function (item) {
                res = res.mul(new Bn(item));
            });
            return res.toString();
        };
        MATH.divide = function (num1Int, num2Int) {
            var Bn = thirdparty.bnjs;
            var a = new Bn(num1Int);
            return a.div(new Bn(num2Int)).toString();
        };
        MATH.subtract = function (num1, num2) {
            var Bn = thirdparty.bnjs;
            var b = new Bn(num2);
            var a = new Bn(num1);
            return a.add(b.neg()).toString();
        };
        MATH.sum = function (vals) {
            var Bn = thirdparty.bnjs;
            var res = new Bn('0');
            vals.forEach(function (item) {
                res = res.add(new Bn(item));
            });
            return res.toString();
        };
        MATH.difference = function (vals) {
            var Bn = thirdparty.bnjs;
            var res = new Bn('0');
            vals.forEach(function (item) {
                res = res.sub(new Bn(item));
            });
            return res.toString();
        };
        MATH.btcToSatoshi = function (btc) {
            // console.log(btc)
            var ar = ('' + btc).replace(',', '.').split('.');
            var suffix = '';
            if (ar.length == 1)
                suffix = '00000000';
            else {
                suffix = ar[1];
                if (suffix.length > 8) {
                    console.error(' btc not valid too long ' + btc);
                    suffix = suffix.substr(0, 8);
                }
                else
                    while (suffix.length < 8)
                        suffix += '0';
            }
            var res = ar[0] + suffix;
            while (res.length && res.substr(0, 1) === '0')
                res = res.substr(1);
            // console.log(res);
            return res;
        };
        MATH.satoshiToBtc = function (satoshi) {
            while (satoshi.length < 9)
                satoshi = '0' + satoshi;
            return satoshi.slice(0, -8) + '.' + satoshi.slice(-8);
        };
        MATH.shiftRight = function (value, length) {
            while (length--)
                value += '0';
            return value;
        };
        MATH.shiftLeft = function (value, length) {
            return value.substr(0, value.length - length);
        };
        MATH.isZero = function (a) {
            if (!a)
                return true;
            var value = a.replace(/[0|.]/g, '');
            if (value.length)
                return false;
            return true;
        };
        MATH.addTrailingZeros = function (value, coinConfig) {
            var multiplier = [];
            for (var i = 0; i < Number(coinConfig.shiftCount); i++) {
                multiplier.push("10");
            }
            multiplier.push(value);
            return this.multiplay(multiplier);
        };
        MATH.removeTrailingZeros = function (value, coinConfig) {
            var multiplier = [];
            for (var i = 0; i < Number(coinConfig.shiftCount); i++) {
                multiplier.push("10");
            }
            return this.divide(value, this.multiplay(multiplier));
        };
        /**
         * Takes a number of an ether and converts it to wei.
         * @method etherToWei
         * @param {Number|String|BigNumber} number can be a number, number string or a HEX of a decimal
         * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
         */
        MATH.etherToWei = function (number) {
            return new BigNumber(number).multiply(MATH.etherUnitMap.ether).toString();
        };
        ;
        /**
         * Takes a number of wei and converts it to ether.
         *
         * @method fromWei
         * @param {Number|String} number can be a number, number string or a HEX of a decimal
         * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
         */
        MATH.weiToEther = function (number) {
            return MATH.stripTrailingZeroes(new BigNumber(number).divide(MATH.etherUnitMap.ether).toString(18));
        };
        ;
        /**
         * Removes all trailing decimal zeroes on a string of numbers (i.e 1.2300 -> 1.23).  If the decimal component
         * (the mantissa) is only zeros, a whole number is returned (i.e. 10.0 -> 10).
         *
         * @method stripTrailingZeroes
         * @param {String} number in the format of a string
         * @return {String} When a string number is passed it returns a string with no trailing zeros
         */
        MATH.stripTrailingZeroes = function (number) {
            // This reqular expression first parses the whole number component ($1) and then parses the mantissa ($2).
            // All trailing zeros are removed from the mantissa; however, if the mantissa comprises of just zeros,
            // it is ignored.
            return number.replace(/\b(\d+)(?:(\.\d*?[1-9]+)|\.0*)/, '$1$2');
        };
        return MATH;
    }());
    //These are the different unit types of ether will come in handy if we plan on converting to different units.
    MATH.etherUnitMap = {
        'noether': '0',
        'wei': '1',
        'kwei': '1000',
        'Kwei': '1000',
        'babbage': '1000',
        'femtoether': '1000',
        'mwei': '1000000',
        'Mwei': '1000000',
        'lovelace': '1000000',
        'picoether': '1000000',
        'gwei': '1000000000',
        'Gwei': '1000000000',
        'shannon': '1000000000',
        'nanoether': '1000000000',
        'nano': '1000000000',
        'szabo': '1000000000000',
        'microether': '1000000000000',
        'micro': '1000000000000',
        'finney': '1000000000000000',
        'milliether': '1000000000000000',
        'milli': '1000000000000000',
        'ether': '1000000000000000000',
        'kether': '1000000000000000000000',
        'grand': '1000000000000000000000',
        'mether': '1000000000000000000000000',
        'gether': '1000000000000000000000000000',
        'tether': '1000000000000000000000000000000'
    };
    jaxx.MATH = MATH;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=math.js.map
var jaxx;
(function (jaxx) {
    /*
    * This is a utility class helps store json data in local storage.
    * */
    var FileManager = (function () {
        function FileManager() {
        }
        /*
        * This updates the localstorage with json file.  If it is obtainable by server it uses the server version.
        * Else it uses the local copy if not available.
        * @method updateLocalStorage
        * @param {String} url
        * @param {String} filePath
        * @param {String} key
        * @param {Function} callback
        * */
        FileManager.updateLocalStorage = function (url, filePath, key, cb) {
            FileManager.downloadFile(url, function (err, response) {
                if (err) {
                    console.error(err);
                    FileManager.downloadFile(filePath, function (localFileErr, localResponse) {
                        if (localFileErr) {
                            console.error(localFileErr);
                            cb(localFileErr);
                        }
                        else {
                            FileManager.saveLocalStorage(key, localResponse);
                            cb();
                        }
                    });
                }
                else {
                    FileManager.saveLocalStorage(key, response);
                    cb();
                }
            });
        };
        /*
        * Get file in local storage
        * @method getLocalStorage
        * @param {String} key
        * @return a stringified JSON object of what is saved in local storagfe
        * */
        FileManager.getLocalStorage = function (key) {
            return JSON.parse(localStorage.getItem(key));
        };
        /*
        * Saves file into local storage
        * @method saveLocalStorage
        * @param {String} key
        * @param {String} response
        * */
        FileManager.saveLocalStorage = function (key, response) {
            localStorage.setItem(key, response);
        };
        /*
        * Downloads JSON Object from specified URL
        * @method downloadFile
        * @param {String} url
        * @param {Function} cb (callback)
        * */
        FileManager.downloadFile = function (url, cb) {
            $.getJSON(url).done(function (response) {
                cb(null, JSON.stringify(response));
            }).fail(function (err) {
                cb(err);
            });
        };
        return FileManager;
    }());
    jaxx.FileManager = FileManager;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=fileManager.js.map
/**
 * Created by Vlad on 10/9/2016.
 */
///<reference path="./models.ts"/>
///<reference path="./Utils.ts"/>
var jaxx;
(function (jaxx) {
    var ServiceMappers = (function () {
        function ServiceMappers() {
        }
        ServiceMappers.mapUTXOsDecentral = function (result) {
            var out = [];
            var obj = result;
            var _loop_1 = function (str) {
                var item = obj[str];
                var utxos = item.map(function (item) {
                    return new VOutxo({
                        address: str,
                        vout: item.vout,
                        amount: item.amount,
                        decimal: +item.amount,
                        block: item.confirmed,
                        satoshis: jaxx.MATH.btcToSatoshi(item.amount),
                        txid: item.txhash
                    });
                });
                out = out.concat(utxos);
            };
            for (var str in obj) {
                _loop_1(str);
            }
            return out;
        };
        ServiceMappers.mapTransactionsDecentral = function (result) {
            var out = [];
            var obj = result;
            for (var str in obj) {
                var item = obj[str];
                var t = new VOTransaction({
                    id: item.hash,
                    block: item.height,
                    from: item.vin[0].address,
                    timestamp: item.time_utc ? Math.ceil((new Date(item.time_utc)).getTime() / 1000) : Math.ceil(item.storedTime / 1e3),
                    confirmations: item.confirmations
                });
                //  console.log(item);
                t.tos = item.vout.map(function (item) {
                    return item.address;
                });
                t.values = item.vout.map(function (item) {
                    return +item.amount;
                });
                t.total = item.vin.reduce(function (sum, vin) {
                    return sum += -vin.amount;
                }, 0);
                t.miningFee = (t.total - _.sum(t.values)).toPrecision(2);
                ///console.log(t);
                out.push(t);
            }
            return out;
        };
        /*static mapTransactionsInsight(result):VOTransaction[]{

            let out:VOTransaction[] = [];
            let obj = result.byAddress;

            for(let str in obj){

                let trxs:any[] = obj[str];

                trxs.forEach(function (item) {

                    let t:VOTransaction = new VOTransaction({
                        id:item.txid,
                        block:item.blockheight,
                        form:item.vin[0].addr,
                        timestamp:item.blocktime,
                        confirmations:item.confirmations
                    });

                    t.tos = item.vout.reduce(function (sum, item) {
                        return sum.concat(item.scriptPubKey.addresses);
                    },[]);

                    t.values = item.vout.map(function (item) {
                        return +item.value;
                    });

                    t.total = item.vin.reduce(function (sum, vin) {
                        sum+=+vin.value;
                    },0);

                    out.push(t);

                })

            }

            return out

        }
*/
        ServiceMappers.mapBitcoinUTXO = function (ar) {
            return ar.map(function (item) {
                return new VOutxo({
                    decimal: +item.amount / 1e8,
                    address: item.address,
                    vout: item.vout,
                    block: item.height,
                    confirmations: item.confirmations,
                    satoshis: item.satoshis + '',
                    amount: item.amount,
                    timestamp: Date.now()
                });
            });
        };
        ServiceMappers.mapBitcoinBalance = function (address, data, confirmed) {
            return new VOBalance({ id: address, balance: String(data), confirmed: confirmed });
        };
        ServiceMappers.parseTransactionsETHjaxxio = function (respond, address) {
            return respond.map(function (item) {
                if (item.timeStamp)
                    item.timestamp = item.timeStamp;
                var date = new Date(+item.timestamp * 1000);
                return new VOTransaction({
                    id: item.hash,
                    address: address,
                    from: item.from,
                    to: item.to,
                    value: (address === item.from) ? -Number(item.value) : Number(item.value),
                    // tax:+item.gasUsed,
                    miningFee: +item.gasUsed,
                    nonce: +item.nonce,
                    confirmations: +item.confirmations,
                    timestamp: +item.timestamp,
                    date: date.toLocaleDateString() + ' ' + date.toLocaleTimeString(),
                    block: +item.blockNumber,
                });
            });
        };
        ServiceMappers.parseBalanceETHjaxxio = function (respond) {
            var stamp = Math.round(Date.now() / 1000);
            // console.log(respond);
            var out = [];
            for (var str in respond) {
                out.push(new VOBalance({
                    id: str,
                    balance: +respond[str],
                    timestamp: stamp
                }));
            }
            return out;
        };
        ServiceMappers.parseUTXOsBlocker = function (response) {
            if (!Array.isArray(response.data))
                response.data = [response.data];
            var data = response.data;
            var out = [];
            data.forEach(function (addressutxos) {
                var address = addressutxos.address;
                var unspent = addressutxos.unspent;
                out = out.concat(unspent.map(function (item) {
                    return new VOutxo({
                        address: address,
                        amountBtc: item.amount,
                        amount: (+item.amount * 1e8),
                        txid: item.tx,
                        vout: item.n,
                        confirmations: item.confirmations,
                        timestamp: Date.now()
                    });
                }));
            });
            return out;
        };
        ServiceMappers.parseUTXOsCoinfabrikLTC = function (data) {
            var out = [];
            var _loop_2 = function (str) {
                var items = data[str];
                items.forEach(function (item) {
                    out.push(new VOutxo({
                        address: str,
                        amountBtc: item.amount,
                        amount: +item.litoshis,
                        txid: item.txhash,
                        vout: item.vout,
                        confirmations: (item.confirmations || -1)
                    }));
                });
            };
            for (var str in data) {
                _loop_2(str);
            }
            return out;
        };
        ServiceMappers.parseUTXOsCoinfabrikBTC = function (respond) {
            var out = [];
            return respond.map(function (item) {
                return new VOutxo({
                    address: item.address,
                    amountBtc: item.amount + '',
                    amount: +item.satoshis,
                    txid: item.txid,
                    vout: item.vout,
                    confirmations: item.confirmations
                });
            });
        };
        ServiceMappers.parseUTXOsCoinfabrikZCash = function (data) {
            var out = [];
            var _loop_3 = function (str) {
                var items = data[str];
                items.forEach(function (item) {
                    out.push(new VOutxo({
                        address: str,
                        amountBtc: item.amount,
                        amount: +item.zatoshis,
                        txid: item.txhash,
                        vout: item.vout,
                        confirmations: (item.confirmations || -1)
                    }));
                });
            };
            for (var str in data) {
                _loop_3(str);
            }
            return out;
        };
        ServiceMappers.mapBalancesCoinfabric = function (response) {
            var out = [];
            for (var address in response) {
                var item = response[address];
                var ac = +item.confirmed.zatoshis;
                // console.log(address + ' item.confirmed  ', item.confirmed);
                // console.log(address + ' item.unconfirmed  ', item.unconfirmed);
                var uc = +item.unconfirmed.zatoshis;
                if (uc < 0)
                    uc = 0;
                out.push(new VOBalance({
                    id: address,
                    balance: ac + uc
                }));
            }
            return out;
        };
        ServiceMappers.mapUTXOsCoinfabrik = function (data) {
            var out = [];
            var _loop_4 = function (str) {
                var items = data[str];
                items.forEach(function (item) {
                    out.push(new VOutxo({
                        address: str,
                        amountBtc: item.amount,
                        amount: +item.zatoshis,
                        txid: item.txhash,
                        vout: item.vout,
                        confirmations: (item.confirmations || -1)
                    }));
                });
            };
            for (var str in data) {
                _loop_4(str);
            }
            return out;
        };
        ServiceMappers.mapEtherTransactions = function (ar, address) {
            return ar.map(function (item) {
                if (item.timeStamp)
                    item.timestamp = item.timeStamp;
                var date = new Date(+item.timestamp * 1000);
                return new VOTransaction({
                    id: item.hash,
                    address: address,
                    from: item.from,
                    to: item.to,
                    value: (address === item.from) ? -Number(item.value) : Number(item.value),
                    // tax:+item.gasUsed,
                    miningFee: +item.gasUsed,
                    gasUsed: item.gasUsed,
                    gasPrice: item.gasPrice,
                    //nonce:+item.nonce,
                    confirmations: +item.confirmations,
                    timestamp: +item.timestamp,
                    date: date.toLocaleDateString() + ' ' + date.toLocaleTimeString(),
                    block: +item.blockNumber
                    // address_index:address_index,
                    // receive_change:receive_change
                });
            });
        };
        ServiceMappers.mapBlockrTransactions = function (ar, address) {
            return ar.map(function (item) {
                return new VOTransaction({
                    id: item.tx,
                    address: address,
                    // from:item.from,
                    // to:item.to,
                    value: +item.amount,
                    // miningFee:+item.gasUsed,
                    // nonce:+item.nonce,
                    confirmed: +item.confirmations,
                    timestamp: +item.timeStamp,
                });
            });
        };
        return ServiceMappers;
    }());
    jaxx.ServiceMappers = ServiceMappers;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=service-mapper.js.map
var jaxx;
(function (jaxx) {
    // class checking Addresses generated in JAXX and stored in local storage are in strict sequence and no missing addresses.
    // If any case where sequence was mismatch is indicator of possible errors of data integrity and flag wasProblem raised as indicator of possibility of data corrupted
    var HealthAddressHD = (function () {
        function HealthAddressHD(balances, generator, isChange) {
            // Normalize balances now do both remove duplicates and fill gaps;
            //check  sequence covers all errors
            //if(this.hasDuplicates(balances))this.removeDuplicates(balances);
            if (!this.checkAddressesSequance(balances))
                this.normalizeAddresses(balances, generator, isChange ? 1 : 0);
            this.destroy();
        }
        //  remove duplicates and fill gaps in addresses what can cause after restore history process
        HealthAddressHD.prototype.normalizeAddresses = function (balances, generator, isChange) {
            this.wasProblem = true;
            var indexed = _.keyBy(balances, 'index');
            // balances.sort(function(a, b){return a.index-b.index});
            var receiveChange = isChange ? 'change' : 'receive';
            var out = [];
            for (var i = balances.length - 1; i >= 0; i--) {
                if (!balances[i] || balances[i].index !== i) {
                    var bal = indexed[i];
                    if (!bal)
                        bal = new VOBalance({
                            id: generator.generateAddress(i, receiveChange),
                            balance: '0',
                            decimal: 0,
                            index: i,
                            type: isChange
                        });
                    balances[i] = bal;
                }
                out.push(balances[i]);
            }
            return out.reverse();
        };
        // detects are duplicates  of address in array
        HealthAddressHD.prototype.hasDuplicates = function (balances) {
            var testObj = {};
            for (var i = balances.length - 1; i >= 0; i--) {
                if (!testObj[balances[i].id])
                    testObj[balances[i].id] = 1;
                else
                    return true;
            }
            return false;
        };
        // removes duplicate of address in array of balances to fix data integrity
        HealthAddressHD.prototype.removeDuplicates = function (balances) {
            this.wasProblem = true;
            var testObj = {};
            for (var i = balances.length - 1; i >= 0; i--) {
                if (!!testObj[balances[i].id]) {
                    balances.splice(i, 1);
                }
                testObj[balances[i].id] = 1;
            }
        };
        // this function checks  all addresses in array in strict sequence otherwise it was a problem during restore history process or
        // other processes relative to address generation what can lead to missing addresses or duplicates
        HealthAddressHD.prototype.checkAddressesSequance = function (balances) {
            return balances.every(function (item, index) {
                return item.index === index;
            });
        };
        /// this function not used yet but useful in future. it removes all balances in array from end wher balance value =0
        HealthAddressHD.prototype.removeTrailingBalances0 = function (balances) {
            //console.log('Removing trailing zeros ');
            balances.sort(function (a, b) { return a.index - b.index; });
            for (var i = balances.length - 1; i >= 0; i--) {
                if (isNaN(balances[i].index))
                    balances[i].index = i;
                if (+balances[i].balance == 0)
                    balances.splice(i, 1);
                else
                    break;
            }
        };
        HealthAddressHD.prototype.destroy = function () {
        };
        return HealthAddressHD;
    }());
    jaxx.HealthAddressHD = HealthAddressHD;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=wallet-health.js.map
///<reference path="../com/models.ts"/>
///<reference path="../com/Utils.ts"/>
///<reference path="../com/Utils2.ts"/>
///<reference path="../com/datastore_local.ts"/>
///<reference path="../archive/services/token_ethereum/ethereum_token.ts"/>
var jaxx;
(function (jaxx) {
    // import Utils2 = jaxx.Utils2;
    var CoinService = (function () {
        function CoinService(config, _db, generator) {
            this._db = _db;
            this.errors = [];
            for (var str in config)
                this[str] = config[str];
            this.generator = generator ? generator : new jaxx.GeneratorBlockchain(config);
            if (config.symbol === 'BTC')
                this.request = new jaxx.InsightApi(config, this.generator);
            else
                this.request = new jaxx.DecentralApi(config, this.generator);
            // this.balances$ = $({});
            ///console.log(this. name + ' : ' + settings.request + ' coin_HD_index   ' + this.coin_HD_index);
        }
        CoinService.prototype.lastBlock = function () {
            return this.request.lastBlock();
        };
        CoinService.prototype.sendTransaction = function (transaction) {
            return this.request.sendTransaction(transaction);
        };
        CoinService.prototype.downlaodUTXOs = function (addresses) {
            return this.request.downlaodUTXOs(addresses);
        };
        CoinService.prototype.downloadBalances = function (addresses) {
            return this.request.downloadBalances(addresses);
        };
        CoinService.prototype.downloadTransactionsDetails = function (transactions) {
            return this.request.downloadTransactionsDetails(transactions);
        };
        CoinService.prototype.stopAll = function () {
            this.request.stopAll();
        };
        CoinService.prototype.downlaodNonces = function (addresses) {
            return null;
        };
        CoinService.prototype.downloadTransactions = function (addresses) {
            return this.request.downloadTransactions(addresses);
        };
        CoinService.prototype.getKeyPairReceive = function (index) {
            return this.generator.generateKeyPairReceive(index);
        };
        CoinService.prototype.getKeyPairChange = function (index) {
            return this.generator.generateKeyPairChange(index);
        };
        CoinService.prototype.onError = function (err) {
            console.error(err);
            this.errors.push(err);
            if (this.errors.length > 1000)
                this.errors.shift();
        };
        CoinService.prototype.restoreHistory = function (receiveIndex, changeIndex) {
            return this.request.restoreHistory(receiveIndex, changeIndex);
        };
        // ON_RESTORED_HISTORY_RECEIVE: string = 'ON_RESTORED_HISTORY_RECEIVE';
        CoinService.prototype.checkAddressesForTranasactions = function (addresses) {
            //console.warn(addresses);
            return null;
            /*  return this.crypto_class.checkAddressesForTranasactions(addresses).then(result => {
                  console.log(result);
                  return result;
              });*/
        };
        return CoinService;
    }());
    jaxx.CoinService = CoinService;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=coin-service.js.map
///<reference path="../com/models.ts"/>
///<reference path="../app/Registry.ts"/>
///<reference path="../com/Utils.ts"/>
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var jaxx;
(function (jaxx) {
    // declare let $: any;
    var CoinController = (function (_super) {
        __extends(CoinController, _super);
        function CoinController(config) {
            var _this = _super.call(this, config) || this;
            // intervalAllBalancesCheckDefault:number ;
            _this.intervalAllBalancesCheckCurrent = 30000;
            _this.intervalCurrentBalanceCheck = 10000;
            _this.spentUTXOs = [];
            _this._coinType = config.coinType;
            _this.init();
            return _this;
        }
        CoinController.prototype.init = function () {
            var _this = this;
            this.miningFeeController = new jaxx.MiningFeeController(this.config, this._db);
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_SATUS_CHANGED, function (evt, name, enbl) {
                console.log(name, enbl);
                if (name == _this.name) {
                    _this.enabled = enbl;
                }
            });
            // let updateOptions = {updateTimeout: 10000, confirmations: 12};
            //if (this.name.indexOf('Ethereum') === -1) updateOptions.confirmations = 6;
        };
        // interface to retrieve mining fee value according user set option
        CoinController.prototype.getMiningFeeValueCtr = function () {
            return this.miningFeeController;
        };
        // interface to retrieve user option for mining fee
        CoinController.prototype.getIMiningFeeOptionCtr = function () {
            return this.miningFeeController;
        };
        CoinController.prototype.getDisplayBalance = function (balance) {
            return jaxx.MATH.satoshiToBtc(balance);
        };
        CoinController.prototype.getBalanceDisplay = function () {
            if (this.isRestoringHistory)
                return '-1';
            return jaxx.MATH.satoshiToBtc(this.getBalance());
        };
        CoinController.prototype.getBalance = function () {
            //if(this.balanceCache) return this.balanceCache;
            var balances = this._db.getBalancesAll(true);
            if (balances.length === 0)
                return '-1';
            var ar = balances
                .reduce(function (ar, item) { if (item.balance !== '0')
                ar.push(item.balance); return ar; }, []);
            var balance = jaxx.MATH.sum(ar);
            if (!!this.spentBalances && this.spentBalances.length) {
                var spentAr = this.spentBalances.map(function (item) { return item.balance; });
                var spent = jaxx.MATH.sum(spentAr);
                if (+spent > +balance) {
                    console.warn(' spent more! balance: ' + balance + ' spent: ' + spent);
                }
                else {
                    balance = jaxx.MATH.subtract(balance, spent);
                }
            }
            // console.log(this.symbol + ' balance ' + result + ' spent: ' + spent + ' was ' + balance);
            this.balanceCache = balance;
            // if (+res < 0) res = '0';
            // console.log('%c '+this.config.symbol + ' balance: '+ balance, 'color:brown');
            return this.balanceCache;
        };
        //         calculateSpendable(utxos: VOutxo[], spentUtxos: VOutxo[]): string {
        //
        //             let outUTXOS:VOutxo[] = utxos;
        //
        //             console.log(Utils.deepCopy(utxos), Utils.deepCopy(spentUtxos));
        //
        //             if(spentUtxos.length){
        //
        //                 outUTXOS = Utils.subtractUTXOS(utxos, spentUtxos);
        //
        //                 console.log(Utils.deepCopy(outUTXOS));
        //
        //             }
        //
        //
        //             let ar = outUTXOS.map(function (item) {
        //                 return item.satoshis;
        //             });
        //
        //
        //             let total = MATH.sum(ar);
        // /*
        //             spentUtxos.forEach(function (item) {
        //                 total = MATH.subtract(total, item.satoshis);
        //             });*/
        //
        //             let mf = this.getMiningFee();
        //
        //             total = MATH.subtract(total, mf);
        //
        //             console.warn('  calculateSpendable  ' + total);
        //
        //             if (+total < 0) return '0';
        //
        //
        //
        //             // if (MATH.lessAthenB(total, mf)) ;
        //             // console.log(this.name + ' spendable ' + total);
        //
        //             return MATH.satoshiToBtc(total);
        //         }
        CoinController.prototype.getSpendable = function () {
            var utxos = this.getSpendableUTXOs();
            var outUTXOS = utxos;
            if (this.spentUTXOs.length) {
                outUTXOS = jaxx.Utils.subtractUTXOS(utxos, this.spentUTXOs);
            }
            var ar = outUTXOS.map(function (item) {
                return item.satoshis;
            });
            var pricePerbyte = this.getMiningPrice();
            var total = jaxx.MATH.sum(ar);
            //console.log('%c ' +this.config.symbol + ' you have total ' + total, 'color:brown');
            total = this.subtractMiningFee(total, outUTXOS.length);
            if (+total < 0 || isNaN(Number(total))) {
                return '0';
            }
            total = jaxx.MATH.satoshiToBtc(total);
            return total;
        };
        CoinController.prototype.getSpendableBalance = function (callback) {
            var _this = this;
            var cachedUTXOs = this._db.getUTXOsFromCache();
            if (cachedUTXOs === null) {
                this.downloadUTXOs(function () {
                    var downloadedTotal = _this.calculateSpendableFromUTXOs(_this.getUTXOs());
                    callback(downloadedTotal);
                });
            }
            else {
                var retVal = this.calculateSpendableFromUTXOs(cachedUTXOs);
                callback(retVal);
            }
        };
        CoinController.prototype.calculateSpendableFromUTXOs = function (utxos) {
            var bytesPerInput = 148;
            var miningFee = Number(this.getMiningPrice());
            var feeToSpend = (bytesPerInput * miningFee);
            var outUTXOS;
            if (this.symbol === 'BTC') {
                outUTXOS = utxos.filter(function (utxo) {
                    return utxo.amount * 1e8 > feeToSpend;
                });
            }
            else {
                outUTXOS = utxos;
            }
            if (this.spentUTXOs.length) {
                outUTXOS = jaxx.Utils.subtractUTXOS(outUTXOS, this.spentUTXOs);
            }
            var ar = outUTXOS.map(function (item) {
                return item.satoshis;
            });
            var total = jaxx.MATH.sum(ar);
            total = this.subtractMiningFee(total, outUTXOS.length);
            if (+total < 0 || isNaN(Number(total))) {
                return '0';
            }
            total = jaxx.MATH.satoshiToBtc(total);
            return total;
        };
        CoinController.prototype.subtractMiningFee = function (total, length) {
            return this.getMiningFeeValueCtr().subtractMiningFee(total, length);
            // let mf = this.getMiningFee();
            //return MATH.subtract(total, mf);
        };
        CoinController.prototype.getMiningPrice = function () {
            return this.getMiningFeeValueCtr().getMiningFeePerByte();
            //return 200;
        };
        CoinController.prototype.getMiningFeeStatic = function () {
            return this.config.miningFee;
        };
        CoinController.prototype.startDownloadUTXOs = function () {
            var _this = this;
            this.stopDownloadUTXOs();
            this.intervalUTXOs = setInterval(function () {
                _this.downloadUTXOs(null);
            }, 20000);
            this.downloadUTXOs(null);
        };
        CoinController.prototype.stopDownloadUTXOs = function () {
            clearInterval(this.intervalUTXOs);
            this.intervalUTXOs = 0;
        };
        CoinController.prototype.isIntersect = function (spent, server) {
            var indexed = {};
            spent.forEach(function (item) {
                indexed[item.txid + item.address];
            });
            for (var i = 0, n = server.length; i < n; i++) {
                var utxo = server[i];
                if (indexed[utxo.txid + utxo.address])
                    return true;
            }
            return false;
        };
        CoinController.prototype.downloadUTXOs = function (callBack) {
            var _this = this;
            if (!this.isActive) {
                this.stopDownloadUTXOs();
                return;
            }
            if (this.isRestoringHistory)
                return;
            var bals = this.getBalancesNot0();
            var addresses = bals.map(function (item) {
                return item.id;
            });
            var start = Date.now();
            console.log(this.symbol + ' downloadUTXOs ' + addresses.length);
            /* let bals = this._db.getBalancesAll(true);
             let addresses:string[] = [];

             bals.forEach(function (item) {
                 if(item.balance !='0') addresses.push(item.id);
             });*/
            if (addresses.length === 0) {
                if (callBack)
                    callBack();
                return;
            }
            this.coinService.downlaodUTXOs(addresses)
                .done(function (utxos) {
                console.log(_this.symbol + ' downloaded utxos in ' + ((Date.now() - start) / 1000).toPrecision(2) + 'sec', utxos);
                var oldValue = jaxx.MATH.sumUTXOs(_this.getUTXOs());
                var newValue = jaxx.MATH.sumUTXOs(utxos);
                if (_this.spentUTXOs.length) {
                    console.log('spent: ', _this.spentUTXOs);
                }
                if (oldValue !== newValue)
                    jaxx.Registry.walletValue$.triggerHandler(jaxx.Registry.ON_WALLET_VALUE_CHANGE);
                var isInresect = _this.isIntersect(_this.spentUTXOs, utxos);
                if (_this.spentUTXOs.length && !isInresect) {
                    console.log(' spent utxos are removed on server they intersect: ' + isInresect);
                    // if(this._db.getUTXOs().length)
                    _this.spentUTXOs = [];
                }
                _this._db.saveUTXOs(utxos);
                if (callBack)
                    callBack();
            }).fail(function (error) {
                this.onError(error);
                if (callBack)
                    callBack(error);
            });
        };
        CoinController.prototype.deactivate = function () {
            this.miningFeeController.deactivate();
            return _super.prototype.deactivate.call(this);
        };
        CoinController.prototype.activate = function () {
            // this.buildTransaction('0.00086474','18jJvZHU1YFK7h7Z2G7mueBQ2Na7nar19t');
            // timestamp = null;
            /* console.log('%c ' + this.name + ' try  activate  timestamp ' + timestamp, 'color:red');
             if (this.isActive) return;
             this.isActive = true;*/
            if (!_super.prototype.activate.call(this))
                return false;
            this.startDownloadUTXOs();
            //this.loadMiningFee();
            this.miningFeeController.activate();
            // this.downloadNewTransactionsForAddresses(['1Fo92AdKZTPXQpoGcBLpbe5xw8sAhZ9Nhb'])
            /*
                        this.coinService.downloadTransactions(['1LtkDq3guaRR2uiCDoB9zXotGE9i3FBrgE']).done(res=>{
                            console.warn(res);
                        })*/
            // this.downloadUTXOs()
            // this.isRestoringHistory = false;
            //this.downloadingBalancesCounter = 0;
            // console.log(Date.now() - starttime);
            // console.log('%c activating ' + this.name + ' hasIndexes: ' + this.getHistoryTimestamp() + ' recieve ' + this._db.getCurrentIndexReceive() + ' change: ' + this._db.getCurrentIndexChange(), 'color:green');
            //this.transactionController.activate();
            this.transactionsUpdater.activate();
            return true;
        };
        CoinController.prototype.getSpendableUTXOs = function () {
            var utxos = this.getUTXOs();
            var bytesPerInput = 148;
            var miningPrice = this.getMiningFeeValueCtr().getMiningFeePerByte();
            var feeToSpend = (bytesPerInput * miningPrice);
            var outUTXOS;
            outUTXOS = utxos.filter(function (utxo) {
                return +utxo.satoshis > feeToSpend;
            });
            /// added console logs to help why spendable zero even user has balance
            if (utxos.length && outUTXOS.length === 0) {
                console.log(' you have dust only. Price per byte: ' + miningPrice);
            }
            // log dust to see why $50 BTC coming to $5 spendable
            if (outUTXOS.length !== utxos.length) {
                console.log(' you have dust ' +
                    utxos
                        .filter(function (item) { return +item.satoshis < feeToSpend; })
                        .map(function (item) { return item.satoshis; }));
            }
            return outUTXOS;
        };
        CoinController.prototype.getUTXOs = function () {
            return this._db.getUTXOs(); //     this.transactionController.getUTXOsNotInQueue();//getTransactionsUnspent();
        };
        CoinController.prototype.getBalancesNot0 = function () {
            return this._db.getBalancesNot0();
        };
        ////////////////////// Addresses////////////////////
        CoinController.prototype.isAddressChange = function (address) {
            var bals = this._db.getBalancesChange(true);
            var addresses = bals.map(function (item) {
                return item.id;
            });
            return addresses.indexOf(address) !== -1;
        };
        CoinController.prototype.getKeyPairReceive = function (address) {
            var i = this._db.getAddressesReceive().indexOf(address);
            if (i === -1) {
                console.error(' ho index for address ' + address);
                return '';
            }
            return this.coinService.generator.generateKeyPairReceive(i);
        };
        CoinController.prototype.getKeyPairChange = function (address) {
            var bals = this._db.getBalancesChange(true);
            var addresses = bals.map(function (item) {
                return item.id;
            });
            var i = addresses.indexOf(address);
            return (i === -1) ? null : this.coinService.generator.generateKeyPairChange(i);
        };
        CoinController.prototype.getKeyPair = function (address) {
            this._db.getAddressesReceive();
            var keyPairEC = this.getKeyPairChange(address);
            if (!keyPairEC)
                keyPairEC = this.getKeyPairReceive(address);
            return keyPairEC;
        };
        // Just a default.... Might be undefined.
        CoinController.prototype.getPrivateKeyWifByAddress = function (address) {
            // Returns '' if a private key cannot be retrieved.
            var keyPairEC = this.getKeyPair(address);
            return keyPairEC.toWIF();
        };
        //Todo: Needs optimization
        CoinController.prototype.mapDisplayTransactions = function (trs) {
            var walletAddresses = this.getAddressesAll();
            jaxx.Utils.mapTransactionsBitcoin(trs, walletAddresses);
        };
        // Takes a raw VOTransaction and returns one that is ready for UI display
        // UI display has properties such as 'displayAddress' or 'incoming' that are not
        // present on raw transactions and have to be deduced from inputs/outputs
        CoinController.prototype.processTransactionForDisplay = function (tx) {
            var new_tx_data = jaxx.Utils.deepCopy(tx);
            var tx_array = [new_tx_data];
            jaxx.Utils.mapTransactionsBitcoin(tx_array, this.getAddressesAll());
            return tx_array[0];
        };
        CoinController.prototype.supportsTransactionHistory = function () {
            return true;
        };
        CoinController.prototype.getTransactionsDisplay = function () {
            // const requiredTxConfirmations = 6; // ToDo: Get from config
            // let txes:VOTransaction[]     = Utils.deepCopy(super.getTransactionsDisplay().transactions);
            var txes = jaxx.Utils.deepCopy(this._db.getTransactionsReceive()).reverse();
            var self = this;
            var notReadytoDisplay = txes.filter(function (item) {
                return !item.displayValue;
            });
            console.log('%c ' + this.symbol + ' transactions not ready to display ' + notReadytoDisplay.length, 'color:red');
            if (notReadytoDisplay.length) {
                this.mapDisplayTransactions(notReadytoDisplay);
                this._db.saveTransactionsReceive();
            }
            return {
                symbol: this.symbol,
                transactions: txes,
                blockexplorer_url: this.config.blockexplorer_url,
                trsConfirmations: this.config.trsConfirmations
            };
        };
        CoinController.prototype.getCurrentAddressChange = function () {
            var balances = this._db.getBalancesChange(true);
            if (balances.length == 0) {
                console.warn(' no addressess change');
                var addressChange = this.coinService.generator.generateAddressChange(0);
                this._db.saveBalancesChange([new VOBalance({
                        id: addressChange,
                        balance: '0',
                        decimal: 0,
                        index: 0,
                        type: 1
                    })]);
                return addressChange;
            }
            var balance = balances[balances.length - 1];
            if (balance.balance !== '0') {
                // last balance in array has to have the highest index generated by HD system
                var index = _.last(balances).index + 1;
                balance = new VOBalance({
                    id: this.coinService.generator.generateAddressChange(index),
                    balance: '0',
                    decimal: 0,
                    index: index,
                    type: 1
                });
                balances.push(balance);
                this._db.saveBalancesChange(balances);
            }
            return balance.id;
        };
        CoinController.prototype.getAddressesAll = function () {
            var balances = this._db.getBalancesReceive(true);
            var addresses = balances.map(function (item) {
                return item.id;
            });
            balances = this._db.getBalancesChange(true);
            addresses = addresses.concat(balances.map(function (item) {
                return item.id;
            }));
            return addresses;
        };
        CoinController.prototype.getQRCode = function () {
            //thirdparty.qrImage.imageSync(uri, {type: "png", ec_level: "H", size: 7, margin: 1}).toString('base64');
            return '';
        };
        ////////////////////////////////////////// Transactions///////////////////////
        CoinController.prototype.adjustUTXOs = function (transactions) {
            var spentUtxos = transactions.inputs;
            if (!spentUtxos) {
                return;
            }
            var hasSpentUTXOs = spentUtxos.every(function (spentUTXO) {
                return !!spentUTXO.txid;
            });
            if (hasSpentUTXOs)
                this.spentUTXOs = this.spentUTXOs.concat(spentUtxos);
        };
        CoinController.prototype.adjustBalances = function (transaction) {
            var spent = transaction.totalSpent;
            var change = transaction.changeAmount;
            //let realSpent = MATH.subtract(spent, change);
            var balance = new VOBalance({
                id: '',
                balance: spent,
                decimal: +jaxx.MATH.satoshiToBtc(spent)
            });
            console.log(this.symbol + ' added temp balance  spent  ' + spent + ' change  ' + change);
            // let spentUtxos: VOutxo[] = transactions.inputs;
            /*
                        let spentBalances: VOBalance[] = spentUtxos.map(function (item) {
                            return new VOBalance({
                                id: item.address,
                                balance: item.satoshis
                            })
                        });*/
            this.spentBalances = [balance]; ////this.spentBalances.concat(spentBalances);
        };
        CoinController.prototype.sendTransaction = function (transaction) {
            var _this = this;
            var deferred = $.Deferred();
            var tr = transaction.transactionBTC;
            console.log(transaction);
            var hex = transaction.hex;
            //  console.log(hex)
            this.coinService.sendTransaction(transaction)
                .done(function (result) {
                console.log(_this.symbol + '   transaction sent ', result);
                // console.log(result);
                _this.adjustBalances(transaction);
                _this.adjustUTXOs(transaction);
                console.log(_this.getSpendable());
                _this.dispatchBalance();
                deferred.resolve(transaction);
            }).fail(function (error) {
                deferred.reject(error);
                _this.onError(error);
            });
            return deferred;
        };
        CoinController.prototype.buildTransaction = function (amount, addressTo, isMax, customGasLimit, customData) {
            var _this = this;
            var spendable = this.getSpendable();
            ///one mo time check if for some reason requested amount more then spendable considering input was wrong and sending max;
            if (!isMax && +amount >= +spendable)
                isMax = true;
            var deferred = $.Deferred();
            var utxos = this.getSpendableUTXOs();
            var privateKeys = {};
            utxos.forEach(function (utxo) {
                privateKeys[utxo.address] = _this.getKeyPair(utxo.address);
            });
            var amountSatoshi = jaxx.MATH.btcToSatoshi(amount);
            //console.log(this.name + ' buildTransaction   amountBTC ' + amount + ' amountSatoshi '+amountSatoshi+ ' to   ' + addressTo);
            var miningFeeStatic = this.getMiningFeeStatic();
            var addressChange = this.getCurrentAddressChange();
            var miningFeePerByte = this.getMiningPrice();
            var transaction;
            if (this.symbol === 'BCH') {
                transaction = jaxx.TransactionsUtilsBitcoin.buildBCHPerbyte(amountSatoshi, addressTo, utxos, privateKeys, null, addressChange, this.config.network, this.symbol, isMax, miningFeePerByte);
            }
            else {
                transaction = jaxx.TransactionsUtilsBitcoin.buildBTC(amountSatoshi, addressTo, utxos, privateKeys, null, addressChange, this.config.network, this.symbol, isMax, miningFeePerByte);
            }
            console.log(transaction);
            deferred.resolve(transaction);
            return deferred.promise();
        };
        CoinController.prototype.onTransactionUserConfirmed = function (data) {
            this.rawTransaction = data;
        };
        CoinController.prototype.setCurrentAddresses = function () {
            var lastIndexReceive = this._db.getCurrentAddressReceive();
        };
        CoinController.prototype.onCurrentReceiveAddressGotBalance = function (balance) {
            this.goToNextAddressReceive();
            this.downloadBalancesAll(null);
        };
        CoinController.prototype.downloadTransactionsDetails = function (transactions) {
            var _this = this;
            this.coinService.downloadTransactionsDetails(transactions).done(function (res) {
                //  console.log(res);
                //  let addressses = this._db.getAddressesAll();
                //if(trs) return trs;
                //Utils.mapTransactionsDisplay(res, addressses);
                _this._db.saveTransactionsReceive(res);
                _this.dispatchTransactions();
            });
        };
        CoinController.prototype.restoreHistory = function (callBack) {
            var _this = this;
            this.isRestoringHistory = true;
            this.stopBalancesCheck();
            //  let obj ={symbol:this.symbol, name:this.name};
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_RESTORE_HISTORY_START, this);
            // Registry.application$.triggerHandler( Registry.ON_BALANCE_CHANGED, obj)
            this.coinService.restoreHistory(0, 0)
                .done(function (result) {
                if (result.transactions) {
                    _this._db.saveTransactionsReceive(result.transactions);
                }
                else {
                    _this.downloadTransactionsDetails(result.transactionsids);
                }
                // before saving new Balances returned from restore history process check are all addresses in array generated without gaps and no duplicates
                // if array contained gaps or duplicated problem was solved by HealthAddressesHD class and flag wasProblem set to true.
                var check = new jaxx.HealthAddressHD(result.balancesReceive, _this.generator, false);
                if (check.wasProblem)
                    console.warn(' was problem  restoring history balancesReceive ' + _this.config.symbol);
                //else console.log('addresses OK');
                check = new jaxx.HealthAddressHD(result.balancesChange, _this.generator, true);
                if (check.wasProblem)
                    console.warn(' was problem  restoring history balancesChange ' + _this.config.symbol);
                //else console.log('addresses OK');
                _this._db.saveBalancesChange(result.balancesChange);
                _this._db.saveBalancesReceive(result.balancesReceive);
                _this.goToNextAddressReceive();
                _this.goToNextAddressChange();
                _this.setHistoryTimestamp();
                _this.isRestoringHistory = false;
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_RESTORE_HISTORY_DONE, _this);
                _this.startBalancesCheck();
                if (result.transactions) {
                    _this.dispatchTransactions();
                }
                if (callBack) {
                    callBack();
                }
            }).fail(function (error) {
                _this.isRestoringHistory = false;
                _this.onError(error);
            });
        };
        return CoinController;
    }(jaxx.CoinControllerBase));
    jaxx.CoinController = CoinController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=coin-controller.js.map
///<reference path="../com/models.ts"/>
///<reference path="../archive/services/account-service.ts"/>
///<reference path="../app/Registry.ts"/>
var jaxx;
(function (jaxx) {
    var CoinStorage = (function () {
        //balancesTimestamp: number = 0;
        function CoinStorage(config) {
            this.config = config;
            // id: string;
            this.maxTransactions = 200;
            /*saveHistoryTimestamp(num: number): void {
                this.historyTimestamp = num;
                localStorage.setItem('history-timestamp-' + this.name, num + '');
            }*/
            //////////////////////////////////////
            //////////////////////////BalancesTemp ////////////////////////////
            /*  addSpending(num: number): number {
                  this.balanceSpent += num;
                  if (this.balanceSpent < 0) this.balanceSpent = 0;
                  return this.balanceSpent;
              }
      
              removeSpending(num?: number): void {
                  if (num) this.balanceSpent -= num;
                  if (this.balanceSpent < 0) this.balanceSpent = 0;
              }*/
            // balanceSpent: number = 0;
            //////////////////////////////
            /////////////////////               Balances Spent                  ////////
            /*
                    reduceBalaceSpent(address: string, amount: number): void {
            
                        let ar: VOBalanceTemp[] = this.getBalancesTemp();
            
                        for (let i = ar.length - 1; i >= 0; i--) {
                            let b: VOBalanceTemp = ar[i];
                            if (b.id === address) {
                                let precision = ar[i].spent / 100;
                                b.spent -= amount;
                                if (b.spent < precision) {
                                    console.log('%c removing balance spent ' + b.id + ' spent ' + b.spent, 'color:green');
                                    ar.splice(i, 1);
                                } else {
                                    console.log('%c balance left ' + b.id + ' spent ' + b.spent, 'color:red');
                                }
                            }
                        }
                    }*/
            /*   onBalancesDifference(diff: VOBalance[]): void {
                   let indexed: _.Dictionary<VOBalance> = {};
       
                   console.warn(this.name ,diff);
                   diff.forEach(function (b) {
                       indexed[b.id] = b
                   });
       
                   let ar: VOBalanceTemp[] = this.getBalancesTemp();
       
                   for (let i = ar.length - 1; i >= 0; i--) {
                       let b = ar[i];
                       if (indexed[b.id]) {
       
                           ///// try just remove balance temp
       
                          ar.splice(i, 1);
                          console.log('%c removing balance temp ' + b.id + ' spent ' + b.spent, 'color:red');
       /!*
       
                           if (indexed[b.id].old_new < 0) {
                               console.error(' balance spent < 0', indexed[b.id]);
                           }
                           let precision = ar[i].spent / 100;
                           //console.log('%c updating balance ' + b.id + '  ' + b.spent / 1e15 + ' - ' + indexed[b.id].spent/1e15,'color:red');
                           b.spent -= indexed[b.id].old_new;
       
                           if (b.spent < precision) {
                               console.log('%c removing balance spent ' + b.id + ' spent ' + b.spent, 'color:red');
                               ar.splice(i, 1);
                           } else {
                               // console.error('%c balance left '+ b.id +' spent '+b.spent,'color:red');
                           }
       *!/
       
                       }
                   }
       
                   if(ar.length === 0){
                      this.resetBalancesSpent();
                   }
                   ar.forEach(function (item) {
                       console.log('%c left balances temp ' + item.id + '  ' + item.spent / 1e15, 'color:red');
                   });
       
               }*/
            this.balancesTemp = [];
            this.name = config.name;
        }
        CoinStorage.prototype.getItem = function (key) {
            return localStorage.getItem(key);
        };
        CoinStorage.prototype.setItem = function (key, value) {
            return localStorage.setItem(key, value);
        };
        CoinStorage.prototype.clearStorage = function () {
            /// this will clenup data from old menemonic
            console.log(this.config.symbol + '     storage cleared ');
            if (this.getBalancesReceive(true).length)
                this.saveBalancesReceive([]);
            if (this.getBalancesChange(true).length)
                this.saveBalancesChange([]);
            ///// this was missing in 1.3.8.
            if (this.getUTXOs().length)
                this.saveUTXOs([]);
            if (this.getNonces())
                this.saveNonces(null);
            if (this.getTransactionsReceive().length) {
                this.saveTransactionsReceive([]);
            }
            this.resetHistoryTimestamp();
        };
        // History flag require to determinate is history was restored in current coin  moving this functionality from controller-base to storage
        CoinStorage.prototype.resetHistoryTimestamp = function () {
            localStorage.removeItem(this.config.symbol + 'historyTimestamp');
        };
        CoinStorage.prototype.setHistoryTimestamp = function () {
            this.historyTimestamp = (new Date()).toISOString();
            localStorage.setItem(this.config.symbol + 'historyTimestamp', this.historyTimestamp);
        };
        CoinStorage.prototype.getHistoryTimestamp = function () {
            if (!this.historyTimestamp) {
                this.historyTimestamp = localStorage.getItem(this.config.symbol + 'historyTimestamp');
            }
            return this.historyTimestamp;
        };
        CoinStorage.prototype.saveUTXOs = function (utxos) {
            // console.log(' save utxos ', utxos);
            this.UTXOs = utxos;
            localStorage.setItem(this.name + '-UTXOs', JSON.stringify(this.UTXOs));
            localStorage.setItem(this.name + '-UTXOs-timestamp', Date.now() + '');
        };
        CoinStorage.prototype.getUTXOs = function () {
            if (!this.UTXOs) {
                var storedUTXOs = localStorage.getItem(this.name + '-UTXOs');
                if (storedUTXOs !== null) {
                    try {
                        this.UTXOs = JSON.parse(storedUTXOs);
                    }
                    catch (e) {
                        console.error('Cannot read ' + this.name + ' UTXOs from cache. ' + JSON.stringify(e));
                        this.UTXOs = [];
                    }
                }
                else {
                    this.UTXOs = [];
                }
            }
            return this.UTXOs;
        };
        /** Reads the unspent transaction outputs that the user can potential spend in a new transaction.
         * Returns an array with the data or null if the data doesn't exist
         */
        CoinStorage.prototype.getUTXOsFromCache = function () {
            var cachedUTXOs = localStorage.getItem(this.name + '-UTXOs');
            if (cachedUTXOs !== null && cachedUTXOs !== undefined) {
                try {
                    return JSON.parse(cachedUTXOs);
                }
                catch (e) {
                    console.error('Cannot read ' + this.name + ' UTXOs from cache. ' + JSON.stringify(e));
                    return null;
                }
            }
            else {
                return null;
            }
        };
        CoinStorage.prototype.saveNonces = function (nonces) {
            //console.log(' save nonces ', nonces);
            this.nonces = nonces;
            localStorage.setItem(this.name + '-nonces', JSON.stringify(this.nonces));
            localStorage.setItem(this.name + '-nonces-timestamp', Date.now() + '');
        };
        CoinStorage.prototype.getNonces = function () {
            if (!this.nonces) {
                var str = localStorage.getItem(this.name + '-nonces');
                this.nonces = str ? JSON.parse(str) : {};
            }
            return this.nonces;
        };
        CoinStorage.prototype.getBalancesNot0 = function () {
            return this.getBalancesReceiveNot0().concat(this.getBalancesChangeNot0());
        };
        /*  getAddressesNo0Change(fee: number = 0): string[] {
              return Utils.getIds(this.getBalancesNot0Change(fee));
          }
  */
        /* getBalancesNot0Change(fee: number = 0): VOBalance[] {
             let out: VOBalance[] = [];
 
             let bals:VOBalance[] = this.getBalancesChange(true);
 
             bals.forEach(function (item) {
                 if (+item.balance > fee) out.push(new VOBalance({id: item.id, balance: item.balance, index: item.index}));
 
             });
             return out;
         }*/
        CoinStorage.prototype.setCreateNewWallet = function () {
            localStorage.setItem(this.name + 'createnewallet', (new Date()).toISOString());
        };
        CoinStorage.prototype.isNewWallet = function () {
            return localStorage.getItem(this.name + 'createnewallet');
        };
        CoinStorage.prototype.unsetCreateNewWalletd = function () {
            localStorage.removeItem(this.name + 'createnewallet');
        };
        /* removeNulesSpent(){
         var ar:VOBalance[] = this.getBalancesTemp();
         for(var i=ar.length-1; i>=0; i--){
         if(ar[i].balance ===0 ) ar.splice(i,1)  ;
         }
         this.balancesSpent = ar;
         }*/
        /*  checkBalancesSpent(): void {
  
              let ar: VOBalanceTemp[] = this.getBalancesTemp();
              let now: number = Date.now();
  
              let delta: number = 120000 * 1000;
  
              for (let i = ar.length - 1; i >= 0; i--) {
  
                  if ((now - ar[i].timestamp) > delta) {
                      console.warn(now + ' removing balance spent due  timestamp  id: ' + ar[i].id + ' spent: ' + ar[i].spent + ' timestamp delta : ' + (now - ar[i].timestamp));
                      ar.splice(i, 1)
                  }
              }
  
              this.balancesTemp = ar;
  
              if (ar.length === 0) {
                  clearInterval(this.spentInreval);
                  this.spentInreval = 0;
              }
  
              if (this.balancesTemp) {
                  // console.log(Utils.addresseFromBalances(this.balancesSpent));
                  // console.log('balances spent: ' + this.getBalanceSpent() / 1e15, this.balancesSpent.forEach(function(item){ console.log(item.id+' spent: '+item.spent/1e15)}));
              }
          }
  */
        // spentInreval: number = 0;
        /*  addBalancesSpent(ar: VOBalanceTemp[]) {
              console.log(this.name + ' adding balances spent ', ar);
              if (this.spentInreval === 0) this.spentInreval = setInterval(() => this.checkBalancesSpent(), 20000);
              if(this.balancesTemp.length === 0){
                  this.balancesTemp = ar;
                  this.emitter$.triggerHandler(this.ON_BALANCE_TEMP_LENGTH_NOT_0,[ar]);
                  return;
              }
  
              let out: VOBalanceTemp[] = [];
              for (let i = 0, n = ar.length; i < n; i++) {
  
                  if (isNaN(ar[i].spent)) continue;
  
                  let bal: VOBalanceTemp = this.getBalanceSpentById(ar[i].id);
  
                  if (bal) {
                      // console.log(' adding balance to existing was  ' + bal.spent/1e15 + ' + '+ ar[i].spent/1e15  )
                      bal.spent += ar[i].spent;
                      // bal.txids = bal.txids.concat(ar[i].txids);
                      //console.log(' now ' + bal.spent/1e15);
                      bal.count++;
                  }
                  else {
                      out.push(ar[i]);
                      /// console.log(' adding new balance ',ar[i]);
                  }
              }
              if (out.length) this.balancesTemp = this.balancesTemp.concat(out);
          }*/
        /*
                removeTempBalancesByTxIds(txids: string[]): void {
                    let ar: VOBalanceTemp[] = this.balancesSpent;
                    for (let i = ar.length - 1; i >= 0; i--) {
        
                        if (txids.indexOf(ar[i].txid)) {
                            // console.log('removing by txdid '+ ar[i].id +"   "+ ar[i].spent/1e10);
                            ar.splice(i, 1);
                        }
                    }
                }*/
        /*   getBalancesTemp(): VOBalanceTemp[] {
               return this.balancesTemp;
           }*/
        /* getBalanceTemp(): number {
             return this.balancesTemp.reduce(function (a, b) {
                 return a+=b.spent;
             },0);
            /!* let spent = 0;
             this.balancesSpent.forEach(function (item) {
                 spent += item.spent
             });
             return spent;*!/
         };*/
        /*
                resetBalancesSpent(): void {
                    //console.warn(' resetBalancesSpent ');
                    this.emitter$.triggerHandler(this.ON_BALANCE_TEMP_LENGTH_0);
                    this.balancesTemp = [];
                }*/
        /*      getBalanceSpentById(id: string): VOBalanceTemp {
                  let ar: VOBalanceTemp[] = this.getBalancesTemp();
                  for (let i = 0, n = ar.length; i < n; i++) if (ar[i].id === id) return ar[i];
                  return null;
              }*/
        //////////////////////////////////////////  end balances Spent///////////////////////////////////////////////////
        /*
         getBalanceTemp(): number {
         let balances: VOBalanceTemp[] = this.getBalancesTemp();
         return balances.length ? jaxx.Utils.calculateBalance(balances) : 0;
         }*/
        /* balancesTemp1: VOBalanceTemp[];

         addBalanceTemp(balance: VOBalanceTemp) {
         // console.log('added balance temp ',balance);
         let bals: VOBalanceTemp[] = this.getBalancesTemp();
         bals.push(balance);
         this.saveBalancesTemp(bals);
         }*/
        /* removeBalanceTemp(balance: VOBalanceTemp) {

         console.log('removing balance temp',balance);
         let bals: VOBalanceTemp[] = this.getBalancesTemp();

         for(let i= bals.length; i>=0 ;i++){
         if(bals[i].id === balance.id && bals[i].balance === balance.balance ) {
         bals.splice(i,1);
         console.log('found balance ', balance);
         }
         }
         this.saveBalancesTemp(bals);
         }*/
        /* addBalancesTemp(balances: VOBalanceTemp[]) {
         let bals: VOBalanceTemp[] = this.getBalancesTemp();


         bals = bals.concat(balances);
         this.saveBalancesTemp(bals);
         }
         */
        /* getBalancesTemp(): VOBalanceTemp[] {
         if (!this.balancesTemp1) {
         let str: string = localStorage.getItem('balances-temp-' + this.name);
         if (str) this.balancesTemp1 = _.map(JSON.parse(str), o => new VOBalanceTemp(o));
         else this.balancesTemp1 = [];
         }
         return this.balancesTemp1;
         }
         */
        /*saveBalancesTemp(balances: VOBalanceTemp[]): void {
         ///console.warn('saveBalancesTemp   ',balances);
         this.balancesTemp1 = balances;
         localStorage.setItem('balances-temp-' + this.name, JSON.stringify(balances));
         this.refreshBalanceTotal();

         }*/
        ////////////////////////////////////////////////////////////////// end Balance temp
        /* getBalancesHighestFirst(): VOBalance[] {
             let bals1: VOBalance[] = this.getBalancesReceive();
             let bals2: VOBalance[] = this.getBalancesChange();
             let bals = bals1.concat(bals2);
             return _.sortBy(bals, item => item.balance);
         }*/
        /* private addTempBalance(balance: VOBalance, balances: VOBalanceTemp[]): void {
         balances.forEach(function (item) {
         if (item.id == balance.id) {
         balance.balance += item.balance;
         }
         })
         }*/
        /* isAddressInternal(address: string): number {
             return (this.getAddressesChange().indexOf(address) !== -1) ? 1 : 0;
         }
 
         getAddressesNot0(): string[] {
             return this.getBalancesNot0().map(function (item) {
                 return item.id;
             })
         }*/
        /*   getAddressesNo0Receive(): string[] {
   
              // return Utils.getIds(this.getBalancesNot0Receive(fee));
   
           }*/
        /* getBalancesNot0Receive(fee: number = 0): VOBalance[] {
             let out: VOBalance[] = [];
             //let ar:VOBalance[] = this._balancesReceive;
             let bals:VOBalance[] = this.getBalancesReceive(true);
 
                 bals.forEach(function (item) {
                     if (+item.balance > fee) out.push(new VOBalance({id: item.id, balance: item.balance, index: item.index}));
                 });
 
 
             return out;
         }
 */
        CoinStorage.prototype.getBalancesChangeNot0WithSpend = function () {
            var out = [];
            var ar = this._balancesChange;
            var spent = this.balancesTemp;
            var indexed = {};
            spent.forEach(function (b) {
                indexed[b.id] = b;
            });
            ar.forEach(function (bal) {
                if (+bal.balance !== 0) {
                    var b = new VOBalance(bal);
                    if (indexed[b.id]) {
                        //TODO link to MATH
                        //+b.balance -= indexed[b.id].spent;
                    }
                    out.push(b);
                }
            });
            return out;
        };
        /* getBalancesReceiveNot0WithSpend(): VOBalance[] {
             let out: VOBalance[] = [];
             let ar: VOBalance[] = this._balancesReceive;
             let spent: VOBalanceTemp[] = this.balancesTemp;
             let indexed = {};
             spent.forEach(function (b) {
                 indexed[b.id] = b;
             });
 
             ar.forEach(function (bal) {
                 if (bal.balance !== 0) {
                     let b = new VOBalance(bal);
                     if (indexed[b.id]) {
                         b.balance -= indexed[b.id].spent;
                         // b.nonce = indexed[b.id].nonce;
 
                     }
                     out.push(b)
 
                 }
             });
             return out;
         }
 */
        /* getBalancesIndexedReceiveNot0WithIndex(): VOBalance[] {
 
             let ballances: VOBalance[] = this.getBalancesReceive();
             if (ballances.length === 0) return [];
 
             let spending: VOBalanceTemp[] = this.getBalancesTemp();
 
             let spend = {};
 
             spending.forEach(function (b) {
 
                 if (spend[b.id]) spend[b.id] += b.spent;
                 else spend[b.id] = b.spent;
                 // spend[b.id] = b;
 
             });
 
             let out: VOBalance[] = [];
 
             for (let i = 0, n = ballances.length; i < n; i++) {
                 let item: VOBalance = ballances[i];
 
                 if (item.balance) {
                     item.index = i;
                     if (spend[item.id]) item.balance -= spend[item.id];
                     out.push(item)
                 }
 
             }
 
             //console.log(out);
 
             /!*
              let addresses: string[] = this.getAddressesReceive();
              ballances.forEach((item) => {
              if (item.balance) {
              let bal: VOBalance = new VOBalance(item);
              bal.index = addresses.indexOf(item.id);
              if (balancesTemp.length) this.addTempBalance(bal, balancesTemp);
              out.push(bal);
              }
 
              })*!/
             return out;
         }
 */
        /*  getBalancesIndexedChangeNot0WithIndex(): VOBalance[] {
              let ballances: VOBalance[] = this.getBalancesChange();
              // if(ballances.length === 0 ) return [];
  
              // let addresses: string[] = this.getAddressesChange();
              let spending: VOBalanceTemp[] = this.getBalancesTemp();
              let out: VOBalance[] = [];
  
              let spend = {};
  
              spending.forEach(function (b) {
  
                  if (spend[b.id]) spend[b.id] += b.spent;
                  else spend[b.id] = b.spent;
                  // spend[b.id] = b;
  
              });
  
  
              // let spent = _.keyBy(spending, 'id');
  
              for (let i = 0, n = ballances.length; i < n; i++) {
                  let item: VOBalance = ballances[i];
                  if (item.balance) {
                      item.index = i;
                      if (spend[item.id]) item.balance -= spend[item.id];
                      out.push(item)
                  }
  
              }
              /!*  _.each(ballances, function (item) {
               if (item.balance) {
               let bal: VOBalance = new VOBalance(item);
               bal.index = addresses.indexOf(item.id);
  
               if (balancesTemp.length) this.addTempBalance(bal, balancesTemp);
               out.push(bal);
               }
  
               })*!/
              return out;
          }
  */
        CoinStorage.prototype.saveBalancesAll = function () {
            this.saveBalancesReceive();
            this.saveBalancesChange();
        };
        CoinStorage.prototype.getBalancesAll = function (orig) {
            return this.getBalancesReceive(orig).concat(this.getBalancesChange(orig));
        };
        //balancesChangePrev: VOBalance[];
        /* addBalanceChange(bal: VOBalance): void {
             if(this.getAddressesChange().indexOf(bal.id) !==-1) return;
             if(isNaN(bal.index)) bal.index = this._balancesChange.length;
             this._balancesChange.push(bal);
             this._saveBalancesChange();
            // this.saveCurrentIndexChange(this._balancesChange.length);
 
         }*/
        /* getBalancesChangePrev(): VOBalance[] {
             return this.balancesChangePrev;
         }*/
        ///set to true risky lost sequence
        CoinStorage.prototype.getBalancesChange = function (orig) {
            if (!this._balancesChange) {
                var str = localStorage.getItem('balances-change-' + this.name);
                if (str)
                    this._balancesChange = JSON.parse(str).map(function (item) {
                        return new VOBalance(item);
                    });
                else
                    this._balancesChange = [];
            }
            if (orig)
                return this._balancesChange;
            var out = [];
            this._balancesChange.forEach(function (item) {
                out.push(new VOBalance(item));
            });
            return out;
        };
        CoinStorage.prototype.getBalancesChangeNot0 = function () {
            return this.getBalancesChange(true).filter(function (item) {
                return item.balance !== '0';
            });
        };
        /*getBalanceChange(): number {
            // let balances: VOBalance[] = this.getBalancesChange();

            // console.log(this.name+' change ' + jaxx.Utils.calculateBalance( this.getBalancesChange(true)));
            return jaxx.Utils.calculateBalance(this.getBalancesChange(true));
        }*/
        /*  updateBalancesChange(ar: VOBalance[]): void {
              this.balancesChangePrev = this._balancesChange;
  
              console.log(' updateBalancesChange  ');
              console.log(ar,this.getBalancesChange());
  
              this._balancesChange =    ar;// Utils.updateOldBalances(this._balancesChange, ar);
              this._saveBalancesChange()
          }*/
        // balaceChangeTotal:number;
        CoinStorage.prototype.saveBalancesChange = function (ar) {
            if (ar)
                this._balancesChange = ar;
            /// console.log('%c'+ this.name + 'saving new balances change length ' + this._balancesChange.length,'color:red');
            localStorage.setItem('balances-change-timestamp-' + this.name, Date.now() + '');
            localStorage.setItem('balances-change-' + this.name, JSON.stringify(this._balancesChange));
        };
        /*  addBalanceChange(balance: VOBalance): number {
         let balances: VOBalance[] = this.getBalancesChange();
         balances.push(balance);
         this.saveBalancesChange(balances);
         return balances.length;
         }

         updateBalanceChange(balance: VOBalance): void {
         let balances: VOBalance[] = this.getBalancesChange();
         jaxx.Utils.updateItemById(balances, balance);
         this.saveBalancesChange(balances);
         }*/
        CoinStorage.prototype.getBalanceChangeByAddress = function (address) {
            var ar = this.getBalancesChange();
            for (var i = 0, n = ar.length; i < n; i++)
                if (ar[i].id === address)
                    return ar[i];
            return null;
        };
        /*getBalanceReceive(): number {
            // console.log(this._balancesReceive)
            //console.log( this.name + ' receive '+jaxx.Utils.calculateBalance(this.getBalancesReceive(true)))

            let bals = this.getBalancesReceive(true);
            //console.log(bals)
            return jaxx.Utils.calculateBalance(bals);
        }*/
        CoinStorage.prototype.getBalanceRecaiveByAddress = function (address) {
            var ar = this.getBalancesReceive();
            for (var i = 0, n = ar.length; i < n; i++)
                if (ar[i].id === address)
                    return ar[i];
            return null;
        };
        /*getBalancesReceivePrev():VOBalance[] {
         return this.balancesReceivePrev.slice(0);
         }*/
        CoinStorage.prototype.addBalanceReceive = function (balance) {
            var addresses = this.getAddressesReceive();
            if (addresses.indexOf(balance.id) !== -1)
                return;
            if (isNaN(balance.index))
                balance.index = this._balancesReceive.length;
            this._balancesReceive.push(balance);
            this.saveBalancesReceive();
            // this.saveCurrentIndexReceive(this._balancesReceive.length);
        };
        ///set to true risky lost sequence
        CoinStorage.prototype.getBalancesReceive = function (orig) {
            if (orig === void 0) { orig = false; }
            // wallet.getPouchFold(COIN_BITCOIN).getDataStorageController()._db
            if (!this._balancesReceive) {
                var str = localStorage.getItem('balances-receive-' + this.name);
                //console.error(str);
                if (str) {
                    var data = JSON.parse(str);
                    if (!Array.isArray(data))
                        data = [data];
                    this._balancesReceive = data.map(function (item) {
                        return new VOBalance(item);
                    });
                }
                else
                    this._balancesReceive = [];
            }
            //console.log(this.balancesReceive1[this.balancesReceive1.length-1].balance);
            if (orig)
                return this._balancesReceive;
            var out = [];
            this._balancesReceive.forEach(function (item) {
                out.push(new VOBalance(item));
            });
            return out; //JSON.parse(JSON.stringify(this.balancesReceive1));
        };
        CoinStorage.prototype.getBalancesReceiveNot0 = function () {
            return this.getBalancesReceive(true).filter(function (item) {
                return item.balance !== '0';
            });
        };
        //balancesRecaiveTotal:number;
        CoinStorage.prototype.updateBalancesReceive = function (ar) {
            this.balancesReceivePrev = this._balancesReceive;
            //console.log(' updateBalancesReceive ');
            //console.log(ar,this.getBalancesReceive());
            var indexed = _.keyBy(ar, 'id');
            var bals = this.getBalancesReceive(true);
            var stamp = Date.now();
            bals.forEach(function (item) {
                if (indexed[item.id])
                    item.balance = indexed[item.id].balance;
                item.timestamp = stamp;
            });
            //this._balancesReceive = Utils.updateOldBalances(this._balancesReceive, ar);
            // console.log(jaxx.Utils.calculateBalance(this._balancesReceive)/1e15);
            this.saveBalancesReceive();
        };
        CoinStorage.prototype.saveBalancesReceive = function (ar) {
            if (ar)
                this._balancesReceive = ar;
            var errors = this._balancesReceive.filter(function (item) {
                return item.id.length < 20;
            });
            if (errors.length) {
                console.error(errors);
            }
            localStorage.setItem('balances-receive-timestamp' + this.name, Date.now() + '');
            localStorage.setItem('balances-receive-' + this.name, JSON.stringify(this._balancesReceive));
        };
        CoinStorage.prototype.indexBalances = function () {
            this.indexBalancesReceive();
            this.indexBalancesChange();
        };
        CoinStorage.prototype.indexBalancesReceive = function () {
            var i = 0;
            this.getBalancesReceive(true).forEach(function (item) {
                item.index = i++;
            });
            this.saveBalancesReceive();
        };
        CoinStorage.prototype.indexBalancesChange = function () {
            var i = 0;
            this.getBalancesChange(true).forEach(function (item) {
                item.index = i++;
            });
            this.saveBalancesChange();
        };
        /*addBalanceReceive(balance: VOBalance): number {

         let balances: VOBalance[] = this.getBalancesReceive();
         balances.push(balance);
         this.saveBalancesReceive(balances);
         return balances.length;
         }*/
        /* getBalanceTempTransactions():number{
         let transactions:VOTransaction[] = this.getTransactionsTemp();
         return jaxx.Utils.calculateBalanceTransactions(transactions);
         }
         */
        ////////////////////////////////////////// Transactions
        /* updateTransactionsReceive(transactions: VOTransaction[]): VOTransaction[] {
         let newtransactions: VOTransaction[] = [];
         let old: VOTransaction[] = this.getTransactionsReceive();
         let indexed: Dictionary<VOTransaction> = _.keyBy(old, 'id');
         transactions.forEach(function (item) {
         if (!indexed[item.id]) {
         newtransactions.push(item);
         }
         })
         if (newtransactions.length) {
         old = old.concat(newtransactions);
         this.saveTransactionsReceive(old);
         }

         return newtransactions;
         }*/
        /////////////////////////////////////////////////// end balances   //////////////////////////////////////
        /*
         updateTransactionsChange(trs: VOTransaction[]):{newtrs: VOTransaction[],updated:VOTransaction[]} {

         let indexed = _.keyBy(trs,'id');
         let transactions:VOTransaction[] = this.getTransactionsChange();
         let out:VOTransaction[] =[];
         let updated:VOTransaction[] = [];
         let newtrs:VOTransaction[] = [];
         transactions.forEach(transaction =>{

         if(indexed[transaction.id]) {
         let tr:VOTransaction = indexed[transaction.id];
         out.push(tr);
         indexed[transaction.id] = null;
         updated.push(tr)
         }else{
         out.push(transaction);
         }
         })

         for(let str in indexed)if(indexed[str]){
         out.push(indexed[str]);
         newtrs.push(indexed[str]);

         }

         this._saveTransactionsChange(out);
         return {newtrs:newtrs,updated:updated};
         }*/
        /* private _updateTransactionsForAddress(address: string, transactionsNew: VOTransaction[], transactionsAll: VOTransaction[]): VOTransaction[] {

         let out: VOTransaction [] = _.filter(transactionsAll, function (o) {
         return o.address !== address
         });
         return out.concat(transactionsNew);
         }*/
        /* updateTransactionsForAddress(address: string, transactions: VOTransaction[], change_receive?: string): void {
         let trs: VOTransaction[];
         if (!change_receive) {
         let addressesChange: string[] = this.getAddressesChange();
         change_receive = (addressesChange.indexOf(address) === -1 ? 'receive' : 'change');
         }

         if (change_receive === 'change') {
         trs = this.getTransactionsChange();
         trs = this._updateTransactionsForAddress(address, transactions, trs);
         this.saveTransactionsChange(trs);
         } else {
         trs = this.getTransactionsReceive();
         trs = this._updateTransactionsForAddress(address, transactions, trs);
         this.saveTransactionsReceive(trs);
         }
         }*/
        CoinStorage.prototype.getTransactionsByAddressReceive = function (address) {
            var transactions = this.getTransactionsReceive();
            var out = [];
            transactions.forEach(function (item) {
                if (item.id === address)
                    out.push(item);
            });
            return out;
        };
        /* getTransactionsByAddressChange(address: string): VOTransaction[] {
             let transactions: VOTransaction[] = this.getTransactionsChange();
             let out: VOTransaction[] = [];
             transactions.forEach(function (item) {
                 if (item.id === address) out.push(item)
             });
             return out;
         }
 */
        CoinStorage.prototype.getTransactionsByAddress = function (address) {
            var out = this.getTransactionsByAddressReceive(address);
            // console.log('getTransactionsByAddressRecaive   ' + address, out);
            if (out.length)
                return out;
            //out = this.getTransactionsByAddressChange(address);
            //if (out.length) return out;
            return null;
        };
        /*
                getTransactionByIdChange(id: string): VOTransaction {
                    let transactions: VOTransaction[] = this.getTransactionsChange();
                    return this._getTransactionById(transactions, id);
                }*/
        CoinStorage.prototype.getTransactionByIdReceive = function (id) {
            var transactions = this.getTransactionsReceive();
            return this._getTransactionById(transactions, id);
        };
        CoinStorage.prototype._getTransactionById = function (transactions, id) {
            for (var i = 0, n = transactions.length; i < n; i++) {
                if (transactions[i].id === id)
                    return transactions[i];
            }
            return null;
        };
        /* getTransactionReceiveLast(): VOTransaction {
             let trs: VOTransaction[] = this.getTransactionsReceive();
             let l: number = trs.length;
             return l ? trs[trs.length - 1] : null;
         }*/
        CoinStorage.prototype.getTransactionsReceive = function () {
            if (!this.transactionsReceive) {
                this.transactionsReceive = [];
                var str = localStorage.getItem('transactions-receive-' + this.name);
                var trs = [];
                if (str) {
                    trs = JSON.parse(str); //.map(function (item) {
                    //                        return new VOTransaction(item);
                    //                    });
                }
                this.transactionsReceive = trs;
            }
            return this.transactionsReceive;
        };
        //transactionTimestampReceive: number = 0;
        /*  setTransactionsReceive(trs: VOTransaction[]): void {
              if (trs.length === 0)return;
              Utils.sortByTimestamp(trs);
              this.transactionTimestampReceive = trs[trs.length - 1].timestamp;
              this.transactionsReceive = trs;
              this.saveTransactionsReceive(trs);
          }*/
        /*updateTransactionsReceive(new_transactions:VOTransaction[]):void{
            let transactions: VOTransaction[] = this.getTransactionsReceive();
            Utils.updateOldTransactions(transactions, new_transactions);
            this.transactionsReceive = transactions;
            this.saveTransactionsReceive();
        }*/
        /*
                setTransactions(trs:VOTransaction[]):void{
                    this.transactionsReceive = trs;
                    this.saveTransactionsReceive();
                }
        
                addTempTransactions(trs:VOTransaction[]):void{
                    this.transactionsReceive = this.transactionsReceive.concat(trs);
                    this.saveTransactionsReceive();
                }*/
        /* updateTransactionsReceiveGetNew(new_transactions: VOTransaction[]): VOTransaction[] {
             let transactions: VOTransaction[] = this.getTransactionsReceive();
 
                 Utils.updateOldTransactions(transactions, new_transactions);
 
             let diff: VOTransaction[] =  Utils.getNewTransactions(transactions, new_transactions);
 
             Utils.sortByTimestamp(transactions);
 
             this.transactionsReceive = transactions.concat(diff);
 
 
             // let out:VOTransaction[] = Utils.filterLatest(trs,this.transactionTimestampReceive);
 
            // if( this.transactionsReceive.length)this.transactionTimestampReceive = this.transactionsReceive[this.transactionsReceive.length - 1].timestamp;
 
             this.saveTransactionsReceive();
 
             return diff;
         }
 */
        CoinStorage.prototype.addTransactions = function (newtrs) {
            if (!this.transactionsReceive)
                this.transactionsReceive = newtrs;
            else {
                this.transactionsReceive = _.uniqBy(this.transactionsReceive.concat(newtrs), 'id');
            }
            //this.saveTransactionsReceive();
            return newtrs;
        };
        CoinStorage.prototype.saveTransactionsReceive = function (transactionos) {
            // console.log(' saveTransactionsReceive  ', trs);
            if (transactionos) {
                this.transactionsReceive = _.uniqBy(transactionos, 'id');
            }
            this.transactionsReceive = _.orderBy(this.transactionsReceive, 'timestamp');
            // this.transactionsReceive = _.sortBy(this.transactionsReceive)
            if (this.transactionsReceive.length > this.maxTransactions) {
                console.log('%c ' + this.config.symbol + ' removing extra transactins ' + (this.transactionsReceive.length - this.maxTransactions), 'color:red');
                this.transactionsReceive = this.transactionsReceive.slice(this.transactionsReceive.length - this.maxTransactions);
            }
            console.log('%c ' + this.config.symbol + ' save transactins ' + this.transactionsReceive.length, 'color:red');
            //localStorage.setItem('transactions-receive-timestamp-' + this.name, this.transactionTimestampReceive + '');
            localStorage.setItem('transactions-receive-' + this.name, JSON.stringify(this.transactionsReceive));
        };
        //////////////// transactions change
        // private transactionsChange: VOTransaction[];
        /*getTransactionsChangeLast():VOTransaction{
         let trs:VOTransaction[] = this.getTransactionsChange();
         let l:number = trs.length;
         return l?trs[trs.length-1]:null;
         }*/
        /* getTransactionsChange(): VOTransaction[] {
             if (!this.transactionsChange) {
 
                 this.transactionTimestampReceive = Number(localStorage.getItem('transactions-change-timestamp-' + this.name));
                 let str: string = localStorage.getItem('transactions-change-' + this.name);
                 if (str) this.transactionsChange = JSON.parse(str).map(function (item) {
                     return new VOTransaction(item);
                 });
                 else this.transactionsChange = [];
             }
 
             return this.transactionsChange;
         }*/
        /* saveTransactionsChange(trs: VOTransaction[], length?: number): void {
            // if (trs.length == 0)return;
          //   console.log(' saveTransactionsChange   ',trs);
 
             this.transactionsChange = trs;
             // trs = _.sortBy(trs,['timestamp']);
             if (trs.length > this.maxTransactions) trs = trs.slice(trs.length - this.maxTransactions);
 
             localStorage.setItem('transactions-change-timestamp-' + this.name, Date.now() + '');
             localStorage.setItem('transactions-change-' + this.name, JSON.stringify(trs));
 
         }*/
        ////////////////////      Address   /////////////////////////////////////////////////////
        CoinStorage.prototype.getAddressesAll = function () {
            return this.getAddressesReceive().concat(this.getAddressesChange());
        };
        CoinStorage.prototype.getAddressesReceive = function () {
            return _.map(this.getBalancesReceive(true), 'id');
            // return this.addressesReceive;
        };
        CoinStorage.prototype.getCurrentAddressReceive = function () {
            var bals = this.getBalancesReceive(true);
            return bals.length ? _.last(bals).id : '';
        };
        CoinStorage.prototype.getCurrentIndexReceive = function () {
            return this.getBalancesReceive(true).length - 1;
        };
        CoinStorage.prototype.getAddressesChange = function () {
            return _.map(this.getBalancesChange(true), 'id');
        };
        CoinStorage.prototype.getCurrentAddressChange = function () {
            var bals = this.getBalancesChange(true);
            return bals.length ? _.last(bals).id : '';
        };
        return CoinStorage;
    }());
    jaxx.CoinStorage = CoinStorage;
})(jaxx || (jaxx = {}));
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//# sourceMappingURL=coin-storage.js.map
/**
 * Created by Vlad on 2017-07-13.
 */
var jaxx;
(function (jaxx) {
    var InsightApi = (function () {
        function InsightApi(config, generator1, generator2) {
            // for (let str in config) this[str] = config[str]
            this.config = config;
            this.generator = generator2 ? generator2 : generator1;
        }
        InsightApi.prototype.downlaodNonces = function (addresses) {
            return null;
        };
        InsightApi.prototype.lastBlock = function () {
            var url = this.config.urlLastBlock;
            return $.getJSON(url)
                .then(function (result) {
                return Number(result.info.blocks);
            });
        };
        InsightApi.prototype.stopAll = function () {
        };
        InsightApi.prototype.sendTransaction = function (transaction) {
            var url = this.config.urlSendTransaction;
            var hex = transaction.hex;
            //  console.log(url);
            // console.log(hex);
            var deferred = $.Deferred();
            // deferred.resolve(transaction);
            $.post(url, { rawtx: hex })
                .done(function (res) {
                console.log(res);
                transaction.success = 'success';
                deferred.resolve(transaction);
            }).fail(function (err) {
                deferred.reject(err);
            });
            /*$.ajax(url, {
                complete: function(ajaxRequest, status) {
                    console.log(status, ajaxRequest);
                    if (status === 'success')     deferred.resolve(JSON.stringify(ajaxRequest.responseText));
                    else  deferred.resolve({error:ajaxRequest.responseText});

                },
                contentType: 'application/x-www-form-urlencoded',
                data: "transaction="+ hex,
                type: 'PUT'
            });*/
            return deferred.promise();
        };
        InsightApi.removeDuplicatesUTXOs = function (ar) {
            var testObj = {};
            for (var i = ar.length - 1; i >= 0; i--) {
                var utxo = ar[i];
                var uid = utxo.address + utxo.txid + utxo.satoshis;
                if (testObj[uid])
                    ar.splice(i, 1);
                testObj[uid] = true;
            }
        };
        InsightApi.mapBitcoinUTXO = function (ar) {
            return ar.map(function (item) {
                return new VOutxo({
                    decimal: +item.amount,
                    address: item.address,
                    vout: item.vout,
                    block: item.height,
                    confirmations: item.confirmations,
                    satoshis: item.satoshis + '',
                    amount: item.amount,
                    txid: item.txid,
                    scriptPubKey: item.scriptPubKey,
                    timestamp: Date.now()
                });
            });
        };
        InsightApi.prototype.downlaodUTXOs = function (addresses) {
            var deffered = jQuery.Deferred();
            var url = this.config.urlUTXOs;
            url = url.replace('{{addresses}}', addresses.toString());
            //  console.log(url);
            $.getJSON(url)
                .then(function (result) {
                var utxos;
                try {
                    utxos = InsightApi.mapBitcoinUTXO(result);
                    InsightApi.removeDuplicatesUTXOs(utxos);
                }
                catch (e) {
                    deffered.reject(e);
                }
                if (utxos) {
                    deffered.resolve(utxos);
                }
            });
            return deffered.promise();
        };
        InsightApi.prototype.downloadTransactionsDetails = function (transactions) {
            //  console.log(transactions);
            var urlDetails = this.config.urlTransactionsDetails;
            var txIds = _.map(transactions, 'id');
            var deffered = jQuery.Deferred();
            var results = [];
            var i = 0;
            var self = this;
            var downloadNext = function (onSuccess, onFail) {
                //console.log(' downloadNext  ' + i);
                var txid = txIds[i];
                var url = urlDetails.replace('{{txid}}', txid);
                //   console.log(url);
                $.getJSON(url).done(function (res) {
                    //  console.log(res)
                    //  console.log('downloadNext res '+i, res1);
                    onSuccess(self.parseTransaction(res));
                    onSuccess(res);
                }).fail(function (err) { return onFail(err); });
            };
            var onDone = function (result) {
                results.push(result);
                if (++i >= txIds.length) {
                    //   console.log(results)
                    deffered.resolve(results);
                }
                else
                    downloadNext(onDone, onError);
            };
            var onError = function (err) {
                deffered.reject(err);
            };
            downloadNext(onDone, onError);
            return deffered.promise();
        };
        InsightApi.prototype.parseTransaction = function (data) {
            return InsightApi.parseTransaction(data);
        };
        InsightApi.parseTransaction = function (item) {
            //console.log('parseTransaction ', item);
            var t = new VOTransaction({
                id: item.txid,
                block: item.blockheight < 0 ? 0 : item.blockheight,
                from: item.vin[0].addr,
                timestamp: item.blocktime || item.time,
                confirmations: item.confirmations
            });
            t.tos = item.vout.reduce(function (sum, item) {
                return sum.concat(item.scriptPubKey.addresses);
            }, []);
            t.values = item.vout.map(function (item) {
                return +item.value;
            });
            t.total = item.vin.reduce(function (sum, vin) {
                sum += +vin.value;
            }, 0);
            t.miningFee = item.fees.toPrecision(2);
            return t;
        };
        InsightApi.transactionsParserOLd = function (result, address) {
            var out = [];
            for (var str in result) {
                var trxs = result[str];
                trxs.forEach(function (item) {
                    var t = InsightApi.parseTransaction(item);
                    out.push(t);
                });
            }
            return out;
        };
        InsightApi.transactionsParserNew = function (trxs, address) {
            return trxs.map(function (item) {
                return InsightApi.parseTransaction(item);
            });
        };
        InsightApi.prototype.transactionsParser = function (result, address) {
            return result.byAddress ? InsightApi.transactionsParserOLd(result.byAddress, address) : InsightApi.transactionsParserNew(result.items, address);
        };
        InsightApi.prototype.restoreHistory = function (receiveIndex, changeIndex) {
            var _this = this;
            /// console.warn(this);
            var deffered = jQuery.Deferred();
            //console.log(this.config);
            var restore1 = new jaxx.RestoreHistoryInsight(this.config, this.generator);
            restore1.parse = this.transactionsParser;
            var transactions = [];
            var balancesChange;
            var balancesReceive;
            var receiveDone;
            var changeDone;
            restore1.restoreHistory('receive', receiveIndex).done(function (res1) {
                // console.warn('receive ', res1);
                transactions = _.uniqBy(transactions.concat(res1.transactions), 'id');
                // let addresses1: string[] = res1.addresses;
                var balances1 = res1.balances;
                if (balances1.length === 0) {
                    receiveDone = true;
                    balancesReceive = [];
                    if (changeDone) {
                        deffered.resolve({
                            balancesChange: balancesChange,
                            balancesReceive: balancesReceive,
                            transactions: transactions
                        });
                    }
                    return;
                }
                _this.downloadBalances(_.map(balances1, 'id')).done(function (balancesRes) {
                    var indexed = _.keyBy(balancesRes, 'id');
                    balances1.forEach(function (item) {
                        var bal = indexed[item.id];
                        item.balance = bal.balance;
                        item.decimal = bal.decimal;
                    });
                    //   console.log(balances1);
                    receiveDone = true;
                    balancesReceive = balances1;
                    if (changeDone)
                        deffered.resolve({
                            balancesChange: balancesChange,
                            balancesReceive: balancesReceive,
                            transactions: transactions
                        });
                });
            }).fail(deffered.reject);
            var restore2 = new jaxx.RestoreHistoryInsight(this.config, this.generator);
            restore2.parse = this.transactionsParser; //ServiceMappers.mapTransactionsInsight;
            restore2.restoreHistory('change', changeIndex).done(function (res2) {
                // console.warn('change ', res2);
                transactions = _.uniqBy(transactions.concat(res2.transactions), 'id');
                // let addresses2: string[] = res2.addresses;
                var balances2 = res2.balances;
                if (balances2.length == 0) {
                    changeDone = true;
                    balancesChange = [];
                    if (receiveDone) {
                        deffered.resolve({
                            balancesChange: balancesChange,
                            balancesReceive: balancesReceive,
                            transactions: transactions
                        });
                    }
                    return;
                }
                _this.downloadBalances(_.map(balances2, 'id')).done(function (balancesRes) {
                    //   console.log(balances2);
                    var indexed = _.keyBy(balancesRes, 'id');
                    balances2.forEach(function (item) {
                        var bal = indexed[item.id];
                        item.balance = bal.balance;
                        item.decimal = bal.decimal;
                    });
                    balancesChange = balances2;
                    changeDone = true;
                    if (receiveDone)
                        deffered.resolve({
                            balancesChange: balancesChange,
                            balancesReceive: balancesReceive,
                            transactions: transactions
                        });
                });
                // console.warn(res2)
            }).fail(deffered.reject);
            return deffered;
        };
        InsightApi.prototype.downloadBalances = function (addresses) {
            var deffered = jQuery.Deferred();
            // console.log('downloadBalances ', addresses);
            var results = [];
            var urlBalance = this.config.urlBalance;
            var urlBalanceUnconfirmed = this.config.urlBalanceUnconfirmed;
            var i = 0;
            var downloadNext = function (onSuccess, onFail) {
                //console.log(' downloadNext  ' + i);
                var address = addresses[i];
                var url = urlBalance.replace('{{address}}', address);
                //console.log(url);
                $.getJSON(url).done(function (res1) {
                    //  console.log('downloadNext res '+i, res1);
                    var balance1 = jaxx.ServiceMappers.mapBitcoinBalance(address, res1, true);
                    url = urlBalanceUnconfirmed.replace('{{address}}', address);
                    $.getJSON(url).done(function (res2) {
                        //console.log(' BitcoinBalance  ' +address +'  ' + res2 +'  ');
                        var balance2 = jaxx.ServiceMappers.mapBitcoinBalance(address, res2, false);
                        balance1.decimal = (+balance1.balance + +balance2.balance) / 1e8;
                        balance1.timestamp = Date.now();
                        balance1.balance = jaxx.MATH.sum([balance1.balance, balance2.balance]);
                        onSuccess(balance1);
                    }).fail(function (err) { return onFail(err); });
                }).fail(function (err) { return onFail(err); });
            };
            var onDone = function (balance) {
                results.push(balance);
                if (++i >= addresses.length) {
                    //   console.log(results)
                    deffered.resolve(results);
                }
                else
                    downloadNext(onDone, onError);
            };
            var onError = function (err) {
                deffered.reject(err);
            };
            downloadNext(onDone, onError);
            return deffered.promise();
            /// return this.crypto_class.downloadBalances(addresses);
        };
        InsightApi.prototype.downloadTransactions = function (addresses) {
            var deffered = $.Deferred();
            // console.log('downloadTransactions  ', addresses.length);
            var results = [];
            var urlTrans = this.config.urlTransactions;
            var urlTransDetails = this.config.urlTransactionsDetails;
            var i = 0;
            var self = this;
            var downloadNext = function (onSuccess, onFail) {
                //console.log(' downloadNext  ' + i);
                var address = addresses[i];
                var url = urlTrans.replace('{{address}}', address);
                //console.log(url);
                $.getJSON(url).done(function (res1) {
                    //console.log('downloadNext res ' + i, res1);
                    var out = self.transactionsParser(res1, address);
                    onSuccess(out);
                }).fail(function (err) { return onFail(err); });
            };
            var onDone = function (trs) {
                results = results.concat(trs);
                if (++i >= addresses.length) {
                    //   console.log(results)
                    deffered.resolve(results);
                }
                else
                    downloadNext(onDone, onError);
            };
            var onError = function (err) {
                deffered.reject(err);
            };
            downloadNext(onDone, onError);
            return deffered.promise();
        };
        return InsightApi;
    }());
    jaxx.InsightApi = InsightApi;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=insight-api.js.map
/**
 * Created by Vlad on 2017-07-13.
 */
///<reference path="../com/math.ts"/>
var jaxx;
(function (jaxx) {
    var DecentralApi = (function () {
        function DecentralApi(config, generator1, generator2) {
            this.config = config;
            this.generator = generator2 ? generator2 : generator1;
            for (var str in config)
                this[str] = config[str];
        } //  console.log(config)
        DecentralApi.prototype.downlaodNonces = function (addresses) {
            return null;
        };
        DecentralApi.prototype.stopAll = function () {
        };
        DecentralApi.prototype.lastBlock = function () {
            var url = this.config.urlLastBlock;
            return $.getJSON(url)
                .then(function (result) {
                return Number(result.height);
            });
        };
        DecentralApi.prototype.sendTransaction = function (transaction) {
            var hex = transaction.hex;
            var tosend;
            var url = this.config.urlSendTransaction;
            var deferred = $.Deferred();
            // promise.resolve(transaction);
            // console.log(url);
            $.ajax(url, {
                complete: function (ajaxRequest, status) {
                    console.log(ajaxRequest.responseText);
                    if (status === 'success') {
                        transaction.success = status;
                        deferred.resolve(transaction);
                    }
                    else {
                        deferred.reject({
                            error: ajaxRequest.responseText,
                            status: status
                        });
                    }
                },
                contentType: 'application/x-www-form-urlencoded',
                data: "transaction=" + hex,
                type: 'PUT'
            });
            return deferred.promise();
        };
        DecentralApi.prototype.downlaodUTXOs = function (addresses) {
            var deffered = $.Deferred();
            var url = this.config.urlUTXOs;
            url = url.replace('{{addresses}}', addresses.toString());
            //  console.log(url);
            $.get(url)
                .done(function (res) {
                //  console.log(res);
                var utxos = jaxx.ServiceMappers.mapUTXOsDecentral(res);
                //remove duplicates
                utxos = _.uniqBy(utxos, function (utxo) {
                    return [utxo.address, utxo.txid].join();
                });
                // console.log(utxos);
                deffered.resolve(utxos);
            });
            return deffered.promise();
        };
        DecentralApi.prototype.downloadTransactionsDetails = function (transactions) {
            // console.log('downloadTransactionsDetails  ', Utils.deepCopy(transactions));
            var deffered = $.Deferred();
            if (transactions.length === 0) {
                deffered.resolve(transactions);
                return deffered.promise();
            }
            var idsAll = _.map(transactions, 'id');
            var idsChunks = _.chunk(idsAll, 10);
            var results = [];
            var url = this.config.urlTransactionsDetails;
            // let urlBalanceUnconfirmed = this.urlBalanceUnconfirmed;
            var i = 0;
            var downloadNext = function (onSuccess, onFail) {
                //console.log(' downloadNext  ' + i);
                var ids = idsChunks[i];
                if (!ids) {
                    console.error(idsChunks, i);
                    onFail();
                    return;
                }
                var turl = url.replace('{{trs-ids}}', ids.toString());
                // console.log(turl);
                $.getJSON(turl).done(function (res1) {
                    //    console.log(res1);
                    var out = jaxx.ServiceMappers.mapTransactionsDecentral(res1);
                    //
                    //  console.log(out);
                    onSuccess(out);
                }).fail(function (err) { return onFail(err); });
            };
            var onDone = function (result) {
                results = results.concat(result);
                if (++i >= idsChunks.length) {
                    //   console.log(results)
                    deffered.resolve(results);
                }
                else
                    downloadNext(onDone, onError);
            };
            var onError = function (err) {
                deffered.reject(err);
            };
            downloadNext(onDone, onError);
            return deffered.promise();
        };
        DecentralApi.prototype.restoreHistory = function (receiveIndex, changeIndex) {
            var _this = this;
            //  console.warn('restoreHistory   ')
            var deffered = $.Deferred();
            var changeDone = false;
            var receiveDone = false;
            var onDone = function () {
                if (changeDone && receiveDone) {
                    deffered.resolve({
                        balancesChange: balancesChange,
                        balancesReceive: balancesReceive,
                        transactions: null,
                        transactionsids: transactions
                    });
                }
            };
            var restore1 = new jaxx.RestoreHistoryInsight(this.config, this.generator);
            restore1.parse = function (res, address) {
                var trs = [];
                var _loop_1 = function (str) {
                    var ar = res[str];
                    ar.forEach(function (item) {
                        trs.push(new VOTransaction({
                            address: str,
                            id: item
                        }));
                    });
                };
                for (var str in res) {
                    _loop_1(str);
                }
                return trs;
            };
            var transactions = [];
            var balancesChange;
            var balancesReceive;
            restore1
                .restoreHistory('receive', receiveIndex)
                .done(function (res1) {
                //  console.log(res1);
                transactions = _.uniqBy(transactions.concat(res1.transactions), 'id');
                // let addresses1: string[] = res1.addresses;
                var balances1 = res1.balances;
                if (balances1.length === 0) {
                    balancesReceive = [];
                    receiveDone = true;
                    onDone();
                    return;
                }
                _this.downloadBalances(_.map(balances1, 'id')).done(function (balancesRes1) {
                    var indexed = _.keyBy(balancesRes1, 'id');
                    balances1.forEach(function (item) {
                        var bal = indexed[item.id];
                        if (bal) {
                            item.balance = bal.balance;
                            item.decimal = bal.decimal;
                        }
                        else
                            console.warn(' no balance ' + item.id);
                    });
                    // console.log(balances1);
                    balancesReceive = balances1;
                    receiveDone = true;
                    onDone();
                }).fail(deffered.reject);
            }).fail(deffered.reject);
            var restore2 = new jaxx.RestoreHistoryInsight(this.config, this.generator);
            restore2.parse = function (res, address) {
                var trs = [];
                var _loop_2 = function (str) {
                    var ar = res[str];
                    ar.forEach(function (item) {
                        trs.push(new VOTransaction({
                            addres: str,
                            id: item
                        }));
                    });
                };
                for (var str in res) {
                    _loop_2(str);
                }
                return trs;
            };
            restore2
                .restoreHistory('change', changeIndex).done(function (res2) {
                transactions = _.uniqBy(transactions.concat(res2.transactions), 'id');
                // console.log(' history restore change ', res2);
                // let addresses2: string[] = res2.addresses;
                var balances2 = res2.balances;
                if (balances2.length === 0) {
                    balancesChange = [];
                    changeDone = true;
                    onDone();
                    return;
                }
                _this.downloadBalances(_.map(balances2, 'id'))
                    .done(function (balancesRes) {
                    var indexed = _.keyBy(balancesRes, 'id');
                    balances2.forEach(function (item) {
                        var bal = indexed[item.id];
                        if (bal) {
                            item.balance = bal.balance;
                            item.decimal = bal.decimal;
                        }
                        else
                            console.warn(' no balance ' + item.id);
                    });
                    balancesChange = balances2;
                    changeDone = true;
                    onDone();
                }).fail(deffered.reject);
                // console.warn(res2)
            }).fail(deffered.reject);
            return deffered;
        };
        //urlUTXO: string;
        //urlBalance: string;
        // urlBalanceUnconfirmed: string;
        DecentralApi.prototype.downloadBalances = function (addressesOrig) {
            var errors = addressesOrig.filter(function (item) {
                return item.length < 20;
            });
            if (errors.length)
                console.error(' some address wrong : length<20', addressesOrig);
            var deffered = $.Deferred();
            var addressesChunks = _.chunk(addressesOrig, 10);
            ;
            // console.warn('downloadBalances ', addressesOrig.length);
            var results = [];
            var urlBalance = this.config.urlBalance;
            // let urlBalanceUnconfirmed = this.config.urlBalanceUnconfirmed;
            var i = 0;
            var downloadNext = function (onSuccess, onFail) {
                var addresses = addressesChunks[i];
                //console.log(' downloadNext  ' + i + addresses);
                var url = urlBalance.replace('{{addresses}}', addresses.toString());
                //console.log(url);
                $.getJSON(url).done(function (res1) {
                    var out = [];
                    // console.log(' downloadBalances Next res ' + i, res1);
                    for (var str in res1) {
                        var item = res1[str];
                        var error = (item.unconfirmed.amount == item.confirmed.amount);
                        var balance = new VOBalance({ id: str });
                        //if(item.unconfirmed.amount !== item.confirmed.amount){
                        balance.decimal = Number(item.confirmed.amount) + (error ? 0 : Number(item.unconfirmed.amount));
                        var confirmed = item.confirmed.amount;
                        balance.balance = '0';
                        if (confirmed !== '0')
                            balance.balance = jaxx.MATH.btcToSatoshi(confirmed);
                        var unconfirmed = item.unconfirmed.amount;
                        if (unconfirmed !== '0' && !error) {
                            unconfirmed = jaxx.MATH.btcToSatoshi(unconfirmed);
                            balance.balance = jaxx.MATH.sum([balance.balance, unconfirmed]);
                        }
                        out.push(balance);
                        // }
                    }
                    onSuccess(out);
                }).fail(function (err) { return onFail(err); });
            };
            var onDone = function (balance) {
                results = results.concat(balance);
                if (++i >= addressesChunks.length) {
                    //   console.log(results)
                    deffered.resolve(results);
                }
                else
                    downloadNext(onDone, onError);
            };
            var onError = function (err) {
                deffered.reject(err);
            };
            downloadNext(onDone, onError);
            return deffered.promise();
            /// return this.crypto_class.downloadBalances(addresses);
        };
        DecentralApi.prototype.downloadTransactions = function (addresses) {
            var deffered = $.Deferred();
            var symbol = this.config.symbol;
            // console.log('downloadTransactions  ', addresses.length);
            var results = [];
            var urlTrans = this.config.urlTransactions;
            var unconfirmed = this.config.urlTransactionsUnconfirmed;
            var urlTransDetails = this.config.urlTransactionsDetails;
            var i = 0;
            var downloadNext = function (onSuccess, onFail) {
                //console.log(' downloadNext  ' + i);
                var address = addresses[i];
                var url1 = urlTrans.replace('{{address}}', address);
                //  console.log(url1);
                $.getJSON(url1).done(function (res1) {
                    //  console.log('downloadNext res '+i, res1);
                    var txids = _.values(res1)[0];
                    /// console.log(txids);
                    var urlU = unconfirmed.replace('{{address}}', address);
                    $.getJSON(urlU).done(function (resU) {
                        txids = _.uniq(txids.concat(_.values(resU)[0]));
                        // console.log(txids);
                        if (txids.length === 0) {
                            onSuccess([]);
                            return;
                        }
                        var url2 = urlTransDetails;
                        url2 = url2.replace('{{trs-ids}}', txids.toString());
                        //  console.log(url2);
                        $.getJSON(url2).done(function (res2) {
                            // console.log(res2);
                            var out = jaxx.ServiceMappers.mapTransactionsDecentral(res2);
                            //   console.log(out);
                            // console.log(out.length)
                            out = _.uniqBy(out, 'txid');
                            //  console.log(out);
                            onSuccess(out);
                        }).fail(function (err) { return onFail(err); });
                    });
                }).fail(function (err) { return onFail(err); });
            };
            var onDone = function (result) {
                results = results.concat(result);
                if (++i >= addresses.length) {
                    //   console.log(results)
                    deffered.resolve(results);
                }
                else
                    downloadNext(onDone, onError);
            };
            var onError = function (err) {
                deffered.reject(err);
            };
            downloadNext(onDone, onError);
            return deffered.promise();
        };
        return DecentralApi;
    }());
    jaxx.DecentralApi = DecentralApi;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=decentral-api.js.map
/**
 * Created by jnewlands on 2017-SEP-01.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var jaxx;
(function (jaxx) {
    var UbietyApi = (function (_super) {
        __extends(UbietyApi, _super);
        function UbietyApi(config, db, generator) {
            return _super.call(this, config, generator) || this;
            // for (let str in config) this[str] = config[str]
        }
        UbietyApi.prototype.lastBlock = function () {
            var url = this.config.urlLastBlock;
            return $.getJSON(url)
                .then(function (result) {
                //console.log(result);
                return result.height || 0;
            });
        };
        UbietyApi.prototype.downloadBalances = function (addresses) {
            var deffered = jQuery.Deferred();
            // console.log('downloadBalances ', addresses);
            var results = [];
            var urlBalance = this.config.urlBalance;
            var urlBalanceUnconfirmed = this.config.urlBalanceUnconfirmed;
            var i = 0;
            var downloadNext = function (onSuccess, onFail) {
                //console.log(' downloadNext  ' + i);
                var address = addresses[i];
                var url = urlBalance.replace('{{address}}', address);
                //console.log(url);
                $.getJSON(url).done(function (res1) {
                    //  console.log('downloadNext res '+i, res1);
                    var balance1 = jaxx.ServiceMappers.mapBitcoinBalance(address, res1, true);
                    url = urlBalanceUnconfirmed.replace('{{address}}', address);
                    $.getJSON(url).done(function (res2) {
                        var balance2 = jaxx.ServiceMappers.mapBitcoinBalance(address, res2, false);
                        if (balance1.balance !== balance2.balance) {
                            balance1.decimal = (+balance1.balance + +balance2.balance) / 1e8;
                            balance1.balance = jaxx.MATH.sum([balance1.balance, balance2.balance]);
                        }
                        balance1.timestamp = Date.now();
                        onSuccess(balance1);
                    }).fail(function (err) { return onFail(err); });
                }).fail(function (err) { return onFail(err); });
            };
            var onDone = function (balance) {
                results.push(balance);
                if (++i >= addresses.length) {
                    //   console.log(results)
                    deffered.resolve(results);
                }
                else
                    downloadNext(onDone, onError);
            };
            var onError = function (err) {
                deffered.reject(err);
            };
            downloadNext(onDone, onError);
            return deffered.promise();
            /// return this.crypto_class.downloadBalances(addresses);
        };
        UbietyApi.prototype.sendTransaction = function (transaction) {
            var url = this.config.urlSendTransaction;
            var hex = transaction.hex;
            var deferred = $.Deferred();
            $.post(url, { rawtx: hex })
                .done(function (res) {
                if (res.txid) {
                    transaction.success = 'success';
                    deferred.resolve(transaction);
                }
                else
                    deferred.reject(res);
            }).fail(function (err) {
                deferred.reject(err);
            });
            /*$.ajax(url, {
                complete: function(ajaxRequest, status) {
                    console.log(status, ajaxRequest);
                    if (status === 'success')     deferred.resolve(JSON.stringify(ajaxRequest.responseText));
                    else  deferred.resolve({error:ajaxRequest.responseText});

                },
                contentType: 'application/x-www-form-urlencoded',
                data: "transaction="+ hex,
                type: 'PUT'
            });*/
            return deferred.promise();
        };
        UbietyApi.mapBitcoinUTXO = function (ar) {
            return ar.map(function (item) {
                return new VOutxo({
                    decimal: +item.amount,
                    address: item.address,
                    vout: item.vout,
                    block: item.height,
                    confirmations: item.confirmations,
                    satoshis: item.satoshis + '',
                    amount: item.amount,
                    txid: item.txid,
                    scriptPubKey: item.scriptPubKey,
                    timestamp: Date.now()
                });
            });
        };
        UbietyApi.prototype.downlaodUTXOs = function (addresses) {
            var deffered = jQuery.Deferred();
            var url = this.config.urlUTXOs;
            url = url.replace('{{addresses}}', addresses.toString());
            //  console.log(url);
            $.getJSON(url)
                .then(function (result) {
                //   console.log('UTXOs ', result);
                jaxx.InsightApi.mapBitcoinUTXO(result);
                var utxos = jaxx.InsightApi.mapBitcoinUTXO(result);
                jaxx.InsightApi.removeDuplicatesUTXOs(utxos);
                deffered.resolve(utxos);
            });
            return deffered.promise();
        };
        UbietyApi.parseTransaction = function (item) {
            //  console.log(item);
            if (!item.txid || !item.vin) {
                console.warn(item);
                return null;
            }
            var t = new VOTransaction({
                id: item.txid,
                block: item.block,
                from: item.vin.length ? item.vin[0].addr : 'BTC',
                timestamp: item.blocktime,
                confirmations: item.confirmations
            });
            t.total = item.vin.reduce(function (sum, vin) {
                return sum += +vin.value;
            }, 0);
            t.values = item.vout.map(function (item) {
                return +item.value;
            });
            t.tos = item.vout.reduce(function (sum, item) {
                return sum.concat(item.scriptPubKey.addresses);
            }, []);
            t.miningFee = (t.total - _.sum(t.values)).toPrecision(2);
            return t;
        };
        UbietyApi.prototype.downloadTransactionsDetails = function (transactions) {
            //  let urlTemplate = this.config.urlTransactionsDetails;
            var deffered = $.Deferred();
            if (transactions.length === 0) {
                deffered.resolve(transactions);
                return deffered.promise();
            }
            var idsAll = _.map(transactions, 'id');
            //let idsChunks = _.chunk(idsAll, 10);
            var results = [];
            var urlTemplate = this.config.urlTransactionsDetails;
            // let urlBalanceUnconfirmed = this.urlBalanceUnconfirmed;
            var i = 0;
            var valid = idsAll.every(function (item) {
                return !!item && !_.isUndefined(item);
            });
            if (!valid) {
                console.error(idsAll);
                deffered.reject(idsAll);
                return deffered.promise();
            }
            var downloadNext = function (onSuccess, onFail) {
                //console.log(' downloadNext  ' + i);
                var txid = idsAll[i];
                if (!txid || _.isUndefined(txid)) {
                    console.error(idsAll, i);
                    onFail(idsAll);
                    return;
                }
                var url = urlTemplate.replace('{{txid}}', txid);
                //  console.log(turl);
                $.getJSON(url).done(function (res1) {
                    ///console.log(res1);
                    var out = UbietyApi.parseTransaction(res1); //
                    // console.log(out);
                    if (!out) {
                        console.warn(url, out);
                        onError(new VOError('ubiety.downloadTransactionsDetails no details', url, {}, 'BCH'));
                    }
                    else
                        onSuccess(out);
                }).fail(function (err) { return onFail(err); });
            };
            var onDone = function (result) {
                if (result)
                    results = results.concat(result);
                if (++i >= idsAll.length) {
                    //   console.log(results)
                    deffered.resolve(results);
                }
                else
                    downloadNext(onDone, onError);
            };
            var onError = function (err) {
                deffered.reject(err);
            };
            downloadNext(onDone, onError);
            return deffered.promise();
        };
        UbietyApi.prototype.restoreHistory = function (receiveIndex, changeIndex) {
            var _this = this;
            var deffered = jQuery.Deferred();
            var restore1 = new jaxx.RestoreHistoryInsight(this.config, this.generator);
            restore1.parse = this.transactionsIdsParser;
            var transactions = [];
            var balancesChange;
            var balancesReceive;
            var receiveDone;
            var changeDone;
            restore1.restoreHistory('receive', receiveIndex).done(function (res1) {
                // console.warn('receive ', res1);
                transactions = _.uniqBy(transactions.concat(res1.transactions), 'id');
                // let addresses1: string[] = res1.addresses;
                var balances1 = res1.balances;
                if (balances1.length === 0) {
                    receiveDone = true;
                    balancesReceive = [];
                    if (changeDone) {
                        deffered.resolve({
                            balancesChange: balancesChange,
                            balancesReceive: balancesReceive,
                            transactionsids: transactions
                        });
                    }
                    return;
                }
                _this.downloadBalances(_.map(balances1, 'id')).done(function (balancesRes) {
                    var indexed = _.keyBy(balancesRes, 'id');
                    balances1.forEach(function (item) {
                        var bal = indexed[item.id];
                        item.balance = bal.balance;
                        item.decimal = bal.decimal;
                    });
                    //   console.log(balances1);
                    receiveDone = true;
                    balancesReceive = balances1;
                    if (changeDone)
                        deffered.resolve({
                            balancesChange: balancesChange,
                            balancesReceive: balancesReceive,
                            transactionsids: transactions
                        });
                });
            }).fail(deffered.reject);
            var restore2 = new jaxx.RestoreHistoryInsight(this.config, this.generator);
            restore2.parse = this.transactionsIdsParser;
            restore2.restoreHistory('change', changeIndex).done(function (res2) {
                // console.warn('change ', res2);
                transactions = _.uniqBy(transactions.concat(res2.transactions), 'id');
                // let addresses2: string[] = res2.addresses;
                var balances2 = res2.balances;
                if (balances2.length == 0) {
                    changeDone = true;
                    balancesChange = [];
                    if (receiveDone) {
                        deffered.resolve({
                            balancesChange: balancesChange,
                            balancesReceive: balancesReceive,
                            transactionsids: transactions
                        });
                    }
                    return;
                }
                _this.downloadBalances(_.map(balances2, 'id')).done(function (balancesRes) {
                    //   console.log(balances2);
                    var indexed = _.keyBy(balancesRes, 'id');
                    balances2.forEach(function (item) {
                        var bal = indexed[item.id];
                        item.balance = bal.balance;
                        item.decimal = bal.decimal;
                    });
                    balancesChange = balances2;
                    changeDone = true;
                    if (receiveDone)
                        deffered.resolve({
                            balancesChange: balancesChange,
                            balancesReceive: balancesReceive,
                            transactionsids: transactions
                        });
                });
                // console.warn(res2)
            }).fail(deffered.reject);
            return deffered;
        };
        UbietyApi.prototype.transactionsIdsParser = function (result, address) {
            return result.map(function (item) {
                return new VOTransaction({
                    id: item.txid,
                    txid: item.txid
                });
            });
        };
        UbietyApi.prototype.downloadTransactions = function (addresses) {
            var deffered = $.Deferred();
            console.log('   downloadTransactions  ', addresses.length);
            if (addresses.length === 0) {
                return deffered.resolve([]).promise();
            }
            var self = this;
            var results = [];
            var urlTrans = this.config.urlTransactions;
            var urlDetails = this.config.urlTransactionsDetails;
            var urlTransDetails = this.config.urlTransactionsDetails;
            var i = 0;
            var downloadNext = function (onSuccess, onFail) {
                //console.log(' downloadNext  ' + i);
                var address = addresses[i];
                var url = urlTrans.replace('{{address}}', address);
                //console.log(url);
                $.getJSON(url).done(function (res1) {
                    //console.log('downloadNext res ' + i, res1);
                    var txids = self.transactionsIdsParser(res1, address);
                    // console.log(txids);
                    self.downloadTransactionsDetails(txids).done(function (transaction) {
                        //console.log(transaction);
                        onSuccess(transaction);
                    });
                }).fail(function (err) { return onFail(err); });
            };
            var onDone = function (trs) {
                results = results.concat(trs);
                if (++i >= addresses.length) {
                    //   console.log(results)
                    deffered.resolve(results);
                }
                else
                    downloadNext(onDone, onError);
            };
            var onError = function (err) {
                deffered.reject(err);
            };
            downloadNext(onDone, onError);
            return deffered.promise();
        };
        return UbietyApi;
    }(jaxx.InsightApi));
    jaxx.UbietyApi = UbietyApi;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=ubiety-api.js.map
/**
 * Created by fieldtempus on 2016-11-10.
 */
///<reference path="../com/models.ts"/>
///<reference path="../com/Utils2.ts"/>
///<reference path="../com/service-mapper.ts"/>
var jaxx;
(function (jaxx) {
    var RestoreHistoryInsight = (function () {
        function RestoreHistoryInsight(config, generator) {
            this.config = config;
            this.generator = generator;
            this.attempts = 10;
            //receive_change:string;
            this.apiKey = '';
            this.requestDelays = 200;
            this.currentIndex = 0;
            this.limitOfTransactionsWithoutHistory = 10;
            //@note: @here: for relay managed classes. eventually it will be applicabe to all of the blockchains.
            this._relayManager = null;
            //@note: @here: for gathering _resolveTxList in a batch.
            this._batchSize = 20;
            this._enableLog = true;
            this.name = config.name;
            this.init();
        }
        /*initialize(name:string, relayManager:any):void {

        }*/
        RestoreHistoryInsight.prototype.init = function () {
            var _this = this;
            jaxx.Registry.application$.on(jaxx.Registry.KILL_HISTORY, function (evt, symbol) {
                console.log(_this.config.symbol + ' killing history ' + symbol);
                _this.deferred.reject({ error: 100, message: 'process killed' });
                setTimeout(function () { return _this.destroy(); }, 100);
            });
            //this.url = 'https://api.etherscan.io/api?module=account&action=txlist&address={{address}}&tag=latest';
            // this.url += this.apiKey;
            // this._name = this.generator.name;
        };
        RestoreHistoryInsight.prototype.wait = function () {
            this.onHold = true;
        };
        RestoreHistoryInsight.prototype.resume = function () {
            this.onHold = false;
            this.loadNextAddress();
        };
        RestoreHistoryInsight.prototype.destroy = function () {
            if (this.currentRequest) {
                this.currentRequest.abort();
                this.currentRequest = null;
            }
            this.addresses = null;
            this.transactions = null;
            this.balances = null;
            this.destroyed = true;
            if (this.onDestroyed)
                this.onDestroyed();
        };
        RestoreHistoryInsight.prototype.reset = function () {
            this.currentIndex = 0;
            this.withoutTransactions = 0;
            this.addresses = [];
            this.transactions = [];
            this.balances = [];
            this.attempts = 10;
            this.requestDelays = 20;
        };
        RestoreHistoryInsight.prototype.parse = function (result, address) {
            console.error('override this function');
            return result;
        };
        RestoreHistoryInsight.prototype.onError = function (num, url, message) {
            var _this = this;
            console.warn(this.attempts + '   error ' + message);
            this.attempts--;
            if (this.attempts < 0) {
                this.deferred.reject({
                    error: num,
                    attempts: this.attempts,
                    message: message,
                    url: url
                });
                this.destroy();
                return;
            }
            this.currentIndex--;
            setTimeout(function () { _this.loadNextAddress(); }, 10000);
        };
        //@note: @here: @codereview: wondering why this doesn't use the same interface as IRequestServer (which is what restore_ethereum.ts is being called from main_Ethereum.)
        RestoreHistoryInsight.prototype.restoreHistory = function (receive_change, startIndex) {
            //var promise:JQueryDeferred<{index:number,addresses:string[]}>
            console.log('%c ' + this.name + ' restoreHistory ' + receive_change + ' from ' + startIndex, 'color:brown');
            this.deferred = $.Deferred();
            this.receive_change = receive_change;
            this.reset();
            this.currentIndex = startIndex - 1;
            //setTimeout(() =>this.loadNextAddress(),50);
            this.loadNextAddress();
            return this.deferred;
        };
        RestoreHistoryInsight.prototype.loadNextAddress = function () {
            var _this = this;
            if (this.onHold || this.destroyed)
                return;
            this.currentIndex++;
            this.withoutTransactions++;
            if (this.withoutTransactions > this.limitOfTransactionsWithoutHistory) {
                // let length = this.balances.length - this.limitOfTransactionsWithoutHistory;
                var balanaces = this.balances.slice(0, -this.limitOfTransactionsWithoutHistory);
                var out = {
                    balances: balanaces,
                    //addresses:this.addresses.slice(0, this.addresses.length - this.limitOfTransactionsWithoutHistory),
                    transactions: this.transactions
                };
                console.log(this.config.symbol + ' restore history ends balances: ' + out.balances.length + ' ' + this.receive_change + ' transactions: ' + out.transactions.length);
                this.deferred.resolve(out);
                setTimeout(function () { return _this.destroy(); }, 100);
                return;
            }
            // var receive_change:string = this.receive_change;
            //  console.log('coin_HD_index  ' + this.coin_HD_index + '' +
            // ' ' + this.i +  '  nullcount: '+ this.limitOfTransactionsWithoutHistory + '  node: ' + this.receive_change);
            var currentIndex = this.currentIndex;
            // console.log(currentIndex);
            var address = this.generator.generateAddress(currentIndex, this.receive_change);
            var balance = new VOBalance({
                id: address,
                index: currentIndex,
                balance: '0',
                decimal: 0,
                type: this.receive_change == 'receive' ? 0 : 1
            });
            this.balances.push(balance);
            var url = this.config.urlTransactions.replace('{{address}}', address);
            this.addresses[currentIndex] = address;
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_RESTORE_HISTORY_NEXT);
            $.getJSON(url).done(function (res) {
                var transactions = _this.parse(res, address);
                if (transactions && transactions.length) {
                    _this.withoutTransactions = 0;
                    if (!Array.isArray(_this.transactions)) {
                        _this.transactions = [];
                        _this.destroy();
                    }
                    balance.trs = transactions.length;
                    if (!_this.transactions)
                        return;
                    _this.transactions = _this.transactions.concat(transactions);
                    // console.log('Transactions ', this.transactions);
                    console.log(_this.name + ' i ' + _this.currentIndex + ' ' + address + '   has ' + transactions.length + ' ' +
                        ' transactions ' + _this.receive_change);
                    setTimeout(function () { _this.loadNextAddress(); }, _this.requestDelays);
                }
                else {
                    if (_this.config.urlTransactionsUnconfirmed) {
                        var url2_1 = _this.config.urlTransactionsUnconfirmed.replace('{{address}}', address);
                        //  console.log(url2);
                        $.getJSON(url2_1).done(function (res) {
                            //  console.log(res);
                            var transactions = _this.parse(res, address);
                            if (transactions && transactions.length) {
                                _this.withoutTransactions = 0;
                                if (!Array.isArray(_this.transactions)) {
                                    _this.transactions = [];
                                    _this.destroy();
                                }
                                balance.trs += transactions.length;
                                _this.transactions = _this.transactions.concat(transactions);
                            }
                            console.log(_this.name + ' i ' + _this.currentIndex + ' ' + address + '   has ' + transactions.length + ' ' +
                                ' transactions UnC ' + _this.receive_change);
                            setTimeout(function () { _this.loadNextAddress(); }, _this.requestDelays);
                        }).fail(function (err) {
                            var e = new VOError('RestoreHistory', url2_1, err);
                            jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, e);
                            //When error from server go back in index and re-query  Error number in google docs "ERRORS jaxx"
                            _this.onError(204, url2_1, ' cant restore history restore-history-insight');
                        });
                    }
                    else {
                        console.log(_this.name + ' i ' + _this.currentIndex + ' ' + address + '   has ' + transactions.length + ' ' +
                            ' transactions ' + _this.receive_change);
                        setTimeout(function () { _this.loadNextAddress(); }, _this.requestDelays);
                    }
                    balance.trs = 0;
                }
            }).fail(function (err) {
                var e = new VOError('RestoreHistory', url, err);
                jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, e);
                //When error from server go back in index and re-query Error number in google docs "ERRORS jaxx"
                _this.onError(203, url, ' cant restore history restore-history-insight');
            });
        };
        return RestoreHistoryInsight;
    }());
    jaxx.RestoreHistoryInsight = RestoreHistoryInsight;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=restore-history-insight.js.map
var jaxx;
(function (jaxx) {
    var TransactionsUtilsBitcoin = (function () {
        function TransactionsUtilsBitcoin() {
        }
        /// this function not used and stay for purpose to go back to build transactions altcoins with static fee
        TransactionsUtilsBitcoin.build = function (toSendSatoshi, addressTo, utxos, privateKeys, miningFeeSatoshi, changeAddress, network, symbol, isMax) {
            //  console.log(['toSendSatoshi','addressTo','utxos'  ,'privateKeys', 'miningFeeInt' ,'changeAddress' ,'network' ,'symbol', 'isMax']);
            //console.log(arguments);
            miningFeeSatoshi = String(miningFeeSatoshi);
            var fullAmount, totalSpent;
            /// if max true ignoring input and calculating amount derived from all UTXOs
            if (isMax) {
                fullAmount = jaxx.MATH.sum(_.map(utxos, 'satoshis'));
                toSendSatoshi = jaxx.MATH.subtract(fullAmount, miningFeeSatoshi);
                totalSpent = fullAmount;
            }
            else
                totalSpent = jaxx.MATH.sum([toSendSatoshi, miningFeeSatoshi]);
            var tx = new thirdparty.bitcoin.TransactionBuilder(network);
            var changeSatoshi;
            var outputs = [
                {
                    address: addressTo,
                    amount: toSendSatoshi,
                    value: toSendSatoshi,
                    script: thirdparty.bitcoin.address.toOutputScript(addressTo, network)
                }
            ];
            var inputs = [];
            var complete;
            var sumSatoshi = '0';
            // console.log(utxos)
            for (var i = 0, n = utxos.length; i < n; i++) {
                var utxo = utxos[i];
                var input = utxo.satoshis;
                sumSatoshi = jaxx.MATH.sum([sumSatoshi, input]);
                inputs.push(utxo);
                // console.log( 'input ' + input + ' total '+ sumSatoshi +'  toSendSatoshi: ' + toSendSatoshi + ' miningFeeSatoshi ' + miningFeeSatoshi + '  totalSpent ' + totalSpent);
                if (isMax)
                    continue;
                if (+sumSatoshi >= +totalSpent) {
                    complete = true;
                    changeSatoshi = jaxx.MATH.subtract(sumSatoshi, totalSpent);
                    //console.log(' change ' + changeSatoshi);
                    // if change less then mining fee ignoring it and amount will be added to mining fee for faster transaction
                    if (+changeSatoshi < (+miningFeeSatoshi)) {
                        miningFeeSatoshi = jaxx.MATH.sum([miningFeeSatoshi, changeSatoshi]);
                        // console.log(' keep penny ' + changeSatoshi);
                        changeSatoshi = null; // keep the penny
                    }
                    else {
                        /// if change exists adding change address to outputs;
                        outputs.push({
                            address: changeAddress,
                            amount: changeSatoshi,
                            value: changeSatoshi,
                            script: thirdparty.bitcoin.address.toOutputScript(changeAddress, network)
                        });
                    }
                    break;
                }
            }
            if (isMax) {
                complete = true;
            }
            if (!complete) {
                Navigation.flashBanner("Can\'t build transaction total", 3, 'error');
                jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, new VOError('buildTransactionBTC', 'not complete line 74: total is less or equal to total spent' + ' cant build transaction total: ' + sumSatoshi + ' totalSpent ' + totalSpent + '  toSendSatoshi ' + toSendSatoshi + '  miningFeeSatoshi ' + miningFeeSatoshi, utxos, 'BTC'));
                console.error(' cant build transaction total: ' + sumSatoshi + ' totalSpent ' + totalSpent + '  toSendSatoshi ' + toSendSatoshi + '  miningFeeSatoshi ' + miningFeeSatoshi);
                // console.log( utxos, toSpend);
                return null;
            }
            // toSpend = thirdparty.bip69.sortInputs(toSpend);
            // outputs = thirdparty.bip69.sortOutputs(outputs);
            ///////////////////////////////////////// Building transaction using inputs and outputs
            outputs.forEach(function (output) {
                var amount = Number(output.amount);
                var address = output.address;
                tx.addOutput(address, amount);
            });
            inputs.forEach(function (input) {
                var txid = input.txid;
                var vout = input.vout;
                // console.log(txid + ' vout  ' + vout);
                tx.addInput(txid, vout);
            });
            tx.buildIncomplete();
            inputs.forEach(function (input, index) {
                var pk = privateKeys[input.address];
                // console.log('signing ');
                tx.sign(index, pk);
            });
            /////////////////////////////////////////////////////////////////// end of build
            var transaction = tx.build();
            var txidBig = transaction.getHash().toString('hex');
            var txid = '';
            for (var i = txidBig.length - 2; i >= 0; i -= 2) {
                txid += txidBig.substring(i, i + 2);
            }
            var serialized = transaction.toHex();
            //console.log('serialized  ', serialized);
            var size = serialized.length / 2 + transaction.ins.length * 107;
            return {
                txid: txid,
                requested: toSendSatoshi,
                amountInt: toSendSatoshi,
                amountDecimal: +jaxx.MATH.satoshiToBtc(toSendSatoshi),
                amountDecimalDisplay: jaxx.MATH.satoshiToBtc(toSendSatoshi),
                miningFeeInt: miningFeeSatoshi,
                miningFeeDecimal: +jaxx.MATH.satoshiToBtc(miningFeeSatoshi),
                miningFeeSymbol: null,
                totalSpent: totalSpent,
                totalSpentDecimal: +jaxx.MATH.satoshiToBtc(totalSpent),
                changeAmount: changeSatoshi,
                size: size,
                hex: serialized,
                // targetTransactionFee: targetTransactionFee,
                transactionBTC: transaction,
                changeAddress: changeAddress,
                // amountDecimal: toSendDecimal,
                outputs: outputs,
                inputs: inputs,
                addressTo: addressTo,
                symbol: symbol,
                isMax: isMax,
                success: {}
            };
        };
        TransactionsUtilsBitcoin.buildBTC = function (toSendSatoshi, addressTo, utxos, privateKeys, miningFeeIntNull, changeAddress, network, symbol, isMax, pricePerB) {
            var tx = new thirdparty.bitcoin.TransactionBuilder(network);
            var outputs = [
                {
                    address: addressTo,
                    amount: toSendSatoshi,
                    // Keys for bip69 to sort on
                    value: toSendSatoshi,
                    script: thirdparty.bitcoin.address.toOutputScript(addressTo, network)
                }
            ];
            var miningFeeDecimal = 0;
            var changeSatoshi;
            var spentUTXOs = [];
            var required = '0';
            var total = '0';
            var complete = false;
            var bytesPerInput = 148;
            var bytesPerOutput = 34;
            var totalBytes = 0;
            var numOuts = isMax ? 1 : 2;
            var countInputs = 0;
            var miningFeeInt = 0;
            var miningFeeSatoshi = '0';
            for (var i = 0, n = utxos.length; i < n; i++) {
                var utxo = utxos[i];
                var input = utxo.satoshis;
                total = jaxx.MATH.sum([total, input]);
                countInputs++;
                totalBytes = (bytesPerInput * countInputs) + (bytesPerOutput * numOuts) + 10;
                var old = miningFeeInt;
                miningFeeInt = (totalBytes * pricePerB); /// not really KB
                miningFeeSatoshi = String(miningFeeInt);
                required = jaxx.MATH.sum([toSendSatoshi, miningFeeSatoshi]);
                spentUTXOs.push(utxo);
                if (isMax)
                    continue;
                if (+total > (+required)) {
                    complete = true;
                    changeSatoshi = jaxx.MATH.subtract(total, required);
                    //// low change
                    //if change less then mining fee ignoring it and amount will be added to mining fee for faster transaction
                    if (+changeSatoshi < (bytesPerOutput * pricePerB)) {
                        console.warn(' small amount ' + changeSatoshi);
                        miningFeeSatoshi = jaxx.MATH.sum([miningFeeSatoshi, changeSatoshi]);
                        changeSatoshi = null;
                    }
                    else {
                        var realSpent = jaxx.MATH.subtract(total, changeSatoshi);
                        outputs.push({
                            address: changeAddress,
                            amount: changeSatoshi,
                            value: changeSatoshi,
                            script: thirdparty.bitcoin.address.toOutputScript(changeAddress, network)
                        });
                    }
                    break;
                }
            }
            if (isMax) {
                complete = true;
            }
            if (!complete) {
                Navigation.flashBanner("Can\'t build transaction total", 3, 'error');
                jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, new VOError('buildTransactionBTC', 'not complete line 287: total is less or equal to total spent' + ' total ' + total + '  totalSpent ' + required + '  toSendSatoshi: ' + toSendSatoshi + ' miningFeeSatoshi ' + miningFeeSatoshi, utxos, 'BTC'));
                console.error(' total ' + total + '  totalSpent ' + required + '  toSendSatoshi: ' + toSendSatoshi + ' miningFeeSatoshi ' + miningFeeSatoshi);
                return null;
            }
            // toSpend = thirdparty.bip69.sortInputs(toSpend);
            // outputs = thirdparty.bip69.sortOutputs(outputs);
            outputs.forEach(function (output) {
                var amount = Number(output.amount);
                var address = output.address;
                tx.addOutput(address, amount);
            });
            spentUTXOs.forEach(function (input) {
                var txid = input.txid;
                var vout = input.vout;
                // console.log(txid + ' vout  ' + vout);
                tx.addInput(txid, vout);
            });
            tx.buildIncomplete();
            spentUTXOs.forEach(function (input, index) {
                var pk = privateKeys[input.address];
                // console.log('signing ', pk);
                tx.sign(index, pk);
            });
            var transaction = tx.build();
            var txidBig = transaction.getHash().toString('hex');
            var txid = '';
            for (var i = txidBig.length - 2; i >= 0; i -= 2) {
                txid += txidBig.substring(i, i + 2);
            }
            var serialized = transaction.toHex();
            var size = serialized.length / 2 + transaction.ins.length * 107;
            var targetTransactionFee = jaxx.MATH.multiplay([String(Math.ceil(size / 1024)), String(miningFeeInt)]);
            return {
                txid: txid,
                requested: toSendSatoshi,
                amountInt: toSendSatoshi,
                amountDecimal: +jaxx.MATH.satoshiToBtc(toSendSatoshi),
                amountDecimalDisplay: null,
                displayAmount: jaxx.MATH.satoshiToBtc(toSendSatoshi),
                miningFeeInt: miningFeeSatoshi,
                miningFeeDecimal: +jaxx.MATH.satoshiToBtc(miningFeeSatoshi),
                miningFeeSymbol: null,
                changeAmount: changeSatoshi,
                totalSpent: required,
                totalSpentDecimal: +jaxx.MATH.satoshiToBtc(required),
                size: size,
                hex: serialized,
                targetTransactionFee: targetTransactionFee,
                transactionBTC: transaction,
                changeAddress: outputs.length > 1 ? changeAddress : null,
                // amountDecimal: +toSendSatoshi / 1e8,
                outputs: outputs,
                inputs: spentUTXOs,
                addressTo: addressTo,
                symbol: symbol,
                isMax: isMax,
                success: {}
            };
        };
        TransactionsUtilsBitcoin.buildBCHPerbyte = function (toSendSatoshi, addressTo, utxos, privateKeys, miningFeeIntNull, changeAddress, network, symbol, isMax, pricePerB) {
            var outputs = [
                {
                    address: addressTo,
                    amount: toSendSatoshi,
                    value: toSendSatoshi,
                    script: bitcore.Script.buildDataOut(addressTo)
                }
            ];
            var miningFeeDecimal = 0;
            var changeSatoshi;
            var spentUTXOs = [];
            var required = '0';
            var total = '0';
            var complete = false;
            var bytesPerInput = 148;
            var bytesPerOutput = 34;
            var totalBytes = 0;
            var numOuts = isMax ? 1 : 2;
            var countInputs = 0;
            var miningFeeInt = 0;
            var miningFeeSatoshi = '0';
            for (var i = 0, n = utxos.length; i < n; i++) {
                var utxo = utxos[i];
                var input = utxo.satoshis;
                total = jaxx.MATH.sum([total, input]);
                countInputs++;
                totalBytes = (bytesPerInput * countInputs) + (bytesPerOutput * numOuts) + 10;
                var old = miningFeeInt;
                miningFeeInt = (totalBytes * pricePerB); /// not really KB
                miningFeeSatoshi = String(miningFeeInt);
                required = jaxx.MATH.sum([toSendSatoshi, miningFeeSatoshi]);
                spentUTXOs.push(utxo);
                // check is enough UTXOs to cover required payment
                if (+total > (+required)) {
                    complete = true;
                    changeSatoshi = jaxx.MATH.subtract(total, required);
                    /// if sending max add change satoshi to sending value else creating change
                    if (isMax) {
                        toSendSatoshi = jaxx.MATH.sum([toSendSatoshi, changeSatoshi]);
                    }
                    else {
                        //if change less then mining fee ignoring it and amount will be added to mining fee for faster transaction
                        if (+changeSatoshi < (bytesPerInput * pricePerB)) {
                            console.log(' small amount ' + changeSatoshi);
                            changeSatoshi = null;
                        }
                        else {
                            outputs.push({
                                address: changeAddress,
                                amount: changeSatoshi,
                                value: changeSatoshi,
                                script: 'change'
                            });
                            var realSpent = jaxx.MATH.subtract(total, changeSatoshi);
                        }
                    }
                    break;
                }
            }
            if (isMax) {
                complete = true;
            }
            if (!complete) {
                Navigation.flashBanner("Can\'t build transaction total", 3, 'error');
                jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, new VOError('buildTransactionBTC', 'not complete line 287: total is less or equal to total spent' + ' total ' + total + '  totalSpent ' + required + '  toSendSatoshi: ' + toSendSatoshi + ' miningFeeSatoshi ' + miningFeeSatoshi, utxos, 'BTC'));
                console.error(' total ' + total + '  totalSpent ' + required + '  toSendSatoshi: ' + toSendSatoshi + ' miningFeeSatoshi ' + miningFeeSatoshi);
                return null;
            }
            // for BCH we need to specify mining fee and the rest goes to change address;
            var utxosAr = spentUTXOs.map(function (o) { return o.satoshis; });
            var amountUtxos = jaxx.MATH.sum(utxosAr);
            // adjusting mining fee after selected UTXOs to build transaction
            var miningFeeSatoshiAfter = jaxx.MATH.subtract(amountUtxos, toSendSatoshi);
            if (changeSatoshi)
                miningFeeSatoshiAfter = jaxx.MATH.subtract(miningFeeSatoshiAfter, changeSatoshi);
            // console.log(' amountUtxos: '+amountUtxos +' toSendSatoshi '+toSendSatoshi + ' miningFeeSatoshi '+miningFeeSatoshi+ ' length: '+ spentUTXOs.length+ ' pricePerB '+pricePerB +' changeSatoshi ' + changeSatoshi);
            var tx = new bitcore.Transaction();
            tx.to(addressTo, +toSendSatoshi);
            if (changeSatoshi)
                tx.change(changeAddress);
            tx.fee(Number(miningFeeSatoshiAfter));
            spentUTXOs.forEach(function (input) {
                var inputObj = {
                    txId: input.txid,
                    outputIndex: input.vout,
                    script: bitcore.Script.buildPublicKeyHashOut(input.address),
                    satoshis: +input.satoshis
                };
                tx.from(inputObj);
            });
            //tx.sort();
            spentUTXOs.forEach(function (input, index) {
                var pk = privateKeys[input.address];
                var signKey = bitcore.PrivateKey.fromWIF(pk.toWIF());
                tx.sign(signKey.toString());
            });
            var serialized = tx.serialize();
            var VO = tx.toJSON();
            var size = serialized.length / 2 + spentUTXOs.length * 107;
            var targetTransactionFee = jaxx.MATH.multiplay([String(Math.ceil(size / 1024)), String(miningFeeInt)]);
            return {
                txid: VO.hash,
                requested: toSendSatoshi,
                amountInt: toSendSatoshi,
                amountDecimal: +jaxx.MATH.satoshiToBtc(toSendSatoshi),
                amountDecimalDisplay: null,
                displayAmount: jaxx.MATH.satoshiToBtc(toSendSatoshi),
                miningFeeInt: miningFeeSatoshiAfter,
                miningFeeDecimal: +jaxx.MATH.satoshiToBtc(miningFeeSatoshiAfter),
                miningFeeSymbol: null,
                changeAmount: changeSatoshi,
                totalSpent: required,
                totalSpentDecimal: +jaxx.MATH.satoshiToBtc(required),
                size: 0,
                hex: serialized,
                targetTransactionFee: targetTransactionFee,
                transactionBTC: VO,
                changeAddress: outputs.length > 1 ? changeAddress : null,
                // amountDecimal: +toSendSatoshi / 1e8,
                outputs: outputs,
                inputs: spentUTXOs,
                addressTo: addressTo,
                symbol: symbol,
                isMax: isMax,
                success: {}
            };
        };
        /// this function not used and stay for purpose to go back to build transactions BCH with static fee
        TransactionsUtilsBitcoin.buildBCH = function (toSendSatoshi, addressTo, utxos, privateKeys, miningFeeInt, changeAddress, network, symbol, isMax, pricePerB) {
            var hasUTXOS = _.every(utxos, function (utxo) {
                return !!utxo.txid;
            });
            if (!hasUTXOS) {
                console.error('UTXOs are not valid');
                return null;
            }
            var tx = new bitcore.Transaction();
            var outputs = [
                {
                    address: addressTo,
                    amount: toSendSatoshi,
                    // Keys for bip69 to sort on
                    value: toSendSatoshi,
                    //script: thirdparty.bitcoin.address.toOutputScript(addressTo, network)
                    script: bitcore.Script.buildDataOut(addressTo)
                }
            ];
            var changeSatoshi;
            var spentUTXOs = [];
            var totalSpent = '0';
            var total = '0';
            var complete = false;
            var numOuts = isMax ? 1 : 2;
            var countInputs = 0;
            var miningFeeSatoshi = '0';
            for (var i = 0, n = utxos.length; i < n; i++) {
                var utxo = utxos[i];
                var input = utxo.satoshis;
                total = jaxx.MATH.sum([total, input]);
                countInputs++;
                miningFeeSatoshi = String(miningFeeInt);
                totalSpent = jaxx.MATH.sum([toSendSatoshi, miningFeeSatoshi]);
                console.log('miningFeeInt  ' + miningFeeInt);
                //console.error('Not sure about utxo.decimal - does it need to be converted?');
                //totalDecimal = MATH.sum([totalDecimal, Number(utxo.decimal).toString()]);
                //console.log('totalDecimal  '+totalDecimal + ' utxo.decimal ' + utxo.decimal);
                console.log('input ' + input + ' total ' + total + '  toSendSatoshi: ' + toSendSatoshi + ' miningFeeSatoshi ' + miningFeeSatoshi + '  totalSpent ' + totalSpent);
                spentUTXOs.push(utxo);
                if (+total > (+totalSpent)) {
                    complete = true;
                    changeSatoshi = jaxx.MATH.subtract(total, totalSpent);
                    /// if sending max add change satoshi to sending value
                    if (isMax) {
                        toSendSatoshi = jaxx.MATH.sum([toSendSatoshi, changeSatoshi]);
                    }
                    else {
                        console.log(' changeSatoshi ' + changeSatoshi);
                        if (+changeSatoshi < +miningFeeInt) {
                            console.log(' keep penny ' + changeSatoshi);
                            changeSatoshi = null;
                        }
                        0;
                        if (changeSatoshi)
                            totalSpent = jaxx.MATH.subtract(total, changeSatoshi);
                    }
                    break;
                }
            }
            if (isMax) {
                complete = true;
            }
            //   console.log( ' complete ' + )
            if (!complete) {
                Navigation.flashBanner("Can\'t build transaction total", 3, 'error');
                jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, new VOError('buildTransactionBTC', 'not complete line 464: total is less or equal to total spent' + ' total ' + total + '  totalSpent ' + totalSpent + '  toSendSatoshi: ' + toSendSatoshi + ' miningFeeSatoshi ' + miningFeeSatoshi, utxos, 'BTC'));
                console.error(' total ' + total + '  totalSpent ' + totalSpent + '  toSendSatoshi: ' + toSendSatoshi + ' miningFeeSatoshi ' + miningFeeSatoshi);
                return null;
            }
            console.log('changeSatoshi ' + changeSatoshi + ' total  ' + total + ' toSendSatoshi ' + toSendSatoshi + ' miningFeeInt ' + miningFeeInt);
            if (changeSatoshi) {
                outputs.push({
                    address: changeAddress,
                    amount: changeSatoshi,
                    value: changeSatoshi,
                    script: thirdparty.bitcoin.address.toOutputScript(changeAddress, network)
                });
            }
            console.log('Outputs: ', jaxx.Utils.deepCopy(outputs), 'Inputs: ', jaxx.Utils.deepCopy(spentUTXOs));
            var miningFee = jaxx.Registry.getCryptoControllerBySymbol('BCH').config.miningFee;
            outputs.forEach(function (output, index) {
                var amount = Number(output.amount);
                if (isNaN(amount)) {
                    console.error('Amount not a number', amount);
                    return null;
                }
                var address = output.address;
                console.log(address, amount);
                if (index == 0)
                    tx.to(address, amount);
                else
                    tx.change(address);
            });
            tx.fee(miningFee);
            spentUTXOs.forEach(function (input) {
                /* let txid = input.txid;
                 let vout = input.vout;*/
                var inputObj = {
                    txId: input.txid,
                    outputIndex: input.vout,
                    script: bitcore.Script.buildPublicKeyHashOut(input.address),
                    satoshis: +input.satoshis
                };
                // console.log(txid + ' vout  ' + vout);
                tx.from(inputObj);
            });
            //tx.buildIncomplete();
            tx.sort();
            spentUTXOs.forEach(function (input, index) {
                var pk = privateKeys[input.address];
                //  console.log('signing ', pk);
                var signKey = bitcore.PrivateKey.fromWIF(pk.toWIF());
                //  console.log(signKey)
                tx.sign(signKey.toString());
                //tx.sign(pk);
            });
            var serialized = tx.serialize();
            // let transaction = tx;
            // console.log(tx.toJSON())
            var VO = tx.toJSON();
            return {
                txid: VO.hash,
                requested: toSendSatoshi,
                amountInt: toSendSatoshi,
                amountDecimal: +jaxx.MATH.satoshiToBtc(toSendSatoshi),
                displayAmount: jaxx.MATH.satoshiToBtc(toSendSatoshi),
                miningFeeInt: miningFeeSatoshi,
                miningFeeSymbol: null,
                miningFeeDecimal: +jaxx.MATH.satoshiToBtc(miningFeeSatoshi),
                amountDecimalDisplay: null,
                changeAmount: changeSatoshi,
                totalSpent: totalSpent,
                totalSpentDecimal: +jaxx.MATH.satoshiToBtc(totalSpent),
                size: 0,
                hex: serialized,
                targetTransactionFee: '0',
                transactionBTC: tx,
                changeAddress: outputs.length > 1 ? changeAddress : null,
                // amountDecimal: +toSendSatoshi / 1e8,
                outputs: outputs,
                inputs: spentUTXOs,
                addressTo: addressTo,
                symbol: symbol,
                isMax: isMax,
                success: {}
            };
        };
        return TransactionsUtilsBitcoin;
    }());
    jaxx.TransactionsUtilsBitcoin = TransactionsUtilsBitcoin;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=coin-transactions-utils.js.map
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var jaxx;
(function (jaxx) {
    var BtcTestService = (function (_super) {
        __extends(BtcTestService, _super);
        function BtcTestService(config, generator1, generator2) {
            return _super.call(this, config, generator1, generator2) || this;
        }
        /* downloadTransactionsDetails(transactions: VOTransaction[]): JQueryPromise<VOTransaction[]> {
 
             // console.log(transactions);
             let urlDetails = this.config.urlTransactionsDetails;
             let indexed = _.keyBy(transactions, 'id');
             let txIds:string[] = _.map(transactions, 'id');
             let deffered  =  <JQueryDeferred<VOTransaction[]>>jQuery.Deferred();
             let results:VOTransaction[] = [];
             let i = 0;
 
 
             let self = this;
 
             let downloadNext = function (onSuccess: Function, onFail: Function) {
                 //console.log(' downloadNext  ' + i);
                 let txid:string = txIds[i];
                 let url:string = urlDetails.replace('{{txid}}', txid);
                   // console.log(url);
 
                 $.getJSON(url).done(res => {
                      // console.log(res)
 
                    // res.id = txid;
                     onSuccess(self.parseTransaction(res))
 
 
                 }).fail(err => onFail(err));
 
             }
 
 
             let onDone = function (result) {
 
                 results.push(result);
 
                 if (++i >= txIds.length) {
                     //   console.log(results)
                     deffered.resolve(results);
                 } else downloadNext(onDone, onError);
             }
 
             let onError = function (err) {
                 deffered.reject(err);
 
             }
 
             downloadNext(onDone, onError);
             return deffered.promise();
 
         }*/
        BtcTestService.parseTransaction = function (item) {
            return {
                id: item.txid,
                txid: item.txid,
                block: item.blockheight,
                from: item.vin[0].addr,
                timestamp: item.time,
                confirmations: item.confirmations,
                tos: item.vout.reduce(function (sum, item) { return sum.concat(item.scriptPubKey.addresses); }, []),
                values: item.vout.map(function (item) { return +item.value; }),
                total: item.vin.reduce(function (sum, vin) { sum += +vin.value; }, 0),
                miningFee: item.fees
            };
        };
        BtcTestService.prototype.parseTransaction = function (data) {
            return BtcTestService.parseTransaction(data);
        };
        BtcTestService.prototype.transactionsParser = function (data, address) {
            return data.items.map(BtcTestService.parseTransaction);
        };
        return BtcTestService;
    }(jaxx.InsightApi));
    jaxx.BtcTestService = BtcTestService;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=btc-test-service.js.map
///<reference path="../com/models.ts"/>
var jaxx;
(function (jaxx) {
    // import Utils2 = jaxx.Utils2;
    var EthereumClassicService = (function () {
        function EthereumClassicService(config, db) {
            this.config = config;
            this.db = db;
            this.generator = new jaxx.GeneratorBlockchain(config);
        }
        EthereumClassicService.prototype.stopAll = function () {
        };
        EthereumClassicService.prototype.lastBlock = function () {
            var url = this.config.urlLastBlock;
            return $.getJSON(url).then(function (result) {
                return Number(result.latestBlockNumberInserted);
            });
        };
        EthereumClassicService.prototype.sendTransaction = function (transaction) {
            var differed = $.Deferred();
            var transactions = transaction.transactionsETH;
            var urlSendTransaction = this.config.urlSendTransaction;
            var symbol = this.config.symbol;
            /* console.log('JN Send ETC', transaction);*/
            var sendNext = function (i) {
                i++;
                if (i < transactions.length) {
                    var transactionToSend_1 = transactions[i];
                    // console.log(symbol + ' Send URL ', urlSendTransaction);
                    $.ajax({
                        url: urlSendTransaction,
                        accepts: {
                            "ContentType": 'application/json'
                        },
                        type: 'PUT',
                        headers: {
                            'Cache-Control': 'no-cache',
                            transaction: transactionToSend_1.hex
                        }
                    }).done(function (result) {
                        transactionToSend_1.result = result;
                        sendNext(i);
                    }).fail(function (error) {
                        var e = new VOError('EthereumClassicService.sendTransaction', error.responseText, transactionToSend_1);
                        jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, e);
                        differed.reject({ error: error.status, message: error.responseText });
                    });
                }
                else {
                    transaction.success = 'success';
                    differed.resolve(transaction);
                }
            };
            // for testing max send
            // transaction.success = 'success';
            //differed.resolve(transaction);
            sendNext(-1);
            return differed.promise();
        };
        EthereumClassicService.prototype.downlaodNonces = function (addresses) {
            var differed = $.Deferred();
            var results = {};
            var urlTransactions = this.config.urlTransactions;
            var onDownlaodNext = function (i) {
                i++;
                if (i < addresses.length) {
                    var address_1 = addresses[i];
                    var url = urlTransactions.replace('{{address}}', address_1);
                    console.log(url);
                    $.get(url).then(function (respond) {
                        // console.warn(respond);
                        var transactions = respond.transactions.filter(function (item) {
                            return item.from === address_1;
                        });
                        return { address: address_1, nonce: transactions.length };
                    }).done(function (result) {
                        results[result.address] = result.nonce;
                        onDownlaodNext(i);
                        //  differed.resolve(result);
                    }).fail(differed.reject);
                }
                else
                    differed.resolve(results);
            };
            onDownlaodNext(-1);
            return differed.promise();
        };
        EthereumClassicService.prototype.downloadTransactions = function (addresses) {
            var differed = $.Deferred();
            var results = [];
            var urlTransactions = this.config.urlTransactions;
            var onDownlaodNext = function (i) {
                i++;
                if (i < addresses.length) {
                    var address = addresses[i];
                    var url = urlTransactions.replace('{{address}}', address);
                    //console.log(url);
                    $.get(url).then(function (respond) {
                        // console.warn(respond);
                        return respond.transactions.map(function (item) {
                            item.timeStamp = item.timestamp;
                            return jaxx.EthereumService.mapTransaction(item);
                        });
                    }).done(function (result) {
                        results = results.concat(result);
                        onDownlaodNext(i);
                        //  differed.resolve(result);
                    }).fail(differed.reject);
                }
                else
                    differed.resolve(results);
            };
            onDownlaodNext(-1);
            return differed.promise();
        };
        EthereumClassicService.prototype.downloadTransactionsDetails = function (tarnsactions) {
            console.error(' all ethereum transactions have to have confirmations ');
            var deffered = $.Deferred();
            tarnsactions.forEach(function (item) {
                if (!item.confirmations) {
                    item.confirmations = 1;
                }
            });
            deffered.resolve(tarnsactions);
            return deffered.promise();
        };
        EthereumClassicService.prototype.downloadBalances = function (addresses) {
            var r = new jaxx.RequestDownloadBalancesETC();
            return r.downloadBalances(addresses, this.config.urlBalance);
        };
        EthereumClassicService.prototype.restoreHistory = function (startIndex) {
            var _this = this;
            var promise = $.Deferred();
            // let url = this.config.urlTransactions;
            var history = new jaxx.RestoreHistoryInsight(this.config, this.generator);
            history.parse = function (res, address) {
                // console.log(res);
                return res.transactions.map(function (item) {
                    item.timeStamp = item.timestamp;
                    return jaxx.EthereumService.mapTransaction(item);
                });
            };
            history.restoreHistory('receive', startIndex)
                .done(function (resultHistory) {
                //  console.log(resultHistory);
                var balances = resultHistory.balances;
                if (balances.length === 0) {
                    promise.resolve({ balancesReceive: [], balancesChange: null, transactions: [] });
                    return;
                }
                var addresses = _.map(balances, 'id');
                _this.downloadBalances(addresses).done((function (result) {
                    var indexed = _.keyBy(result, 'id');
                    balances.forEach(function (item) {
                        var bal = indexed[item.id];
                        item.balance = bal.balance;
                        item.decimal = bal.decimal;
                        item.timestamp = Date.now();
                    });
                    promise.resolve({ balancesReceive: balances, balancesChange: null, transactions: resultHistory.transactions });
                })).fail(promise.reject);
            });
            // $.getJSON(url)
            return promise;
        };
        EthereumClassicService.prototype.stop = function () {
        };
        EthereumClassicService.prototype.downlaodUTXOs = function (addresses) {
            return null;
        };
        //////////////////////////////////////    Generator
        EthereumClassicService.prototype.addKeyPairToBalances = function (balances) {
            var _this = this;
            var i;
            balances.forEach(function (balance) {
                // console.log(balance);
                var address = balance.id;
                i = _this.db.getAddressesReceive().indexOf(address);
                balance.keyPair = _this.getKeyPairReceive(i);
            });
        };
        EthereumClassicService.prototype.getKeyPairReceive = function (index) {
            return this.generator.generateKeyPairReceive(index);
        };
        EthereumClassicService.prototype.getSignatureForIndex = function (index) {
            return this.generator.getSignatureForIndex(index);
        };
        EthereumClassicService.prototype.getKeyPairChange = function (index) {
            return this.generator.generateKeyPairChange(index);
        };
        EthereumClassicService.prototype.getAddressReceive = function (index) {
            return this.generator.generateAddressReceive(index);
        };
        return EthereumClassicService;
    }());
    jaxx.EthereumClassicService = EthereumClassicService;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=ethereum-classic-service.js.map
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var jaxx;
(function (jaxx) {
    var EthereumService = (function () {
        function EthereumService(config, db) {
            this.config = config;
            this.db = db;
            this.generator = new jaxx.GeneratorBlockchain(config);
        }
        EthereumService.mapTransaction = function (item) {
            return new VOTransaction({
                id: item.hash,
                from: item.from,
                to: item.to,
                miningFee: item.gasUsed * item.gasPrice / 1e18,
                value: item.value,
                timestamp: item.timeStamp ? +item.timeStamp : +item.timestamp,
                block: +item.blockNumber,
                confirmations: +item.confirmations
            });
        };
        /// returning only transactions after timestamp
        EthereumService.filterTransaction = function (item) {
            if (item.hasOwnProperty('timeStamp'))
                item.timestamp = +item.timeStamp;
            if (item.timestamp > this['timestamp']) {
                item.id = item.hash;
                item.miningFee = item.gasUsed * item.gasPrice / 1e18; //+MATH.weiToEther(String(+item.gasUsed * + item.gasPrice)),
                item.timestamp = +item.timeStamp;
                item.block = +item.blockNumber;
                item.confirmations = +item.confirmations;
                return true;
            }
            return false;
        };
        EthereumService.prototype.lastBlock = function () {
            var url = this.config.urlLastBlock;
            return $.getJSON(url)
                .then(function (result) {
                return Number(result.result);
            });
        };
        EthereumService.prototype.stopAll = function () {
        };
        EthereumService.prototype.downloadTransactions = function (addresses, timestamp) {
            if (timestamp === void 0) { timestamp = 5; }
            var differed = $.Deferred();
            var results = [];
            var urlTransactions = this.config.urlTransactions;
            var onDownlaodNext = function (i) {
                i++;
                if (i < addresses.length) {
                    var address = addresses[i];
                    var url = urlTransactions.replace('{{address}}', address);
                    $.get(url).then(function (respond) {
                        //only including in respose transactions after timestamp provided
                        return respond.result.filter(EthereumService.filterTransaction, { timestamp: timestamp });
                        /*  return respond.result.map(function (item) {
                              return EthereumService.mapTransaction(item);
                          });*/
                    }).done(function (result) {
                        results = results.concat(result);
                        onDownlaodNext(i);
                        //  differed.resolve(result);
                    }).fail(differed.reject);
                }
                else
                    differed.resolve(results);
            };
            onDownlaodNext(-1);
            return differed.promise();
        };
        EthereumService.prototype.downlaodNonces = function (addresses) {
            var differed = $.Deferred();
            var results = {};
            var urlTransactions = this.config.urlTransactionCount;
            var onDownlaodNext = function (i) {
                i++;
                if (i < addresses.length) {
                    var address_1 = addresses[i];
                    var url = urlTransactions.replace('{{address}}', address_1);
                    //console.log(url);
                    $.get(url).then(function (respond) {
                        // console.warn(item);
                        return { address: address_1, nonce: Number(respond.result) };
                    }).done(function (result) {
                        results[result.address] = result.nonce;
                        onDownlaodNext(i);
                    }).fail(differed.reject);
                }
                else
                    differed.resolve(results);
            };
            onDownlaodNext(-1);
            return differed.promise();
        };
        EthereumService.prototype.downlaodNoncesOld = function (addresses) {
            var differed = $.Deferred();
            var results = {};
            var urlTransactions = this.config.urlTransactions;
            var onDownlaodNext = function (i) {
                i++;
                if (i < addresses.length) {
                    var address_2 = addresses[i];
                    var url = urlTransactions.replace('{{address}}', address_2);
                    //console.log(url);
                    $.get(url).then(function (respond) {
                        // console.warn(item);
                        var transactions = respond.result.filter(function (item) {
                            return item.from === address_2;
                        });
                        return { address: address_2, nonce: transactions.length };
                    }).done(function (result) {
                        results[result.address] = result.nonce;
                        onDownlaodNext(i);
                    }).fail(differed.reject);
                }
                else
                    differed.resolve(results);
            };
            onDownlaodNext(-1);
            return differed.promise();
        };
        EthereumService.prototype.downloadTransactionsDetails = function (transactions) {
            console.error(' all ethereum transactions have to have confirmations');
            jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, new VOError('EthereumService.downloadTransactionsDetails', ' all ethereum transactions have to have confirmations', transactions, this.config.symbol));
            var deffered = $.Deferred();
            transactions.forEach(function (item) {
                if (!item.confirmations) {
                    item.confirmations = 1;
                }
            });
            deffered.resolve(transactions);
            return deffered.promise();
        };
        EthereumService.prototype.sendTransaction = function (transaction) {
            var deferred = $.Deferred();
            var transactions = transaction.transactionsETH;
            // let url:string = this.config.urlSendTransaction;
            var urlSendTransaction = this.config.urlSendTransaction; //.split('&apikey')[0];
            var sendNext = function (i) {
                i++;
                if (i < transactions.length) {
                    var transactionToSend_1 = transactions[i];
                    var url = urlSendTransaction
                        .replace("{{hex}}", transactionToSend_1.hex);
                    $.getJSON(url).then(function (respond) {
                        if (respond.error) {
                            // if(respond.error.message && respond.error.message.indexOf('nonce') !==-1){
                            //   deferred.reject('nonce');
                            // return;
                            //}
                            // console.error(respond);
                            transactionToSend_1.error = respond;
                            if (!transaction.error)
                                transaction.error = [];
                            transaction.error.push(respond);
                        }
                        transactionToSend_1.result = respond.result;
                        return transactionToSend_1;
                    }).done(function (result) {
                        sendNext(i);
                    }).fail(deferred.reject);
                }
                else {
                    if (!transaction.error)
                        transaction.success = 'success';
                    deferred.resolve(transaction);
                }
            };
            sendNext(-1);
            return deferred.promise();
        };
        EthereumService.prototype.downloadBalances = function (addresses) {
            var request = new RequestDownloadBalancesETH();
            return request.downloadBalances(addresses, this.config.urlBalance, 10);
        };
        EthereumService.prototype.restoreHistory = function (startIndex) {
            var _this = this;
            var promise = $.Deferred();
            var history = new jaxx.RestoreHistoryInsight(this.config, this.generator);
            history.parse = function (res) {
                return res.result.map(function (item) {
                    return EthereumService.mapTransaction(item);
                });
            };
            history.restoreHistory('receive', 0).done(function (resultHistory) {
                var balances = resultHistory.balances;
                if (balances.length === 0) {
                    promise.resolve({ balancesReceive: [], balancesChange: null, transactions: [] });
                }
                var addresses = _.map(balances, 'id');
                _this.downloadBalances(addresses).done((function (result) {
                    //console.log(balances.length +'  '+result.length);
                    var indexed = _.keyBy(result, 'id');
                    balances.forEach(function (item) {
                        var bal = indexed[item.id];
                        if (bal) {
                            item.balance = bal.balance;
                            item.decimal = bal.decimal;
                            item.timestamp = Math.ceil(Date.now() / 1000);
                        }
                        else {
                            console.warn('  no balance for ' + item.id);
                        }
                    });
                    promise.resolve({ balancesReceive: balances, balancesChange: null, transactions: resultHistory.transactions });
                })).fail(promise.reject);
            }).fail(promise.reject);
            return promise;
        };
        //////////////////////////////////////    Generator
        EthereumService.prototype.addKeyPairToBalances = function (balances) {
            var _this = this;
            var i;
            balances.forEach(function (balance) {
                // console.log(balance);
                var address = balance.id;
                i = _this.db.getAddressesReceive().indexOf(address);
                balance.keyPair = _this.getKeyPairReceive(i);
            });
        };
        EthereumService.prototype.getKeyPairReceive = function (index) {
            return this.generator.generateKeyPairReceive(index);
        };
        EthereumService.prototype.getSignatureForIndex = function (index) {
            //  console.error(index);
            return this.generator.getSignatureForIndex(index);
        };
        EthereumService.prototype.downlaodUTXOs = function (addresses) {
            return null;
        };
        return EthereumService;
    }());
    jaxx.EthereumService = EthereumService;
    var RequestDownloadBalances = (function () {
        function RequestDownloadBalances() {
        }
        RequestDownloadBalances.prototype.downloadBalances = function (addresses, urlTemplate, length) {
            if (length === void 0) { length = 20; }
            var deferred = $.Deferred();
            var urlT = urlTemplate;
            var idsChunks = _.chunk(addresses, length);
            var i = -1;
            var results = [];
            this._downloadBalances(urlT, i, idsChunks, results, deferred);
            return deferred.promise();
        };
        RequestDownloadBalances.prototype._downloadBalances = function (urlT, i, idsChunks, results, deferred) {
            var _this = this;
            i++;
            if (i >= idsChunks.length) {
                deferred.resolve(results);
                return;
            }
            var isDataReceived = false;
            var waitTime = 20000;
            var url = urlT.replace('{{addresses}}', idsChunks[i].toString());
            var request = $.getJSON(url).done(function (res) {
                if (res.message !== 'NOTOK') {
                    isDataReceived = true;
                    var ar = _this.parser(res, url);
                    if (ar.length)
                        results = results.concat(ar);
                    setTimeout(function () { return _this._downloadBalances(urlT, i, idsChunks, results, deferred); }, 200);
                }
                else {
                    deferred.reject(new VOError('ethservice', '', res, 'ETH'));
                }
            }).fail(function (err) {
                isDataReceived = true;
                console.error(err, url);
                deferred.reject(new VOError('serverstable', 'Cant collect balances for all addresses', {}, 'ETH'));
            });
            setTimeout(function () {
                if (!isDataReceived) {
                    console.error(' timeout on url  ', url);
                    request.abort();
                    deferred.reject(new VOError('serverstable', 'Cant collect balances for all addresses', {}, 'ETH'));
                }
            }, waitTime);
        };
        return RequestDownloadBalances;
    }());
    jaxx.RequestDownloadBalances = RequestDownloadBalances;
    var RequestDownloadBalancesETH = (function (_super) {
        __extends(RequestDownloadBalancesETH, _super);
        function RequestDownloadBalancesETH() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RequestDownloadBalancesETH.prototype.parser = function (result, url) {
            return result.result.map(function (item) {
                return new VOBalance({
                    id: item.account,
                    balance: item.balance,
                    decimal: +item.balance / 1e18,
                    timestamp: Date.now()
                });
            });
        };
        return RequestDownloadBalancesETH;
    }(RequestDownloadBalances));
    jaxx.RequestDownloadBalancesETH = RequestDownloadBalancesETH;
    var RequestDownloadBalancesETC = (function (_super) {
        __extends(RequestDownloadBalancesETC, _super);
        function RequestDownloadBalancesETC() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RequestDownloadBalancesETC.prototype.parser = function (result, url) {
            // console.log(result);
            var out = [];
            for (var str in result)
                out.push(new VOBalance({
                    id: str,
                    balance: result[str],
                    decimal: result[str] / 1e18,
                    timestamp: Date.now()
                }));
            return out;
        };
        return RequestDownloadBalancesETC;
    }(RequestDownloadBalances));
    jaxx.RequestDownloadBalancesETC = RequestDownloadBalancesETC;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=ethereum-service.js.map
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var jaxx;
(function (jaxx) {
    var EthereumController = (function (_super) {
        __extends(EthereumController, _super);
        function EthereumController(config) {
            var _this = _super.call(this, config) || this;
            _this.config = config;
            _this.emitter$ = $({});
            _this.spentBalances = [];
            _this.privateKeyCounter = 0;
            _this.out = [];
            _this.init();
            return _this;
        }
        EthereumController.prototype.getUTXOs = function () {
            return [];
        };
        EthereumController.generateQRCode = function () {
            return '';
        };
        EthereumController.prototype.init = function () {
            if (jaxx.Registry.appState && jaxx.Registry.appState.create) {
                console.log(this.name + ' create new wallet');
                this._db.clearStorage();
            }
        };
        /*onBalancesDownloaded(oldBalances: VOBalance[], newBalances: VOBalance[]) {


        }*/
        EthereumController.prototype.onBalancesDownloadedDifference = function (delta, balancesOld, balancesNew) {
            if (delta < 0) {
                console.log(this.symbol + ' Resetting temp on balance difference  TODO calculate amount');
                this.spentBalances = [];
            }
            var was = _.sumBy(balancesOld, function (item) {
                return Number(item.balance);
            });
            var now = _.sumBy(balancesNew, function (item) {
                return Number(item.balance);
            });
            var diff = jaxx.Utils.updateOldBalances2(balancesOld, balancesNew);
            var after = _.sumBy(balancesOld, function (item) {
                return Number(item.balance);
            });
            console.log('was: ', was, ' now: ', now, ' after: ', after);
            if (diff.length) {
                console.log('saving');
                this._db.saveBalancesAll();
                this.logConfirmedTransaction();
                this.dispatchBalance();
            }
            var addresses = diff.map(function (item) {
                return item.id;
            });
            this.attempt = 0;
            this.downloadNewTransactionsForAddresses(addresses);
        };
        EthereumController.prototype.sendTransaction = function (transaction) {
            var _this = this;
            var deferred = $.Deferred();
            console.log(this.name + ' sendTransaction  ', transaction);
            this.coinService.sendTransaction(transaction).done(function (results) {
                console.log('sendTransaction - results -', results);
                var transactions = results.transactionsETH;
                if (results.success === 'success') {
                    var balances = transactions.map(function (item) {
                        //TODO: Special function in the future to analyze transaction status (success/failure).
                        return new VOBalance({
                            id: item.addressFrom,
                            balance: item.spendWei
                        });
                    });
                    _this.spentBalances = _this.spentBalances.concat(balances);
                    var spent = _.sumBy(balances, function (item) {
                        return Number(item.balance);
                    });
                    console.log(' spent  ' + spent / 1e18);
                    _this.logSentTransaction();
                    _this.dispatchBalance();
                }
                else {
                    deferred.reject(transaction);
                }
                deferred.resolve(results);
            }).fail(function (error) {
                deferred.reject(error);
                _this.onError(error);
            });
            return deferred;
        };
        EthereumController.prototype.logSentTransaction = function () {
            this.timestampStartSeconds = String(Date.now() / 1000);
            console.log('%c ' + this.symbol + ' Sent Transaction ' + new Date().toLocaleTimeString(), 'color:pink');
        };
        EthereumController.prototype.logConfirmedTransaction = function () {
            this.timestampEndSeconds = String(Date.now() / 1000);
            console.log('%c ' + this.symbol + ' Confirmed Transaction ' + new Date().toLocaleTimeString(), 'color:pink');
            if (Number(this.timestampEndSeconds) - Number(this.timestampStartSeconds) > 60) {
                console.log('%c Transaction taking too long need to optimize gas price and gas limits', 'color:red');
            }
        };
        EthereumController.prototype.getMiningFee = function () {
            var gasPrice = this.config.gasPrice;
            var gasLimit = this.config.gasLimit;
            console.log(' gasPrice ' + gasPrice + ' gasLimit ' + gasLimit);
            return jaxx.MATH.multiplay([gasPrice, gasLimit]);
        };
        EthereumController.prototype.getNonces = function (addresses) {
            return this.coinService.downlaodNonces(addresses);
        };
        EthereumController.prototype.buildTransaction = function (amountDecimals, addressTo, isMax, customGasLimit, customData) {
            var _this = this;
            var balances = this.getBalancesNotDust();
            var spendable = this.getSpendable();
            ///one mo time check if for some reason requested amount more then spendable considering input was wrong and sending max;
            if (!isMax && +amountDecimals >= +spendable)
                isMax = true;
            var differed = $.Deferred();
            var gasLimit = (customGasLimit == null) ? this.config.gasLimit : customGasLimit;
            console.log(this.name + ' buildTransaction   amount ' + amountDecimals + ' customGasLimit ' + customGasLimit + ' to ' + addressTo);
            var addresses = balances.map(function (item) {
                return item.id;
            });
            var privateKeys = {};
            balances.forEach(function (balance) {
                privateKeys[balance.id] = _this.getKeyPair(balance.id);
            });
            var signatures = {};
            balances.forEach(function (item) {
                var address = item.id;
                signatures[address] = _this.getSignatureForAddress(address);
            });
            var amountInt = jaxx.MATH.etherToWei(amountDecimals);
            this.getNonces(addresses).done(function (nonces) {
                console.log('nonces ', nonces);
                var trs = jaxx.TransactionsUtilsEthereum.buildETH(amountInt, amountDecimals, addressTo, balances, nonces, signatures, // privateKeys,
                _this.config.gasPrice, gasLimit, _this.symbol, isMax, customData);
                differed.resolve(trs);
            });
            return differed.promise();
        };
        ////////////////////////////////////////////////// End Transactions ////////////////////////////////////////
        EthereumController.prototype.restoreHistory = function (callBack) {
            var _this = this;
            this.isRestoringHistory = true;
            this.stopBalancesCheck();
            var obj = { symbol: this.symbol };
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_RESTORE_HISTORY_START, obj);
            this.coinService.restoreHistory(0).done(function (result) {
                if (result.balancesReceive.length === 0) {
                    var address = _this.coinService.generator.generateAddressReceive(0);
                    result.balancesReceive = [new VOBalance({ id: address, balance: '0', decimal: 0, index: 0 })];
                }
                _this._db.saveTransactionsReceive(result.transactions);
                // before saving new Balances check all addresses are organized by index
                var check = new jaxx.HealthAddressHD(result.balancesReceive, _this.generator, false);
                if (check.wasProblem)
                    console.warn(' was problem  restoring history balancesReceive ' + _this.config.symbol);
                _this._db.saveBalancesReceive(result.balancesReceive);
                _this.goToNextAddressReceive();
                _this.setHistoryTimestamp();
                _this.isRestoringHistory = false;
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_RESTORE_HISTORY_DONE, obj);
                _this.startBalancesCheck();
                if (callBack)
                    callBack();
            }).fail(function (error) {
                _this.isRestoringHistory = false;
                _this.onError(error);
            });
        };
        EthereumController.prototype.getBalances = function () {
            return this._db.getBalancesAll();
        };
        //when token transaction sent token controller calling this function to update balance on first address.
        EthereumController.prototype.refreshBalanceOnAddress0 = function () {
            var _this = this;
            var address = this.getAddressReceive(0);
            this.coinService.downloadBalances([address]).done(function (balances) {
                var balance = balances[0];
                var bals = _this._db.getBalancesReceive(true);
                bals[0].balance = balance.balance;
                bals[0].timestamp = balance.timestamp;
                console.log(_this.config.symbol + ' on first address balance  ' + balance.balance);
                _this._db.saveBalancesReceive(bals);
            });
        };
        EthereumController.prototype.getBalanceForAddress0 = function () {
            var balances = this._db.getBalancesReceive(true);
            if (balances.length === 0)
                return '-1';
            return balances[0].balance;
        };
        EthereumController.prototype.getBalancesReceive = function () {
            return this._db.getBalancesReceive(true);
        };
        EthereumController.prototype.getBalanceByAddress = function (address) {
            var balances = this._db.getBalancesReceive(true);
            var returnBalance = '-1';
            for (var i = 0; i < balances.length; i++) {
                if (balances[i].id === address) {
                    return balances[i].balance;
                }
            }
            return returnBalance;
        };
        /* mapTransactions(trs: VOTransaction[]): void {
             let myAddresses: string[] = this.getAddressesAll();
             Utils.mapDisplayTransactionsEthereum(trs, myAddresses, this.symbol);
         }*/
        EthereumController.prototype.getSpendable = function (gasLimit) {
            //TODO need to implement gasLimit in send transaction controller
            if (!gasLimit)
                gasLimit = this.config.gasLimit;
            var gasPrice = this.config.gasPrice;
            var fee = jaxx.MATH.multiplay([gasPrice, gasLimit]);
            var balances = this.getBalancesNotDust();
            var ar = balances.map(function (item) {
                return jaxx.MATH.subtract(item.balance, fee);
            });
            /// if some balances are spent subtract values form total amounts
            if (this.spentBalances && this.spentBalances.length) {
                var spent = this.spentBalances.map(function (item) {
                    return '-' + jaxx.MATH.subtract(item.balance, fee);
                });
                ar = ar.concat(spent);
            }
            var res = jaxx.MATH.sum(ar);
            if (+res < 0)
                return '0';
            return ar.length ? jaxx.MATH.weiToEther(res) : '0';
        };
        EthereumController.prototype.getSpendableBalance = function (callback) {
            callback(this.getSpendable());
        };
        /*
        * Fired when ethereum wallet is activated
        * @method activate
        * */
        EthereumController.prototype.activate = function () {
            if (!_super.prototype.activate.call(this))
                return false;
            this.transactionsUpdater.activate();
            this.loadGasPrice();
            return true;
        };
        //        readyTransactionsLength: number = 0;
        EthereumController.prototype.getBalancesNotDust = function () {
            var fee = Number(this.config.gasPrice) * Number(this.config.gasLimit);
            return this._db.getBalancesReceive(true)
                .filter(function (item) {
                return +item.balance > fee;
            });
        };
        ////////////////////// Addresses////////////////////
        /*getPrivateKeyDB(index: number): any {
            return this.coinService.generator.generateKeyPairReceive(index);
        }*/
        EthereumController.prototype.getKeyPairReceive = function (address) {
            var i = this._db.getAddressesReceive().indexOf(address);
            if (i === -1) {
                console.error(' ho index for address ' + address);
                return '';
            }
            return this.coinService.generator.generateKeyPairReceive(i);
        };
        EthereumController.prototype.getSignatureForIndex = function (index) {
            // console.warn('getSignatureForAddress  ' + index);
            return this.coinService.generator.getSignatureForIndex(index);
        };
        EthereumController.prototype.getSignatureForAddress = function (address) {
            var ind = this._db.getAddressesReceive().indexOf(address);
            if (ind !== -1)
                return this.getSignatureForIndex(ind);
            else
                return this.getSignatureForIndex(0);
            // return null;
        };
        EthereumController.prototype.getKeyPair = function (address) {
            return this.getKeyPairReceive(address);
        };
        // Just a default.... Might be undefined.
        /*getPrivateKeyByAddress(address: string): any {
            // Returns '' if a private key cannot be retrieved.
            let keyPairEC: any = this.getKeyPair(address);
            return keyPairEC.toWIF();
        }*/
        EthereumController.prototype.isMyAddressDB = function (address) {
            return this.isMyAddressReceive(address);
        };
        EthereumController.prototype.isMyAddressReceive = function (address) {
            return this.getAddressIndexReceive(address) !== -1;
        };
        EthereumController.prototype.getAddressIndex = function (address) {
            return this.getAddressIndexReceive(address);
        };
        EthereumController.prototype.getAddressIndexReceive = function (address) {
            return this._db.getAddressesReceive().indexOf(address);
        };
        EthereumController.prototype.getAddressReceive = function (i) {
            return this.coinService.generator.generateAddressReceive(i);
        };
        EthereumController.prototype.getCurrentPublicAddresReceive = function () {
            return this._db.getCurrentAddressReceive();
        };
        // Ethereum based coins don't have change address. To comply with interface we have this function but it always return null
        EthereumController.prototype.getCurrentAddressChange = function () {
            return null;
        };
        EthereumController.prototype.getCurrentIndexReceive = function () {
            return this._db.getCurrentIndexReceive();
        };
        EthereumController.prototype.getAddressesReceive = function () {
            return this._db.getAddressesReceive();
        };
        EthereumController.prototype.getAddressesAll = function () {
            return this._db.getAddressesReceive();
        };
        /*getQRCode(): string {
            //thirdparty.qrImage.imageSync(uri, {type: "png", ec_level: "H", size: 7, margin: 1}).toString('base64');
            return '';
        }*/
        ////////////////////////////////////////// Transactions///////////////////////
        EthereumController.prototype.onTransactionUserConfirmed = function (data) {
            this.rawTransaction = data;
        };
        EthereumController.prototype.mapDisplayTransactions = function (trs) {
            var myAddresses = this.getAddressesAll();
            jaxx.Utils.mapDisplayTransactionsEthereum(trs, myAddresses, this.symbol);
        };
        // Takes a raw VOTransaction and returns one that is ready for UI display
        // UI display has properties such as 'displayAddress' or 'incoming' that are not
        // present on raw transactions and have to be deduced from inputs/outputs
        EthereumController.prototype.processTransactionForDisplay = function (tx) {
            var new_tx_data = jaxx.Utils.deepCopy(tx);
            var tx_array = [new_tx_data];
            jaxx.Utils.mapDisplayTransactionsEthereum(tx_array, this.getAddressesAll(), this.symbol);
            return tx_array[0];
        };
        // Indicates if the controller supports TX history
        // Invoked by the UI when attempting to render 
        EthereumController.prototype.supportsTransactionHistory = function () {
            return true;
        };
        EthereumController.prototype.getTransactionsDisplay = function () {
            var trs = this._db.getTransactionsReceive();
            var notReady = trs.filter(function (item) {
                return !item.displayValue;
            });
            if (notReady.length) {
                this.mapDisplayTransactions(notReady);
                this._db.saveTransactionsReceive();
            }
            return {
                symbol: this.config.symbol,
                transactions: jaxx.Utils.deepCopy(trs).reverse(),
                blockexplorer_url: this.config.blockexplorer_url,
                trsConfirmations: this.config.trsConfirmations
            };
        };
        EthereumController.prototype.getBalance = function () {
            var balances = this._db.getBalancesReceive(true);
            if (balances.length === 0)
                return '0';
            //all balances including in balance result. before included only not dust
            balances = this._db.getBalancesReceiveNot0();
            var ar1 = balances.map(function (item) {
                return item.balance;
            });
            var res = jaxx.MATH.sum(ar1);
            var spent = this.spentBalances;
            spent.forEach(function (item) {
                res = jaxx.MATH.subtract(res, item.balance);
            });
            if (+res <= 0)
                res = '0';
            return res;
        };
        EthereumController.prototype.getBalanceDisplay = function () {
            if (this.isRestoringHistory)
                return '-1';
            var v = this.getBalance();
            if (+v < 0)
                return '0';
            return jaxx.MATH.weiToEther(v);
        };
        // included check balances sequence before generating keys
        EthereumController.prototype.mapPrivateKeys = function (balances, isChange) {
            var check = new jaxx.HealthAddressHD(balances, this.generator, isChange);
            if (check.wasProblem)
                console.warn(' it was a problem with addresses ' + this.config.symbol);
            var generator = this.generator;
            return balances.map(function (item) {
                var node = isChange ? generator.generateKeyPairChange(item.index) : generator.generateKeyPairReceive(item.index);
                return {
                    address: item.id,
                    balance: jaxx.MATH.weiToEther(item.balance),
                    privateKey: node.d.toBuffer(32).toString('hex')
                };
            });
        };
        EthereumController.prototype.generatePrivateKey = function (balances, isChange, cb) {
            var _this = this;
            var balance = balances[this.privateKeyCounter];
            if (balance) {
                var privateKey = void 0;
                if (isChange) {
                    privateKey = this.coinService.generator.generateKeyPairChange(this.privateKeyCounter).d.toBuffer(32).toString('hex');
                }
                else {
                    privateKey = this.coinService.generator.generateKeyPairReceive(this.privateKeyCounter).d.toBuffer(32).toString('hex');
                }
                this.out.push({
                    address: balance.id,
                    balance: jaxx.MATH.weiToEther(balance.balance),
                    privateKey: privateKey
                });
            }
            this.privateKeyCounter++;
            if (this.privateKeyCounter < balances.length) {
                setTimeout(function () {
                    _this.generatePrivateKey(balances, isChange, cb);
                }, 100);
            }
            else {
                cb();
            }
        };
        EthereumController.prototype.getPrivateKeys = function () {
            var _this = this;
            var deferred = $.Deferred();
            if (this._db.isNewWallet()) {
                this.createNewWallet();
                this.setHistoryTimestamp();
            }
            var timestamp = this.getHistoryTimestamp();
            this.out = [];
            this.privateKeyCounter = 0;
            if (!timestamp) {
                this.restoreHistory(function (error) {
                    if (error) {
                        deferred.reject(error);
                        return;
                    }
                    var balances = _this._db.getBalancesReceive(true);
                    _this.generatePrivateKey(balances, false, function () {
                        balances = _this._db.getBalancesChange(true);
                        _this.generatePrivateKey(balances, true, function () {
                            deferred.resolve(_this.out);
                        });
                    });
                });
            }
            else {
                var balances = this._db.getBalancesReceive(true);
                this.generatePrivateKey(balances, false, function () {
                    deferred.resolve(_this.out);
                });
            }
            return deferred;
        };
        EthereumController.prototype.validateAddress = function (address) {
            return this.validateAddressETH(address);
        };
        /*
        * Load Gas Price from api https://api.blockcypher.com/v1/eth/main
        * @method loadGasPrice
        * */
        EthereumController.prototype.loadGasPrice = function () {
            var _this = this;
            var ethereumController = jaxx.Registry.getCurrentCryptoController();
            if (ethereumController.config.useGasPriceApi) {
                var url = JaxxUtils.scrubInput(ethereumController.config.gasPriceUrl);
                $.getJSON(url).done(function (res) {
                    _this.setMiningFeeData(res);
                }).fail(function (err) {
                    console.error(err);
                });
            }
        };
        /*
        * Modify the ethereum config gas price with response from average gas price api
        * @method setMiningFeeData
        * @param {any} res - response from api server
        * */
        EthereumController.prototype.setMiningFeeData = function (res) {
            var ethController = jaxx.Registry.getCurrentCryptoController();
            var gasPrice = JaxxUtils.scrubInput(res[ethController.config.gasPriceOption]);
            if (gasPrice) {
                this.config.gasPrice = gasPrice;
            }
        };
        return EthereumController;
    }(jaxx.CoinControllerBase));
    jaxx.EthereumController = EthereumController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=ethereum-controller.js.map
var jaxx;
(function (jaxx) {
    var TransactionsUtilsEthereum = (function () {
        function TransactionsUtilsEthereum() {
        }
        TransactionsUtilsEthereum.buildETH = function (requested, amountEther, addressTo, balances, nonces, signatures, //privateKeys:{[address:string]:string},
            gasPrice, gasLimit, symbol, isMax, customData) {
            //gasPrice = String(+gasPrice *3 );
            var txid = '';
            var size = 0;
            var serialized = '';
            var requestedDecimals = +amountEther;
            //let requestedWei = amountToSendWei;
            var totalSpent = '0';
            var totalMiningFee = '0';
            var miningPrice = jaxx.MATH.multiplay([gasPrice, gasLimit]);
            //let miningFeeTotalWei: string = '0';
            var isComplete = false;
            var transactions = [];
            var sendingTotal = '0';
            if (isMax) {
                var ar = balances.map(function (item) {
                    return jaxx.MATH.subtract(item.balance, miningPrice);
                });
                var maxToSend = jaxx.MATH.sum(ar);
                requested = maxToSend;
            }
            for (var i = 0, n = balances.length; i < n; i++) {
                if (isComplete)
                    break;
                var input = balances[i].balance;
                var addressFrom = balances[i].id;
                if (jaxx.MATH.greaterOrEqualAthenB(miningPrice, input)) {
                    console.warn(' DUST ' + (+input / 1e10) + '  miningPrice ' + (+miningPrice / 1e10) + '  ' + addressFrom);
                    continue;
                }
                var toSendWei = jaxx.MATH.subtract(input, miningPrice);
                totalSpent = jaxx.MATH.sum([totalSpent, input]);
                sendingTotal = jaxx.MATH.sum([sendingTotal, toSendWei]);
                var change = jaxx.MATH.subtract(sendingTotal, requested);
                // console.log(change, sendingTotal, requested, input, toSendWei, totalSpent);
                var isEmpty = true;
                if (!isMax && +change >= 0) {
                    isComplete = true;
                    if (+change > +miningPrice) {
                        isEmpty = false;
                        toSendWei = jaxx.MATH.subtract(toSendWei, change);
                        sendingTotal = jaxx.MATH.subtract(sendingTotal, change);
                        totalSpent = jaxx.MATH.subtract(totalSpent, change);
                    }
                    else {
                    }
                    //sendingTotal =  MATH.sum([sendingTotal, change]);
                }
                totalMiningFee = jaxx.MATH.sum([totalMiningFee, miningPrice]);
                var tr1 = {
                    addressFrom: addressFrom,
                    addressTo: addressTo,
                    balanceWei: input,
                    toSendWei: toSendWei,
                    isEmpty: isEmpty,
                    spendWei: jaxx.MATH.sum([toSendWei, miningPrice]),
                    nonce: nonces[addressFrom],
                    miningFeeWei: miningPrice,
                    gasPrice: gasPrice,
                    gasLimit: gasLimit,
                    hex: null,
                    txid: null,
                    error: null,
                    result: null
                };
                transactions.push(tr1);
                if (isComplete)
                    break;
            }
            //console.log(transactions);
            var web3 = thirdparty.web3;
            transactions.forEach(function (item) {
                var transaction = new thirdparty.ethereum.tx({
                    nonce: web3.toHex(+item.nonce),
                    gasPrice: web3.toHex(gasPrice),
                    gasLimit: web3.toHex(gasLimit),
                    to: addressTo,
                    value: web3.toHex(item.toSendWei),
                    data: (customData && customData.length > 5) ? customData : null
                });
                if (customData && customData.length)
                    transaction.data = customData;
                var signature = signatures[item.addressFrom] ? signatures[item.addressFrom] : signatures['address'];
                transaction.sign(signature);
                item.txid = ('0x' + transaction.hash().toString('hex'));
                var hex = transaction.serialize().toString('hex');
                item.hex = hex;
            });
            return {
                requested: requested,
                amountDecimal: +jaxx.MATH.weiToEther(sendingTotal),
                amountInt: sendingTotal,
                displayAmount: jaxx.MATH.weiToEther(sendingTotal),
                amountDecimalDisplay: jaxx.MATH.weiToEther(sendingTotal),
                miningFeeInt: totalMiningFee,
                miningFeeDecimal: +jaxx.MATH.weiToEther(totalMiningFee),
                miningFeeSymbol: null,
                totalSpent: totalSpent,
                totalSpentDecimal: +jaxx.MATH.weiToEther(totalSpent),
                txid: txid,
                size: size,
                complete: isComplete,
                hex: serialized,
                addressTo: addressTo,
                symbol: symbol,
                transactionsETH: transactions,
                isMax: isMax,
                success: null
            };
        };
        return TransactionsUtilsEthereum;
    }());
    jaxx.TransactionsUtilsEthereum = TransactionsUtilsEthereum;
    var UtilsETH = (function () {
        function UtilsETH() {
        }
        // converts string into hex
        UtilsETH.fromAscii = function (str) {
            var hex = "";
            for (var i = 0; i < str.length; i++) {
                var code = str.charCodeAt(i);
                var n = code.toString(16);
                hex += n.length < 2 ? '0' + n : n;
            }
            return "0x" + hex;
        };
        ;
        return UtilsETH;
    }());
    jaxx.UtilsETH = UtilsETH;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=ethereum-transactions-utils.js.map
///<reference path="../com/models.ts"/>
///<reference path="../app/Registry.ts"/>
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var jaxx;
(function (jaxx) {
    var TokenController = (function (_super) {
        __extends(TokenController, _super);
        function TokenController(config) {
            var _this = _super.call(this, config) || this;
            _this.config = config;
            _this.gasPrice = 21 * 1e9;
            _this.gasLimit = 150000;
            _this.isToken = true;
            _this.BALANCE_CHANGED = 'BALANCE_CHANGED';
            _this.NOT_ENOUGH_ETHER = 'NOT_ENOUGH_ETHER';
            _this.ENOUGH_ETHER = 'ENOUGH_ETHER';
            _this.spentBalances = [];
            return _this;
        }
        TokenController.prototype.isEnoughGas = function () {
            var bal = +jaxx.Registry.Ethereum.getBalanceForAddress0();
            var gasRequred = +this.config.gasPrice * +this.config.gasLimit;
            return bal > gasRequred;
        };
        // returns reference to current address generator
        TokenController.prototype.getGenerator = function () {
            return jaxx.Registry.Ethereum.coinService.generator;
        };
        TokenController.prototype.initService = function () {
            this.coinService = new jaxx.TokenService(this.config);
        };
        // Takes a raw VOTransaction and returns one that is ready for UI display
        // UI display has properties such as 'displayAddress' or 'incoming' that are not
        // present on raw transactions and have to be deduced from inputs/outputs
        TokenController.prototype.processTransactionForDisplay = function (tx) {
            var new_tx_data = jaxx.Utils.deepCopy(tx);
            var tx_array = [new_tx_data];
            jaxx.Utils.mapDisplayTransactionsEthereum(tx_array, this.getAddressesAll(), this.symbol);
            return tx_array[0];
        };
        // Indicates if the controller supports TX history
        // Invoked by the UI when attempting to render 
        TokenController.prototype.supportsTransactionHistory = function () {
            return false;
        };
        TokenController.prototype.downloadBalancesAll = function (callBack) {
        };
        TokenController.prototype.getUTXOs = function () {
            return [];
        };
        TokenController.prototype.restoreHistory = function (callBack) {
            var _this = this;
            var address = this.getCurrentAddress();
            this.coinService.downloadBalances([address]).done(function (res) {
                if (res && res.length) {
                    var balance = _this.getCurrentBalance();
                    balance.balance = res[0].balance;
                    _this._db.saveBalancesReceive();
                }
                if (callBack)
                    callBack();
            });
        };
        TokenController.prototype.getCurrentBalance = function () {
            var balances = this._db.getBalancesReceive(true);
            if (balances.length === 0) {
                var balance = new VOBalance({
                    id: this.generateAddress(0, 'receive'),
                    balance: 0
                });
                this._db.saveBalancesReceive([balance]);
                return balance;
            }
            else
                return balances[0];
        };
        TokenController.prototype.checkBalanceCurrentReceive = function () {
            var _this = this;
            var address = this.getCurrentAddress();
            this.coinService.downloadBalances([address]).done(function (balances) {
                if (!balances)
                    return;
                var curBal = _this.getCurrentBalance();
                var curAmount = curBal.balance;
                var newAmount = balances[0].balance;
                var delta = Number(newAmount) - Number(curAmount);
                var precision = +newAmount / 1e6;
                if (Math.abs(delta) < precision)
                    delta = 0;
                console.log('%c ' + _this.symbol +
                    ' balance old: ' + jaxx.MATH.weiToEther(curAmount) +
                    ' new: ' + jaxx.MATH.weiToEther(newAmount) +
                    ' delta: ' + jaxx.MATH.weiToEther(delta + '') +
                    ' precision: ' + jaxx.MATH.weiToEther(precision + '') + ' ' +
                    (new Date()).toLocaleTimeString(), 'color:coral');
                if (delta < 0) {
                    console.warn(' erasing temp balance ');
                    _this.logConfirmedTransaction();
                    //When transaction processed update balance ETH to check is enough balance for next transaction
                    jaxx.Registry.Ethereum.refreshBalanceOnAddress0();
                    _this.spentBalances = [];
                }
                _this._db.saveBalancesReceive(balances);
                if (delta) {
                    console.log('%c ' + _this.symbol + ' delta  ' + delta, 'color:blue');
                    _this.dispatchBalance();
                }
            }).fail(function (err) { _this.onError(err); });
        };
        TokenController.prototype.logSentTransaction = function () {
            this.timestampStartSeconds = String(Date.now() / 1000);
            console.log('%c ' + this.symbol + ' Sent Transaction ' + new Date().toLocaleTimeString(), 'color:pink');
        };
        TokenController.prototype.logConfirmedTransaction = function () {
            this.timestampEndSeconds = String(Date.now() / 1000);
            console.log('%c ' + this.symbol + ' Confirmed Transaction ' + new Date().toLocaleTimeString(), 'color:pink');
            if (Number(this.timestampEndSeconds) - Number(this.timestampStartSeconds) > 60) {
                console.error('Transaction taking too long need to optimize gas price and gas limits');
            }
        };
        TokenController.prototype.getCurrentAddress = function () {
            return this.getCurrentBalance().id;
        };
        // Ethereum based coins and all tokens don't have change address. To comply with interface we have this function but it always return null
        TokenController.prototype.getCurrentAddressChange = function () {
            return null;
        };
        TokenController.prototype.getAddressesAll = function () {
            return [this.getCurrentAddress()];
        };
        TokenController.prototype.getSpendable = function () {
            var bals = this._db.getBalancesReceive(true);
            if (bals.length) {
                var balance = bals[0].balance;
                return jaxx.MATH.weiToEther(balance);
            }
            //TODO: Need to create balance
            console.log('TODO: Need to create balance');
            return 'NO balance';
        };
        TokenController.prototype.getSpendableBalance = function (callback) {
            var bals = this._db.getBalancesReceive(true);
            if (bals.length) {
                var balance = bals[0].balance;
                callback(jaxx.MATH.weiToEther(balance));
            }
            //TODO: Need to create balance
            //console.log('TODO: Need to create balance');
            callback(null);
        };
        TokenController.prototype.buildTransaction = function (amount, addressTo, isMax, customGasLimit, customData) {
            var _this = this;
            var spendable = this.getSpendable();
            ///one mo time check if for some reason requested amount more then spendable considering input was wrong and sending max;
            if (!isMax && +amount >= +spendable)
                isMax = true;
            var requested = amount;
            var addressFrom = this.getCurrentAddress();
            var contractAddress = this.config.contractAddress;
            var differed = $.Deferred();
            var gasLimit = (customGasLimit == null) ? this.config.gasLimit : customGasLimit;
            var gasPrice = this.config.gasPrice;
            var symbol = this.config.symbol;
            var signature = jaxx.Registry.Ethereum.getSignatureForAddress(addressFrom);
            gasLimit = this.config.gasLimit;
            console.log(this.name + ' buildTransaction - user amount ' + amount + ' to ' + addressTo);
            var amountWei = jaxx.MATH.etherToWei(amount);
            if (isMax) {
                amountWei = this.getBalance();
            }
            var shift = this.config.shiftCount;
            if (shift) {
                // TODO if has shift do not convert to wei
                amountWei = jaxx.MATH.removeTrailingZeros(amountWei, this.config);
            }
            jaxx.Registry.Ethereum.getNonces([addressFrom]).done(function (nonces) {
                var nonce = nonces[addressFrom];
                var transaction = jaxx.TransactionsUtilsToken.buildToken(requested, amountWei, addressTo, nonce, contractAddress, gasLimit, gasPrice, signature, symbol, isMax, customData, _this.config);
                transaction.miningFeeSymbol = 'ETH';
                console.log(transaction);
                differed.resolve(transaction);
            });
            return differed.promise();
        };
        TokenController.prototype.mapDisplayTransactions = function (trs) {
        };
        /*getAddresseAll():string[]{
            return [this.getCurrentReceiveAddress()]
        }*/
        TokenController.prototype.onCurrentAddressGotBalance = function (balance) {
            var currentBalances = this._db.getBalancesAll(true);
            if (currentBalances.length === 0)
                return console.error('JN - onCurrentAddressGotBalance - No Balance');
            var currentBalance = currentBalances[0];
            if (currentBalance.balance !== balance.balance) {
                this._db.saveBalancesReceive([balance]);
                this.dispatchBalance();
                // TODO: Display update to UI NOT WORKING.
            }
            else {
                console.log(this.name + ' same balance ');
            }
        };
        TokenController.prototype.addListener = function (updateWalletUI) {
            this._updateWalletUI = updateWalletUI;
        };
        TokenController.getHistory = function () {
            return [];
        };
        TokenController.generateQRCode = function () {
            return jaxx.EthereumController.generateQRCode();
        };
        /* getCurrentReceiveAddress() {
             return this.getCurrentAddress();
         }*/
        /*  getSpendableBalance() {
              return this.getBalance();
          }*/
        //        private _transactionsData;
        /*setTransactionData(data) {
            this._transactionsData = data;
        }*/
        /*getTransactionDataTemp() {
            return 0;
        }*/
        /*setMaxSpendableCachedAmount(amount) {
            console.log(amount);
        }*/
        TokenController.prototype.adjustBalances = function (amount) {
            var shift = this.config.shiftCount;
            //console.warn('Has shift? ', shift);
            if (shift) {
                //TODO need to check if has shift and shift it back to the right
                amount = jaxx.MATH.addTrailingZeros(amount, this.config);
            }
            if (this.spentBalances.length) {
                this.spentBalances[0].balance = jaxx.MATH.sum([amount, this.spentBalances[0].balance]);
            }
            else
                this.spentBalances = [new VOBalance({
                        id: this.getCurrentAddress(),
                        balance: amount
                    })];
        };
        /*setIsSendingFullMaxSpendable(bool) {
            this._isSendingAll = bool;
        }*/
        TokenController.prototype.getIsSendingFullMaxSpendable = function () {
            return this._isSendingAll;
        };
        //        sendTranasactionController: TokenTransactions;
        TokenController.prototype.sendTransaction = function (transaction) {
            var _this = this;
            var deferred = $.Deferred();
            console.log(this.name = '  sendTransaction   ', transaction);
            this.coinService.sendTransaction(transaction).then(function (result) {
                console.log(result);
                if (result.success === 'success') {
                    var spent = transaction.amountInt;
                    _this.adjustBalances(spent);
                    _this.dispatchBalance();
                    _this.logSentTransaction();
                    deferred.resolve(result);
                }
                else {
                    deferred.reject(result);
                }
            }).fail(function (error) {
                deferred.reject({ error: error });
            });
            return deferred;
        };
        TokenController.prototype.getBalance = function () {
            var balances = this._db.getBalancesReceive(true);
            if (balances.length === 0)
                return '-1';
            var res = balances[0].balance;
            var spent = this.spentBalances;
            spent.forEach(function (item) {
                res = jaxx.MATH.subtract(res, item.balance);
            });
            return res;
        };
        TokenController.prototype.getBalanceDisplay = function () {
            return jaxx.MATH.weiToEther(this.getBalance());
        };
        /* deactivate(): boolean {
             console.warn('  deactivate ');
             this.isActive = false;
             //this.balanceController.stop();
             return true;
         }*/
        TokenController.prototype.activate = function () {
            var _this = this;
            if (this.isActive)
                return;
            this.isActive = true;
            this.loadGasPrice();
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_COIN_ACTIVATED, this);
            var timestamp = this.getHistoryTimestamp();
            if (!timestamp) {
                this.restoreHistory(function () {
                    _this.setHistoryTimestamp();
                    jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_RESTORE_HISTORY_DONE, _this);
                    setTimeout(function () { return _this.startBalancesCheck(); }, 10000);
                });
            }
            else {
                this.startBalancesCheck();
            }
            var onStart = this.getStartOption();
            if (onStart && onStart != 'pair-device') {
                console.warn(' pair device ');
                this.setHistoryTimestamp();
                this.createStartAddresses();
            }
            console.log('%c ' + this.symbol + ' activate  on-start: ' + onStart + '    ' + timestamp, 'color:red');
            return true;
        };
        TokenController.prototype.createNewWallet = function () {
        };
        /*setEnabled(enabled: boolean): void {
            this.isEnabled = enabled;
        }*/
        TokenController.prototype.generateAddress = function (index, type) {
            return jaxx.Registry.Ethereum.getAddressReceive(0);
        };
        /* getCurrentAddress(): string {
             let balances:VOBalance[] = this._db.getBalancesAll(true);
             if (!balances.length) {
                 let address:string =
 
                 this._db._saveBalancesReceive([new VOBalance({ id:address, balance:"0", decimal:0})]);
                 return address;
             }
             return balances[0].id;
         }*/
        TokenController.prototype.validateAddress = function (address) {
            return this.validateAddressETH(address);
        };
        /*
        * Load Gas Price from api https://api.blockcypher.com/v1/eth/main
        * @method loadGasPrice
        * */
        TokenController.prototype.loadGasPrice = function () {
            var _this = this;
            var ethereumController = jaxx.Registry.getCryptoControllerBySymbol('ETH');
            if (ethereumController.config.useGasPriceApi) {
                var url = JaxxUtils.scrubInput(ethereumController.config.gasPriceUrl);
                $.getJSON(url).done(function (res) {
                    _this.setMiningFeeData(res);
                }).fail(function (err) {
                    console.error(err);
                });
            }
        };
        /*
        * Modify the ethereum config gas price with response from average gas price api
        * @method setMiningFeeData
        * @param {any} res - response from api server
        * */
        TokenController.prototype.setMiningFeeData = function (res) {
            var ethController = jaxx.Registry.getCryptoControllerBySymbol("ETH");
            this.config.gasPrice = JaxxUtils.scrubInput(res[ethController.config.gasPriceOption]);
        };
        return TokenController;
    }(jaxx.CoinControllerBase));
    jaxx.TokenController = TokenController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=token-controller.js.map
var jaxx;
(function (jaxx) {
    var TransactionsUtilsToken = (function () {
        function TransactionsUtilsToken() {
        }
        //buildTokenTransaction
        TransactionsUtilsToken.buildToken = function (requested, amountWei, addressTo, nonce, contractAddress, gasLimit, gasPrice, signature, symbol, isMax, customData, coinConfig) {
            //console.log(arguments);
            var tempValue;
            // if(coinConfig.shiftCount) {
            //   tempValue = MATH.addTrailingZeros(amountWei, coinConfig);
            // } else {
            // tempValue = amountWei
            // }
            //  let amountDecimal: number =  Number(MATH.weiToEther(tempValue));
            var miningFeeDecimal = jaxx.MATH.weiToEther(String(+gasPrice * +gasLimit));
            // console.warn(' nonce ' + nonce);
            var data = jaxx.Utils.createTokenData(thirdparty.web3, amountWei, addressTo);
            if (customData) {
                console.error('User supplied custom data which is being ignored!');
                console.log('Custom Data', customData);
            }
            //  console.log('Data', data);
            var raw = jaxx.Utils.mapEthereumTransaction(thirdparty.web3, contractAddress, '0', nonce, gasPrice, gasLimit, data);
            // console.log(raw);
            var transaction = new thirdparty.ethereum.tx(raw);
            //console.log(transaction);
            transaction.sign(signature);
            var serialized = transaction.serialize().toString('hex');
            var txid = ('0x' + transaction.hash().toString('hex'));
            return {
                txid: txid,
                requested: requested + '',
                hex: serialized,
                totalSpent: amountWei,
                totalSpentDecimal: +jaxx.MATH.weiToEther(amountWei),
                amountDecimal: Number(requested),
                displayAmount: requested,
                amountInt: amountWei,
                addressTo: addressTo,
                symbol: symbol,
                miningFeeDecimal: +miningFeeDecimal,
                miningFeeSymbol: 'ETH',
                amountDecimalDisplay: requested,
                miningFeeInt: null,
                success: null,
                error: null,
                transactionETH: transaction,
                isMax: isMax,
                gasLimit: gasLimit,
                gasPrice: gasPrice
            };
        };
        return TransactionsUtilsToken;
    }());
    jaxx.TransactionsUtilsToken = TransactionsUtilsToken;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=token-transactions-utils.js.map
var jaxx;
(function (jaxx) {
    // declare var $:any;
    var TokenService = (function () {
        // emitter$:JQuery
        function TokenService(config) {
            this.config = config;
            this.ON_ERROR = 'ON_ERROR';
            // this.emitter$ = $({});
        }
        TokenService.prototype.stopAll = function () {
        };
        TokenService.prototype.lastBlock = function () {
            return null;
        };
        TokenService.prototype.downloadTransactions = function (addresses) {
            return null;
        };
        TokenService.prototype.downloadTransactionsDetails = function (transactions) {
            return null;
        };
        TokenService.prototype.restoreHistory = function (startIndex) {
            return null;
        };
        TokenService.prototype.downlaodUTXOs = function (addresses) {
            return null;
        };
        TokenService.prototype.downlaodNonces = function (addresses) {
            return null;
        };
        TokenService.prototype.sendTransaction = function (transaction) {
            var deferred = $.Deferred();
            //console.log(transaction);
            // let url = 'https://api.etherscan.io/api?module=proxy&action=eth_sendRawTransaction&hex={{hex}}';
            var url = jaxx.Registry.getCryptoControllerByName('Ethereum').urlSendTransaction;
            url = url.replace('{{hex}}', transaction.hex);
            //  console.log(url);
            //return null
            $.getJSON(url)
                .then(function (res) {
                //   console.log(res);
                return res;
            })
                .done(function (result) {
                if (result.result)
                    transaction.success = 'success';
                transaction.result = result;
                // transaction.success= result;
                deferred.resolve(transaction);
            })
                .fail(function (error) {
                deferred.reject(error);
                console.error(error);
            });
            return deferred.promise();
        };
        TokenService.prototype.downloadBalances = function (addresses) {
            var address = addresses[0];
            var shiftCount = this.config.shiftCount;
            if (!address)
                console.error(address);
            var url = this.config.urlBalanceToken || 'https://api.etherscan.io/api?module=account&action=tokenbalance&contractaddress={{contractAddress}}&address={{address}}&tag=latest&apikey=WGWHHAU4F2Y58UW5FQWTUJWSXBNHU7WBSX';
            url = url.replace('{{contractAddress}}', this.config.contractAddress);
            url = url.replace('{{address}}', address);
            return $.getJSON(url)
                .then(function (item) {
                // if server error balance not valid
                if (!+item.status || item.message === 'NOTOK' || isNaN(+item.result)) {
                    return null;
                }
                var balance = item.result;
                if (shiftCount)
                    balance = jaxx.MATH.shiftRight(balance, shiftCount);
                return [new VOBalance({ id: address, balance: balance })];
            });
        };
        return TokenService;
    }());
    jaxx.TokenService = TokenService;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=token-service.js.map
var jaxx;
(function (jaxx) {
    var CoinsCarouselSelectionType;
    (function (CoinsCarouselSelectionType) {
        CoinsCarouselSelectionType[CoinsCarouselSelectionType["CoinNav"] = 0] = "CoinNav";
        CoinsCarouselSelectionType[CoinsCarouselSelectionType["ShapeShift"] = 1] = "ShapeShift";
    })(CoinsCarouselSelectionType || (CoinsCarouselSelectionType = {}));
    var CoinsCarousel = (function () {
        function CoinsCarousel() {
            var _this = this;
            this.bringSelectedCoinIntoViewTimer = null; // activated by this.onArrowClicked
            this.timeToWaitUntilResettingCarouselScroll = 5000; //duration until it's checked if the user selected a coin after scrolling
            this._coinBannerCarouselAnimationTime = 300;
            this._coinBannerCarousel = null; // tiny carousel jQuery plugin instance
            this.$view = $('#scrollHeaderContainer');
            this.$carousel = $('#CarouselList');
            this.$viewPortContainer = $('#scrollHeaderContainer');
            this.$leftArrow = $('#scrollHeaderContainer a.leftArrow');
            this.$rightArrow = $('#scrollHeaderContainer a.rightArrow');
            this.$leftArrow.click(this.onArrowClicked.bind(this));
            this.$rightArrow.click(this.onArrowClicked.bind(this));
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_INTERWALLET_ANIMATION_END, function () {
                _this.onInterWalletAnimationEnded();
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_ACTIVATED, function () {
                _this.activateBringActiveCoinIntoViewTimer();
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE, function () {
                // In the ShapeShift menu, when the "From" coin is changed
                // The carousel is also changed to reflect the new wallet selection
                var symbol = jaxx.Registry.getCurrentCryptoController().symbol;
                _this.setSelected(symbol, CoinsCarouselSelectionType.ShapeShift);
            });
            this.$view.on('click', 'li', function (evt) {
                var element = $(evt.currentTarget);
                var symbol = element.data('symbol');
                _this.setSelected(symbol, CoinsCarouselSelectionType.CoinNav);
            });
            this.$list = $('#CarouselList');
        }
        CoinsCarousel.prototype.onEnableChange = function (symbol, enabled) {
            var _this = this;
            clearTimeout(this.timeout);
            this.timeout = setTimeout(function () {
                _this.render();
                _this.bringSelectedCoinIntoViewTimer = setTimeout(_this.carouselBringCurrentCoinIntoView.bind(_this), _this.timeToWaitUntilResettingCarouselScroll);
            }, 1000);
        };
        CoinsCarousel.prototype.onSequanceChange = function (coins) {
            var _this = this;
            clearTimeout(this.timeout);
            this.timeout = setTimeout(function () {
                _this.render();
                //this.resetCoin();
            }, 200);
            if (this.bringSelectedCoinIntoViewTimer !== null) {
                clearTimeout(this.bringSelectedCoinIntoViewTimer);
            }
            this.bringSelectedCoinIntoViewTimer = setTimeout(this.carouselBringCurrentCoinIntoView.bind(this), this.timeToWaitUntilResettingCarouselScroll);
        };
        /**
         * When the user moves the mouse around the carousel, we directly cancel any pending
         * coin move.
         */
        CoinsCarousel.prototype.onMouseEnterCarousel = function (e) {
            if (this.bringSelectedCoinIntoViewTimer !== null) {
                clearTimeout(this.bringSelectedCoinIntoViewTimer);
                this.bringSelectedCoinIntoViewTimer = null;
            }
        };
        CoinsCarousel.prototype.onInterWalletAnimationEnded = function () {
            var _this = this;
            var coinControllerToBeActivated = jaxx.Registry.getCryptoControllerBySymbol(this.selectedSymbol);
            if (coinControllerToBeActivated) {
                setTimeout(function () {
                    jaxx.Registry.setCurrentControllerBySymbol(_this.selectedSymbol);
                }, 100);
            }
            else {
                jaxx.Registry.setCurrentControllerBySymbol(this.selectedSymbol);
            }
            jaxx.Registry.application.balanceController.fiatBalanceView.updatefiatWalletBalance(this.selectedSymbol);
            setTimeout(function () {
                jaxx.Registry.application.spinner.hideSpinner(function () {
                    jaxx.Registry.application.spinner.animateInAllWalletElements();
                });
            }, 1000);
        };
        /**
         * Called when any of the scrolling arrows are clicked.
         * The purpose is: if user scrolls but did not select another coin after scrolling, we set a timer and when that completes
         * we bring the active coin into view
         *
         * @param e Event
         */
        CoinsCarousel.prototype.onArrowClicked = function (e) {
            this.activateBringActiveCoinIntoViewTimer();
        };
        CoinsCarousel.prototype.resetCoin = function () {
            console.warn("SYMBOL INITIAL: ", this.selectedSymbol);
            if (this.selectedSymbol) {
                var coinIsInWallet = this.checkForCoinInWallets(this.selectedSymbol);
                if (!coinIsInWallet) {
                    this.selectDefaultCoin();
                }
                else {
                    this.setSelected(this.selectedSymbol, CoinsCarouselSelectionType.CoinNav);
                }
            }
            console.warn("SYMBOL FINAL: ", this.selectedSymbol);
        };
        CoinsCarousel.prototype.activateBringActiveCoinIntoViewTimer = function () {
            if (this.bringSelectedCoinIntoViewTimer !== null) {
                clearTimeout(this.bringSelectedCoinIntoViewTimer);
            }
            this.bringSelectedCoinIntoViewTimer = setTimeout(this.carouselBringCurrentCoinIntoView.bind(this), this.timeToWaitUntilResettingCarouselScroll);
        };
        CoinsCarousel.prototype.checkForCoinInWallets = function (checkSymbol) {
            var coins = jaxx.Registry.getWalletsEnabledSorted();
            var coinIsInWallet = false;
            for (var i = 0; i < coins.length; i++) {
                var coinSymbol = (coins[i]).symbol;
                if (coinSymbol === checkSymbol) {
                    coinIsInWallet = true;
                }
            }
            return coinIsInWallet;
        };
        CoinsCarousel.prototype.selectDefaultCoin = function () {
            console.log(' selectDefaultCoin ');
            var firstCoin = _.first(jaxx.Registry.getWalletsEnabledSorted());
            if (!firstCoin) {
                firstCoin = _.first(jaxx.Registry.getAllCryptoControllers());
            }
            this.render();
            this.setSelected(firstCoin.symbol, CoinsCarouselSelectionType.CoinNav);
            return firstCoin.coinType;
        };
        /**
         * Sets the selected coin / token in the menu based on what caused the carousel to update
         * @method setSelected
         * @param {String} symbol
         * @param {CoinsCarouselSelectionType} selection
         * */
        CoinsCarousel.prototype.setSelected = function (symbol, selection) {
            if (this.selectedSymbol === symbol) {
                console.log(' already selected ' + symbol);
            }
            this.selectedSymbol = symbol;
            jaxx.Registry.application$.trigger(jaxx.Registry.ON_UI_COIN_ACTIVATE_START, this.selectedSymbol);
            var element = this.$view.find('[data-symbol=' + symbol + ']').first();
            if (element.length) {
                if (this.$selected) {
                    // deselect the current activated item
                    this.$carousel.children('cssSelected').removeClass('cssSelected');
                    this.$carousel.children().each(function () {
                        var hueRotated;
                        var doesNeedHue;
                        if (this.style.filter) {
                            hueRotated = (this.style.filter.split('hue-rotate('))[1].split(')')[0];
                            doesNeedHue = !(typeof hueRotated === 'undefined');
                        }
                        if ($(this).data('symbol') == symbol) {
                            $(this).removeClass('cssCoinSelecterGreyFilter');
                            $(this).removeClass('cssCoinSelectGenericFilter');
                        }
                        else if (doesNeedHue) {
                            $(this).addClass('cssCoinSelectGenericFilter');
                        }
                        else {
                            $(this).addClass('cssCoinSelecterGreyFilter');
                        }
                    });
                }
                // select the newly clicked item
                element.addClass('cssSelected');
                element.removeClass('cssCoinSelecterGreyFilter');
                element.removeClass('cssCoinSelecterGreyFilter');
                this.$selected = element;
            }
            else {
                console.error("Can't find element " + symbol);
            }
            if (selection === CoinsCarouselSelectionType.CoinNav) {
                this.$list.scrollLeft(0);
                var stc = jaxx.SendTransactionsController.instance;
                stc.deactivateShapeShift();
                stc.resetAll();
                stc.currentState = '';
            }
        };
        CoinsCarousel.prototype.render = function () {
            var _this = this;
            var html = '';
            var coins = jaxx.Registry.getWalletsEnabledSorted();
            // render the coin list
            for (var i = 0; i < coins.length; i++) {
                var coin = coins[i];
                var extraCss = '';
                var hueRotation = coin.hueRotate;
                var doesNeedHue = !(typeof coin.hueRotate === 'undefined');
                if (this.selectedSymbol == coin.symbol) {
                    extraCss = 'cssSelected';
                }
                else if (doesNeedHue) {
                    extraCss = 'cssCoinSelectGenericFilter';
                }
                else {
                    extraCss = 'cssCoinSelecterGreyFilter';
                }
                html += '<li data-name="' + coin.name + '" data-symbol="' + coin.symbol + '" class="item cssItem cssCoinSelector ' + extraCss + '" switchToCoin="' + coin.name + '" value="' + coin.name + '"' +
                    ' style="background-image: url(' + coin.icon + '); filter: hue-rotate(' + hueRotation + 'deg)">' +
                    ' <span class="cssCoinButtonText"> ' + coins[i].threeLetterCode + '</span></li>';
            }
            if (coins.length > 3) {
                // then render the 1st 3 coins again having 'mirrored' css class, as it's required by tinycarousel http://baijs.com/tinycarousel/
                for (var x = 0; x < Math.min(coins.length, 3); x++) {
                    var extraCss = void 0;
                    var coin = coins[x];
                    var hueRotation = coin.hueRotate;
                    var doesNeedHue = !(typeof coin.hueRotate === 'undefined');
                    if (doesNeedHue) {
                        extraCss = 'cssCoinSelectGenericFilter';
                    }
                    else {
                        extraCss = 'cssCoinSelecterGreyFilter';
                    }
                    html += '<li data-name="' + coin.name + '" data-symbol="' + coin.symbol + '" class="item cssItem ' + extraCss + ' cssCoinSelector mirrored" switchToCoin="' + coin.name + '" value="' + coin.name + '"' +
                        ' style="background-image: url(' + coin.icon + '); filter: hue-rotate(' + hueRotation + 'deg)">' +
                        ' <span class="cssCoinButtonText"> ' + coins[x].threeLetterCode + '</span></li>';
                }
            }
            this.$list.html(html);
            // this code controls if a tinycarousel is used or not
            // it also sets the width of the viewPortContainer to specifically fit less than 3 coins (such as 1 or 2) in oder to keep the coin selector centered
            if (coins.length <= 3) {
                var items = $('#CarouselList li');
                var itemWidth = items.outerWidth(true);
                var viewPortContainerWidth = coins.length * itemWidth;
                this.$viewPortContainer.width(viewPortContainerWidth);
                var carousel = $('#scrollHeaderContainer').data('plugin_tinycarousel');
                if (carousel && carousel['move']) {
                    carousel.update();
                    carousel.move(0);
                }
                this._coinBannerCarousel = null;
                this.$leftArrow.hide();
                this.$rightArrow.hide();
            }
            else {
                this.$leftArrow.show();
                this.$rightArrow.show();
                this.$viewPortContainer.width('230px');
                var carousel = $('#scrollHeaderContainer').data('plugin_tinycarousel');
                if (carousel) {
                    this._coinBannerCarousel = carousel;
                }
                if (this._coinBannerCarousel === null) {
                    setTimeout(function () {
                        $('#scrollHeaderContainer').tinycarousel({ infinite: true, animationTime: _this._coinBannerCarouselAnimationTime });
                        _this._coinBannerCarousel = $('#scrollHeaderContainer').data('plugin_tinycarousel');
                    }, 1);
                }
                else {
                    setTimeout(function () {
                        _this._coinBannerCarousel.update();
                    }, 1);
                }
            }
        };
        CoinsCarousel.prototype.carouselBringCurrentCoinIntoView = function () {
            if (this._coinBannerCarousel && this._coinBannerCarousel.move) {
                var current_coin_id = this.carouselGetCoinIDFromSymbol(this.selectedSymbol);
                this._coinBannerCarousel.move(current_coin_id);
            }
        };
        CoinsCarousel.prototype.carouselGetCoinIDFromSymbol = function (coin_symbol) {
            var id;
            id = $('#CarouselList').children('[data-symbol="' + coin_symbol + '"]').index();
            return id;
        };
        return CoinsCarousel;
    }());
    jaxx.CoinsCarousel = CoinsCarousel;
    var CoinsMenu = (function () {
        function CoinsMenu() {
            var _this = this;
            /** Triggerred when a coin/wallet is activated/deactivated.
             *
             * Looks if it's a coin deactivation request and if that coin is the currently enabled
             * wallet, switches to the next enabled wallet.
             *
             * Then updates the coin carousel to reflect the coin selection changes.
             */
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_SATUS_CHANGED, function (evt, name, enbl, symbol) {
                var currentCrypto = null;
                currentCrypto = jaxx.Registry.getCurrentCryptoController();
                if (currentCrypto) {
                    var currentlyActivatedCoinSymbol = currentCrypto.symbol;
                    if (enbl == false && symbol == currentlyActivatedCoinSymbol) {
                        var wallets = jaxx.Registry.getWalletsEnabledSorted();
                        var loop_count = 0;
                        if (wallets.length > 1) {
                            var starting_pos = wallets.indexOf(currentCrypto) + 1;
                            var next_wallet = null;
                            do {
                                if (starting_pos >= wallets.length) {
                                    starting_pos = 0;
                                }
                                if (wallets[starting_pos].symbol != currentlyActivatedCoinSymbol) {
                                    next_wallet = wallets[starting_pos];
                                }
                                else {
                                    next_wallet = null;
                                }
                                if (loop_count > 1000) {
                                    break; // just making sure the loop won't go forever
                                }
                                loop_count++;
                            } while (next_wallet != null);
                            _this.carousel.setSelected(next_wallet.symbol, CoinsCarouselSelectionType.CoinNav);
                        }
                    }
                }
                else {
                    console.error("Couldn't active/deactivate " + name + " wallet. Cannot find the currently activated crypto controller.");
                }
                _this.carousel.onEnableChange(symbol, enbl);
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_SEQUENCE_CHANGED, function (evt, out) {
                _this.carousel.onSequanceChange(out);
            });
            CoinsMenu.instance = this;
            this.carousel = new CoinsCarousel();
            this.selector = new CoinsSelector();
        }
        CoinsMenu.prototype.selectDefaultCoin = function () {
            this.carousel.selectDefaultCoin();
        };
        return CoinsMenu;
    }());
    jaxx.CoinsMenu = CoinsMenu;
    var CoinsSelector = (function () {
        function CoinsSelector() {
        }
        return CoinsSelector;
    }());
    jaxx.CoinsSelector = CoinsSelector;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=coins-menus.js.map
/**
 * Created by Vlad on 2016-11-24.
 */
var jaxx;
(function (jaxx) {
    var TransactionsUpdater = (function () {
        function TransactionsUpdater(controller, service, config) {
            this.controller = controller;
            this.service = service;
            this.config = config;
            // name:string;
            this.ON_TRANSACTION_CONFIRM_CHANGES = 'ON_TRANSACTION_CONFIRM_CHANGES';
            this.ON_TRANSACTION_INBLOCK = 'ON_TRANSACTION_INBLOCK';
            this.emitter$ = $({});
            // this.name = config.symbol;
            this.updateTime = 30000;
        }
        TransactionsUpdater.prototype.activate = function () {
            var _this = this;
            this.log('Activated.');
            clearInterval(this.updateInterval);
            this.updateInterval = setInterval(function () { return _this.onTimer(); }, this.updateTime);
            this.onTimer();
        };
        /* setTimeout(fast:boolean):void{
                 let timeout = fast?this.options.updateTimeout*3;
             if(this.updateTime !== timeout){
                 this.updateTime = timeout;
                 this.activate();
             }
         }
 */
        TransactionsUpdater.prototype.deactivate = function () {
            this.log('Deactivated.');
            clearInterval(this.updateInterval);
        };
        TransactionsUpdater.prototype.checkUnconfirmed = function (trs) {
            var _this = this;
            this.log('Checking transactions that have not been mined yet.');
            var unconfirmed = trs.filter(function (item) {
                return !item.block;
            });
            if (unconfirmed.length == 0) {
                this.log('No un-mined transactions to check.');
                return false;
            }
            this.log('found ' + unconfirmed.length + ' un-mined TX(es) that need to be updated. Downloading TX details...');
            // this.log(unconfirmed);
            this.service.downloadTransactionsDetails(unconfirmed).done(function (results) {
                var haveChanges = false;
                var indexed = _.keyBy(results, 'id');
                unconfirmed.forEach(function (item) {
                    var nt = indexed[item.id];
                    if (!!nt && nt.block > 0) {
                        item.block = nt.block;
                        item.confirmations = nt.confirmations;
                        item.timestamp = nt.timestamp;
                        haveChanges = true;
                    }
                });
                if (haveChanges) {
                    _this.log('Updated ' + unconfirmed.length + ' TX(es) within the UI.');
                    _this.emitter$.triggerHandler(_this.ON_TRANSACTION_INBLOCK, { transactions: unconfirmed });
                    // this.log(unconfirmed);
                }
                else {
                    _this.log('No new data from the backend for ' + unconfirmed.length + ' un-mined TX(es).');
                }
            }).fail(function (err) {
                console.error(err);
            });
            return true;
        };
        TransactionsUpdater.prototype.updateBlocks = function (need) {
            var lastBlock = this.prevBlock;
            var haveChanges = 0;
            need.forEach(function (item) {
                if (!!item.block) {
                    var confirmations = (lastBlock - item.block) + 1;
                    if (item.confirmations !== confirmations) {
                        item.confirmations = confirmations;
                        haveChanges++;
                    }
                    ;
                }
            });
            if (haveChanges) {
                this.log('Found ' + this.config.symbol + ' confirmation updates for ' + need.length + ' TX(es). Updating UI.');
                //this.controller
                this.emitter$.triggerHandler(this.ON_TRANSACTION_CONFIRM_CHANGES, { transactions: need });
            }
            else
                this.log('No confirmations updates for ' + need.length + ' unconfirmed transaction(s).');
        };
        TransactionsUpdater.prototype.onTimer = function () {
            var _this = this;
            if (!this.controller.isActive) {
                this.deactivate();
                return;
            }
            this.log('Refreshing un-mined and un-confirmed transactions status...');
            var trs = this.controller._db.getTransactionsReceive();
            this.checkUnconfirmed(trs);
            var confirmations = this.config.trsConfirmations || 6;
            var need = trs.filter(function (item) {
                return (item.confirmations <= confirmations);
            });
            if (need.length === 0) {
                this.log('' + this.config.symbol + ' has no transactions with less than ' + confirmations + ' confirmations. Nothing to do.');
                //this.deactivate();
                return;
            }
            ;
            var cofs = need.map(function (item) {
                return item.confirmations;
            });
            //this.log(' ' + this.config.symbol + ' needs '+confirmations + ' confirmations => have:' + cofs.toString() + '  get Block', 'color:blue');
            this.service.lastBlock().done(function (lastBlock) {
                //this.log(need);
                if (lastBlock === 0) {
                    console.warn(' ' + _this.config.symbol + ' retrieved a blockheight of 0. Invalid height, skipping updates.');
                    return;
                }
                if (!_this.prevBlock) {
                    _this.prevBlock = lastBlock;
                    _this.updateBlocks(need);
                    return;
                }
                // this.log('prevBlock:'+ this.prevBlock +'  lastBlock: '+ lastBlock);
                if (_this.prevBlock === lastBlock) {
                    _this.log('' + _this.config.symbol + ' last mined block is still the same: ' + lastBlock);
                    return;
                }
                else
                    _this.log('new mined block detected ' + lastBlock + '. Checking which TX confirmations to update in UI.');
                _this.prevBlock = lastBlock;
                _this.updateBlocks(need);
            }).fail(function (err) {
                _this.log('Failed to update last mined block. Error: ' + JSON.stringify(err));
                _this.controller.onError(err);
            });
        };
        TransactionsUpdater.prototype.log = function (msg) {
            msg = new Date().toLocaleString() + " TransactionUpdater [" + this.controller.symbol + "]: %c " + msg;
            console.log(msg, 'color: darkblue');
        };
        return TransactionsUpdater;
    }());
    jaxx.TransactionsUpdater = TransactionsUpdater;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=transactions_updater.js.map
///<reference path="./models.ts"/>
///<reference path="../archive/services/account-service.ts"/>
///<reference path="../app/Registry.ts"/>
var jaxx;
(function (jaxx) {
    var JaxxDatastoreLocal = (function () {
        function JaxxDatastoreLocal(settings) {
            this.emitter$ = $({});
            this.ON_BALANCE_TEMP_LENGTH_0 = 'ON_BALANCE_TEMP_LENGTH_0';
            this.ON_BALANCE_TEMP_LENGTH_NOT_0 = 'ON_BALANCE_TEMP_LENGTH_NOT_0';
            this.maxTransactions = 300;
            this.balancesTimestamp = 0;
            this.balancesTemp = [];
            this.spentInreval = 0;
            this.balanceTotal = -1;
            this.transactionTimestampReceive = 0;
            /* getTransactionsChange(): VOTransaction[] {
                 if (!this.transactionsChange) {
     
                     this.transactionTimestampReceive = Number(localStorage.getItem('transactions-change-timestamp-' + this.name));
                     let str: string = localStorage.getItem('transactions-change-' + this.name);
                     if (str) this.transactionsChange = JSON.parse(str).map(function (item) {
                         return new VOTransaction(item);
                     });
                     else this.transactionsChange = [];
                 }
     
                 return this.transactionsChange;
             }*/
            /* saveTransactionsChange(trs: VOTransaction[], length?: number): void {
                // if (trs.length == 0)return;
              //   console.log(' saveTransactionsChange   ',trs);
     
                 this.transactionsChange = trs;
                 // trs = _.sortBy(trs,['timestamp']);
                 if (trs.length > this.maxTransactions) trs = trs.slice(trs.length - this.maxTransactions);
     
                 localStorage.setItem('transactions-change-timestamp-' + this.name, Date.now() + '');
                 localStorage.setItem('transactions-change-' + this.name, JSON.stringify(trs));
     
             }*/
            this.historyTimestamp = -1;
            this.name = settings.name;
            this.id = settings.id;
        }
        JaxxDatastoreLocal.prototype.clearStorage = function () {
            console.log(this.name + '     storage cleared ');
            if (this.getBalancesReceive(true).length)
                this._saveBalancesReceive([]);
            if (this.getBalancesChange(true).length)
                this._saveBalancesChange([]);
            if (this.getTransactionsReceive().length) {
                this.saveTransactionsReceive([]);
            }
            //if(this.getTransactionsChange().length) this.saveTransactionsChange([]);
            //this.addressesChange = [];
            // this.addressesReceive = [];
        };
        JaxxDatastoreLocal.prototype.setNewWallet = function (isNew) {
            localStorage.setItem(this.name + 'newwallet', isNew ? 'true' : '');
        };
        JaxxDatastoreLocal.prototype.isNewWallet = function () {
            return localStorage.getItem(this.name + 'newwallet') === 'true';
        };
        // relayedTransactionListArray2: VORelayedTransactionList[] = [];
        /* addRelayedTransactionListArray(ar: VORelayedTransactionList[]): void {
 
             this.relayedTransactionListArray2 = this.relayedTransactionListArray2.concat(ar);
 
             // let utxos:ReferenceRelaysUTXOData[] = Utils.getTransactionsUnspentFromVORelayedTransactionList(ar);
             // console.log(' adding utxos ' + utxos.length);
 
             // console.log(this.UTXOs);
         }*/
        JaxxDatastoreLocal.prototype.saveUTXOs = function (utxos) {
            // console.log(' save utxos ', utxos);
            this.UTXOs = utxos;
            localStorage.setItem(this.name + '-UTXOs', JSON.stringify(this.UTXOs));
            localStorage.setItem(this.name + '-UTXOs-timestamp', Date.now() + '');
        };
        JaxxDatastoreLocal.prototype.getUTXOs = function () {
            if (!this.UTXOs) {
                var str = localStorage.getItem(this.name + '-UTXOs');
                this.UTXOs = str ? JSON.parse(str) : [];
            }
            return this.UTXOs;
        };
        JaxxDatastoreLocal.prototype.saveNonces = function (nonces) {
            //console.log(' save nonces ', nonces);
            this.nonces = nonces;
            localStorage.setItem(this.name + '-nonces', JSON.stringify(this.nonces));
            localStorage.setItem(this.name + '-nonces-timestamp', Date.now() + '');
        };
        JaxxDatastoreLocal.prototype.getNonces = function () {
            if (!this.nonces) {
                var str = localStorage.getItem(this.name + '-nonces');
                this.nonces = str ? JSON.parse(str) : {};
            }
            return this.nonces;
        };
        //////////////////////////////////////
        //////////////////////////BalancesTemp ////////////////////////////
        /*  addSpending(num: number): number {
              this.balanceSpent += num;
              if (this.balanceSpent < 0) this.balanceSpent = 0;
              return this.balanceSpent;
          }
  
          removeSpending(num?: number): void {
              if (num) this.balanceSpent -= num;
              if (this.balanceSpent < 0) this.balanceSpent = 0;
          }*/
        // balanceSpent: number = 0;
        //////////////////////////////
        /////////////////////               Balances Spent                  ////////
        /*
                reduceBalaceSpent(address: string, amount: number): void {
        
                    let ar: VOBalanceTemp[] = this.getBalancesTemp();
        
                    for (let i = ar.length - 1; i >= 0; i--) {
                        let b: VOBalanceTemp = ar[i];
                        if (b.id === address) {
                            let precision = ar[i].spent / 100;
                            b.spent -= amount;
                            if (b.spent < precision) {
                                console.log('%c removing balance spent ' + b.id + ' spent ' + b.spent, 'color:green');
                                ar.splice(i, 1);
                            } else {
                                console.log('%c balance left ' + b.id + ' spent ' + b.spent, 'color:red');
                            }
                        }
                    }
                }*/
        JaxxDatastoreLocal.prototype.onBalancesDifference = function (diff) {
            var indexed = {};
            console.warn(this.name, diff);
            diff.forEach(function (b) {
                indexed[b.id] = b;
            });
            var ar = this.getBalancesTemp();
            for (var i = ar.length - 1; i >= 0; i--) {
                var b = ar[i];
                if (indexed[b.id]) {
                    ///// try just remove balance temp
                    ar.splice(i, 1);
                    console.log('%c removing balance temp ' + b.id + ' spent ' + b.spent, 'color:red');
                    /*
                    
                                        if (indexed[b.id].old_new < 0) {
                                            console.error(' balance spent < 0', indexed[b.id]);
                                        }
                                        let precision = ar[i].spent / 100;
                                        //console.log('%c updating balance ' + b.id + '  ' + b.spent / 1e15 + ' - ' + indexed[b.id].spent/1e15,'color:red');
                                        b.spent -= indexed[b.id].old_new;
                    
                                        if (b.spent < precision) {
                                            console.log('%c removing balance spent ' + b.id + ' spent ' + b.spent, 'color:red');
                                            ar.splice(i, 1);
                                        } else {
                                            // console.error('%c balance left '+ b.id +' spent '+b.spent,'color:red');
                                        }
                    */
                }
            }
            if (ar.length === 0) {
                this.resetBalancesSpent();
            }
            ar.forEach(function (item) {
                console.log('%c left balances temp ' + item.id + '  ' + item.spent / 1e15, 'color:red');
            });
        };
        /* removeNulesSpent(){
         var ar:VOBalance[] = this.getBalancesTemp();
         for(var i=ar.length-1; i>=0; i--){
         if(ar[i].balance ===0 ) ar.splice(i,1)  ;
         }
         this.balancesSpent = ar;
         }*/
        JaxxDatastoreLocal.prototype.checkBalancesSpent = function () {
            var ar = this.getBalancesTemp();
            var now = Date.now();
            var delta = 120000 * 1000;
            for (var i = ar.length - 1; i >= 0; i--) {
                if ((now - ar[i].timestamp) > delta) {
                    console.warn(now + ' removing balance spent due  timestamp  id: ' + ar[i].id + ' spent: ' + ar[i].spent + ' timestamp delta : ' + (now - ar[i].timestamp));
                    ar.splice(i, 1);
                }
            }
            this.balancesTemp = ar;
            if (ar.length === 0) {
                clearInterval(this.spentInreval);
                this.spentInreval = 0;
            }
            if (this.balancesTemp) {
                // console.log(Utils.addresseFromBalances(this.balancesSpent));
                // console.log('balances spent: ' + this.getBalanceSpent() / 1e15, this.balancesSpent.forEach(function(item){ console.log(item.id+' spent: '+item.spent/1e15)}));
            }
        };
        JaxxDatastoreLocal.prototype.addBalancesSpent = function (ar) {
            var _this = this;
            console.log(this.name + ' adding balances spent ', ar);
            if (this.spentInreval === 0)
                this.spentInreval = setInterval(function () { return _this.checkBalancesSpent(); }, 20000);
            if (this.balancesTemp.length === 0) {
                this.balancesTemp = ar;
                this.emitter$.triggerHandler(this.ON_BALANCE_TEMP_LENGTH_NOT_0, [ar]);
                return;
            }
            var out = [];
            for (var i = 0, n = ar.length; i < n; i++) {
                if (isNaN(ar[i].spent))
                    continue;
                var bal = this.getBalanceSpentById(ar[i].id);
                if (bal) {
                    // console.log(' adding balance to existing was  ' + bal.spent/1e15 + ' + '+ ar[i].spent/1e15  )
                    bal.spent += ar[i].spent;
                    // bal.txids = bal.txids.concat(ar[i].txids);
                    //console.log(' now ' + bal.spent/1e15);
                    bal.count++;
                }
                else {
                    out.push(ar[i]);
                    /// console.log(' adding new balance ',ar[i]);
                }
            }
            if (out.length)
                this.balancesTemp = this.balancesTemp.concat(out);
        };
        /*
                removeTempBalancesByTxIds(txids: string[]): void {
                    let ar: VOBalanceTemp[] = this.balancesSpent;
                    for (let i = ar.length - 1; i >= 0; i--) {
        
                        if (txids.indexOf(ar[i].txid)) {
                            // console.log('removing by txdid '+ ar[i].id +"   "+ ar[i].spent/1e10);
                            ar.splice(i, 1);
                        }
                    }
                }*/
        JaxxDatastoreLocal.prototype.getBalancesTemp = function () {
            return this.balancesTemp;
        };
        JaxxDatastoreLocal.prototype.getBalanceTemp = function () {
            return this.balancesTemp.reduce(function (a, b) {
                return a += b.spent;
            }, 0);
            /* let spent = 0;
             this.balancesSpent.forEach(function (item) {
                 spent += item.spent
             });
             return spent;*/
        };
        ;
        JaxxDatastoreLocal.prototype.resetBalancesSpent = function () {
            //console.warn(' resetBalancesSpent ');
            this.emitter$.triggerHandler(this.ON_BALANCE_TEMP_LENGTH_0);
            this.balancesTemp = [];
        };
        JaxxDatastoreLocal.prototype.getBalanceSpentById = function (id) {
            var ar = this.getBalancesTemp();
            for (var i = 0, n = ar.length; i < n; i++)
                if (ar[i].id === id)
                    return ar[i];
            return null;
        };
        //////////////////////////////////////////  end balances Spent///////////////////////////////////////////////////
        /*
         getBalanceTemp(): number {
         let balances: VOBalanceTemp[] = this.getBalancesTemp();
         return balances.length ? jaxx.Utils.calculateBalance(balances) : 0;
         }*/
        /* balancesTemp1: VOBalanceTemp[];

         addBalanceTemp(balance: VOBalanceTemp) {
         // console.log('added balance temp ',balance);
         let bals: VOBalanceTemp[] = this.getBalancesTemp();
         bals.push(balance);
         this.saveBalancesTemp(bals);
         }*/
        /* removeBalanceTemp(balance: VOBalanceTemp) {

         console.log('removing balance temp',balance);
         let bals: VOBalanceTemp[] = this.getBalancesTemp();

         for(let i= bals.length; i>=0 ;i++){
         if(bals[i].id === balance.id && bals[i].balance === balance.balance ) {
         bals.splice(i,1);
         console.log('found balance ', balance);
         }
         }
         this.saveBalancesTemp(bals);
         }*/
        /* addBalancesTemp(balances: VOBalanceTemp[]) {
         let bals: VOBalanceTemp[] = this.getBalancesTemp();


         bals = bals.concat(balances);
         this.saveBalancesTemp(bals);
         }
         */
        /* getBalancesTemp(): VOBalanceTemp[] {
         if (!this.balancesTemp1) {
         let str: string = localStorage.getItem('balances-temp-' + this.name);
         if (str) this.balancesTemp1 = _.map(JSON.parse(str), o => new VOBalanceTemp(o));
         else this.balancesTemp1 = [];
         }
         return this.balancesTemp1;
         }
         */
        /*saveBalancesTemp(balances: VOBalanceTemp[]): void {
         ///console.warn('saveBalancesTemp   ',balances);
         this.balancesTemp1 = balances;
         localStorage.setItem('balances-temp-' + this.name, JSON.stringify(balances));
         this.refreshBalanceTotal();

         }*/
        ////////////////////////////////////////////////////////////////// end Balance temp
        JaxxDatastoreLocal.prototype.getBalancesHighestFirst = function () {
            var bals1 = this.getBalancesReceive();
            var bals2 = this.getBalancesChange();
            var bals = bals1.concat(bals2);
            return _.sortBy(bals, function (item) { return item.balance; });
        };
        /* private addTempBalance(balance: VOBalance, balances: VOBalanceTemp[]): void {
         balances.forEach(function (item) {
         if (item.id == balance.id) {
         balance.balance += item.balance;
         }
         })
         }*/
        JaxxDatastoreLocal.prototype.isAddressInternal = function (address) {
            return (this.getAddressesChange().indexOf(address) !== -1) ? 1 : 0;
        };
        JaxxDatastoreLocal.prototype.getAddressesNot0 = function () {
            return this.getBalancesNot0().map(function (item) {
                return item.id;
            });
        };
        JaxxDatastoreLocal.prototype.getBalancesNot0 = function () {
            return this.getBalancesReceiveNot0().concat(this.getBalancesChangeNot0());
        };
        JaxxDatastoreLocal.prototype.getAddressesNo0Change = function (fee) {
            if (fee === void 0) { fee = 0; }
            return jaxx.Utils.getIds(this.getBalancesNot0Change(fee));
        };
        JaxxDatastoreLocal.prototype.getBalancesNot0Change = function (fee) {
            if (fee === void 0) { fee = 0; }
            var out = [];
            var bals = this.getBalancesChange(true);
            bals.forEach(function (item) {
                if (+item.balance > fee)
                    out.push(new VOBalance({ id: item.id, balance: item.balance, index: item.index }));
            });
            return out;
        };
        /*   getAddressesNo0Receive(): string[] {
   
              // return Utils.getIds(this.getBalancesNot0Receive(fee));
   
           }*/
        /* getBalancesNot0Receive(fee: number = 0): VOBalance[] {
             let out: VOBalance[] = [];
             //let ar:VOBalance[] = this._balancesReceive;
             let bals:VOBalance[] = this.getBalancesReceive(true);
 
                 bals.forEach(function (item) {
                     if (+item.balance > fee) out.push(new VOBalance({id: item.id, balance: item.balance, index: item.index}));
                 });
 
 
             return out;
         }
 */
        JaxxDatastoreLocal.prototype.getBalancesChangeNot0WithSpend = function () {
            var out = [];
            var ar = this._balancesChange;
            var spent = this.balancesTemp;
            var indexed = {};
            spent.forEach(function (b) {
                indexed[b.id] = b;
            });
            ar.forEach(function (bal) {
                if (+bal.balance !== 0) {
                    var b = new VOBalance(bal);
                    if (indexed[b.id]) {
                        //TODO link to MATH
                        //+b.balance -= indexed[b.id].spent;
                    }
                    out.push(b);
                }
            });
            return out;
        };
        /* getBalancesReceiveNot0WithSpend(): VOBalance[] {
             let out: VOBalance[] = [];
             let ar: VOBalance[] = this._balancesReceive;
             let spent: VOBalanceTemp[] = this.balancesTemp;
             let indexed = {};
             spent.forEach(function (b) {
                 indexed[b.id] = b;
             });
 
             ar.forEach(function (bal) {
                 if (bal.balance !== 0) {
                     let b = new VOBalance(bal);
                     if (indexed[b.id]) {
                         b.balance -= indexed[b.id].spent;
                         // b.nonce = indexed[b.id].nonce;
 
                     }
                     out.push(b)
 
                 }
             });
             return out;
         }
 */
        /* getBalancesIndexedReceiveNot0WithIndex(): VOBalance[] {
 
             let ballances: VOBalance[] = this.getBalancesReceive();
             if (ballances.length === 0) return [];
 
             let spending: VOBalanceTemp[] = this.getBalancesTemp();
 
             let spend = {};
 
             spending.forEach(function (b) {
 
                 if (spend[b.id]) spend[b.id] += b.spent;
                 else spend[b.id] = b.spent;
                 // spend[b.id] = b;
 
             });
 
             let out: VOBalance[] = [];
 
             for (let i = 0, n = ballances.length; i < n; i++) {
                 let item: VOBalance = ballances[i];
 
                 if (item.balance) {
                     item.index = i;
                     if (spend[item.id]) item.balance -= spend[item.id];
                     out.push(item)
                 }
 
             }
 
             //console.log(out);
 
             /!*
              let addresses: string[] = this.getAddressesReceive();
              ballances.forEach((item) => {
              if (item.balance) {
              let bal: VOBalance = new VOBalance(item);
              bal.index = addresses.indexOf(item.id);
              if (balancesTemp.length) this.addTempBalance(bal, balancesTemp);
              out.push(bal);
              }
 
              })*!/
             return out;
         }
 */
        /*  getBalancesIndexedChangeNot0WithIndex(): VOBalance[] {
              let ballances: VOBalance[] = this.getBalancesChange();
              // if(ballances.length === 0 ) return [];
  
              // let addresses: string[] = this.getAddressesChange();
              let spending: VOBalanceTemp[] = this.getBalancesTemp();
              let out: VOBalance[] = [];
  
              let spend = {};
  
              spending.forEach(function (b) {
  
                  if (spend[b.id]) spend[b.id] += b.spent;
                  else spend[b.id] = b.spent;
                  // spend[b.id] = b;
  
              });
  
  
              // let spent = _.keyBy(spending, 'id');
  
              for (let i = 0, n = ballances.length; i < n; i++) {
                  let item: VOBalance = ballances[i];
                  if (item.balance) {
                      item.index = i;
                      if (spend[item.id]) item.balance -= spend[item.id];
                      out.push(item)
                  }
  
              }
              /!*  _.each(ballances, function (item) {
               if (item.balance) {
               let bal: VOBalance = new VOBalance(item);
               bal.index = addresses.indexOf(item.id);
  
               if (balancesTemp.length) this.addTempBalance(bal, balancesTemp);
               out.push(bal);
               }
  
               })*!/
              return out;
          }
  */
        JaxxDatastoreLocal.prototype.getBalancesAll = function () {
            return this.getBalancesReceive().concat(this.getBalancesChange());
        };
        JaxxDatastoreLocal.prototype.saveBalanceTotal = function (num) {
            this.balanceTotal = num;
            this.balanceTotalTimestamp = Date.now();
            localStorage.setItem('balance-total-timestamp-' + this.name, this.balanceTotalTimestamp + '');
            localStorage.setItem('balance-total-' + this.name, num + '');
        };
        ////////////////////////////////////////////////
        /*  saveBalanceChange(num:number):void{
         localStorage.setItem('balance-change-'+this.name,num+'');
         }
         saveBalanceReceive(num:number):void{
         localStorage.setItem('balance-receive-'+this.name,num+'');
         }
         loadBalanceChange():number{
         return Number(localStorage.getItem('balance-change-'+this.name));
         }
         loadBalanceReceive():number{
         return Number(localStorage.getItem('balance-receive-'+this.name));
         }*/
        //////////////////////////
        JaxxDatastoreLocal.prototype.getBalancesUnconfirmed = function () {
            if (!this.balancesUncofirmed) {
                var bals = JSON.parse(localStorage.getItem('balances-unconfirmed-' + this.name));
                if (!bals)
                    bals = [];
                else
                    bals = bals.map(function (item) {
                        return new VOBalance(item);
                    });
                this.balancesUncofirmed = bals;
            }
            return this.balancesUncofirmed;
        };
        JaxxDatastoreLocal.prototype.saveBalancesUncofirmed = function (balances) {
            this.balancesUncofirmed = balances;
            var stamp = Date.now();
            localStorage.setItem('balances-unconfirmed-timestamp-' + this.name, stamp + '');
            localStorage.setItem('balances-unconfirmed-' + this.name, JSON.stringify(this.balancesUncofirmed));
        };
        JaxxDatastoreLocal.prototype.addBalanceChange = function (bal) {
            if (this.getAddressesChange().indexOf(bal.id) !== -1)
                return;
            if (isNaN(bal.index))
                bal.index = this._balancesChange.length;
            this._balancesChange.push(bal);
            this._saveBalancesChange();
            // this.saveCurrentIndexChange(this._balancesChange.length);
        };
        JaxxDatastoreLocal.prototype.getBalancesChangePrev = function () {
            return this.balancesChangePrev;
        };
        ///set to true risky lost sequence
        JaxxDatastoreLocal.prototype.getBalancesChange = function (orig) {
            if (!this._balancesChange) {
                var str = localStorage.getItem('balances-change-' + this.name);
                if (str)
                    this._balancesChange = JSON.parse(str).map(function (item) {
                        return new VOBalance(item);
                    });
                else
                    this._balancesChange = [];
            }
            if (orig)
                return this._balancesChange;
            var out = [];
            this._balancesChange.forEach(function (item) {
                out.push(new VOBalance(item));
            });
            return out;
        };
        JaxxDatastoreLocal.prototype.getBalancesChangeNot0 = function () {
            return this.getBalancesChange(true).filter(function (item) {
                return item.balance !== '0';
            });
        };
        JaxxDatastoreLocal.prototype.getBalanceChange = function () {
            // let balances: VOBalance[] = this.getBalancesChange();
            // console.log(this.name+' change ' + jaxx.Utils.calculateBalance( this.getBalancesChange(true)));
            return jaxx.Utils.calculateBalance(this.getBalancesChange(true));
        };
        /*  updateBalancesChange(ar: VOBalance[]): void {
              this.balancesChangePrev = this._balancesChange;
  
              console.log(' updateBalancesChange  ');
              console.log(ar,this.getBalancesChange());
  
              this._balancesChange =    ar;// Utils.updateOldBalances(this._balancesChange, ar);
              this._saveBalancesChange()
          }*/
        // balaceChangeTotal:number;
        JaxxDatastoreLocal.prototype._saveBalancesChange = function (ar) {
            if (ar)
                this._balancesChange = ar;
            /// console.log('%c'+ this.name + 'saving new balances change length ' + this._balancesChange.length,'color:red');
            localStorage.setItem('balances-change-timestamp-' + this.name, Date.now() + '');
            localStorage.setItem('balances-change-' + this.name, JSON.stringify(this._balancesChange));
        };
        /*  addBalanceChange(balance: VOBalance): number {
         let balances: VOBalance[] = this.getBalancesChange();
         balances.push(balance);
         this.saveBalancesChange(balances);
         return balances.length;
         }

         updateBalanceChange(balance: VOBalance): void {
         let balances: VOBalance[] = this.getBalancesChange();
         jaxx.Utils.updateItemById(balances, balance);
         this.saveBalancesChange(balances);
         }*/
        JaxxDatastoreLocal.prototype.getBalanceChangeByAddress = function (address) {
            var ar = this.getBalancesChange();
            for (var i = 0, n = ar.length; i < n; i++)
                if (ar[i].id === address)
                    return ar[i];
            return null;
        };
        /*getBalanceReceive(): number {
            // console.log(this._balancesReceive)
            //console.log( this.name + ' receive '+jaxx.Utils.calculateBalance(this.getBalancesReceive(true)))

            let bals = this.getBalancesReceive(true);
            //console.log(bals)
            return jaxx.Utils.calculateBalance(bals);
        }*/
        JaxxDatastoreLocal.prototype.getBalanceRecaiveByAddress = function (address) {
            var ar = this.getBalancesReceive();
            for (var i = 0, n = ar.length; i < n; i++)
                if (ar[i].id === address)
                    return ar[i];
            return null;
        };
        /*getBalancesReceivePrev():VOBalance[] {
         return this.balancesReceivePrev.slice(0);
         }*/
        JaxxDatastoreLocal.prototype.addBalanceReceive = function (balance) {
            var addresses = this.getAddressesReceive();
            if (addresses.indexOf(balance.id) !== -1)
                return;
            if (isNaN(balance.index))
                balance.index = this._balancesReceive.length;
            this._balancesReceive.push(balance);
            this._saveBalancesReceive();
            // this.saveCurrentIndexReceive(this._balancesReceive.length);
        };
        ///set to true risky lost sequence
        JaxxDatastoreLocal.prototype.getBalancesReceive = function (orig) {
            if (orig === void 0) { orig = false; }
            // wallet.getPouchFold(COIN_BITCOIN).getDataStorageController()._db
            if (!this._balancesReceive) {
                var str = localStorage.getItem('balances-receive-' + this.name);
                //console.error(str);
                if (str) {
                    var data = JSON.parse(str);
                    if (!Array.isArray(data))
                        data = [data];
                    this._balancesReceive = data.map(function (item) {
                        return new VOBalance(item);
                    });
                }
                else
                    this._balancesReceive = [];
            }
            //console.log(this.balancesReceive1[this.balancesReceive1.length-1].balance);
            if (orig)
                return this._balancesReceive;
            var out = [];
            this._balancesReceive.forEach(function (item) {
                out.push(new VOBalance(item));
            });
            return out; //JSON.parse(JSON.stringify(this.balancesReceive1));
        };
        JaxxDatastoreLocal.prototype.getBalancesReceiveNot0 = function () {
            return this.getBalancesReceive(true).filter(function (item) {
                return item.balance !== '0';
            });
        };
        //balancesRecaiveTotal:number;
        JaxxDatastoreLocal.prototype.updateBalancesReceive = function (ar) {
            this.balancesReceivePrev = this._balancesReceive;
            //console.log(' updateBalancesReceive ');
            //console.log(ar,this.getBalancesReceive());
            var indexed = _.keyBy(ar, 'id');
            var bals = this.getBalancesReceive(true);
            var stamp = Date.now();
            bals.forEach(function (item) {
                if (indexed[item.id])
                    item.balance = indexed[item.id].balance;
                item.timestamp = stamp;
            });
            //this._balancesReceive = Utils.updateOldBalances(this._balancesReceive, ar);
            // console.log(jaxx.Utils.calculateBalance(this._balancesReceive)/1e15);
            this._saveBalancesReceive();
        };
        JaxxDatastoreLocal.prototype._saveBalancesReceive = function (ar) {
            if (ar)
                this._balancesReceive = ar;
            localStorage.setItem('balances-receive-timestamp' + this.name, Date.now() + '');
            localStorage.setItem('balances-receive-' + this.name, JSON.stringify(this._balancesReceive));
        };
        /*addBalanceReceive(balance: VOBalance): number {

         let balances: VOBalance[] = this.getBalancesReceive();
         balances.push(balance);
         this.saveBalancesReceive(balances);
         return balances.length;
         }*/
        /* getBalanceTempTransactions():number{
         let transactions:VOTransaction[] = this.getTransactionsTemp();
         return jaxx.Utils.calculateBalanceTransactions(transactions);
         }
         */
        ////////////////////////////////////////// Transactions
        /* updateTransactionsReceive(transactions: VOTransaction[]): VOTransaction[] {
         let newtransactions: VOTransaction[] = [];
         let old: VOTransaction[] = this.getTransactionsReceive();
         let indexed: Dictionary<VOTransaction> = _.keyBy(old, 'id');
         transactions.forEach(function (item) {
         if (!indexed[item.id]) {
         newtransactions.push(item);
         }
         })
         if (newtransactions.length) {
         old = old.concat(newtransactions);
         this.saveTransactionsReceive(old);
         }

         return newtransactions;
         }*/
        /////////////////////////////////////////////////// end balances   //////////////////////////////////////
        /*
         updateTransactionsChange(trs: VOTransaction[]):{newtrs: VOTransaction[],updated:VOTransaction[]} {

         let indexed = _.keyBy(trs,'id');
         let transactions:VOTransaction[] = this.getTransactionsChange();
         let out:VOTransaction[] =[];
         let updated:VOTransaction[] = [];
         let newtrs:VOTransaction[] = [];
         transactions.forEach(transaction =>{

         if(indexed[transaction.id]) {
         let tr:VOTransaction = indexed[transaction.id];
         out.push(tr);
         indexed[transaction.id] = null;
         updated.push(tr)
         }else{
         out.push(transaction);
         }
         })

         for(let str in indexed)if(indexed[str]){
         out.push(indexed[str]);
         newtrs.push(indexed[str]);

         }

         this._saveTransactionsChange(out);
         return {newtrs:newtrs,updated:updated};
         }*/
        /* private _updateTransactionsForAddress(address: string, transactionsNew: VOTransaction[], transactionsAll: VOTransaction[]): VOTransaction[] {

         let out: VOTransaction [] = _.filter(transactionsAll, function (o) {
         return o.address !== address
         });
         return out.concat(transactionsNew);
         }*/
        /* updateTransactionsForAddress(address: string, transactions: VOTransaction[], change_receive?: string): void {
         let trs: VOTransaction[];
         if (!change_receive) {
         let addressesChange: string[] = this.getAddressesChange();
         change_receive = (addressesChange.indexOf(address) === -1 ? 'receive' : 'change');
         }

         if (change_receive === 'change') {
         trs = this.getTransactionsChange();
         trs = this._updateTransactionsForAddress(address, transactions, trs);
         this.saveTransactionsChange(trs);
         } else {
         trs = this.getTransactionsReceive();
         trs = this._updateTransactionsForAddress(address, transactions, trs);
         this.saveTransactionsReceive(trs);
         }
         }*/
        JaxxDatastoreLocal.prototype.getTransactionsByAddressReceive = function (address) {
            var transactions = this.getTransactionsReceive();
            var out = [];
            transactions.forEach(function (item) {
                if (item.id === address)
                    out.push(item);
            });
            return out;
        };
        /* getTransactionsByAddressChange(address: string): VOTransaction[] {
             let transactions: VOTransaction[] = this.getTransactionsChange();
             let out: VOTransaction[] = [];
             transactions.forEach(function (item) {
                 if (item.id === address) out.push(item)
             });
             return out;
         }
 */
        JaxxDatastoreLocal.prototype.getTransactionsByAddress = function (address) {
            var out = this.getTransactionsByAddressReceive(address);
            // console.log('getTransactionsByAddressRecaive   ' + address, out);
            if (out.length)
                return out;
            //out = this.getTransactionsByAddressChange(address);
            //if (out.length) return out;
            return null;
        };
        /*
                getTransactionByIdChange(id: string): VOTransaction {
                    let transactions: VOTransaction[] = this.getTransactionsChange();
                    return this._getTransactionById(transactions, id);
                }*/
        JaxxDatastoreLocal.prototype.getTransactionByIdReceive = function (id) {
            var transactions = this.getTransactionsReceive();
            return this._getTransactionById(transactions, id);
        };
        JaxxDatastoreLocal.prototype._getTransactionById = function (transactions, id) {
            for (var i = 0, n = transactions.length; i < n; i++) {
                if (transactions[i].id === id)
                    return transactions[i];
            }
            return null;
        };
        ////////////////// transactionstemp ////////
        /*  transactionsTemp:VOTransactionTemp[];
         addTransactionsTemp(transactioins:VOTransactionTemp[]):void{
         let trs:VOTransactionTemp[] =  this.getTransactionsTemp();
         trs = trs.concat(transactioins);
         this.saveTransactionsTemp(trs);
         }

         saveTransactionsTemp(transactions:VOTransactionTemp[]):void{
         localStorage.setItem('transactions-temp-timestamp-' + this.name,Date.now()+'');
         localStorage.setItem('transactions-temp-' + this.name,JSON.stringify(this.transactionsTemp))

         }

         getTransactionsTemp():VOTransactionTemp[]{
         if(!this.transactionsTemp){
         let str:string = localStorage.getItem('transactions-temp-' + this.name);
         if(str) this.transactionsTemp = JSON.parse(str);
         else this.transactionsTemp = [];
         }
         return this.transactionsTemp;
         }*/
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        JaxxDatastoreLocal.prototype.getTransactionsAll = function () {
            return this.getTransactionsReceive(); //.concat(this.getTransactionsChange());
        };
        JaxxDatastoreLocal.prototype.getTransactionReceiveLast = function () {
            var trs = this.getTransactionsReceive();
            var l = trs.length;
            return l ? trs[trs.length - 1] : null;
        };
        JaxxDatastoreLocal.prototype.getTransactionsReceive = function () {
            if (!this.transactionsReceive) {
                this.transactionsReceive = [];
                var str = localStorage.getItem('transactions-receive-' + this.name);
                var trs = [];
                if (str) {
                    trs = JSON.parse(str).map(function (item) {
                        return new VOTransaction(item);
                    });
                }
                if (trs.length) {
                    this.transactionTimestampReceive = trs[trs.length - 1].timestamp;
                }
                this.transactionsReceive = trs;
            }
            // console.warn(this.name + '  '+ this.transactionsReceive.length);
            return this.transactionsReceive;
        };
        /*  setTransactionsReceive(trs: VOTransaction[]): void {
              if (trs.length === 0)return;
              Utils.sortByTimestamp(trs);
              this.transactionTimestampReceive = trs[trs.length - 1].timestamp;
              this.transactionsReceive = trs;
              this.saveTransactionsReceive(trs);
          }*/
        JaxxDatastoreLocal.prototype.updateTransactionsReceive = function (new_transactions) {
            var transactions = this.getTransactionsReceive();
            jaxx.Utils.updateOldTransactions(transactions, new_transactions);
            this.transactionsReceive = transactions;
            this.saveTransactionsReceive();
        };
        JaxxDatastoreLocal.prototype.setTransactions = function (trs) {
            this.transactionsReceive = trs;
            this.saveTransactionsReceive();
        };
        JaxxDatastoreLocal.prototype.addTempTransactions = function (trs) {
            this.transactionsReceive = this.transactionsReceive.concat(trs);
        };
        JaxxDatastoreLocal.prototype.updateTransactionsReceiveGetNew = function (new_transactions) {
            var transactions = this.getTransactionsReceive();
            jaxx.Utils.updateOldTransactions(transactions, new_transactions);
            var diff = jaxx.Utils.getNewTransactions(transactions, new_transactions);
            jaxx.Utils.sortByTimestamp(transactions);
            this.transactionsReceive = transactions.concat(diff);
            // let out:VOTransaction[] = Utils.filterLatest(trs,this.transactionTimestampReceive);
            if (this.transactionsReceive.length)
                this.transactionTimestampReceive = this.transactionsReceive[this.transactionsReceive.length - 1].timestamp;
            this.saveTransactionsReceive();
            return diff;
        };
        JaxxDatastoreLocal.prototype.addTransactions = function (trs) {
            if (this.transactionsReceive)
                this.transactionsReceive = this.transactionsReceive.concat(trs);
            else
                this.transactionsReceive = trs;
            this.saveTransactionsReceive();
        };
        JaxxDatastoreLocal.prototype.saveTransactionsReceive = function (transactionos) {
            // console.log(' saveTransactionsReceive  ', trs);
            if (transactionos)
                this.transactionsReceive = transactionos;
            if (this.transactionsReceive.length > this.maxTransactions) {
                this.transactionsReceive = this.transactionsReceive.slice(this.transactionsReceive.length - this.maxTransactions);
            }
            //console.warn(this.transactionsReceive.length);
            //localStorage.setItem('transactions-receive-timestamp-' + this.name, this.transactionTimestampReceive + '');
            localStorage.setItem('transactions-receive-' + this.name, JSON.stringify(this.transactionsReceive));
        };
        JaxxDatastoreLocal.prototype.saveHistoryTimestamp = function (num) {
            this.historyTimestamp = num;
            localStorage.setItem('history-timestamp-' + this.name, num + '');
        };
        JaxxDatastoreLocal.prototype.getHistoryTimestamp = function () {
            if (this.historyTimestamp === -1) {
                var num = Number(localStorage.getItem('history-timestamp-' + this.name));
                if (isNaN(num))
                    num = 0;
                this.historyTimestamp = num;
            }
            return this.historyTimestamp;
        };
        ////////////////////      Address   /////////////////////////////////////////////////////
        // private addressesReceive: string[];
        /* getLastAddressesReceive(length: number): string[] {
             return _.takeRight(this.getAddressesReceive(), length);
         }*/
        JaxxDatastoreLocal.prototype.getAddressesReceive = function () {
            var bals = this.getBalancesReceive(true);
            return jaxx.Utils.getIds(bals);
            // return this.addressesReceive;
        };
        /*saveAddressesReceive(addresses: string[]): void {
            //   console.error('saveAddressesReceive  '+ addresses.length)
            this.addressesReceive = addresses;
            // localStorage.setItem('addresses-receive-' + this.name, JSON.stringify(addresses));
        }*/
        /* saveCurrentAddressReceive(address: string): void {
             this.currentAddressReceive = address;
             localStorage.setItem('current-address-receive' + this.name, address);
         }*/
        JaxxDatastoreLocal.prototype.getCurrentAddressReceive = function () {
            var bals = this.getBalancesReceive(true);
            return bals.length ? _.last(bals).id : '';
            /*if (!this.currentAddressReceive) this.currentAddressReceive = localStorage.getItem('current-address-receive' + this.name);
            return this.currentAddressReceive;*/
        };
        /*   saveCurrentIndexReceive(ind: number): void {
               this.currentIndexReceive = ind;
               localStorage.setItem('current-index-receive-' + this.name, ind + '');
           }*/
        JaxxDatastoreLocal.prototype.getCurrentIndexReceive = function () {
            return this.getBalancesReceive(true).length - 1;
            /* if (isNaN(this.currentIndexReceive)) {
             let str: string = localStorage.getItem('current-index-receive-' + this.name);
             if (str) this.currentIndexReceive = Number(str);
             else this.currentIndexReceive = -1;
             if (isNaN(this.currentIndexReceive)) this.currentIndexReceive = -1;
             }
             return this.currentIndexReceive;
             }*/
        };
        /////////////////// addresses Change////////////////
        // private addressesChange: string[];
        JaxxDatastoreLocal.prototype.getCurrentAddressChange = function () {
            var bals = this.getBalancesChange(true);
            return bals.length ? _.last(bals).id : '';
            // if (!this.currentAddressChange) this.currentAddressChange = localStorage.getItem('current-address-change-' + this.name);
            // return this.currentAddressChange;
        };
        /* saveCurrentAddressChange(address: string): void {
      this.currentAddressChange = address;
      localStorage.setItem('current-address-change-' + this.name, address);
      }*/
        /*saveCurrentIndexChange(ind: number): void {
            this.currentIndexChange = ind;
            localStorage.setItem('current-index-change-' + this.name, ind + '');
        }*/
        JaxxDatastoreLocal.prototype.getCurrentIndexChange = function () {
            return this.getBalancesChange(true).length - 1;
            /*  if (isNaN(this.currentIndexChange)) {
                  let str: string = localStorage.getItem('current-index-change-' + this.name);
                  if (str) this.currentIndexChange = +str;
                  else this.currentIndexChange = -1;
                  if (isNaN(this.currentIndexChange)) this.currentIndexChange = -1;
              }
              return this.currentIndexChange;*/
        };
        JaxxDatastoreLocal.prototype.getLastAddressesChange = function (length) {
            return _.takeRight(this.getAddressesChange(), length);
        };
        JaxxDatastoreLocal.prototype.getAddressesChange = function () {
            //if (!this.addressesChange) {
            var bals = this.getBalancesChange(true);
            //this.addressesChange = Utils.addresseFromBalances(bals);
            //let str: string = localStorage.getItem('addresses-change-' + this.name);
            //if (str) this.addressesChange = JSON.parse(str);
            //else this.addressesChange = [];
            // }
            return jaxx.Utils.getIds(bals);
        };
        return JaxxDatastoreLocal;
    }());
    jaxx.JaxxDatastoreLocal = JaxxDatastoreLocal;
})(jaxx || (jaxx = {}));
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//# sourceMappingURL=datastore_local.js.map
///<reference path="../com/models.ts"/>
// To investigate
// https://utils.jaxx.io/api/exchange/legacy/
//
// map function
// deferred
// put it into app
var jaxx;
(function (jaxx) {
    /**
     * Sets to local storage:
     * "FiatPriceController_fiat_currencies"
     * and
     * "FiatPriceController_coin_prices"
     *
     */
    var FiatPriceController = (function () {
        function FiatPriceController() {
            var _this = this;
            this.emitter$ = $({});
            FiatPriceController.instance = this;
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_ACTIVATED, function (evt, ctr) {
                var symbol = ctr.config.symbol;
                //  console.warn(symbol);
                jaxx.Registry.jaxxUI.populateCurrencyList(symbol);
            });
            jaxx.Registry.application$.on(jaxx.Registry.GO_SLEEP, function (evt, ctr) {
                _this.stopInterval();
            });
            jaxx.Registry.application$.on(jaxx.Registry.WAKE_UP, function (evt, ctr) {
                _this.startInterval();
            });
            //this.last_update_from_server = Number(localStorage.getItem('FiatPriceController_last_update'));
        }
        /// stop autoupdate fiat price
        FiatPriceController.prototype.stopInterval = function () {
            clearInterval(this.timer);
        };
        //starts autoupdate fiat
        FiatPriceController.prototype.startInterval = function () {
            var _this = this;
            this.checkData();
            clearInterval(this.timer);
            var interval = this.config.fiatUpdateIntervalSec;
            // if update interval not set  setting minimum 30 sec
            if (!interval || interval < 30)
                interval = 30;
            this.timer = setInterval(function () { return _this.loadData(); }, interval * 1000);
        };
        FiatPriceController.prototype.init = function (config) {
            var _this = this;
            this.config = config['fiat'];
            //this.coin_cfg = config;
            setTimeout(function () { return _this.startInterval(); }, 5000);
        };
        FiatPriceController.prototype.setActiveFiatCurrencies = function (currencies) {
            this.activeCurrencies = currencies;
            localStorage.setItem('currencies_selected', JSON.stringify(currencies));
            jaxx.Registry.application$.trigger(jaxx.Registry.ON_ACTIVE_CURRENCIES_CHANGED, { currencies: currencies });
        };
        FiatPriceController.prototype.getActiveFiatCurrencies = function () {
            if (!this.activeCurrencies)
                this.activeCurrencies = JSON.parse(localStorage.getItem('currencies_selected') || '["USD"]');
            return this.activeCurrencies;
        };
        FiatPriceController.prototype.getActiveFiatCurrency = function () {
            if (!this.currentFiat)
                this.currentFiat = localStorage.getItem('fiat') || 'USD';
            return this.currentFiat;
        };
        /**
         * @param {string} newCurrencyCode - The currency code to be stored, for example "USD", "CAD", "EUR"
         */
        FiatPriceController.prototype.setActiveFiatCurrency = function (newCurrencyCode) {
            if (this.currentFiat === newCurrencyCode)
                return;
            this.currentFiat = newCurrencyCode;
            this.emitter$.triggerHandler(jaxx.Registry.ON_FIAT_MAIN_CURRENCY_CHANGE, newCurrencyCode);
            jaxx.Registry.application$.trigger(jaxx.Registry.ON_FIAT_MAIN_CURRENCY_CHANGE, newCurrencyCode);
        };
        /**
         * Converts the passed coin amount to the user active currency (the currency the user selects as main)
         * in a string ready for display.
         * Example input: ("1", "BTC") => "US$4,105"
         *
         * @param coinAmount - The amount of coin to be converted.
         * @param coinSymbol - The 3 letter symbol of the coin
         */
        FiatPriceController.coinToActiveDisplayFiat = function (coinAmount, coinSymbol) {
            var errorFiatValue = '--.--';
            var retVal = '';
            var activeFiatCurrencyCode = FiatPriceController.instance.getActiveFiatCurrency();
            var convertedAmount = FiatPriceController.coinToFiat(coinAmount, coinSymbol, activeFiatCurrencyCode);
            if (convertedAmount !== null) {
                convertedAmount = jaxx.Formatters.balanceForDisplay(convertedAmount, 2);
                convertedAmount = jaxx.Formatters.formatFinancialNumber(convertedAmount);
                retVal = FiatPriceController.prependFiatSymbolToString(activeFiatCurrencyCode, convertedAmount);
            }
            else {
                retVal = errorFiatValue;
            }
            return retVal;
        };
        FiatPriceController.fiatToCoin = function (fiat_value, fiat_code, symbol) {
            //   console.log(arguments);
            var data = FiatPriceController.instance.getData();
            var fiatValue = +fiat_value;
            if (isNaN(fiatValue)) {
                console.error('fiat_value NaN' + fiat_value);
                return '0';
            }
            var fiatPrice = data.fiat[fiat_code];
            if (!fiatPrice) {
                console.error(fiat_code + ' not available');
                console.log(Object.keys(data.fiat));
                return '0';
            }
            var coinPrice = data.coins[symbol];
            if (!coinPrice) {
                console.error(symbol + ' no price ');
                console.log(Object.keys(data.coins));
                return '0';
            }
            var out = fiatValue / coinPrice;
            return out.toFixed(8);
        };
        /**
         * Converts the given coins into the fiat currency specified
         *
         * @param {string} src_coin_value - The number value of the source coin to be converted
         * @param {string} src_coin_symbol - The type of coin given in src_coin_value. For example: 'BTC', 'LTC', 'ETH
         * @param {string} dst_fiat_code - The destination fiat code such as 'USD', 'EUR', 'CAD'
         *
         * @return {number} - Returns the converted value or 0 if the fiat currency is not supported
         *
         * TODO: src_coin_value should be a string
         */
        FiatPriceController.coinToFiat = function (coin_value, symbol, fiatCode) {
            var data = FiatPriceController.instance.getData();
            var coinValue = +coin_value;
            if (isNaN(coinValue))
                throw new Error(coin_value);
            var fiatPrice = data.fiat[fiatCode];
            if (!fiatPrice) {
                console.error(fiatCode + ' not available');
                console.log(Object.keys(data.fiat));
                return '0';
            }
            var coinPrice = data.coins[symbol];
            if (!coinPrice) {
                console.error(symbol + ' no price ');
                return '0';
            }
            var out = coinValue * fiatPrice * coinPrice;
            // console.log(out);
            return out.toFixed(2);
        };
        FiatPriceController.makeDisplayFiat = function (fiat_amount, fiat_code) {
            if (typeof fiat_amount === 'number') {
                fiat_amount = String(fiat_amount);
            }
            var displayString = '--.--';
            var currentCryptoController = jaxx.Registry.getCurrentCryptoController();
            var balance = currentCryptoController.getBalance();
            var currentCoinDisplayBalance = currentCryptoController.getBalanceDisplay();
            // jaxx.Registry.getCurrentCryptoController().getBalanceDisplay()
            // looks like the conversion gone wrong (maybe a provider issue)
            if (fiat_amount == "0" && currentCoinDisplayBalance != '0') {
                return '--.--';
            }
            if (fiat_amount != null) {
                var prefix = FiatPriceController.getFiatUnitPrefix(fiat_code);
                displayString = prefix + jaxx.Formatters.balanceForDisplay(fiat_amount, 2);
                //displayString = prefix + String(Math.round(fiat_amount * 100) / 100);
            }
            return displayString;
        };
        FiatPriceController.prependFiatSymbolToString = function (fiat_code, numberStr) {
            return FiatPriceController.fiatDictionary[fiat_code].prefix + numberStr;
        };
        FiatPriceController.prependCoinSymbolLetterToString = function (coinThreeLetterCode, amount) {
            var coinEntry = FiatPriceController.coinSymbolDirectory[coinThreeLetterCode.toUpperCase()];
            var prefix = "";
            if (coinEntry === undefined) {
                prefix = coinThreeLetterCode;
            }
            else {
                prefix = coinEntry.symbol;
            }
            var retVal = prefix + amount;
            return retVal;
        };
        FiatPriceController.displayFiatValue = function (fiat_amount) {
            var displayString = '--.--';
            var currentCryptoController = jaxx.Registry.getCurrentCryptoController();
            var balance = currentCryptoController.getBalance();
            var currentCoinDisplayBalance = currentCryptoController.getBalanceDisplay(balance);
            // jaxx.Registry.getCurrentCryptoController().getBalanceDisplay()
            // looks like the conversion gone wrong (maybe a provider issue)
            if (fiat_amount == 0 && Number(currentCoinDisplayBalance) != 0) {
                return '--.--';
            }
            if (fiat_amount != null && !isNaN(fiat_amount)) {
                // let prefix: string = FiatPriceController.getFiatUnitPrefix(fiat_code);
                displayString = jaxx.Formatters.balanceForDisplay(String(fiat_amount), 2);
                //displayString = prefix + String(Math.round(fiat_amount * 100) / 100);
            }
            return displayString;
        };
        FiatPriceController.listAllAvailableCurrencies = function () {
            return JSON.parse(localStorage.getItem('FiatPriceController_fiat_currencies'));
        };
        FiatPriceController.listAllAvailableCoins = function () {
            return JSON.parse(localStorage.getItem('FiatPriceController_coin_prices'));
        };
        // function  converts values received from string to numbers
        FiatPriceController.prototype.mapData = function (data) {
            var setNumbers = function (item) { for (var str in item)
                item[str] = +item[str]; };
            setNumbers(data.coins);
            setNumbers(data.fiat);
            data.timestamp = moment(data.createdAt).valueOf();
        };
        FiatPriceController.prototype.getFiatByCode = function (code) {
            return this.getFiat()[code];
        };
        FiatPriceController.prototype.getFiat = function () {
            return this.getData().fiat;
        };
        FiatPriceController.prototype.getCoins = function () {
            return this.getData().coins;
        };
        // if fiat data older then 5 min download new data
        FiatPriceController.prototype.checkData = function () {
            var data = this.getData();
            if (isNaN(data.timestamp) || !data.timestamp || (Date.now() - data.timestamp) > this.config.fiatUpdateIntervalSec * 1000) {
                this.loadData();
            }
            else {
                console.log(' diff ' + (Date.now() - data.timestamp) + ' need ' + this.config.fiatUpdateIntervalSec * 1000);
            }
        };
        FiatPriceController.prototype.getData = function () {
            if (!this.rawData) {
                var str = localStorage.getItem('currency-fiat-data');
                if (str) {
                    this.rawData = JSON.parse(str);
                }
                else
                    this.rawData = { coins: {}, fiat: {}, timestamp: 0, ver: '0' };
            }
            return this.rawData;
        };
        // loads fiat data from server
        FiatPriceController.prototype.loadData = function () {
            var _this = this;
            var url = this.config.aggregatedDataUrl;
            if (!url || url.length < 10) {
                console.error(' fiat configuration  "aggregatedDataUrl"  url not provided ');
                return;
            }
            $.getJSON(url).done(function (res) {
                if (res.fiat) {
                    _this.mapData(res);
                    console.log(' new data fiat ' + res.createdAt);
                    _this.rawData = res;
                    localStorage.setItem('currency-fiat-data', JSON.stringify(res));
                    _this.emitter$.triggerHandler(FiatPriceController.ON_UPDATED, res);
                    // console.log(res);
                }
            }).fail(function (err) {
                console.error(err);
            });
        };
        // used by UI to get prefix displayed in front of fiat value taken form fiatDictionary
        FiatPriceController.getFiatUnitPrefix = function (fiatUnit) {
            if (!fiatUnit)
                fiatUnit = FiatPriceController.instance.getActiveFiatCurrency();
            var fiatCurrency = FiatPriceController.fiatDictionary[fiatUnit];
            if (fiatCurrency === undefined) {
                return "XX$"; // Returns this when the currency symbol is not in the dictionary.
            }
            else {
                return fiatCurrency.prefix;
            }
        };
        return FiatPriceController;
    }());
    FiatPriceController.ON_UPDATED = 'ON_UPDATED';
    FiatPriceController.fiatDictionary = {
        "ARS": { "prefix": "AR$", "name": "Argentina Pesos" },
        "AUD": { "prefix": "AU$", "name": "Australian Dollar" },
        "BRL": { "prefix": "R$", "name": "Brazilian Real" },
        "CAD": { "prefix": "CA$", "name": "Canadian Dollar" },
        "CHF": { "prefix": "\u20A3", "name": "Swiss Franc" },
        "CLP": { "prefix": "CL$", "name": "Chilean Peso" },
        "CNY": { "prefix": "\u00A5", "name": "Chinese Yuan" },
        "CZK": { "prefix": "\u004b", "name": "Czech Republic Koruna" },
        "DKK": { "prefix": "kr", "name": "Danish Krona" },
        "EUR": { "prefix": "\u20AC", "name": "Euro" }
        //@note: @todo: @here: something was an issue here.. dan figures the prefix.
        /*,"FRA" : {"prefix" : "\u20A3", "name" : "French Franc"}*/
        ,
        "GBP": { "prefix": "\u00A3", "name": "British Pound" },
        "HKD": { "prefix": "HK$", "name": "Hong Kong Dollar" },
        "HUF": { "prefix": "\u0046", "name": "Hungarian Forint" },
        "IDR": { "prefix": "Rp", "name": "Indonesian Rupiah" },
        "ILS": { "prefix": "\u20AA", "name": "Israeli New Shekel" },
        "INR": { "prefix": "\u20B9", "name": "Indian Rupee" },
        "ISK": { "prefix": "kr", "name": "Icelandik Kroner" },
        "JPY": { "prefix": "\u00A5", "name": "Japanese Yen" },
        "KRW": { "prefix": "\u20A9", "name": "South Korean Won" },
        "MXN": { "prefix": "MX$", "name": "Mexican Peso" },
        "MYR": { "prefix": 'RM', "name": "Malaysian Myr" },
        "NOK": { "prefix": "kr", "name": "Norwegian Kroner" },
        "NZD": { "prefix": "NZ$", "name": "New Zealand Dollar" },
        "PHP": { "prefix": "\u20B1", "name": "Phillipine Peso" },
        "PKR": { "prefix": "\u20A8", "name": "Pakistani Rupee" },
        "PLN": { "prefix": "z\u0142", "name": "Polish Zlotty" },
        "RON": { "prefix": "RON", "name": "Romanian Leu" },
        "RUB": { "prefix": "\u20BD", "name": "Russian Ruble" },
        "SEK": { "prefix": "kr", "name": "Swedish Krona" },
        "SGD": { "prefix": "SG$", "name": "Singapore Dollar" },
        "THB": { "prefix": "\u0e3f", "name": "Thailand Baht" },
        "TRY": { "prefix": "t", "name": "Turkey Lira" },
        "TWD": { "prefix": "NT$", "name": "New Taiwan Dollar" },
        "USD": { "prefix": "US$", "name": "United States Dollar" },
        "ZAR": { "prefix": "\u0052", "name": "South African Rand" }
    };
    FiatPriceController.coinSymbolDirectory = {
        "BTC": { symbol: '\u0E3F' },
        "ETC": { symbol: '\u039E' },
        "ETH": { symbol: '\u039E' },
        "DASH": { symbol: '\u2145' },
        "DGE": { symbol: '\u00d0' },
        "DOGE": { symbol: '\u00d0' },
        "LSK": { symbol: '\u2C60' },
        "LTC": { symbol: '\u0141' },
        "RSK": { symbol: '\uc98c' },
        "ZEC": { symbol: '\u24E9' },
        "REP": { symbol: '\u024C' },
        "BCAP": { symbol: '\u024C' },
        "CVC": { symbol: '\u024C' },
        "DGX": { symbol: '\u024C' },
        "GNO": { symbol: '\u024C' },
        "GNT": { symbol: '\u024C' },
        "ICN": { symbol: '\u024C' },
        "SNGLS": { symbol: '\u024C' }
        //"DEFAULT": {symbol: '\u0966'}
        //"DEFAULT": {symbol: '\u1CC3'}
    };
    jaxx.FiatPriceController = FiatPriceController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=fiat-price-controller.js.map
var jaxx;
(function (jaxx) {
    var NavigationToolMenuController = (function () {
        function NavigationToolMenuController() {
            var _this = this;
            this.active_fiat_currency_code = "USD"; // this will have to be replaced by what is selected in the balance view
            this.fiat_price_controller = jaxx.FiatPriceController.instance;
            this.$view = $('#menu');
            this.$view.load('js/app/navigation-tool-menu/navigation-tool-menu.html', "", function () {
                setTimeout(function () {
                    _this.init();
                }, 1000);
            });
        }
        NavigationToolMenuController.prototype.init = function () {
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.MODULE_REDY, this);
            //Registry.application$.on(Registry.ON_COIN_ACTIVATED, this.onCoinChange.bind(this));
            jaxx.Registry.application$.on(jaxx.Registry.ON_FIAT_MAIN_CURRENCY_CHANGE, this.updateFiatValueIfCurrencyActive.bind(this));
            this.$currency_tab = $('#CurrenciesMenuTab');
            this.$coin_exchange_value = $('.mainMenuCurrencies span.exchangeRate');
            this.$coin_symbol = $('.mainMenuCurrencies span.exchangeRateAbbreviatedUnit');
            this.attachClickEvents();
            this.$currency_tab.click(this.updateUITopFiatValueOfCoinToActiveFiatCurrency.bind(this));
        };
        NavigationToolMenuController.prototype.attachClickEvents = function () {
            var elements = this.$view.find(".scriptAction").not(".scrollHeaderContainer .rightArrow").not(".scrollHeaderContainer .leftArrow"); // Exclude carousel arrows
            this.attachClickEventForScriptAction(elements);
        };
        NavigationToolMenuController.prototype.attachClickEventForScriptAction = function (jquerySelector) {
            $(jquerySelector).off('click');
            $(jquerySelector).click(function (event) {
                scriptAction(event);
            });
        };
        // Called by JaxxUI.prototype.openMainMenu() from jaxx_ui.js
        // and by ON_FIAT_MAIN_CURRENCY_CHANGE event
        NavigationToolMenuController.prototype.updateFiatValueIfCurrencyActive = function () {
            if (this.$currency_tab.hasClass('cssSelected')) {
                this.updateUITopFiatValueOfCoinToActiveFiatCurrency();
            }
        };
        /** Updates the Fiat value of 1 coin unit shown in the CURRENCY tools menu */
        NavigationToolMenuController.prototype.updateUITopFiatValueOfCoinToActiveFiatCurrency = function () {
            var coin_fiat_value = "0";
            var coin_symbol = '';
            var active_crypto = jaxx.Registry.getCurrentCryptoController();
            if (active_crypto) {
                coin_symbol = active_crypto.symbol;
            }
            var active_fiat_currency_code = jaxx.Registry.application.fiatPriceController.getActiveFiatCurrency();
            var prefix = jaxx.FiatPriceController.getFiatUnitPrefix(active_fiat_currency_code);
            coin_fiat_value = jaxx.FiatPriceController.coinToFiat("1", coin_symbol, active_fiat_currency_code);
            if (coin_fiat_value == null) {
                coin_fiat_value = "0";
            }
            coin_fiat_value = jaxx.Formatters.balanceForDisplay(coin_fiat_value, 2);
            this.$coin_symbol.text(coin_symbol);
            this.$coin_exchange_value.text(prefix + String(coin_fiat_value));
        };
        /** Writes the config file information to the Hamburger menu DOM (can be seen in Menu > About) */
        NavigationToolMenuController.prototype.updateUIConfigInformation = function (configVer, updateTimeStamp, isUsingLocalConfigFile) {
            var template = "v{{configVersion}} retrieved: {{updateDate}} {{updateTime}}";
            var $configInfoDomElm = $('#ConfigInfo');
            var uiConfigVersion = "N/A";
            var uiUpdateTime = "";
            var uiUpdateDate = "pending";
            if (configVer && configVer['length'] && configVer.length > 0) {
                uiConfigVersion = configVer;
            }
            if (updateTimeStamp && isNaN(updateTimeStamp) === false && updateTimeStamp !== 0) {
                uiUpdateDate = moment(Number(updateTimeStamp)).format('MMM DD YYYY');
                uiUpdateTime = moment(Number(updateTimeStamp)).format('hh:mm A');
            }
            if (isUsingLocalConfigFile) {
                template = template.replace('{{updateDate}} {{updateTime}}', 'using local file');
            }
            var renderedHtml = template.replace('{{configVersion}}', configVer)
                .replace('{{updateDate}}', uiUpdateDate)
                .replace('{{updateTime}}', uiUpdateTime);
            $configInfoDomElm.html(renderedHtml);
        };
        return NavigationToolMenuController;
    }());
    jaxx.NavigationToolMenuController = NavigationToolMenuController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=navigation-tool-menu-controller.js.map
var jaxx;
(function (jaxx) {
    var TransactionsView = (function () {
        function TransactionsView() {
            var _this = this;
            this.dateFormat = "MMM DD YYYY";
            this.timeFormat = 'hh:mm A';
            // this array is populated at the UI layer when a transaction is successfully sent with the details of the sent transaction        
            // the addition of txes happens when the Sent Transaction controller 
            // triggers the ON_TRANSACTION_SENT event
            // in the end, these temporary TXes are inserted into the UI tx history list until the mempool transaction is downloaded
            this.tempTxes = []; // these are not saved anywhere, if the app is restarted the temp tx goes away - its purpose is to fill in until the real data comes form the backend to improve UX
            this.counter = 0;
            $('head').append('<link rel="stylesheet" href="js/app/transaction-history/transactions-history.css" type="text/css" />');
            this.$view = $('#TransactionsView');
            this.$view.load('js/app/transaction-history/transactions-history.html', function () {
                //console.warn(arguments);
                setTimeout(function () { return _this.init(); }, 50);
            });
            $.get('js/app/transaction-history/transaction-history-not-available.html').done(function (res) {
                _this.tx_history_not_avail_template = res;
            });
            $.get('js/app/transaction-history/empty-transaction-history.html').done(function (res) {
                _this.no_transactions_template = res;
            });
            $.get('js/app/transaction-history/transactions-history-row.html').done(function (res) {
                _this.template = res;
            });
        }
        TransactionsView.prototype.init = function () {
            var _this = this;
            this.$list = $('#TransactionsList');
            this.$header = $('#TransactionsHeader');
            this.$container = $('#TransactionsListContainer');
            this.initEvents();
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.MODULE_REDY, this);
            jaxx.Registry.application$.on(jaxx.Registry.ON_BALANCE_RENDER, function () {
                _this.render();
            });
            jaxx.Registry.application$.on(jaxx.Registry.UI_CONFIRM_TRANSACTION_CLOSED, function () {
                _this.render();
            });
            jaxx.Registry.application$.on(jaxx.Registry.HIDE_INIT_WALLET, function () {
                _this.populateTransactionHistory();
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_START, function () {
                // whenever it is initializing wallet clear previous coin/token's history
                _this.clear();
            });
            // to avoid unpredictable durations until the server registers the transaction the user just sent and it gets displayed in the TX history,
            // we temporarily store their sent transaction based on the data the Send Transaction controller submitted
            // and triggered through this ON_SEND_TRANSACTION event below
            jaxx.Registry.application$.on(jaxx.Registry.ON_SEND_TRANSACTION, function (ev, sent_tx) {
                // if the coin controller doesn't support TX history skip the whole temporary transaction process
                var transactionCoinController = jaxx.Registry.getCryptoControllerBySymbol(sent_tx.symbol);
                if (!transactionCoinController.supportsTransactionHistory()) {
                    return;
                }
                // Convert from VOSentTransaction to VOTransaction below:
                var transactionFormat;
                // VOSendTransactions are formatted differently for ETH and ERC20 tokens than for Bitcoin derived coins (ZEC, DASH, etc)
                // we handle both cases accordingly
                if (sent_tx.transactionsETH) {
                    var txDdata = sent_tx.transactionsETH[0];
                    transactionFormat = new VOTransaction({
                        txid: txDdata.txid,
                        id: txDdata.txid,
                        confirmations: 0,
                        timestamp: undefined,
                        address: txDdata.addressTo,
                        incoming: 0,
                        from: txDdata.addressFrom,
                        to: txDdata.addressTo,
                        value: sent_tx.amountInt,
                        miningFee: String(sent_tx.miningFeeDecimal),
                        symbol: sent_tx.symbol,
                    });
                }
                else {
                    transactionFormat = new VOTransaction({
                        txid: sent_tx.txid,
                        id: sent_tx.txid,
                        confirmations: 0,
                        timestamp: undefined,
                        address: sent_tx.addressTo,
                        incoming: 0,
                        from: sent_tx.inputs[0].address,
                        to: sent_tx.addressTo,
                        tos: sent_tx.outputs.map(function (output) {
                            return output.address;
                        }),
                        value: sent_tx.amountDecimalDisplay,
                        miningFee: String(sent_tx.miningFeeDecimal),
                        symbol: sent_tx.symbol,
                        values: sent_tx.outputs.map(function (output) { return jaxx.MATH.satoshiToBtc(output.amount); })
                    });
                }
                transactionFormat = _this.currentController.processTransactionForDisplay(transactionFormat);
                // register our temporary transaction
                _this.tempTxes.push(transactionFormat);
                // because this event might come after our TX history was already rendered
                // we order another render to ensure display in all situations
                setTimeout(function () {
                    _this.render();
                }, 500);
            });
            // Received from CoinControllerBase when too many unsuccessful attempts where made to download a newly sent transaction
            jaxx.Registry.application$.on(jaxx.Registry.ON_TRANSACTION_DROPPED, function (ev, dropped_txid) {
                _this.tempTxes.forEach(function (val, index) {
                    if (val.id == dropped_txid) {
                        _this.tempTxes.splice(index, 1);
                        _this.$list.remove('#' + dropped_txid);
                    }
                });
            });
        };
        /** Retrieves the transaction history from the current active controller, merges the list with temporary transactions (the temp txes are removed if they are present in the controller)
         * and calls the rendering functions to display the data in UI.
         */
        TransactionsView.prototype.populateTransactionHistory = function () {
            var _this = this;
            var ctr = jaxx.Registry.getCurrentCryptoController();
            if (!ctr) {
                console.warn(' no current controller ');
                return;
            }
            this.currentController = ctr;
            var obj = ctr.getTransactionsDisplay();
            // find and remove and temporary transactions that are also present in the saved transactions (the ones stored in localStorage)
            this.tempTxes = this.tempTxes.filter(function (tempTx) {
                return obj.transactions.filter(function (savedTx) { return savedTx.id == tempTx.id; }).length == 0;
            });
            // filter temp txes by coin symbol to make sure no TXes leak from other coins/wallets
            var filteredTempTxes = this.tempTxes.filter(function (tx) { return tx.symbol == _this.currentController.symbol; });
            // prepend all filtered temporary to the transaction list
            filteredTempTxes.forEach(function (txItem) {
                obj.transactions.unshift(txItem);
            });
            //obj.transactions = obj.transactions.concat(filteredTempTxes);
            this.displayTransactions(obj);
        };
        TransactionsView.prototype.render = function () {
            var isMobile = PlatformUtils.mobileCheck();
            var isExtension = PlatformUtils.extensionCheck();
            var transactionHeight;
            var transactionHistoryHeightMobileDeviation = 1.2;
            var isNotIPad = !(PlatformUtils.mobileIpadCheck());
            if ((isMobile || isExtension) && isNotIPad) {
                // Transaction History height is equal to the whole document minus the top menu portion
                // and then adjusted by 120% to  account for the view-port difference on mobile being set to ~80%
                transactionHeight = ($(document).height() - $('.landscapeLeft').height()) * transactionHistoryHeightMobileDeviation;
            }
            else {
                transactionHeight = "100%";
            }
            this.$view.height(transactionHeight);
            if (!jaxx.Registry.application.isWalletInitializing) {
                this.populateTransactionHistory();
            }
        };
        TransactionsView.prototype.reset = function () {
            this.$list.find('.selected').removeClass('selected');
            this.$list.find('.transactionDetails').show('fast');
        };
        TransactionsView.prototype.initEvents = function () {
            var _this = this;
            this.$list.on('click', '.cssTransactionHistoryRow', function (evt) {
                var el = $(evt.currentTarget);
                if (el.hasClass('selected')) {
                    el.removeClass('selected');
                }
                else {
                    el.addClass('selected');
                }
            });
            // Touch versus click glitch for hover CSS class
            this.$list.on('touchstart', '.cssTransactionHistoryRow', function (e) {
                $(e.currentTarget).find('.cssTransactionOverview').css('background-color', '#0D0D0D');
            });
            /**
             * Handles the click on the "copy" graphic inside the TX expanded view
             */
            this.$list.on('click', '.cssImageCopy', function (e) {
                var value_to_be_copied = e.target.getAttribute('data-jaxx-copy-value');
                var copySuccessful = false;
                if (window.native && window.native.copyToClipboard) {
                    try {
                        window.native.copyToClipboard(value_to_be_copied);
                        copySuccessful = true;
                    }
                    catch (e) {
                        copySuccessful = false;
                    }
                }
                else {
                    var temp_textarea = document.getElementById('clipboard'); // We have a global text area ready to use for copying
                    temp_textarea.value = value_to_be_copied;
                    temp_textarea.select();
                    copySuccessful = document.execCommand('copy');
                }
                if (copySuccessful) {
                    Navigation.flashBanner('Copied to clipboard', 2, 'success', { close: false });
                }
                else {
                    Navigation.flashBanner("Couldn't copy", 2, 'error', { close: false });
                }
            });
            //This is not being called when coin is switched in the navigation
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_ACTIVATED, function (evt, ctr) {
                _this.currentSymbol = ctr.symbol;
                _this.currentController = ctr;
                // this.render();
                _this.$container.scrollTop(0);
            });
            // need to check where this is getting the value from
            jaxx.Registry.application$.on(jaxx.Registry.ON_TRANSACTIONS_CHANGED, function (evt, ctr) {
                var current = jaxx.Registry.getCurrentCryptoController();
                if (current && ctr.symbol === current.symbol)
                    _this.render();
            });
            jaxx.Registry.transactions$.on(jaxx.Registry.ON_TRANSACTIONS_CONFIRMATIONS, function (evt, data) {
                //  console.log(Registry.ON_TRANSACTIONS_CONFIRMATIONS, data);
                var current = jaxx.Registry.getCurrentCryptoController();
                if (data.symbol !== current.symbol)
                    return;
                _this.updateConfirmations(data.transactions);
            });
            jaxx.Registry.transactions$.on(jaxx.Registry.ON_TRANSACTION_INBLOCK, function (evt, data) {
                console.log(jaxx.Registry.ON_TRANSACTION_INBLOCK, data);
                var current = jaxx.Registry.getCurrentCryptoController();
                if (data.symbol !== current.symbol)
                    return;
                _this.updateConfirmations(data.transactions);
            });
        };
        TransactionsView.prototype.clear = function () {
            if (this.$list.html)
                this.$list.html('');
        };
        TransactionsView.prototype.updateConfirmations = function (transactions) {
            var _this = this;
            var max = this.currentController.config.trsConfirmations || 6;
            transactions.forEach(function (item) {
                var processedTx;
                var $tr = $('#' + item.id);
                // if we don't have these properties the TX is in raw format
                if (item.incoming === undefined || item.displayAddress === undefined) {
                    processedTx = _this.currentController.processTransactionForDisplay(item);
                }
                else {
                    processedTx = item;
                }
                var confirmations = '';
                if (isNaN(processedTx.confirmations) || processedTx.confirmations === null) {
                    confirmations = "0";
                }
                else if (processedTx.confirmations < max) {
                    confirmations = String(processedTx.confirmations);
                }
                else {
                    confirmations = "+" + max;
                }
                $tr.find('.confirmations').first().text(confirmations);
                var status;
                if (!processedTx.confirmations) {
                    status = 'Unconfirmed';
                }
                else if (!processedTx.incoming) {
                    status = "Sent To - " + processedTx.displayAddress;
                }
                else {
                    status = 'Confirmed';
                }
                $tr.find('.tr-status').first().text(status);
                $tr.find('.blockHeight').first().text('#' + processedTx.block);
                if (!(isNaN(processedTx.timestamp) || processedTx.timestamp === null)) {
                    $tr.find('.date').first().text(moment.unix(Number(processedTx.timestamp)).format('MMM DD YYYY'));
                    $tr.find('.time').first().text(moment.unix(Number(processedTx.timestamp)).format('hh:mm A'));
                }
            });
        };
        TransactionsView.externalLink = function (linkAddress, displayText) {
            var stringVersion;
            // if(!Registry.mobile && !Registry.chromeExtension && !Registry.desktop) {
            //     stringVersion = "<a href=\"" + linkAddress + "\" target=\"_blank\">" + displayText + "</a>";
            // } else if(Registry.chromeExtension) {
            //     stringVersion = "<a href=\"" + linkAddress + "\" target=\"_blank\">" + displayText + "</a>";
            // } else if(Registry.android || Registry.iPhone || Registry.desktop) {
            if (jaxx.Registry.chromeExtension) {
                stringVersion = "<a href=\"" + linkAddress + "\" target=\"_blank\">" + displayText + "</a>";
            }
            else {
                stringVersion = "<a href='#' onclick=\"Navigation.tryToOpenExternalLink('" + linkAddress + "')\">" + displayText + "</a>";
            }
            // } else {
            //     stringVersion = "<a href=\"" + linkAddress + "\" target=\"_blank\">" + displayText + "</a>";
            // }
            return stringVersion;
        };
        TransactionsView.formatRow = function (tr, template, symbol, maxConfirmations, blockexplorer_url) {
            var displayTime;
            var displayDate;
            var displayAddress;
            if (tr.timestamp) {
                var timestamp = moment.unix(Number(tr.timestamp));
                displayDate = timestamp.format('MMM DD YYYY');
                displayTime = timestamp.format('hh:mm A');
            }
            else {
                displayDate = 'Pending confirmation';
                displayTime = '';
            }
            var confirmations;
            var blockNo = '#';
            var url = blockexplorer_url.replace('{{txid}}', tr.id);
            var tx_blockexplorer_url = TransactionsView.externalLink(url, tr.displayTxid);
            var signPrefix = tr.incoming ? '+' : '-';
            if (+tr.displayValue === 0)
                signPrefix = '';
            var status;
            if (tr.block && tr.block != -1) {
                blockNo += String(tr.block);
            }
            else {
                blockNo = 'None';
            }
            if (!tr.confirmations) {
                status = 'Unconfirmed';
            }
            else if (!tr.incoming) {
                status = "Sent To - " + tr.displayAddress;
            }
            else {
                status = 'Confirmed';
            }
            if (isNaN(tr.confirmations) || tr.confirmations == null || tr.confirmations === undefined) {
                confirmations = "0";
            }
            else if (tr.confirmations < maxConfirmations) {
                confirmations = String(tr.confirmations);
            }
            else {
                confirmations = "+" + maxConfirmations;
            }
            return template.replace('{{addressTo}}', tr.displayAddress)
                .replace('{{date}}', displayDate)
                .replace('{{time}}', displayTime)
                .replace('{{amount}}', signPrefix + jaxx.MATH.stripTrailingZeroes(tr.displayValue) + ' ' + symbol)
                .replace('{{block}}', blockNo)
                .replace('{{status}}', status)
                .replace('{{confirmations}}', confirmations)
                .replace('{{displayAddress}}', tr.displayAddress)
                .replace('{{miningFee}}', tr.displayMiningFee)
                .replace('{{from_to}}', tr.incoming ? 'Received From' : 'Send To')
                .replace('{{address}}', tr.address)
                .replace('{{block_tx_url}}', tx_blockexplorer_url)
                .replace('{{txid}}', tr.id);
        };
        TransactionsView.prototype.displayTransactions = function (evt) {
            var symbol = evt.symbol;
            var ctr = jaxx.Registry.getCryptoControllerBySymbol(symbol);
            var trs = evt.transactions;
            var blockexplorer_url = evt.blockexplorer_url;
            var trsConfirmations = evt.trsConfirmations || 6;
            var tpl = this.template;
            var html = '';
            if (ctr.supportsTransactionHistory() == false) {
                html = this.tx_history_not_avail_template;
            }
            else if (!!trs && trs.length) {
                trs.forEach(function (item) {
                    html += TransactionsView.formatRow(item, tpl, symbol, trsConfirmations, blockexplorer_url);
                });
            }
            else
                html = this.no_transactions_template;
            this.$list.html(html);
        };
        return TransactionsView;
    }());
    jaxx.TransactionsView = TransactionsView;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=transaction-history-view.js.map
var jaxx;
(function (jaxx) {
    var TransferPaperWalletMenu = (function () {
        /*
        * Dynamically adds the html to index.html with appropriate content and attaches click events (scriptAction) to
        * appropriate dom elements.
        * */
        function TransferPaperWalletMenu() {
            var _this = this;
            this.$view = $('#paperWalletList').first();
            this.$view.load('js/app/transfer-paper-wallet/paper-wallet-menu.html', null, function (res) {
                setTimeout(function () {
                    _this.addPaperWallets();
                }, 1000);
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_SATUS_CHANGED, function (evt, name, lbl) {
                _this.reset();
            });
        }
        /*
        * Clears out the template.
        * @method clearPaperWallet
        * */
        TransferPaperWalletMenu.prototype.clearPaperWallet = function () {
            this.$view.find('.cssScrollableMenuList').empty();
        };
        /*
        * Resets the paper wallet menu view
        * @method reset
        * */
        TransferPaperWalletMenu.prototype.reset = function () {
            var _this = this;
            setTimeout(function () {
                _this.clearPaperWallet();
                _this.addPaperWallets();
            }, 100);
        };
        /*
        * Attaches click event to scriptAction events for the dynamically added content.
        * @method attachClickEvents
        * */
        TransferPaperWalletMenu.prototype.attachClickEvents = function () {
            var elements = this.$view.find(".scriptAction").not(".scrollHeaderContainer .rightArrow").not(".scrollHeaderContainer .leftArrow"); // Exclude carousel arrows
            this.attachClickEventForScriptAction(elements);
        };
        /*
        * Attaches click events for any dom elements with the script action tag that we added dynamically.
        * @method attachClickEventForScriptAction
        * */
        TransferPaperWalletMenu.prototype.attachClickEventForScriptAction = function (jquerySelector) {
            $(jquerySelector).off('click');
            $(jquerySelector).click(function (event) {
                scriptAction(event);
            });
        };
        /*
        * Template for list item component.  These items are clickable and allows the user to navigate to proceeding
        * window to enter their private key.
        * @method getHtmlForPaperWalletItem
        * @param {String} symbolName
        * @return {String} a string with html formatted content.*/
        TransferPaperWalletMenu.prototype.getHtmlForPaperWalletItem = function (symbolName) {
            var expandedHeight = "\'[[355, \"120px\"], [2000, \"100px\"]]\'";
            var html = '<div class="settingsResetCache expandableText cssExpandableText scriptAction cssOpacity expandableDetailsAncestor cssInitialHeight" pushSettings="paperWarning" specialAction="jaxx_ui.preparePaperWarning" value="' + symbolName + '">'
                + '<div class="expandableDetailsHeader cssExpandableDetailsHeader">'
                + '<div class="triangleArrow cssTriangleArrow scriptAction stopPropagation" specialAction="jaxx_ui.toggleNearbyExpandableDetails"></div>'
                + '<div class="optionTrigger cssOptionTrigger">'
                + '<div class="optionHeading cssOptionHeading">'
                + '<label>' + 'Transfer ' + symbolName + ' Paper Wallet' + '</label>'
                + '</div>'
                + '</div>'
                + '</div>'
                + '<div class="cssExpandableDetailsElement expandableDetailsElement" expandedheight=' + expandedHeight + '>'
                + '<div class="toggler cssToggler">'
                + '<p class="cssIntroScreenHeading"> Click this option to import your paper wallet / private key. </p>'
                + '</div>'
                + '</div>'
                + '</div>';
            return html;
        };
        /*
        * Filter out wallets that do not have paper wallets enabled.  Add the paper wallet items to the view.
        * @method addPaperWallets
        * */
        TransferPaperWalletMenu.prototype.addPaperWallets = function () {
            var _this = this;
            var wallets = jaxx.Registry.getWalletsEnabledSorted();
            wallets.forEach(function (wallet) {
                if (wallet.config.paperwallet && wallet.paperwallet.regular) {
                    _this.$view.find('.cssScrollableMenuList').append(_this.getHtmlForPaperWalletItem(wallet.symbol));
                }
            });
            this.attachClickEvents();
        };
        return TransferPaperWalletMenu;
    }());
    jaxx.TransferPaperWalletMenu = TransferPaperWalletMenu;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=transfer-paper-wallet-menu.js.map
var jaxx;
(function (jaxx) {
    var TransferPaperWalletWarning = (function () {
        /*
        * Dynamically adds the html to index.html with appropriate content and attaches click events (scriptAction) to
        * appropriate dom elements.
        * */
        function TransferPaperWalletWarning() {
            var _this = this;
            this.$view = $('#transferWalletWarning');
            this.$view.load('js/app/transfer-paper-wallet/transfer-paper-wallet-warning.html', null, function (res) {
                setTimeout(function () {
                    _this.attachClickEvents();
                }, 1000);
            });
        }
        /*
        * Attaches click event to scriptAction events for the dynamically added content.
        * @method attachClickEvents
        * */
        TransferPaperWalletWarning.prototype.attachClickEvents = function () {
            var elements = this.$view.find(".scriptAction").not(".scrollHeaderContainer .rightArrow").not(".scrollHeaderContainer .leftArrow"); // Exclude carousel arrows
            this.attachClickEventForScriptAction(elements);
        };
        /*
        * Attaches click events for any dom elements with the script action tag that we added dynamically.
        * @method attachClickEventForScriptAction
        * */
        TransferPaperWalletWarning.prototype.attachClickEventForScriptAction = function (jquerySelector) {
            $(jquerySelector).off('click');
            $(jquerySelector).click(function (event) {
                scriptAction(event);
            });
        };
        return TransferPaperWalletWarning;
    }());
    jaxx.TransferPaperWalletWarning = TransferPaperWalletWarning;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=transfer-paper-wallet-warning.js.map
var jaxx;
(function (jaxx) {
    var TransferPaperWallet = (function () {
        /*
        * Dynamically adds the html to index.html with appropriate content and attaches click events (scriptAction) to
        * appropriate dom elements.
        * */
        function TransferPaperWallet() {
            var _this = this;
            this.$view = $('#transferPaperWallet');
            this.$view.load('js/app/transfer-paper-wallet/transfer-paper-wallet.html', null, function () {
                setTimeout(function () {
                    _this.attachClickEvents();
                    _this.$inputPrivateKey = _this.$view.find('#privateKeySweep');
                    _this.$inputPrivateKey.on('change paste keyup', function () {
                        _this.sweepPrivateKey();
                    });
                    _this.$nextButton = _this.$view.find('.sweepNextButton');
                    _this.$nextButton.on('click', function () {
                        _this.enableSweeping();
                        if (_this.symbol === 'ETH' || _this.symbol === 'ETC') {
                            _this.sweepEthereum(function () {
                                _this.disableSweeping();
                            });
                        }
                        else {
                            _this.sweepCoin(function () {
                                _this.disableSweeping();
                            });
                        }
                    });
                }, 1000);
            });
        }
        /*
        * Sweeps the coin(ex. BTC) private key that was provided.  If there is data in the callback and it is not "zero" then it will
        * load the next screen (Confirm to sweep the private key), clear the input field.  Otherwise it will show a
        * banner telling the user that they have insufficient funds or invalid private key.
        * @method sweepCoin
        * */
        TransferPaperWallet.prototype.sweepCoin = function (cb) {
            var _this = this;
            jaxx.Registry.application.paperWalletTransactionController.prepareSweepTransactionCoin(this.$inputPrivateKey.val().toString(), this.symbol, function (err, data) {
                if (err) {
                    Navigation.flashBanner(err, 2);
                    return cb();
                }
                if (data) {
                    if (data === 'zero') {
                        return Navigation.flashBanner('Insufficient funds or no funds in this private key.', 2);
                    }
                    jaxx.Registry.application.sweepPrivateKey.symbol = _this.symbol;
                    jaxx.Registry.application.sweepPrivateKey.signedTransaction = data.signedTransaction;
                    jaxx.Registry.application.sweepPrivateKey.amount = data.totalValue;
                    jaxx.Registry.application.sweepPrivateKey.setAmount();
                    Navigation.pushSettings('confirmSweepPrivateKey');
                    _this.$inputPrivateKey.val('').trigger('keyup');
                    cb();
                }
                else {
                    cb();
                    Navigation.flashBanner('Invalid Private Key', 2);
                }
            });
        };
        /*
        * Sweeps ethereum private key that was provided.  If there is data in the callback and it is not "zero" then it will
        * load the next screen (Confirm to sweep the private key), clear the input field.  Otherwise it will show a
        * banner telling the user that they have insufficient funds or invalid private key.
        * @method sweepEthereum
        * */
        TransferPaperWallet.prototype.sweepEthereum = function (cb) {
            var _this = this;
            jaxx.Registry.application.paperWalletTransactionController.prepareSweepTransactionEthereum(this.symbol, this.$inputPrivateKey.val().toString(), function (err, data) {
                if (err) {
                    Navigation.flashBanner(err, 2);
                    return cb();
                }
                if (data) {
                    if (data === 'zero') {
                        return Navigation.flashBanner('Insufficient funds or no funds in this private key.', 2);
                    }
                    jaxx.Registry.application.sweepPrivateKey.symbol = _this.symbol;
                    jaxx.Registry.application.sweepPrivateKey.signedTransaction = data.signedTransaction;
                    jaxx.Registry.application.sweepPrivateKey.amount = data.totalValue;
                    jaxx.Registry.application.sweepPrivateKey.setAmount();
                    Navigation.pushSettings('confirmSweepPrivateKey');
                    _this.$inputPrivateKey.val('').trigger('keyup');
                    cb();
                }
                else {
                    cb();
                    Navigation.flashBanner('Invalid Private Key', 2);
                }
            });
        };
        /*
        * Disable the next button in the bottom right corner
        * @method disableButton
        * */
        TransferPaperWallet.prototype.disableButton = function () {
            this.$nextButton.addClass('cssStartHidden').css('cursor', 'default');
        };
        /*
        * Enable the next button in the bottom right corner
        * @method enableButton
        * */
        TransferPaperWallet.prototype.enableButton = function () {
            this.$nextButton.removeClass('cssStartHidden').css('cursor', 'pointer');
        };
        /*
        * Sweeps the private key that the user inputs and enables/disables the button depending on if the user inputs a
        * somewhat valid private key.  We will analyze if it is a truly valid private key when we try to send the
        * transaction.
        * @method sweepPrivateKey
        * */
        TransferPaperWallet.prototype.sweepPrivateKey = function () {
            var value = this.$inputPrivateKey.val();
            if (value === "") {
                this.disableButton();
                return;
            }
            var isPlainPrivateKey = TransferPaperWallet.validPrivateKey(this.symbol, value);
            if (isPlainPrivateKey) {
                this.enableButton();
            }
            else {
                this.disableButton();
            }
        };
        /*
        * When user clicks next button we want to disable the button and change the text to sweeping...
        * @method enableSweeping
        * */
        TransferPaperWallet.prototype.enableSweeping = function () {
            this.$nextButton.prop("disabled", true);
            this.$nextButton.text('Sweeping...');
        };
        /*
        * Revert the text and functionality of the button back of the next button
        * @method disableSweeping
        * */
        TransferPaperWallet.prototype.disableSweeping = function () {
            this.$nextButton.text('Next');
            this.$nextButton.prop("disabled", false);
        };
        /*
        * Attaches click event to scriptAction events for the dynamically added content.
        * @method attachClickEvents
        * */
        TransferPaperWallet.prototype.attachClickEvents = function () {
            var elements = this.$view.find(".scriptAction").not(".scrollHeaderContainer .rightArrow").not(".scrollHeaderContainer .leftArrow"); // Exclude carousel arrows
            this.attachClickEventForScriptAction(elements);
        };
        /*
        * Attaches click events for any dom elements with the script action tag that we added dynamically.
        * @method attachClickEventForScriptAction
        * */
        TransferPaperWallet.prototype.attachClickEventForScriptAction = function (jquerySelector) {
            $(jquerySelector).off('click');
            $(jquerySelector).click(function (event) {
                scriptAction(event);
            });
        };
        /*
        * Validates the private key based on the symbol and returns a true or false value based on the validity.
        * @method validPrivateKey
        * @param {String} symbol
        * @param {String} privateKey
        * @return {Boolean} */
        TransferPaperWallet.validPrivateKey = function (symbol, privateKey) {
            var coinController = jaxx.Registry.getCryptoControllerBySymbol(symbol);
            if (coinController.config.request === "RequestBitcoin" && coinController.config.network) {
                return TransferPaperWallet.isValidBTCPrivateKey(privateKey, coinController.config.network);
            }
            else if (coinController.config.request === "EthereumService") {
                if (TransferPaperWallet.addressFromEthereumPrivateKey(privateKey)) {
                    return true;
                }
            }
            return false;
        };
        /*
        * Validates coin private key and returns true or false based on the validity.
        * @method isValidBTCPrivateKey
        * @param {String} privateKey
        * @param {Object} networkDef
        * @return {Boolean}
        * */
        TransferPaperWallet.isValidBTCPrivateKey = function (privateKey, networkDef) {
            var valid = false;
            try {
                var keyPair = thirdparty.bitcoin.ECPair.fromWIF(privateKey, networkDef);
                if (keyPair) {
                    valid = true;
                }
            }
            catch (err) {
                valid = false;
            }
            return valid;
        };
        /*
        * Validates etheruem private key and returns an address string.
        * @method addressFromEthereumPrivateKey
        * @param {String} privateKey
        * @return {String} ethereum public address
        * */
        TransferPaperWallet.addressFromEthereumPrivateKey = function (privateKey) {
            //Create a fake tx
            var controller = jaxx.Registry.getCryptoControllerBySymbol('ETH');
            var mockUpTxRaw = {
                nonce: thirdparty.web3.toHex(1),
                gasPrice: thirdparty.web3.toHex(thirdparty.web3.toBigNumber(thirdparty.web3.toWei(21, 'shannon')).toDigits(1)),
                gasLimit: thirdparty.web3.toHex(controller.config.gasLimit),
                to: "0xbac369f138d479abd45340e7735f80617a008ee7",
                value: thirdparty.web3.toHex(1)
            };
            var mockUpTxR = new thirdparty.ethereum.tx(mockUpTxRaw);
            //Sign with the private key
            var privateKeyHex = new thirdparty.Buffer.Buffer(privateKey, 'hex');
            mockUpTxR.sign(privateKeyHex);
            var address = mockUpTxR.getSenderAddress().toString('hex');
            if (address) {
                return '0x' + address;
            }
            return null;
        };
        return TransferPaperWallet;
    }());
    jaxx.TransferPaperWallet = TransferPaperWallet;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=transfer-paper-wallet.js.map
var jaxx;
(function (jaxx) {
    var SweepPrivateKey = (function () {
        /*
        * Dynamically adds the html to index.html with appropriate content and attaches click events (scriptAction) to
        * appropriate dom elements.
        * */
        function SweepPrivateKey() {
            var _this = this;
            this.$view = $('#sweepPrivateKey');
            this.$view.load('js/app/transfer-paper-wallet/sweep-private-key.html', null, function (res) {
                setTimeout(function () {
                    _this.attachClickEvents();
                    _this.$nextButton = _this.$view.find('.continueButton');
                    _this.$nextButton.on('click', function () {
                        _this.sendTransaction();
                    });
                }, 1000);
            });
        }
        /*
        * Attaches click event to scriptAction events for the dynamically added content.
        * @method attachClickEvents
        * */
        SweepPrivateKey.prototype.attachClickEvents = function () {
            var elements = this.$view.find(".scriptAction").not(".scrollHeaderContainer .rightArrow").not(".scrollHeaderContainer .leftArrow"); // Exclude carousel arrows
            this.attachClickEventForScriptAction(elements);
        };
        /*
        * Attaches click events for any dom elements with the script action tag that we added dynamically.
        * @method attachClickEventForScriptAction
        * */
        SweepPrivateKey.prototype.attachClickEventForScriptAction = function (jquerySelector) {
            $(jquerySelector).off('click');
            $(jquerySelector).click(function (event) {
                scriptAction(event);
            });
        };
        /*
        * Displays the coin value on screen and the next button
        * @method setAmount
        * */
        SweepPrivateKey.prototype.setAmount = function () {
            this.$view.find('.spinner').html('The Balance for this Private Key is ' + this.amount + ' ' + this.symbol);
            this.showNextButton();
        };
        /*
        * Sends the transaction to the mempool to be approved by the miners.  If the transaction fails it pops up a
        * banner notifying the user the transaction has failed.
        * @method sendTransaction*/
        SweepPrivateKey.prototype.sendTransaction = function () {
            this.hideNextButton();
            jaxx.Registry.getCryptoControllerBySymbol(this.symbol).sendTransaction(this.signedTransaction).done(function (res) {
                if (res.success === 'success') {
                    Navigation.flashBanner('Transaction sent', 2, 'success');
                }
                else {
                    Navigation.flashBanner('Transaction failed', 2);
                    console.error(res);
                }
            }).fail(function (err) {
                Navigation.flashBanner('Transaction failed', 2);
                console.error(err);
            });
        };
        /*
        * Displays the next button in the bottom right corner.
        * @method showNextButton
        * */
        SweepPrivateKey.prototype.showNextButton = function () {
            this.$nextButton.show();
        };
        /*
        * Hide the next button in the bottom right corner.
        * @method hideNextButton
        * */
        SweepPrivateKey.prototype.hideNextButton = function () {
            this.$nextButton.hide();
        };
        return SweepPrivateKey;
    }());
    jaxx.SweepPrivateKey = SweepPrivateKey;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=sweep-private-key.js.map
var jaxx;
(function (jaxx) {
    var PaperWalletTransactionController = (function () {
        function PaperWalletTransactionController() {
        }
        /*
        * determines how much the user should receive when they spend all their UTXOs associated with their private key.
        * @method getSpendableCoin
        * @param {VOutxo[]} utxos
        * @param {String} symbol three letter symbol for coins ex. BTC
        * */
        PaperWalletTransactionController.prototype.getSpendableCoin = function (utxos, symbol) {
            var ar = utxos.map(function (item) {
                return item.satoshis;
            });
            var total;
            if (utxos.length > 1) {
                total = jaxx.MATH.sum(ar);
            }
            else {
                total = ar[0];
            }
            total = jaxx.Registry.getCryptoControllerBySymbol(symbol).subtractMiningFee(total, utxos.length);
            if (+total < 0 || isNaN(Number(total))) {
                return '0';
            }
            total = jaxx.MATH.satoshiToBtc(total);
            return total;
        };
        /*
        * Sweeps the private key for all UTXOs associated with it
        * @method prepareSweepTransactionCoin
        * @param {String} privateKey
        * @param {String} symbol
        * @param {Function} callback
        * */
        PaperWalletTransactionController.prototype.prepareSweepTransactionCoin = function (privateKey, symbol, callback) {
            var _this = this;
            var coinNetwork;
            coinNetwork = jaxx.Registry.getCryptoControllerBySymbol(symbol).config.network; //HDWalletPouch.getStaticCoinPouchImplementation(this._pouchManager._coinType).networkDefinitions.testNet;
            var keyPair;
            try {
                keyPair = thirdparty.bitcoin.ECPair.fromWIF(privateKey, coinNetwork);
            }
            catch (err) {
                return;
            }
            var coinController = jaxx.Registry.getCryptoControllerBySymbol(symbol);
            var publicAddress = keyPair.getAddress();
            coinController.coinService.downlaodUTXOs([publicAddress]).done(function (res) {
                var utxos = res;
                var privateKeys = {};
                utxos.forEach(function (utxo) {
                    //this was changed to use keyPair as we already have this information saved
                    privateKeys[utxo.address] = keyPair;
                });
                var spendable = _this.getSpendableCoin(utxos, symbol);
                if (Number(spendable) > 0) {
                    var amountSatoshi = jaxx.MATH.btcToSatoshi(spendable);
                    var addressChange = coinController.getCurrentAddressChange();
                    var transaction = void 0;
                    var miningFeePerByte = coinController.getMiningPrice();
                    var isMax = true;
                    var addressTo = coinController.getCurrentAddress();
                    var symbol_1 = coinController.config.symbol;
                    var network = coinController.config.network;
                    //try catch were added to prevent UI hang ups.  This is good practice as this prevents the app
                    //from not responding in the event of an error in the functions within the try catch.
                    try {
                        if (coinController.symbol === 'BCH') {
                            transaction = jaxx.TransactionsUtilsBitcoin.buildBCHPerbyte(amountSatoshi, addressTo, utxos, privateKeys, null, addressChange, network, symbol_1, isMax, miningFeePerByte);
                        }
                        else {
                            transaction = jaxx.TransactionsUtilsBitcoin.buildBTC(amountSatoshi, addressTo, utxos, privateKeys, null, addressChange, network, symbol_1, isMax, miningFeePerByte);
                        }
                    }
                    catch (e) {
                        return callback('There is an error in the application. Jaxx is not able to sweep this private key', null);
                    }
                    if (transaction) {
                        return callback(null, {
                            signedTransaction: transaction,
                            totalValue: spendable,
                        });
                    }
                }
                callback('This private key does not have enough spendable ' + symbol + ' to move out of private key.', null);
            }).fail(function (err) {
                callback(err, null);
            });
        };
        /*
        * Sweeps the private key for the balance associated with it
        * @method prepareSweepTransactionEthereum
        * @param {String} privateKey
        * @param {Function} callback
        * */
        PaperWalletTransactionController.prototype.prepareSweepTransactionEthereum = function (symbol, privateKey, callback) {
            var privateKeyHex = new thirdparty.Buffer.Buffer(privateKey, 'hex');
            var signatures = {};
            signatures['address'] = privateKeyHex;
            var ethAddressToSweep = [this.ethereumAddressFromPrivateKey(symbol, privateKey)];
            if (ethAddressToSweep[0]) {
                var ethereumController_1 = jaxx.Registry.getCryptoControllerBySymbol(symbol);
                var spendableWei_1 = 0;
                ethereumController_1.coinService.downloadBalances(ethAddressToSweep).done(function (res) {
                    var fee = Number(ethereumController_1.config.gasPrice) * Number(ethereumController_1.config.gasLimit);
                    if (res[0]) {
                        var balances_1 = res;
                        var balanceItem = res[0];
                        if (Number(balanceItem.balance) > fee) {
                            spendableWei_1 = Number(balanceItem.balance) - fee;
                        }
                        if (spendableWei_1 <= 0) {
                            callback(null, 'zero');
                        }
                        else {
                            ethereumController_1.getNonces(ethAddressToSweep).done(function (nonces) {
                                var decimal = jaxx.MATH.weiToEther(String(spendableWei_1));
                                var transaction = jaxx.TransactionsUtilsEthereum.buildETH(String(spendableWei_1), decimal, ethereumController_1.getCurrentAddress(), balances_1, nonces, signatures, // privateKeys,
                                ethereumController_1.config.gasPrice, ethereumController_1.config.gasLimit, ethereumController_1.symbol, true, null);
                                callback(null, {
                                    signedTransaction: transaction,
                                    totalValue: decimal,
                                });
                            }).fail(function (err) {
                                callback(err, null);
                            });
                        }
                    }
                }).fail(function (err) {
                    callback(err, null);
                });
            }
            else {
                callback('Invalid ethereum address', null);
            }
        };
        /*
        * Generates a public address by doing a mock transaction and signing with private key provided.
        * @method ethereumAddressFromPrivateKey
        * @param {String} privateKey
        * @return {String}*/
        PaperWalletTransactionController.prototype.ethereumAddressFromPrivateKey = function (symbol, privateKey) {
            //Create a fake tx
            var mockUpTxRaw = {
                nonce: thirdparty.web3.toHex(1),
                gasPrice: thirdparty.web3.toHex(thirdparty.web3.toBigNumber(thirdparty.web3.toWei(21, 'shannon')).toDigits(1)),
                gasLimit: thirdparty.web3.toHex(jaxx.Registry.getCryptoControllerBySymbol(symbol).config.gasLimit),
                to: "0xbac369f138d479abd45340e7735f80617a008ee7",
                value: thirdparty.web3.toHex(1)
            };
            var mockUpTxR = new thirdparty.ethereum.tx(mockUpTxRaw);
            //Sign with the private key
            var privateKeyHex = new thirdparty.Buffer.Buffer(privateKey, 'hex');
            mockUpTxR.sign(privateKeyHex);
            var address = mockUpTxR.getSenderAddress().toString('hex');
            if (address) {
                return '0x' + address;
            }
            return null;
        };
        return PaperWalletTransactionController;
    }());
    jaxx.PaperWalletTransactionController = PaperWalletTransactionController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=paper-wallet-transaction-controller.js.map
/**
 * Created by jnewlands on 2017-AUG-16.
 */
var jaxx;
(function (jaxx) {
    var BalanceView = (function () {
        function BalanceView() {
            // CSS should be ready while rendering HTML so put it first
            $('head').append('<link rel="stylesheet" href="js/app/view-balance/fiat-currency.css" type="text/css" />');
            this.$balanceView = $('#BalanceView');
            this.$balanceCoinUnit = $('#BalanceCoinUnit');
            this.$wholePortion = $('#wholePortion');
            this.$wholePortionValue = $('#wholePortionValue');
            this.$decimapPoint = $('#decimapPoint');
            this.$decimalPortionValue = $('#decimalPortionValue');
            this.$WalletFiatBalance = $('#WalletFiatBalance');
            this.fiatBalanceView = new jaxx.FiatBalanceView();
            this.init();
        }
        BalanceView.prototype.setUnknown = function () {
            this.$wholePortionValue.text('---');
            this.$decimalPortionValue.text('');
            this.$decimapPoint.text('');
            this.$wholePortionValue.css("margin-left", "0px");
            this.currentBalance = null;
        };
        BalanceView.prototype.onBalanceChanged = function () {
            var current = jaxx.Registry.getCurrentCryptoController();
            if (!current)
                return;
            var balance = current.getBalanceDisplay();
            if (balance === this.currentBalance)
                return;
            if (this.currentBalance && this.currentBalance !== '-1') {
                var precision = 0.00005;
                var delta = +balance - +this.currentBalance;
                if (delta > precision) {
                    //checks to see if wallet is in setup mode.
                    var wallet_setup = localStorage.getItem('wallet_setup');
                    if (wallet_setup && wallet_setup !== 'false') {
                        return;
                    }
                    Navigation.flashBanner('Payment Received!', 5, 'success');
                }
                else {
                    console.log('%c  delta ' + delta + ' less then precision ' + precision, 'color:orange');
                }
            }
            this.currentBalance = balance; // update the current balance
            this.renderBalance();
        };
        BalanceView.prototype.renderBalance = function () {
            if (this.currentBalance === undefined || this.currentBalance === null) {
                // get currentBalance, it is not available
                var current = jaxx.Registry.getCurrentCryptoController();
                this.currentBalance = current.getBalanceDisplay();
            }
            var balance = this.currentBalance;
            if (balance === '-1') {
                this.setUnknown();
                return;
            }
            balance = String(+balance);
            if (+balance < 0.00000001) {
                balance = '0.0';
            }
            var ar = balance.split('.');
            var wholePortion = ar[0];
            var cut = wholePortion.length > 3 ? 2 : 8;
            var decimalPortion = !!ar[1] ? ar[1].substr(0, cut) : '0';
            this.$wholePortionValue.text(wholePortion);
            this.$decimapPoint.text('.');
            this.$decimalPortionValue.text(decimalPortion);
            this.$WalletFiatBalance.css("opacity", 1);
            var w = $(window).width();
            if (wholePortion == "0" && decimalPortion == "0") {
                var wholePortionFontSize = this.$wholePortionValue.css("font-size");
                this.$wholePortionValue.css("margin-left", "0");
                this.$decimalPortionValue.css("font-size", wholePortionFontSize);
                if (w > 360) {
                    this.$wholePortion.css("padding-left", "0px");
                }
            }
            else {
                if (w <= 375) {
                    if ((decimalPortion.length > 5) && (wholePortion.length > 2)) {
                        this.$wholePortionValue.css("margin-left", "-0.27em");
                        this.$wholePortionValue.css("font-size", '19pt');
                        this.$decimalPortionValue.css("font-size", '16pt');
                        this.$wholePortionValue.css("margin-top", "0px");
                    }
                    else {
                        this.$wholePortionValue.css("margin-left", "0");
                        this.$wholePortionValue.css("font-size", '25pt');
                        this.$decimalPortionValue.css("font-size", '20pt');
                        this.$wholePortionValue.css("margin-top", "0px");
                    }
                    this.$wholePortion.css("padding-left", "0px");
                }
                else {
                    this.$wholePortionValue.css("font-size", this.originalWholePortion);
                    this.$decimalPortionValue.css("font-size", this.originalDecimalPortion);
                    this.$wholePortionValue.css("margin-left", "0");
                }
            }
            jaxx.Registry.application$.trigger(jaxx.Registry.ON_BALANCE_RENDER);
        };
        BalanceView.prototype.reset = function () {
            this.setUnknown();
        };
        BalanceView.prototype.setCoinUnit = function (coinSymbol) {
            this.$balanceCoinUnit.text(coinSymbol);
        };
        BalanceView.prototype.init = function () {
            var _this = this;
            var ctr = jaxx.Registry.getCurrentCryptoController();
            if (!ctr) {
                setTimeout(function () { return _this.init(); }, 500);
                return;
            }
            this.setCoinUnit(ctr.symbol);
            var temporaryNewCoinController;
            this.originalWholePortion = $('#wholePortionValue').css("font-size");
            this.originalDecimalPortion = $('#decimalPortionValue').css("font-size");
            this.$refreshBtn = $('.scriptAction.refresh').first();
            if (this.$refreshBtn.length == 0) {
                setTimeout(function () {
                    _this.$refreshBtn = $('.scriptAction.refresh').first();
                }, 1500);
                return;
            }
            this.renderBalance();
            jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_START, function () {
                _this.currentBalance = null;
                _this.setUnknown();
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_DONE, function () {
                _this.currentBalance = null;
                _this.renderBalance();
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_ACTIVATED, function (evt, ctr) {
                _this.currentBalance = ctr.getBalanceDisplay(); // Changed from ctr.getBalance()
                _this.setCoinUnit(ctr.symbol);
                _this.renderBalance();
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_BALANCE_CHANGED, function (evt, obj) {
                var ctr = jaxx.Registry.getCurrentCryptoController();
                if (!ctr || ctr.symbol !== obj.symbol)
                    return;
                _this.onBalanceChanged();
            });
            jaxx.Registry.application$.on(jaxx.Registry.WALLET_FIRST_INIT, function () {
                // To determine whether or not it is appropriate to show "Payment Received"
                // this.isWalletFirstInitialziation = true;
            });
        };
        return BalanceView;
    }());
    jaxx.BalanceView = BalanceView;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=view-balance.js.map
var global_fiat_view; // used for testing in the dev console
var jaxx;
(function (jaxx) {
    /*
        This module depends on Registry.getCurrentCryptoController() and FiatPriceController
    */
    /**
     * This class controls the fiat amount in the main wallet view AND the quick fiat selector menu triggered by the round arrow next to the fiat balance.
     *
     * All the action happens at constructor(), init() and inside the event handlers that start with "on", look at those if you wnat ot understand what's going on
     */
    var FiatBalanceView = (function () {
        function FiatBalanceView() {
            var _this = this;
            this.outsideClickHandler = this.onOutsideClick.bind(this); //
            this.menu_item_tpl = '<tr class="cssCurrencyAdditionalElement quickFiatCurrencySelector cssCurrencyFirstElement {{highlighted}}" data-currency-code-value="{{fiat_code}}"> \
                <td class="fiatUnit cssFiatUnit">{{fiat_code}}</td>\
                <td class="covertedBalance cssConvertedBalance"> {{fiat_amount}}</td>\
             </tr>';
            this.menu_button_and_container_tpl = '<div id="FiatSelectorDropdown" class="displayCurrenciesSelectedArrow cssDisplayCurrenciesArrow">\
               <img id="FiatSelectorDropdownButton" class="cssStartHidden cssFlipped" src="images/arrowCircle.png" alt=""> \
               <div id="FiatSelectorDropDownMenu" class="wrapTableCurrencySelectionMenu cssWrapTableCurrencySelectionMenu cssList cssStartHidden"> \
                   <table class="cssTableFiatCurrencySelectionMenu" cellspacing="0" cellpadding="0"> \
                       <tbody id="FiatSelectorMenuBody" class="fiatCurrencySelectionMenu cssList cssFiatCurrencySelectionMenu"> \
                       \
                       </tbody>\
                   </table>\
               </div>\
              </div>';
            global_fiat_view = this;
            this.fiat_price_controller = jaxx.FiatPriceController.instance;
            this.$view = $('#FiatSelector');
            this.$amount = $('#WalletFiatAmount');
            this.$amountHolder = $('#WalletFiatBalance');
            this.$view.html(this.menu_button_and_container_tpl);
            // the code executed in the handler below depends on the DOM items being flushed
            // that's why we delay execution a bit
            setTimeout(function () {
                _this.$selector = $('#FiatSelectorDropdown');
                _this.$dropdown_button = $('#FiatSelectorDropdownButton');
                _this.$dropdown_menu = $('#FiatSelectorDropDownMenu');
                _this.$dropdown_menu_body = $('#FiatSelectorMenuBody');
                _this.init();
            }, 0);
        }
        FiatBalanceView.prototype.onNewCoinActivationStart = function (event, newCoinSymbol) {
            this.temporaryNewCoinSymbol = newCoinSymbol;
        };
        FiatBalanceView.prototype.onAboutToShowNewCoin = function (event) {
            if (this.temporaryNewCoinSymbol) {
                this.updatefiatWalletBalance(this.temporaryNewCoinSymbol);
            }
        };
        FiatBalanceView.prototype.init = function () {
            jaxx.Registry.application$.on(jaxx.Registry.ON_BALANCE_CHANGED, this.onCoinBalanceChange.bind(this));
            jaxx.Registry.application$.on(jaxx.Registry.ON_BALANCE_RENDER, this.onCoinBalanceChange.bind(this));
            jaxx.Registry.walletValue$.on(jaxx.Registry.ON_WALLET_VALUE_CHANGE, this.onCoinBalanceChange.bind(this));
            jaxx.Registry.application$.on(jaxx.Registry.ON_FIAT_MAIN_CURRENCY_CHANGE, this.onUserSelectedMainCurrencyChanges.bind(this));
            jaxx.Registry.application$.on(jaxx.Registry.ON_ACTIVE_CURRENCIES_CHANGED, this.onUserSelectedCurrenciesChanges.bind(this));
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_INTERWALLET_ANIMATION_END, this.onAboutToShowNewCoin.bind(this));
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE_ANIMATION_END, this.onAboutToShowNewCoin.bind(this));
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_COIN_ACTIVATE_START, this.onNewCoinActivationStart.bind(this));
            this.$amount.on('click', this.onFiatAmountClicked.bind(this));
            this.$dropdown_button.on('click', this.onQuickSelectorMenuArrowClick.bind(this));
            // manually trigger first ON_FIAT_MAIN_CURRENCY_CHANGE for initial display
            this.onUserSelectedMainCurrencyChanges();
            // manually trigger ON_ACTIVE_CURRENCIES_CHANGED
            this.onUserSelectedCurrenciesChanges();
            // manually polled until the event is implemented
            setInterval(this.onFiatPriceChange.bind(this), 35000);
            if (jaxx.Registry.iPhone) {
                // On iPhone devices the fiat selector drop-down needs special styling to align properly
                this.$selector.css("margin-right", "-26px");
            }
        };
        /** Only call after rendering menu items. */
        FiatBalanceView.prototype.setupMenuItemsEvents = function () {
            this.$dropdown_menu_body.children('tr').on('click', this.onQuickSelectorCurrencyClick.bind(this));
        };
        FiatBalanceView.prototype.fiatConvertAndPrepareForDisplay = function (fiatPriceController, coinBalance, coinSymbol, fiat_code) {
            var displayString = '--.--';
            var fiatAmount = "0";
            if (coinBalance === null || coinBalance === undefined) {
                return displayString;
            }
            fiatAmount = jaxx.FiatPriceController.coinToFiat(coinBalance, coinSymbol, fiat_code);
            // looks like the conversion gone wrong (maybe a provider issue)
            if (fiatAmount == "0" && Number(coinBalance) != 0) {
                return displayString;
            }
            if (fiatAmount != null) {
                var prefix = jaxx.FiatPriceController.getFiatUnitPrefix(fiat_code);
                fiatAmount = jaxx.Formatters.balanceForDisplay(fiatAmount, 2);
                displayString = prefix + jaxx.Formatters.formatFinancialNumber(fiatAmount);
                //displayString = prefix + String(Math.round(fiat_amount * 100) / 100);
            }
            return displayString;
        };
        FiatBalanceView.prototype.prepareConvertedFiatsForMenuItems = function (fiatPriceController) {
            var _this = this;
            var return_array = [];
            var current_crypto_ctrl = jaxx.Registry.getCurrentCryptoController();
            var active_coin_symbol = 'BTC'; // these are some safe defaults
            var raw_balance = "0"; //
            var coin_balance = null; // the null here will cause the dispalyed value to be '--.--'
            var user_activated_currencies = jaxx.FiatPriceController.instance.getActiveFiatCurrencies();
            var active_fiat_currency = jaxx.FiatPriceController.instance.getActiveFiatCurrency();
            console.log(active_fiat_currency);
            if (current_crypto_ctrl) {
                active_coin_symbol = current_crypto_ctrl.symbol;
                raw_balance = current_crypto_ctrl.getBalance();
                coin_balance = current_crypto_ctrl.getBalanceDisplay(raw_balance);
            }
            console.log(user_activated_currencies);
            user_activated_currencies.forEach(function (currency_code) {
                console.log(currency_code);
                var is_active = currency_code.toLowerCase() == active_fiat_currency.toLowerCase() ? true : false;
                var display_fiat_amount = _this.fiatConvertAndPrepareForDisplay(_this.fiat_price_controller, coin_balance, active_coin_symbol, currency_code);
                return_array.push({
                    fiatCode: currency_code,
                    fiatValue: display_fiat_amount,
                    isHighlighted: is_active
                });
            });
            return return_array;
        };
        /** Empties the selector menu, then renders the items inside */
        FiatBalanceView.prototype.renderMenuItemsAndSetupEvents = function (items) {
            var _this = this;
            var items_html = '';
            this.$dropdown_menu_body.empty();
            if (items.length == 1) {
                this.$dropdown_button.hide();
                var w = $(window).width;
                var h = $(window).height;
                if (w > h) {
                    this.$amountHolder.css('padding-left', '26px');
                }
            }
            else {
                this.$dropdown_button.show();
                this.$amountHolder.css('padding-left', '0px');
            }
            items.forEach(function (item) {
                if (items_html.indexOf(item.fiatCode) < 0) {
                    //If duplicate item, don't render
                    items_html += renderItem(_this.menu_item_tpl, item.fiatCode, item.fiatValue, item.isHighlighted);
                }
                else {
                    //console.warn("DUPLICATE: " + item.fiatCode);
                }
            });
            this.$dropdown_menu_body.html(items_html);
            this.setupMenuItemsEvents();
            function renderItem(template, fiat_code, fiat_balance, isHighlighted) {
                var highlighted = isHighlighted ? FiatBalanceView.highlightClass : '';
                return template.replace('{{fiat_code}}', fiat_code) // until we find a more elegant solution
                    .replace('{{fiat_code}}', fiat_code) // we'll use two replace()-es for the 2 placeholders
                    .replace('{{fiat_amount}}', fiat_balance)
                    .replace('{{highlighted}}', highlighted);
            }
            if (items[0])
                this.fiat_price_controller.setActiveFiatCurrency(items[0].fiatCode);
        };
        /** Updates the main fiat balance (gray text under the coin balance in big orange text) and the fiat selector menu items */
        FiatBalanceView.prototype.updateMenuItemAmounts = function (coinBalance, coinSymbol) {
            var $menu_items = this.$dropdown_menu_body.children('tr');
            var self = this;
            $menu_items.each(function (index, item) {
                var fiat_code = item.getAttribute('data-currency-code-value');
                var $fiat_amount_holder = $(item).children('.covertedBalance');
                var converted_fiat_ammount = self.fiatConvertAndPrepareForDisplay(self.fiat_price_controller, coinBalance, coinSymbol, fiat_code);
                $fiat_amount_holder.text(converted_fiat_ammount);
            });
        };
        FiatBalanceView.prototype.updateSelectedMenuItem = function (fiatCode) {
            this.$dropdown_menu_body.children('.' + FiatBalanceView.highlightClass).removeClass(FiatBalanceView.highlightClass);
            this.$dropdown_menu_body.children('tr[data-currency-code-value="' + fiatCode + '"]').addClass(FiatBalanceView.highlightClass);
        };
        FiatBalanceView.prototype.updatefiatWalletBalance = function (updateCoinSymbol) {
            var current_crypto_controller;
            if (updateCoinSymbol) {
                current_crypto_controller = jaxx.Registry.getCryptoControllerBySymbol(updateCoinSymbol);
            }
            else {
                current_crypto_controller = jaxx.Registry.getCurrentCryptoController();
            }
            if (!current_crypto_controller)
                return;
            // set intermediate amount until the coin controller restored history
            if (current_crypto_controller.getHistoryTimestamp() === null) {
                this.$amount.text('0.00');
                return;
            }
            var raw_balance = current_crypto_controller.getBalance();
            var coin_balance = current_crypto_controller.getBalanceDisplay(raw_balance);
            var coin_symbol = current_crypto_controller.symbol;
            var newly_activated_currency = jaxx.FiatPriceController.instance.getActiveFiatCurrency();
            var new_fiat_amount = this.fiatConvertAndPrepareForDisplay(this.fiat_price_controller, coin_balance, coin_symbol, newly_activated_currency);
            this.$amount.text(new_fiat_amount);
            this.updateMenuItemAmounts(coin_balance, coin_symbol);
        };
        FiatBalanceView.prototype.onQuickSelectorMenuArrowClick = function (e) {
            if (this.$dropdown_menu.css('display') == 'none') {
                this.$dropdown_button.removeClass('cssFlipped');
                this.$dropdown_menu.fadeIn(150);
                window.addEventListener('click', this.outsideClickHandler);
            }
            else {
                this.$dropdown_menu.fadeOut(150);
                this.$dropdown_button.addClass('cssFlipped');
                window.removeEventListener('click', this.outsideClickHandler);
            }
            e.stopImmediatePropagation();
        };
        /** When the fiat amount is clicked we cycle through user's active tokens */
        FiatBalanceView.prototype.onFiatAmountClicked = function (e) {
            var active_currencies = this.fiat_price_controller.getActiveFiatCurrencies();
            var current_active_currency = jaxx.FiatPriceController.instance.getActiveFiatCurrency();
            var current_position = active_currencies.indexOf(current_active_currency);
            var new_position = current_position + 1;
            if (new_position >= active_currencies.length) {
                new_position = 0;
            }
            var new_currency_code = active_currencies[new_position];
            this.fiat_price_controller.setActiveFiatCurrency(new_currency_code);
        };
        FiatBalanceView.prototype.onOutsideClick = function (e) {
            this.$dropdown_menu.fadeOut(150);
            this.$dropdown_button.addClass('cssFlipped');
            window.removeEventListener('click', this.outsideClickHandler);
        };
        FiatBalanceView.prototype.onQuickSelectorCurrencyClick = function (e) {
            var new_currency_code = e.currentTarget.getAttribute('data-currency-code-value');
            if (new_currency_code && new_currency_code.length > 0) {
                this.fiat_price_controller.setActiveFiatCurrency(new_currency_code); // this will store the preference and trigger ON_FIAT_MAIN_CURRENCY_CHANGE which will cause the updates in the event handlers below
            }
        };
        /** The user selection of currencies changed */
        FiatBalanceView.prototype.onUserSelectedCurrenciesChanges = function () {
            var menu_items = this.prepareConvertedFiatsForMenuItems(this.fiat_price_controller);
            this.renderMenuItemsAndSetupEvents(menu_items);
            this.updatefiatWalletBalance();
        };
        /** Called when the main display currency was changed. That happens when the user clicks a item in the quick currency selector menu or when the user activates a new
         * currency. The event itself is triggered by FiatPriceController
         *
         * The main display currency - is the amount shown in a smaller gray text under the big orange coin balance in the wallet.
         */
        FiatBalanceView.prototype.onUserSelectedMainCurrencyChanges = function () {
            var newly_activated_currency = jaxx.FiatPriceController.instance.getActiveFiatCurrency();
            this.updatefiatWalletBalance();
            this.updateSelectedMenuItem(newly_activated_currency);
        };
        FiatBalanceView.prototype.onCoinBalanceChange = function () {
            this.updatefiatWalletBalance();
        };
        /** Called by a polling timer right now, in the future an event will be implemented */
        FiatBalanceView.prototype.onFiatPriceChange = function () {
            this.updatefiatWalletBalance();
        };
        return FiatBalanceView;
    }());
    FiatBalanceView.highlightClass = 'cssBlueHighlight'; // class used to mark the active item as highlighted
    jaxx.FiatBalanceView = FiatBalanceView;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=fiat-balance.js.map
/**
 * Created by Vlad on 10/11/2016.
 */
var jaxx;
(function (jaxx) {
    var JaxxDeveloper = (function () {
        function JaxxDeveloper() {
            this.$view = $('#JaxxLogo');
            $('<div>').attr('id', 'RestoreHistoryBtn').text('Restore').appendTo('#RefreshContainer')
                .on('click', function () {
                jaxx.Registry.current_crypto_controller.restoreHistory(null);
            });
        }
        return JaxxDeveloper;
    }());
    jaxx.JaxxDeveloper = JaxxDeveloper;
    var AddressView = (function () {
        function AddressView() {
            this.$view = $('#AddressView');
            this.$address = $('#AddressView-address');
            this.$displayName = $('#CoinDisplayName');
            this.$qrcode = $('.populateQRCode');
            this.$copyBtn = $('#CopyToClipboardBtn');
            this.$qrCodeModal = $('.modal.full');
            this.init();
        }
        AddressView.prototype.setCurrentAddress = function () {
            var address;
            var ctr = jaxx.Registry.getCurrentCryptoController();
            if (!ctr)
                address = null;
            else
                address = ctr.getCurrentAddress();
            address = address || '--------';
            this.currentAddress = address;
            this.$address.text(address);
            this.populateQRCode(address);
        };
        AddressView.prototype.setCurrentDisplayName = function () {
            var controller = jaxx.Registry.getCurrentCryptoController();
            var name = controller.config.name;
            var text = controller.config.HD ? 'Your Current ' + name + ' Address:' : 'Your ' + name + ' Address:';
            this.$displayName.text(text);
        };
        AddressView.prototype.setDisplayNameFromSymbol = function (coinSymbol) {
            var controller = jaxx.Registry.getCryptoControllerBySymbol(coinSymbol);
            var name = controller.config.name;
            var text = controller.config.HD ? 'Your Current ' + name + ' Address:' : 'Your ' + name + ' Address:';
            this.$displayName.text(text);
        };
        AddressView.prototype.init = function () {
            var _this = this;
            var self = this;
            this.$qrCodeModal.find('.imageCopy').on('click', function () {
                jaxx.Utils.copyClipboard(_this.currentAddress);
            });
            this.$qrcode.on('click', function () {
                console.log(' qrcode click');
                Navigation.closeModal();
                $('.modal #modal-wallet-name').text(jaxx.Registry.getCurrentCryptoController().displayName);
                $('.modal .populateAddress.cssAddress').text(_this.currentAddress);
                Navigation.openModal('full');
                $('.modal.visible').hide(); // replaces closeModal();
                _this.$qrCodeModal.css({ opacity: 0 }).show().animate({ opacity: 1 }).addClass('visible');
                _this.$qrCodeModal.click(function (e) {
                    if ($(e.target).hasClass('modal')) {
                        _this.closeModal();
                    }
                });
            });
            this.$copyBtn.on('click', function () {
                var address = _this.currentAddress;
                jaxx.Utils.copyClipboard(address);
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_ACTIVATED, function (evt, ctr) {
                _this.setCurrentAddress();
                _this.setCurrentDisplayName();
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_ADDRESS_CHANGED, function (evt, ctr) {
                var current = jaxx.Registry.getCurrentCryptoController();
                if (!current || current.symbol !== ctr.symbol)
                    return;
                _this.setCurrentAddress();
            });
        };
        AddressView.prototype.populateQRCode = function (address) {
            var qrCode = jaxx.Utils.generateQRCode(address, true);
            this.$qrcode.attr('src', qrCode);
            var modal = $('.modal.full');
            modal.find('.imageCopy').on('click', function () {
                jaxx.Utils.copyClipboard(address);
            });
        };
        AddressView.prototype.closeModal = function () {
            Navigation.closeModal();
        };
        return AddressView;
    }());
    jaxx.AddressView = AddressView;
    var SpinningCoinOverlay = (function () {
        function SpinningCoinOverlay() {
        }
        return SpinningCoinOverlay;
    }());
    jaxx.SpinningCoinOverlay = SpinningCoinOverlay;
    var Spinner = (function () {
        function Spinner() {
            this.transitions_out = {
                '#ReceiveTabBtn': 'slideOutLeft',
                '#SendTabBtn': 'slideOutRight',
                '.mainAddressBox': 'zoomOut',
                '.mainBalanceBox': 'slideOutLeft',
                '#QRContainer': 'slideOutRight',
                '.landscapeQRSeperator': 'fadeOut',
                '#TransactionsHeader': 'fadeOutDown',
                '#TransactionsListViewport': 'fadeOut',
                '.balanceBoxSeperator': 'fadeOut',
                '.shapeshiftTab': 'fadeOut',
                '.cssRefresh': 'fadeOut',
                '.cssRefreshContainer': 'fadeOut'
            };
            this.transitions_in = {
                '#ReceiveTabBtn': 'slideInLeft',
                '#SendTabBtn': 'slideInRight',
                '.mainAddressBox': 'zoomIn',
                '.mainBalanceBox': 'slideInLeft',
                '#QRContainer': 'slideInRight',
                '.landscapeQRSeperator': 'fadeIn',
                '#TransactionsListViewport': 'fadeIn',
                '#TransactionsHeader': 'fadeInUp',
                '.balanceBoxSeperator': 'fadeIn',
                '.shapeshiftTab': 'fadeIn',
                '.cssRefresh': 'fadeIn',
                '.cssRefreshContainer': 'fadeIn'
            };
            this.$view = $('#SpinnerContainer');
            this.$view.html('<div id="SpinningImageHolder" class=".cssCoinSpinningGreyFilter wow animated spinning" data-wow-duration="0.5s" style="opacity: 0; display: none;"></div>');
            this.$container = $('#SpinningImageHolder');
            this.animationEndEvent = this.checkBrowser();
            this.$shapeShiftIcon = $('#ShapeSiftFoxBtn');
        }
        Spinner.prototype.checkBrowser = function () {
            var eventName, fakeEl = document.createElement('fakeelement');
            var ANIMATION_END_EVENT_NAMES = {
                'animation': 'animationend',
                '-o-animation': 'oAnimationEnd',
                '-moz-animation': 'animationend',
                '-webkit-animation': 'webkitAnimationEnd'
            };
            for (eventName in ANIMATION_END_EVENT_NAMES) {
                if (typeof (fakeEl.style[eventName]) !== 'undefined') {
                    return ANIMATION_END_EVENT_NAMES[eventName];
                }
            }
            return null;
        };
        Spinner.prototype.newController = function (ctr, callback) {
        };
        Spinner.prototype.showShapeShiftSpinnerBySymbol = function (symbol) {
            var _this = this;
            var cfg = jaxx.Registry.getCryptoControllerBySymbol(symbol);
            var image = cfg.icon;
            var addressView = $('#AddressView');
            this.resetTop = this.$container.css('top');
            this.resetHeight = this.$container.css('height');
            var topPosition = (addressView.offset()).top + "px";
            var calculatedHeight = $(document).height() - (addressView.offset()).top;
            // On mobile when the main section animates out we place a spinning symbol of the newly selected
            // coin in the main balance display section centered to that area which is responsive to the screen size
            this.$container.css({
                'background-image': "url('" + image + "')",
                'width': '50%',
                'height': calculatedHeight,
                'left': '25%',
                'top': topPosition,
                '-webkit-filter': 'grayscale(100%)',
                '-moz-filter': 'grayscale(100%)',
                '-o-filter': 'grayscale(100%)',
                'filter': 'grayscale(100%)',
                'transition': 'opacity 1.5s',
                'display': 'initial',
                'opacity': '0'
            });
            // On desktop and iPad where the width is much larger, we adjust the height to be almost twice
            // as large and adjust the left/top position to keep it centered in the landscape view of Jaxx
            if ($(document).width() > 1000) {
                topPosition = (addressView.offset()).top + 15 + "px";
                this.$container.css({
                    'width': '50%',
                    'height': calculatedHeight * 0.9,
                    'left': '0',
                    'top': topPosition
                });
            }
            this.animateOutAllWalletElements(function () {
                _this.$container.css({
                    'z-index': '1100',
                    'opacity': '0.4',
                });
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE_ANIMATION_END);
            });
        };
        Spinner.prototype.showSpinnerBySymbol = function (symbol) {
            var _this = this;
            var cfg = jaxx.Registry.getCryptoControllerBySymbol(symbol);
            var image = cfg.icon;
            this.$container.css({
                'background-image': "url('" + image + "')",
                'width': '50%',
                'height': this.resetHeight,
                'left': '25%',
                'top': this.resetTop,
                '-webkit-filter': 'grayscale(100%)',
                '-moz-filter': 'grayscale(100%)',
                '-o-filter': 'grayscale(100%)',
                'filter': 'grayscale(100%)',
                'transition': 'opacity 1.5s',
                'display': 'initial',
                'opacity': '0'
            });
            this.animateOutAllWalletElements(function () {
                _this.$container.css({
                    'z-index': '1100',
                    'opacity': '0.4'
                });
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_UI_INTERWALLET_ANIMATION_END);
                console.log('%c ' + jaxx.Registry.ON_UI_INTERWALLET_ANIMATION_END, 'color:lime');
            });
        };
        Spinner.prototype.animateInAllWalletElements = function (onDone) {
            var _this = this;
            // for every object activated for animation
            // we add a reference to it in this array
            // then for each "animationend" event we cross that element form the array
            // when the array is empty, it means all items finished animating
            // at that point we call onDone
            var eventName = this.animationEndEvent;
            var objects_to_animate = [];
            var done_callback_invoked = false;
            function onElementAnimationEnd(e) {
                var dom_elm = e.currentTarget;
                var dom_elm_index = objects_to_animate.indexOf(dom_elm);
                if (dom_elm_index > -1) {
                    objects_to_animate.splice(dom_elm_index, 1);
                    dom_elm.removeEventListener(eventName, onElementAnimationEnd);
                }
                if (objects_to_animate.length <= 1) {
                    if (!done_callback_invoked) {
                        if (onDone) {
                            onDone();
                        }
                        done_callback_invoked = true;
                    }
                }
            }
            if ($(document).width() > 1000) {
                $('#landscapeQRCode').css('opacity', '1');
                $('#TransactionsView').css({
                    'border-top': 'solid 1px #444444',
                    'border-left': 'solid 1px #444444'
                });
            }
            Object.keys(this.transitions_in).forEach(function (cssSelector) {
                var $current_element = $(cssSelector);
                var dom_elm = $current_element.get(0);
                $current_element.removeClass(_this.transitions_out[cssSelector]);
                $current_element.addClass(_this.transitions_in[cssSelector]);
                _this.$shapeShiftIcon.css("opacity", "1");
                objects_to_animate.push(dom_elm);
                if (eventName)
                    dom_elm.addEventListener(eventName, onElementAnimationEnd);
                else
                    setTimeout(function () { return onElementAnimationEnd({ currentTarget: dom_elm }); }, 500);
            });
        };
        Spinner.prototype.animateOutAllWalletElements = function (onDone) {
            var _this = this;
            // for every object activated for animation
            // we add a reference to it in this array
            // then for each "animationend" event we cross that element form the array
            // when the array is empty, it means all items finished animating
            // at that point we call onDone
            var eventName = this.animationEndEvent;
            var objects_to_animate = [];
            var done_callback_invoked = false;
            function onElementAnimationEnd(e) {
                var dom_elm = e.currentTarget;
                var dom_elm_index = objects_to_animate.indexOf(dom_elm);
                if (dom_elm_index > -1) {
                    objects_to_animate.splice(dom_elm_index, 1);
                    dom_elm.removeEventListener(eventName, onElementAnimationEnd);
                }
                if (objects_to_animate.length <= 5) {
                    if (!done_callback_invoked) {
                        onDone();
                        done_callback_invoked = true;
                    }
                }
            }
            if ($(document).width() > 1000) {
                $('#landscapeQRCode').css('opacity', '0');
                $('#TransactionsView').css({
                    'border-top': 'none',
                    'border-left': 'none'
                });
            }
            Object.keys(this.transitions_out).forEach(function (cssSelector) {
                var $current_element = $(cssSelector);
                var dom_elm = $current_element.get(0);
                $current_element.removeClass(_this.transitions_in[cssSelector]);
                $current_element.addClass(_this.transitions_out[cssSelector]);
                _this.$shapeShiftIcon.css("opacity", "0");
                if (dom_elm) {
                    objects_to_animate.push(dom_elm);
                    if (eventName)
                        dom_elm.addEventListener(eventName, onElementAnimationEnd);
                    else
                        setTimeout(function () { return onElementAnimationEnd({ currentTarget: dom_elm }); }, 500);
                }
            });
        };
        Spinner.prototype.showSpinner = function (targetCoinType) {
            var id = targetCoinType;
            $(id).fadeTo(100, 1);
            $(id).css('z-index', '1100');
        };
        Spinner.prototype.hideSpinner = function (onDone) {
            var _this = this;
            this.$container.css('opacity', '0');
            setTimeout(function () {
                _this.$container.css('display', 'none');
                onDone();
            }, 550);
        };
        return Spinner;
    }());
    jaxx.Spinner = Spinner;
    var CurrentAddressController = (function () {
        function CurrentAddressController() {
        }
        return CurrentAddressController;
    }());
    jaxx.CurrentAddressController = CurrentAddressController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=view-main-page.js.map
var jaxx;
(function (jaxx) {
    var ToolBarMenu = (function () {
        function ToolBarMenu() {
        }
        return ToolBarMenu;
    }());
    jaxx.ToolBarMenu = ToolBarMenu;
    var SendConfirmationView = (function () {
        function SendConfirmationView(main) {
            var _this = this;
            this.main = main;
            this.emitter$ = $({});
            this.ON_CANCEL = 'ON_CANCEL';
            SendConfirmationView.instance = this;
            this.$view = $('#SendTransactionConfirmationView');
            // this.$content = $('<div></div>').appendTo(this.$view);
            // this.$content.slideUp();
            /*  this.$view.load('js/app/send-transaction/send-confirmation.html', ()=>{
  
              })*/
            $.get('js/app/send-transaction/send-confirmation.html').done(function (res) {
                _this.template = res;
                setTimeout(function () { return _this.init(); }, 1000);
            });
            $.get('js/app/send-transaction/shape-shift-confirmation.html').done(function (res) {
                _this.shapeshiftTemplate = res;
            });
        }
        SendConfirmationView.prototype.show = function () {
            this.$view.removeClass('hideNotificationFooter');
            // TODO: Find if any notification banner is open
            var bannerHeight;
            var documentHeight = $(document).height();
            var transactionTop = $('#TransactionsHeader').position().top;
            var calculatedHeight = Math.round(documentHeight - transactionTop);
            if (jaxx.Registry.mobile || jaxx.Registry.chromeExtension) {
                bannerHeight = calculatedHeight;
            }
            else {
                bannerHeight = $('.landscapeRight').height();
            }
            var banner = this.$view.find('.cssNotificationFooter.cssSendConfirmation, .cssShapeShiftConfirmation.cssNotificationFooter');
            banner.parent().removeClass("hideNotificationFooter").addClass('visibleNotificationFooter');
            banner.slideDown(400, "swing").animate({ height: bannerHeight });
            if (jaxx.Registry.android) {
                if (window.native && !!window.native.getAndroidSoftNavbarHeight()) {
                    $('.modal-bottom').addClass('softKeys');
                }
            }
            this.addListeners();
        };
        SendConfirmationView.prototype.hide = function () {
            this.$view.children().first().remove();
            this.$view.addClass('hideNotificationFooter');
        };
        SendConfirmationView.prototype.init = function () {
            /* this.showConfirmation({
                miningFee:'45676'
             });
             this.show();*/
        };
        SendConfirmationView.prototype.addListeners = function () {
            var _this = this;
            this.$view.find('[data-click=Confirm]').click(function () {
                _this.onConfirm();
            });
            this.$view.find('[data-click=Cancel]').click(function () {
                _this.emitter$.triggerHandler((_this.ON_CANCEL));
                _this.onCancel();
            });
        };
        SendConfirmationView.prototype.showShapeShiftConfirmation = function (obj, isFiat, coinValue) {
            var html;
            var currentCoin = jaxx.Registry.getCryptoControllerBySymbol(obj.depositType);
            // The symbol used for the FROM coin for display purposes
            var displaySymbolFrom = currentCoin.threeLetterCode;
            var shiftCoin = jaxx.Registry.getCryptoControllerBySymbol(obj.withdrawalType);
            // The symbol used for the TO coin for display purposes
            var displaySymbolTo = shiftCoin.threeLetterCode;
            if (isFiat) {
                // The amount to display in crypto plus the three letter symbol
                var depositAmount = String(obj.amountToDeposit);
                // The amount to display in fiat followed by the currency type wrapped in parentheses
                var alternateAmount = '(' + jaxx.FiatPriceController.displayFiatValue(Number(obj.displayAmountToDeposit)) + ' ' + jaxx.FiatPriceController.instance.getActiveFiatCurrency() + ')';
                html = this.shapeshiftTemplate
                    .replace('{{convertSymbolFrom}}', displaySymbolFrom)
                    .replace('{{convertAmountFrom}}', depositAmount)
                    .replace('{{convertAmountTo}}', obj.displayAmountToWithdraw)
                    .replace('{{convertSymbolTo}}', displaySymbolTo)
                    .replace('{{miningFee}}', obj.miningFee + '')
                    .replace('{{miningFeeSymbol}}', displaySymbolTo)
                    .replace('{{alternateAmount}}', alternateAmount);
            }
            else {
                html = this.shapeshiftTemplate
                    .replace('{{convertSymbolFrom}}', displaySymbolFrom)
                    .replace('{{convertAmountFrom}}', obj.displayAmountToDeposit)
                    .replace('{{convertAmountTo}}', obj.displayAmountToWithdraw)
                    .replace('{{convertSymbolTo}}', displaySymbolTo)
                    .replace('{{miningFee}}', obj.miningFee + '')
                    .replace('{{miningFeeSymbol}}', displaySymbolTo)
                    .replace('{{alternateAmount}}', '');
            }
            this.$view.prepend(html);
            this.show();
        };
        SendConfirmationView.prototype.showConfirmation = function (obj) {
            //
            var symbol;
            if (obj.fiatSymbol) {
                symbol = obj.fiatSymbol;
            }
            else {
                symbol = obj.symbol;
            }
            // let isShapeShift:boolean;
            var html;
            // if(obj.apiPubKey) {
            //     isShapeShift = true;
            // } else {
            //     isShapeShift = false;
            // }
            if (obj.fiatSymbol) {
                html = this.template.replace('{{symbol}}', symbol)
                    .replace('{{amount}}', obj.displayAmount + '')
                    .replace('{{addressTo}}', obj.addressTo)
                    .replace('{{miningFee}}', obj.miningFeeDecimal + '')
                    .replace('{{miningFeeSymbol}}', obj.miningFeeSymbol || obj.symbol)
                    .replace('{{alternate_amount}}', " (" + obj.amountDecimal + ' ' + obj.symbol + ")");
            }
            else {
                var fiatEquivalent = jaxx.FiatPriceController.coinToActiveDisplayFiat(String(obj.amountDecimal), obj.symbol);
                html = this.template.replace('{{symbol}}', symbol)
                    .replace('{{amount}}', obj.amountDecimal + '')
                    .replace('{{addressTo}}', obj.addressTo)
                    .replace('{{miningFee}}', obj.miningFeeDecimal + '')
                    .replace('{{miningFeeSymbol}}', obj.miningFeeSymbol || obj.symbol)
                    .replace('{{alternate_amount}}', ' (' + fiatEquivalent + ')');
            }
            // this.$content.html(html);
            this.$view.prepend(html);
            this.show();
        };
        return SendConfirmationView;
    }());
    jaxx.SendConfirmationView = SendConfirmationView;
    var SpendableView = (function () {
        function SpendableView() {
            this.$view = $('#SpendableView');
            this.init();
        }
        SpendableView.prototype.init = function () {
            this.$amount = $('#SpendableAmount');
            this.$loading = $('#SpendableUndefined');
            this.$spendableFiatSymbol = $('#spendableFiatCurrency');
            this.$spendableCryptoSymbol = $('#spendableCryptoSymbol');
            this.$spendableLoading = $('#SpendableUndefined');
            this.$loading.hide();
        };
        // update(delta:number) {
        //
        //     let ctr = jaxx.Registry.getCurrentCryptoController();
        //
        //     if(ctr){
        //         let spendable  = ctr.getSpendable();
        //
        //         console.log(' spendable   ' + spendable +  ' delta   ' + delta);
        //
        //         spendable+=delta;
        //
        //        // if(isNaN(spendable) || spendable < 0) spendable = 0;
        //         //this.$undefined.hide();
        //         //spendable = Math.floor(spendable * 1e8)/1e8;
        //        // console.log(spendable);
        //
        //         if(Number(spendable) < 0) {
        //             this.spendable = '0';
        //         } else {
        //             this.spendable = spendable;
        //         }
        //         this.$amount.text(Formatters.balanceForDisplay(this.spendable));
        //     } else {
        //         console.error(' no current controller ')
        //     }
        // }
        SpendableView.prototype.getSpendable = function () {
            if (Number(this.spendable) < 0) {
                return '0';
            }
            return this.spendable;
        };
        SpendableView.prototype.show = function () {
            this.$view.show();
        };
        SpendableView.prototype.hide = function () {
            this.$view.hide();
        };
        // Shows loading indicator and hides the amount
        SpendableView.prototype.showLoadingIndicator = function () {
            this.$amount.hide();
            this.$loading.show();
        };
        // Hides loading indicator and shows the amount
        SpendableView.prototype.hideLoadingIndicator = function () {
            this.$amount.show();
            this.$loading.hide();
        };
        // Updates UI with spendable amount and formats it with 2 decimals if "isFiat" is passed as true or with 8 decimals otherwise
        SpendableView.prototype.setSpendableAmount = function (newAmount, isFiat) {
            var formattedAmount;
            if (isFiat) {
                formattedAmount = jaxx.Formatters.balanceForDisplay(newAmount, 2);
            }
            else {
                formattedAmount = jaxx.Formatters.balanceForDisplay(newAmount, 8);
            }
            this.$amount.text(formattedAmount);
        };
        return SpendableView;
    }());
    jaxx.SpendableView = SpendableView;
    var SendButtonComponent = (function () {
        function SendButtonComponent(sendTransactionController) {
            var _this = this;
            this.sendTransactionController = sendTransactionController;
            this.$view = $('#Send_Recieve_Btn');
            this.$sendLabel = $('#sendLabel');
            this.$view.on('click', function (evt) {
                _this.onClick();
            });
        }
        SendButtonComponent.prototype.update = function (status) {
            console.log(' button status ' + status);
            switch (status) {
                case 'active':
                    this.$sendLabel.addClass('whiteText');
                    this.$view.addClass('enabled').addClass('cssEnabled');
                    break;
                default:
                    this.$sendLabel.removeClass('whiteText');
                    this.$view.removeClass('enabled').removeClass('cssEnabled');
                    break;
            }
        };
        return SendButtonComponent;
    }());
    jaxx.SendButtonComponent = SendButtonComponent;
    var AdvanceGasController = (function () {
        function AdvanceGasController() {
            this.init();
        }
        AdvanceGasController.prototype.getCustomData = function () {
            if (!this.isActive() || !this.isOptionsActive())
                return null;
            return (this.customDataValid) ? this.customDataValue : null;
        };
        AdvanceGasController.prototype.getCustomGasLimit = function () {
            // console.warn(' is active '+ this.isOptionsActive());
            if (!this.isActive() || !this.isOptionsActive())
                return null;
            var data = String(this.$customGasLimit.val()).trim();
            return (data.length) ? data : null;
        };
        AdvanceGasController.prototype.init = function () {
            var _this = this;
            this.$button = $('.advancedTabButton').first();
            this.$customData = $('#inputCustomData');
            this.customDataValid = false;
            this.customDataValue = null;
            this.$customGasLimit = $('.inputCustomGasLimit').first();
            this.$view = $('#AdvancedGasEthereumView');
            this.buttonVisible = this.$button.is(":visible");
            this.optionsVisible = this.$view.is(":visible");
            this.optionsActive = this.optionsVisible;
            this.updateCallback = null;
            this.viewActive = false;
            this.$button.on("click", function () {
                _this.toggleView();
                if (_this.updateCallback)
                    _this.updateCallback();
            });
            this.$customData.on('change paste blur', function () {
                _this.validateCustomData();
                if (!_this.customDataValid && String(_this.$customData.val()).trim().length)
                    Navigation.flashBanner('Custom Data must be in Hex', 3, 'error');
                if (_this.updateCallback)
                    _this.updateCallback();
            });
        };
        AdvanceGasController.prototype.hide = function () {
            if (this.viewActive) {
                this.hideButton();
                this.hideOptions();
            }
        };
        AdvanceGasController.prototype.hideButton = function () {
            if (this.buttonVisible) {
                this.buttonVisible = false;
                this.$button.hide();
            }
        };
        AdvanceGasController.prototype.hideOptions = function () {
            if (this.optionsVisible) {
                this.optionsVisible = false;
                this.$view.slideUp();
                $('.advancedBtnImage').removeClass('flipped');
            }
        };
        AdvanceGasController.prototype.isActive = function () {
            return this.viewActive;
        };
        AdvanceGasController.prototype.isCustomDataValid = function () {
            return this.validateCustomData();
        };
        AdvanceGasController.prototype.isOptionsActive = function () {
            return this.optionsActive;
        };
        AdvanceGasController.prototype.setActive = function (isActive, options) {
            this.optionsActive = false;
            //  console.warn(' setActive   ' + isActive);
            this.viewActive = isActive;
            if (this.viewActive) {
                if (options)
                    this.$customGasLimit.val(options.gasLimit);
                this.showButton();
            }
            else {
                this.hideButton();
                this.$customData.val('');
                this.customDataValid = false;
                this.customDataValue = null;
                this.$customGasLimit.val('');
            }
            this.hideOptions();
        };
        AdvanceGasController.prototype.setUpdateCallback = function (callback) {
            this.updateCallback = callback;
        };
        AdvanceGasController.prototype.show = function () {
            if (this.viewActive) {
                this.showButton();
                if (this.optionsActive)
                    this.showOptions();
            }
        };
        AdvanceGasController.prototype.showButton = function () {
            if (!this.buttonVisible) {
                this.buttonVisible = true;
                this.$button.show();
            }
        };
        AdvanceGasController.prototype.showOptions = function () {
            if (!this.optionsVisible) {
                this.optionsVisible = true;
                this.$view.slideDown();
                $('.advancedBtnImage').addClass('flipped');
            }
        };
        AdvanceGasController.prototype.toggleView = function () {
            if (this.optionsVisible) {
                this.hideOptions();
            }
            else {
                this.showOptions();
            }
            this.optionsActive = this.optionsVisible;
        };
        AdvanceGasController.prototype.validateCustomData = function () {
            var dirtyInput = String(this.$customData.val()).trim();
            this.customDataValue = JaxxUtils.scrubInput(dirtyInput);
            if (this.customDataValue) {
                this.customDataValid = true;
            }
            return this.customDataValid;
        };
        return AdvanceGasController;
    }());
    jaxx.AdvanceGasController = AdvanceGasController;
    var SendConfirmationController = (function () {
        function SendConfirmationController() {
            this.init();
        }
        SendConfirmationController.prototype.init = function () {
            var _this = this;
            this.$view = $('.modal.send').first();
            this.$btnClose = this.$view.find('.cssClose').first().click(function () { console.log('on close click'); });
            this.$btnConfirm = $('#sendConfirmationButton').click(function (evt) {
                _this.onConfirmed();
            });
        };
        SendConfirmationController.prototype.show = function () {
            this.$view.show();
        };
        SendConfirmationController.prototype.hide = function () {
            this.$view.hide();
        };
        SendConfirmationController.prototype.setTransaction = function (tr) {
            this.tr = tr;
        };
        SendConfirmationController.prototype.setAmount = function (num) {
        };
        SendConfirmationController.prototype.setMessage = function (str) {
        };
        return SendConfirmationController;
    }());
    jaxx.SendConfirmationController = SendConfirmationController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=send-transaction-components.js.map
var jaxx;
(function (jaxx) {
    /**
     * Enum for types of shape shift drop down menus
     * @readonly
     * @enum {number}
     * */
    var ShapeShiftDropDownMenuType;
    (function (ShapeShiftDropDownMenuType) {
        ShapeShiftDropDownMenuType[ShapeShiftDropDownMenuType["From"] = 0] = "From";
        ShapeShiftDropDownMenuType[ShapeShiftDropDownMenuType["To"] = 1] = "To";
    })(ShapeShiftDropDownMenuType || (ShapeShiftDropDownMenuType = {}));
    var ShapeshiftRequest = (function () {
        function ShapeshiftRequest() {
            this.apiKey = '';
        }
        ShapeshiftRequest.prototype.getShift = function (data) {
            var url = "https://shapeshift.io/shift/";
            return $.post(url, data).then(function (result) {
                return result;
            });
        };
        ShapeshiftRequest.prototype.getPair = function (pair) {
            var url = "https://shapeshift.io/marketinfo/" + pair;
            return $.getJSON(url).then(function (result) {
                return result;
            });
        };
        return ShapeshiftRequest;
    }());
    var ShapeShiftController = (function () {
        function ShapeShiftController(sendTransactionsController) {
            var _this = this;
            this.sendTransactionsController = sendTransactionsController;
            this.ON_EXCHANGE_CHANGED = 'ON_EXCHANGE_CHANGED';
            this.ON_SHIFT_CHANGED = 'ON_SHIFT_CHANGED';
            this.emitter$ = $({});
            this.onExchangeDataDownloaded = null;
            this.outsideClickHandler = this.onOutsideClick.bind(this);
            ShapeShiftController.instance = this;
            this.$sendLabel = $('#sendLabel');
            this.$view = $('#ShapeShiftView');
            this.$view.load('js/app/shape-shift/shape-shift-view.html', function (res) {
                setTimeout(function () { return _this.init(); }, 60);
            });
            this.confirmScreen = new jaxx.SendConfirmationView();
            this.shapeShiftNotAvailable = new jaxx.ShapeShiftNotAvailable();
            this.confirmScreen.onCancel = function () {
                _this.confirmScreen.hide();
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CANCEL_TRANSACTION, 'shapeShift');
            };
            this.confirmScreen.onConfirm = function () {
                _this.confirmScreen.hide();
                // A wrapper function that wrap the complete send transaction logic
                var completedSendTransaction = function () {
                    jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CONFIRM_TRANSACTION);
                    var ctr = jaxx.Registry.getCurrentCryptoController();
                    // Perform send transaction
                    ctr.sendTransaction(_this.sendTransactionsController.transaction).done(function (result) {
                        if (result.success === 'success') {
                            Navigation.flashBanner('ShapeShift Successful', 2, 'success');
                        }
                        else {
                            Navigation.flashBanner('ShapeShift Failed', 2);
                        }
                    }).fail(function (err) {
                        Navigation.flashBanner('ShapeShift Failed', 2);
                    });
                };
                //If user has pin setup then show the pin input screen
                if (g_JaxxApp.getUser().hasPin()) {
                    g_JaxxApp.getUI().showEnterPinModal(function (error) {
                        //If input pin error, return without proceed to transaction
                        if (error) {
                            console.log("enter pin error :: " + error);
                            return;
                        }
                        //Pin enter succeed, proceed to complete transaction
                        completedSendTransaction();
                    });
                }
                else {
                    // If no pin setup then proceed to complete transaction
                    completedSendTransaction();
                }
            };
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE_ANIMATION_END, function () {
                _this.onShapeShiftWalletAnimationEnded();
            });
        }
        /**
         * Function to fire after the animation of switching the from coin / token in the ShapeShift drop down menu
         * @method onShapeShiftWalletAnimationEnded
         * */
        ShapeShiftController.prototype.onShapeShiftWalletAnimationEnded = function () {
            jaxx.Registry.application.balanceController.fiatBalanceView.updatefiatWalletBalance(jaxx.Registry.getCurrentCryptoController().symbol);
            setTimeout(function () {
                jaxx.Registry.application.spinner.hideSpinner(function () {
                    jaxx.Registry.application.spinner.animateInAllWalletElements();
                });
            }, 1000);
        };
        ShapeShiftController.prototype.isReady = function (amountDecimal, callBack) {
            var amount = amountDecimal;
            this.amountToSend = String(amountDecimal);
            if (!this.exchange) {
                callBack({ warn: { message: 'no exchange yet' } });
                return;
            }
            console.log('SS  ' + amount + ' depositMin ' + this.exchange.minimum + ' depositMax ' + this.exchange.minimum);
            amount = amount - this.exchange.minerFee;
            if (this.exchange.minimum < amount && this.exchange.maxLimit > amount) {
                callBack({ success: this.exchange });
            }
            else {
                var resp = {
                    warn: {
                        message: 'no exchange yet'
                    }
                };
                callBack(resp);
            }
        };
        ShapeShiftController.prototype.onOutsideClick = function () {
            if (!this.clickedOutside) {
                this.hideList();
            }
            else {
                this.clickedOutside = false;
            }
        };
        /**
         * When the dropdown menu button is click it will show the list
         * @method showList
         * @param {ShapeShiftDropDownMenuType} shapeshiftMenuType
         * */
        ShapeShiftController.prototype.showList = function (shapeshiftMenuType) {
            if (shapeshiftMenuType === ShapeShiftDropDownMenuType.To) {
                this.$listViewTo.fadeIn(150);
                this.$buttonShowListImageTo.removeClass('cssFlipped');
            }
            else if (!this.isFromListEmpty) {
                this.$listViewFrom.fadeIn(150);
                this.$buttonShowListImageFrom.removeClass('cssFlipped');
            }
            window.addEventListener('click', this.outsideClickHandler);
            this.isLastOpen = true;
        };
        /**
         * Hides the dropdown list
         * @method hideList
         * */
        ShapeShiftController.prototype.hideList = function () {
            this.isLastOpen = false;
            this.$listViewTo.fadeOut(150);
            this.$listViewFrom.fadeOut(150);
            this.$buttonShowListImageTo.addClass('cssFlipped');
            this.$buttonShowListImageFrom.addClass('cssFlipped');
            window.removeEventListener('click', this.outsideClickHandler);
        };
        ShapeShiftController.prototype.init = function () {
            var _this = this;
            this.$help = $('#ShapeShiftHelp').hide();
            this.visible = false;
            this.request = new ShapeshiftRequest();
            this.$listTo = $('#ShapeshiftCoinSelectionList');
            this.$listFrom = $('#ShapeshiftCoinSelectionListFrom');
            this.$listViewTo = $('#ShapeShiftListView');
            this.$listViewFrom = $('#ShapeShiftListViewFrom');
            this.$symbolFrom1 = $('.shapeShiftAbbreviatedUnitSend');
            this.$symbolTo1 = $('#ShapeShift-symbolTo1');
            this.$symbolTo2 = $('#ShapeShift-symbolTo2');
            this.$rate = $('#ShapeShift-rate');
            this.$depositMin = $('#ShapeShiftDepositMin');
            this.$depositMax = $('#ShapeShiftDepositMax');
            this.$depositMinCaution = $('#depositMinCaution');
            this.$depositMaxCaution = $('#depositMaxCaution');
            this.$From = $('#ShapeShift-From');
            this.$To = $('#ShapeShift-To');
            this.$shapeShiftHelp = $('#ShapeShiftHelp');
            this.$shapeShiftInfoButton = $('#shapeShiftInfoButton');
            this.$shapeShiftClose = $('#ShapeShiftClose');
            this.$buttonDropDownTo = $('#ShapeShift-buttonShowList');
            this.$buttonShowListImageTo = $('#ShapeShift-buttonShowList-Image');
            this.$buttonShowListFrom = $('#ShapeShift-buttonShowList-From');
            this.$buttonShowListImageFrom = $('#ShapeShift-buttonShowList-Image-From');
            this.$maxButton = $('#shapeShiftMaxButton');
            this.isFromListEmpty = false;
            this.$buttonDropDownTo.on('click', function () {
                _this.clickedOutside = true;
                if (_this.isLastOpen) {
                    _this.hideList();
                }
                else {
                    _this.showList(ShapeShiftDropDownMenuType.To);
                }
            });
            //click listener for the shapeshift from drop down button
            this.$buttonShowListFrom.on('click', function () {
                _this.clickedOutside = true;
                if (_this.isLastOpen) {
                    _this.hideList();
                }
                else {
                    _this.showList(ShapeShiftDropDownMenuType.From);
                }
            });
            //click listener for the shapeshift to drop down button
            this.$listTo.on('click', 'tr', function (el) {
                var element = $(el.currentTarget);
                var symbol = element.data('symbol');
                _this.changeCoinShiftToType(symbol);
            });
            //clicking on list items in the shapeshift from menu
            this.$listFrom.on('click', 'tr', function (el) {
                var element = $(el.currentTarget);
                var symbol = element.data('symbol');
                _this.transitionState(symbol);
                jaxx.Registry.application$.trigger(jaxx.Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE, symbol);
            });
            //listens for shape shift coin animation change
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE_ANIMATION_END, function () {
                jaxx.Registry.application$.trigger(jaxx.Registry.ON_COIN_SATUS_CHANGED);
                _this.renderShapeShiftView();
                _this.renderLists();
            });
            this.$shapeShiftHelp.show();
            this.$shapeShiftInfoButton.on('click', function () {
                _this.clickShapeShiftInfoToggle();
            });
            this.$shapeShiftClose.on('click', function () {
                _this.clickShapeShiftClose();
            });
            //click event listener for shape shift max button click
            this.$maxButton.on('click', function () {
                _this.sendTransactionsController.updateFieldWithBalance(_this.sendTransactionsController.$amount, _this.sendTransactionsController.spendableView.getSpendable());
                _this.sendTransactionsController.amountDidChangeListener();
                // When max is input into the amount field, remove the placeholder text
                _this.sendTransactionsController.$amount.attr("placeholder", "");
            });
        };
        ShapeShiftController.prototype.setLastToSelected = function () {
            var symbol = this.lastSymbol;
            this.changeCoinShiftToType(symbol);
        };
        /**
         * function that is fired when user click on shape shift to list item
         * @method changeCoinShiftToType
         * @param {String} symbol
         * */
        ShapeShiftController.prototype.changeCoinShiftToType = function (symbol) {
            if (!symbol || symbol == "XXX") {
                throw new Error("ShapeShift Error: Cannot find symbol or temporarily unavailable.");
            }
            var el = this.$listTo.find("[data-symbol=" + symbol + "]");
            this.ctrTo = jaxx.Registry.getCryptoControllerBySymbol(symbol);
            this.$selected = el;
            this.lastSymbol = symbol;
            this.hideList();
            this.downloadExchange(null);
        };
        ShapeShiftController.getAPIKey = function () {
            var apiKey = DCConfig.apiKeys.SHAPESHIFT;
            if (apiKey) {
                return apiKey;
            }
            else {
                return '180aaede8f5451a52847824f4965cc25f43a5d2bb49f483c1f1ecc8afad661b65e22a01046bfd67257e31189b48f5a1ec35207653bd017f8203f4241c763074a';
            }
        };
        ShapeShiftController.prototype.shift = function (amount, callBack) {
            var _this = this;
            if (!this.ctrFrom || !this.ctrTo) {
                callBack({ error: 'from and to has to be set  ' });
                console.error('from and to has to be set ', this.ctrTo, this.ctrFrom);
                return;
            }
            var addressFrom = this.ctrFrom.getCurrentAddress();
            var addressTo = this.ctrTo.getCurrentAddress();
            var data = {
                pair: this.exchange.pair,
                returnAddress: addressFrom,
                withdrawal: addressTo,
                apiKey: ShapeShiftController.getAPIKey()
            };
            var amountToDeposit;
            console.warn('get  tDepositAddress   ');
            this.request.getShift(data).done(function (res) {
                _this.currentShift = res;
                res.miningFee = _this.exchange.minerFee;
                console.log(_this.sendTransactionsController.$amount.val());
                console.log(jaxx.FiatPriceController.instance.getActiveFiatCurrency());
                console.log(jaxx.Registry.getCurrentCryptoController().symbol);
                console.log(jaxx.FiatPriceController.fiatToCoin(_this.sendTransactionsController.$amount.val(), jaxx.FiatPriceController.instance.getActiveFiatCurrency(), jaxx.Registry.getCurrentCryptoController().symbol));
                if (_this.sendTransactionsController.cryptoToFiatButton.isFiat) {
                    amountToDeposit = Number(jaxx.FiatPriceController.fiatToCoin(_this.sendTransactionsController.$amount.val(), jaxx.FiatPriceController.instance.getActiveFiatCurrency(), jaxx.Registry.getCurrentCryptoController().symbol));
                    res.displayAmountToDeposit = String(_this.sendTransactionsController.$amount.val());
                }
                else {
                    amountToDeposit = Number(_this.sendTransactionsController.$amount.val());
                    res.displayAmountToDeposit = jaxx.Formatters.balanceForDisplay(String(amountToDeposit), 8);
                }
                console.warn('Amount to Desposit: ', amountToDeposit);
                var exchangeRate = Number($('#ShapeShift-rate').text());
                res.displayAmountToWithdraw = jaxx.Formatters.balanceForDisplay(String(amountToDeposit * exchangeRate), 8);
                res.amountToDeposit = amountToDeposit;
                console.warn('Amount to Withdraw: ', res.displayAmountToWithdraw);
                callBack(res);
                _this.emitter$.triggerHandler(_this.ON_SHIFT_CHANGED, _this.currentShift);
            }).fail(function (error) {
                callBack({ error: error });
            });
        };
        ShapeShiftController.prototype.toggle = function () {
            if (this._isActive) {
                this.deactivate();
                this.hide();
            }
            else {
                this.activate();
                this.show();
            }
        };
        ShapeShiftController.prototype.deactivate = function () {
            console.log('SS deactivating ' + this._isActive);
            if (!this._isActive) {
                return;
            }
            this._isActive = false;
            this.minerFee = undefined; // this informs that the miner fee hasn't been update yet
        };
        ShapeShiftController.prototype.activate = function () {
            if (this._isActive) {
                return;
            }
            this._isActive = true;
            console.log(' SS ACTIVATE ' + this._isActive);
            this.updateShapeShiftView();
        };
        /**
         * Updates the shapeshift view
         * @method updateShapeShiftView
         * */
        ShapeShiftController.prototype.updateShapeShiftView = function () {
            var _this = this;
            this.ctrFrom = jaxx.Registry.getCurrentCryptoController();
            if (!this.ctrFrom) {
                console.error(' no current crypto controller');
                return;
            }
            if (this.ctrFrom.symbol === 'BTC') {
                this.ctrTo = jaxx.Registry.getCryptoControllerBySymbol('ETH');
            }
            else {
                this.ctrTo = jaxx.Registry.getCryptoControllerBySymbol('BTC');
            }
            this.downloadExchange(function (exchange) {
                _this.minerFee = exchange.minerFee;
                if (_this.onExchangeDataDownloaded != null) {
                    _this.onExchangeDataDownloaded();
                }
            });
        };
        /*        updateSpendable() {
                    this.loadingSpendable();
        
                    setTimeout(() => {
                        let spendable: string;
                        let coinSymbol: string = Registry.getCurrentCryptoController().symbol;
                        let fiatCode: string = FiatPriceController.instance.getActiveFiatCurrency();
        
                        if (this.sendTransactionsController.cryptoToFiatButton.isFiat) {
                            spendable = String(FiatPriceController.coinToFiat(Formatters.balanceForDisplay(String(Number(Registry.getCurrentCryptoController().getSpendable()))), coinSymbol, fiatCode));
                        } else {
                            spendable = Formatters.balanceForDisplay(String(Number(Registry.getCurrentCryptoController().getSpendable())));
                        }
        
                        if (MATH.displayGreaterAthenB(spendable, '0')) {
                            this.sendTransactionsController.spendableView.spendable = spendable;
                        } else {
                            this.sendTransactionsController.spendableView.spendable = '0';
                        }
        
                        if (this.sendTransactionsController.cryptoToFiatButton.isFiat) {
                            this.sendTransactionsController.spendableView.$amount.text(Formatters.balanceForDisplay(this.sendTransactionsController.spendableView.spendable, 2));
                        } else {
                            this.sendTransactionsController.spendableView.$amount.text(Formatters.balanceForDisplay(this.sendTransactionsController.spendableView.spendable, 8));
                        }
        
                        this.finishLoadingSpendable();
                    }, 1000);
                }*/
        // Updates the spendable amount as soon as the exchange data is downloaded 
        // or right away if the data is readly available
        // calls onDone when the update has been made
        ShapeShiftController.prototype.setSpendableAmount = function (amount, onDone) {
            var _this = this;
            var spendableData = {
                amount: amount,
                amountSymbol: undefined,
                isFiat: this.sendTransactionsController.cryptoToFiatButton.isFiat,
                minerFee: this.minerFee,
                onDoneCallback: onDone,
                sentTxController: this.sendTransactionsController
            };
            // find out what our current coin type is
            var currentCrypto = jaxx.Registry.getCurrentCryptoController();
            if (currentCrypto) {
                spendableData.amountSymbol = currentCrypto.symbol;
            }
            else {
                onDone();
                throw new Error("Couldn't get the currently activated controller from Registry.getCurrentCryptController().");
            }
            // this means the minerFee wasn't yet downloaded from the exchange data
            if (this.minerFee === undefined) {
                // wait until the download is completed
                this.onExchangeDataDownloaded = function () {
                    spendableData.minerFee = _this.minerFee;
                    updateUI(spendableData);
                };
            }
            else {
                updateUI(spendableData);
            }
            function updateUI(data) {
                var minerFeeToBeDeducted;
                var feeDeductedAmount;
                var amountToBeShownInUI;
                if (data.isFiat) {
                    minerFeeToBeDeducted = new BigNumber(jaxx.FiatPriceController.coinToFiat(String(data.minerFee), data.amountSymbol, jaxx.FiatPriceController.instance.getActiveFiatCurrency()));
                }
                else {
                    minerFeeToBeDeducted = new BigNumber(data.minerFee);
                }
                feeDeductedAmount = new BigNumber(data.amount).subtract(minerFeeToBeDeducted).toString();
                if (jaxx.MATH.displayGreaterAthenB(amount, '0')) {
                    amountToBeShownInUI = feeDeductedAmount.toString();
                }
                else {
                    amountToBeShownInUI = '0';
                }
                data.sentTxController.spendableView.setSpendableAmount(amountToBeShownInUI, data.isFiat);
                if (data.onDoneCallback) {
                    data.onDoneCallback();
                }
            }
        };
        ShapeShiftController.prototype.loadingSpendable = function () {
            this.sendTransactionsController.spendableView.$spendableLoading.show();
            this.sendTransactionsController.spendableView.$amount.hide();
        };
        ShapeShiftController.prototype.finishLoadingSpendable = function () {
            this.sendTransactionsController.spendableView.$spendableLoading.hide();
            this.sendTransactionsController.spendableView.$amount.show();
        };
        ShapeShiftController.prototype.render = function () {
            this.$symbolFrom1.text(this.ctrFrom.threeLetterCode);
            this.$symbolTo1.text(this.ctrTo.threeLetterCode);
            this.$symbolTo2.text(this.ctrTo.threeLetterCode);
            this.$From.children('.cssCoinText').text(this.ctrFrom.displayName);
            this.$From.css({ "background-image": "url(" + this.ctrFrom.icon + ")" });
            this.$From.css({ "filter": "hue-rotate(" + this.ctrFrom.hueRotate + "deg)" });
            this.$To.children('.cssCoinText').text(this.ctrTo.displayName);
            this.$To.css({ "background-image": "url(" + this.ctrTo.icon + ")" });
            this.$To.css({ "filter": "hue-rotate(" + this.ctrTo.hueRotate + "deg)" });
            this.$depositMinCaution.removeClass('caution');
            this.$depositMin.removeClass('warningText');
            this.$depositMaxCaution.removeClass('caution');
            this.$depositMax.removeClass('warningText');
        };
        ShapeShiftController.prototype.renderData = function () {
            this.$rate.text(jaxx.Formatters.noExponentsStringFormat(this.exchange.rate)); // make sure its user readable
            this.$depositMin.text(this.exchange.minimum);
            this.$depositMax.text(this.exchange.maxLimit);
        };
        ShapeShiftController.prototype.downloadExchange = function (callBack) {
            var _this = this;
            this.render();
            if (!this.ctrFrom || !this.ctrTo) {
                console.error(' to and from has to be set');
                return;
            }
            console.log('downloadExchange  ' + this.ctrFrom.symbol + '   ' + this.ctrTo.symbol);
            var pair = this.ctrFrom.symbol.toLowerCase() + '_' + this.ctrTo.symbol.toLowerCase();
            console.log(pair);
            this.request.getPair(pair)
                .then(function (res) {
                return res;
            }).done(function (result) {
                _this.exchange = result;
                _this.pair = _this.exchange.pair;
                _this.renderData();
                _this.emitter$.triggerHandler(_this.ON_EXCHANGE_CHANGED, _this.exchange);
                if (callBack) {
                    callBack(result);
                }
            });
        };
        ShapeShiftController.prototype.isVisible = function () {
            return this.visible;
        };
        ShapeShiftController.prototype.greaterThanShapeShiftMin = function (userInput) {
            var shapeShiftMin = this.$depositMin.text();
            if (Number(userInput) > Number(shapeShiftMin)) {
                console.log('user input is greater than shapeShift min');
                return true;
            }
            else {
                console.log('user input is less than shapeShift min');
                return false;
            }
        };
        ShapeShiftController.prototype.lessThanShapeShiftMax = function (userInput) {
            var shapeShiftMax = this.$depositMax.text();
            if (Number(userInput) <= Number(shapeShiftMax)) {
                console.log('user input  is less than shapeShift max');
                return true;
            }
            else {
                console.log('user input is greater than shapeShift max');
                return false;
            }
        };
        /**
         * Renders the warning styles when below deposit min or above deposit max
         * @param userInput
         */
        ShapeShiftController.prototype.updateMinMaxWarnings = function (userInput) {
            // Reset all warning text/caution classes from the min/max divs
            this.$depositMinCaution.removeClass('caution');
            this.$depositMin.removeClass('warningText');
            this.$depositMaxCaution.removeClass('caution');
            this.$depositMax.removeClass('warningText');
            // If the input is too small show the warnings on the min divs
            if (!this.greaterThanShapeShiftMin(userInput)) {
                this.$depositMinCaution.addClass('caution');
                this.$depositMin.addClass('warningText');
            }
            // If the input is too large show the warnings on the max divs
            if (!this.lessThanShapeShiftMax(userInput)) {
                this.$depositMaxCaution.addClass('caution');
                this.$depositMax.addClass('warningText');
            }
        };
        ShapeShiftController.prototype.meetsShapeShiftMinMax = function (userInput) {
            // If user's input is greater than min and less than max: return true, otherwise return false
            return (this.greaterThanShapeShiftMin(userInput) && this.lessThanShapeShiftMax(userInput));
        };
        /**
         * Renders the shape shift list
         * @method renderLists
         * */
        ShapeShiftController.prototype.renderLists = function () {
            var symbolFrom = this.ctrFrom.symbol;
            var symbolTo = jaxx.Registry.getCurrentCryptoController().symbol;
            var coins = jaxx.Registry.getAllCryptoControllers();
            var enabledCoins = jaxx.Registry.getWalletsEnabledSorted();
            var htmlTo = '';
            var htmlFrom = '';
            var requiredCoinsList = [];
            var coinListFrom = [];
            coins = coins.filter(function (item) {
                if (item.shapeshift) {
                    requiredCoinsList.push(item.symbol);
                }
                return item.shapeshift;
            });
            enabledCoins = enabledCoins.filter(function (item) {
                if (item.shapeshift) {
                    coinListFrom.push(item.symbol);
                }
                return item.shapeshift;
            });
            this.renderList(requiredCoinsList, coins, symbolFrom, htmlTo, this.$listTo);
            this.renderList(coinListFrom, enabledCoins, symbolTo, htmlFrom, this.$listFrom);
        };
        /**
         * Populates the ShapeShift to list of available coins and token that you can shift to.
         * @method renderList
         * @param {Array} requiredCoinsList
         * @param {ICoinController[]} coins
         * @param {String} symbolFrom
         * @param {String} html
         * @param {JQuery} $list
         * */
        ShapeShiftController.prototype.renderList = function (requiredCoinsList, coins, symbolFrom, html, $list) {
            var _this = this;
            DCShapeShift.availableCoins({ isAvailable: true, requiredCoins: requiredCoinsList, symbolsOnly: true }, function (coinList) {
                html = _this.generateShapeShiftList(coins, symbolFrom, coinList, html);
                $list.html(html);
                if ($list.html().length <= 0) {
                    _this.$buttonShowListImageFrom.css('opacity', '0.5');
                    _this.isFromListEmpty = true;
                }
                else {
                    _this.$buttonShowListImageFrom.css('opacity', '1');
                    _this.isFromListEmpty = false;
                }
            }, function (err) {
                console.error(err);
            });
        };
        /**
         * Generates ShapeShift list
         * @method generateShapeShiftList
         * @param {ICoinController[]} coins
         * @param {String} symbol
         * @param {} coinList
         * @param {String} html
         * @return {String} A DOM element in string format
         * */
        ShapeShiftController.prototype.generateShapeShiftList = function (coins, symbol, coinList, html) {
            coins.forEach(function (coin) {
                var hueRotation = coin.hueRotate;
                if (coin.symbol !== symbol) {
                    //added a check to see if crypto is available on shapeshift and if it is currenlty available
                    var shapeshiftCoin = coinList.getCoinWithSymbol(coin.symbol);
                    var isAvailable = false;
                    if (shapeshiftCoin) {
                        if (shapeshiftCoin.isAvailable()) {
                            isAvailable = true;
                        }
                    }
                    if (isAvailable) {
                        html += '<tr data-symbol="'
                            + coin.symbol
                            + '" data-available="'
                            + '" class="shapeShiftCoinItem cssShapeShiftCoinListItem coinType'
                            + coin.coinType
                            + '" value="'
                            + coin.coinType
                            + '"><td class="icon cssHighlighted'
                            + '" style="background-image: url('
                            + coin.icon
                            + '); filter: hue-rotate(' + hueRotation + 'deg)"></td><td class="label">'
                            + coin.threeLetterCode
                            + ' - '
                            + coin.displayName
                            + '</td></tr>';
                        //checks to see if the crypto is available on shapeshift but is not currently available
                    }
                    else if (!isAvailable && shapeshiftCoin) {
                        html += '<tr data-symbol="XXX"'
                            + '" data-available="'
                            + '" class="cssShapeShiftCoinListItem coinType'
                            + coin.coinType
                            + '" value="'
                            + coin.coinType
                            + '"><td class="icon cssHighlighted'
                            + '" style="background-image: url('
                            + coin.icon
                            + '); filter: hue-rotate(' + hueRotation + 'deg); opacity:0.4"></td><td class="label" style="color:#959595">'
                            + coin.threeLetterCode
                            + ' - '
                            + 'Unavailable'
                            + '</td></tr>';
                    }
                }
            });
            return html;
        };
        ShapeShiftController.prototype.hide = function () {
            if (this.visible) {
                this.$view.slideUp();
            }
            this.visible = false;
            this.showAvailable();
        };
        ShapeShiftController.prototype.showAvailable = function () {
            this.sendTransactionsController.$view.find('.available').show();
            this.sendTransactionsController.$view.find('.notAvailable').hide();
        };
        ShapeShiftController.prototype.hideSendTransaction = function () {
            this.sendTransactionsController.$view.find('.available').hide();
        };
        ShapeShiftController.prototype.shapeShiftIsAvailable = function (cb) {
            var _this = this;
            this.hideSendTransaction();
            DCShapeShift.availableCoins({
                isAvailable: true,
                requiredCoins: [jaxx.Registry.getCurrentCryptoController().symbol],
                symbolsOnly: true
            }, function (coinList) {
                var coin = coinList.getCoinWithSymbol(jaxx.Registry.getCurrentCryptoController().symbol);
                if (coin) {
                    if (coin._status === "unavailable") {
                        return _this.notAvailable();
                    }
                    _this.showAvailable();
                    cb();
                }
                else {
                    _this.notAvailable();
                }
            }, function (err) {
                console.error(err);
            });
        };
        /*
        * Displays a modal stating that shapeshift is not available.
        * @method notAvailable*/
        ShapeShiftController.prototype.notAvailable = function () {
            var _this = this;
            this.sendTransactionsController.resetAll();
            return this.shapeShiftNotAvailable.show(function () {
                _this.showAvailable();
            });
        };
        ShapeShiftController.prototype.show = function () {
            if (!this.visible) {
                var coinFrom = jaxx.Registry.getCurrentCryptoController();
                var coins = jaxx.Registry.getShapeShiftEnabled();
                var coinTo = (coins[0].symbol !== coinFrom.symbol) ? coins[0] : coins[1];
                jaxx.Registry.shapeShiftTo = coinTo;
                this.$view.slideDown();
                if (!this.isListRendered) {
                    this.renderLists();
                }
            }
            this.visible = true;
            return this;
        };
        /**
         * Renders shapeShift view
         * @method renderShapeShiftView
         * */
        ShapeShiftController.prototype.renderShapeShiftView = function () {
            this.updateShapeShiftView();
            var coinFrom = jaxx.Registry.getCurrentCryptoController();
            var coins = jaxx.Registry.getShapeShiftEnabled();
            var coinTo = (coins[0].symbol !== coinFrom.symbol) ? coins[0] : coins[1];
            jaxx.Registry.shapeShiftTo = coinTo;
        };
        ShapeShiftController.prototype.isActive = function () {
            return this._isActive;
        };
        /**
         * Updates the shapeshift view to a loading state
         * @method transitionState
         * @param {String} symbol
         * */
        ShapeShiftController.prototype.transitionState = function (symbol) {
            if (!symbol || symbol == "XXX") {
                throw new Error("ShapeShift Error: Cannot find symbol or temporarily unavailable.");
            }
            jaxx.Registry.setCurrentControllerBySymbol(symbol);
            this.exchange.minimum = null;
            this.exchange.maxLimit = null;
            this.exchange.rate = null;
            this.exchange = null;
            this.pair = null;
            this.$depositMin.text('- - -');
            this.$depositMax.text('- - -');
            this.$rate.text('- - -');
        };
        return ShapeShiftController;
    }());
    jaxx.ShapeShiftController = ShapeShiftController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=shape-shift-controller.js.map
var jaxx;
(function (jaxx) {
    var ShapeShiftNotAvailable = (function () {
        function ShapeShiftNotAvailable() {
            var _this = this;
            this.$view = $('#shapeshiftNotAvailable');
            this.$view.load('js/app/shape-shift/not-available.html', function () {
                _this.init();
            });
        }
        ShapeShiftNotAvailable.prototype.init = function () {
            var _this = this;
            this.$buttonUnderstand = this.$view.find('#shapeshiftNAUnderstand');
            this.$buttonClose = this.$view.find('.cssClose');
            this.$buttonUnderstand.on('click', function () {
                _this.hide();
            });
            this.$buttonClose.on('click', function () {
                _this.hide();
            });
        };
        ShapeShiftNotAvailable.prototype.hide = function () {
            this.$view.addClass('hideNotificationFooter');
        };
        ShapeShiftNotAvailable.prototype.show = function (callback) {
            var height;
            var isMobile = PlatformUtils.mobileCheck();
            var isExtension = PlatformUtils.extensionCheck();
            var isNotIPad = !(PlatformUtils.mobileIpadCheck());
            if ((isMobile || isExtension) && isNotIPad) {
                // Transaction History height is equal to the whole document minus the top menu portion
                height = ($(document).height() - $('#TransactionsHeader').offset().top);
            }
            else {
                height = "100%";
            }
            this.$view.find('.cssNotificationFooter').height(height);
            if (!isNotIPad) {
                this.$view.find('.cssNotificationFooter').width('50%');
                this.$view.find('.cssNotificationFooter').css('left', '50%');
            }
            this.$view.find('.coinName').text(jaxx.Registry.getCurrentCryptoController().displayName);
            this.$view.find('.coinSymbol').text(jaxx.Registry.getCurrentCryptoController().symbol);
            this.$view.removeClass('hideNotificationFooter');
            if (callback) {
                callback();
            }
        };
        return ShapeShiftNotAvailable;
    }());
    jaxx.ShapeShiftNotAvailable = ShapeShiftNotAvailable;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=shape-shift-not-available.js.map
//# sourceMappingURL=shape-shift-components.js.map
//- DCShapeShift.js ---------------------------------------------------------------------------------------------------------------

"use strict";

var DCShapeShift = {
    cache: {
        lastCheck: null,
        coins: null
    },
    constants: {
        "ALL_COINS":null,
        "COIN_AVAILABLE":"available",
        "COIN_UNAVAILABLE":"unavailable"
    },
    messages: {
        "COIN_PAIR_ERROR":"Invalid Coin Pair sent to ShapeShift.",
        "COMMUNICATION_ERROR":"Unable to communicate with ShapeShift; please try again shortly.",
        "SHAPESHIFT_REGISTRY_TO_MISSING":"Registry value for 'shapeShiftTo' is invalid."
    },
    errors: {
        "UNKNOWN_PAIR":"Unknown pair"
    },
    util: {
    }
}

//- DCShapeShift.availableCoins ---------------------------------------------------------------------------------------------------
DCShapeShift.availableCoins = function(options, callbackSuccess, callbackFailure){
    var isAvailableCheck = false;
    var requiredCoins = DCShapeShift.constants.ALL_COINS;
    var symbolsOnly = false;
    var difference
    if(!this.cache.lastCheck) {
        this.cache.lastCheck = this.cache.lastCheck = new Date().getTime();
        difference = 600000;
    } else {
         difference = new Date().getTime() - this.cache.lastCheck
    }

    if(difference >= 600000) {
        this.cache.lastCheck = new Date().getTime();

        if (options) {
          if (options.isAvailable) isAvailableCheck = options.isAvailable;
          if (options.requiredCoins) requiredCoins = options.requiredCoins;
          if (options.symbolsOnly) symbolsOnly = options.symbolsOnly;
        }
        DCUtil.get(DCConfig.endpoints.SHAPESHIFT_AVAILABLE_COINS, function(coins) {
            DCShapeShift.cache.coins = coins;
            callbackSuccess(new DCCoinList(coins, requiredCoins, isAvailableCheck, symbolsOnly));
          },
          function(err) {
            if(DCShapeShift.cache.coins) {
              callbackSuccess(new DCCoinList(DCShapeShift.cache.coins, requiredCoins, isAvailableCheck, symbolsOnly));
            } else {
              callbackFailure({ "message":err, "source":DCConfig.errorSources.NETWORK });
            }
        });
    } else {
        callbackSuccess(new DCCoinList(DCShapeShift.cache.coins, requiredCoins, isAvailableCheck, symbolsOnly));
    }

}

//- DCShapeShift.marketInfo -------------------------------------------------------------------------------------------------------
DCShapeShift.marketInfo = function(options, callbackSuccess, callbackFailure){
    var requestedPair = null;
    var url = DCConfig.endpoints.SHAPESHIFT_MARKET_INFO;

    if (options) {
        if (options.fromSymbol && (options.fromSymbol.length > 0) && options.toSymbol && (options.toSymbol.length > 0)) {
            requestedPair = options.fromSymbol + '_' + options.toSymbol;
            url += '/' + requestedPair;
        }
    }
    DCUtil.get(url, function(response) {
        if (response.error) return callbackFailure({ "message":response.error, "source":DCConfig.errorSources.SERVICE });
        if (requestedPair) {
            callbackSuccess(new DCCoinPair(response));
        } else {
            callbackSuccess(new DCCoinPairList(response));
        }
    },
    function(err) {
        callbackFailure({ "message":err, "source":DCConfig.errorSources.NETWORK });
    });
}

//- DCUtil.js ---------------------------------------------------------------------------------------------------------------------
"use strict";

var DCUtil = {
    buildErrorMsg: function (message1, message2) {
        var msg = "";
            
        if (message1 && message1.length) msg = message1;
        if (message2 && message2.length) {
            if (msg.length) msg += "; ";
                msg += message2;
            }
        if (!msg.length) msg = "No Error Message provided.";   
        return msg;
    },
    get: function (url, callbackSuccess, callbackFailure) {
        var req = new XMLHttpRequest();
        req.onreadystatechange = function () {
            if (req.readyState === 4 && req.status === 200) {
                var json = {};

                try {
                    json = JSON.parse(req.responseText);
                    callbackSuccess(json);
                }
                catch(err) {
                    callbackFailure(DCUtil.buildErrorMsg("JSON Parse Error @ " + url, err));
                }
            }
            else if (req.readyState === 4 && (req.status === 0 || req.status === 401 || req.status === 404)) {
                callbackFailure(DCUtil.buildErrorMsg("Error: GET " + url, req.responseText));
            }
        };
        req.open("GET", url, true);
        req.send();
    }
}
//- DCConfig.js -------------------------------------------------------------------------------------------------------------------
"use strict";

var DCConfig = {
    apiKeys: {
        "SHAPESHIFT": "180aaede8f5451a52847824f4965cc25f43a5d2bb49f483c1f1ecc8afad661b65e22a01046bfd67257e31189b48f5a1ec35207653bd017f8203f4241c763074a"
    },
    endpoints: {
        "BITCOINFEES_21_RECOMMENDED": "https://bitcoinfees.21.co/api/v1/fees/recommended",
        "DASH_BLOCKCHAIN_INFO": "https://api.jaxx.io/api/dash/blockchainInfo",
        "ETH_BLOCKCHAIN_INFO": "https://api.jax.io/api/eth/latestBlockNumberInserted",
        "SHAPESHIFT_AVAILABLE_COINS": "https://shapeshift.io/getcoins",
        "SHAPESHIFT_MARKET_INFO": "https://shapeshift.io/marketinfo"
    },
    errorSources: {
        "NETWORK": "network",
        "SERVICE": "service"
    }
};

//- DCCoin.js ---------------------------------------------------------------------------------------------------------------------
"use strict";


//- DCCoin ------------------------------------------------------------------------------------------------------------------------
var DCCoin = function (shapeShiftCoin) {
    if (shapeShiftCoin) {
        this._imageUrl = shapeShiftCoin.image;
        this._imageSmallUrl = shapeShiftCoin.imageSmall;
        this._name = shapeShiftCoin.name;
        this._status = shapeShiftCoin.status;
        this._symbol = shapeShiftCoin.symbol;
    } else {
        this._imageUrl = "";
        this._imageSmallUrl = "";
        this._name = "";
        this._status = DCShapeShift.contants.COIN_UNAVAILABLE;
        this._symbol = "";
    }
}
DCCoin.prototype.imageUrl = function () { return this._imageUrl; }
DCCoin.prototype.imageSmallUrl = function () { return this._imageSmallUrl; }
DCCoin.prototype.isAvailable = function () { return(this && this._status === DCShapeShift.constants.COIN_AVAILABLE); }
DCCoin.prototype.name = function () { return this._name; }
DCCoin.prototype.status = function () { return this._status; }
DCCoin.prototype.symbol = function () { return this._symbol; }


//- DCCoinList --------------------------------------------------------------------------------------------------------------------
var DCCoinList = function (shapeShiftCoins, requiredCoins, isAvailableCheck, symbolsOnly) {
    this._dictionary = {};
    this._numberOfCoins = 0;
    this._symbolArray = null;

    if (isAvailableCheck === undefined) isAvailableCheck = false;
    if (symbolsOnly === undefined) symbolsOnly = false;
    if (shapeShiftCoins) {
        var match = null;

        if (requiredCoins && (requiredCoins instanceof Array)) {
            match = {};
            requiredCoins.forEach(function(coin) {
               match[coin] = coin;
            });
        }
        for (var key in shapeShiftCoins) {
            if (shapeShiftCoins.hasOwnProperty(key)) {
                var coin = new DCCoin(shapeShiftCoins[key]);
                var coinFound = false;

                if (match && (match[coin.name()] || match[coin.symbol()])) coinFound = true;
                if (!match || coinFound) {
                    coinFound = (isAvailableCheck) ? coin.isAvailable() : true;
                    if (coinFound) {
                      if (!symbolsOnly) this._dictionary[coin.name()] = coin;
                      this._dictionary[coin.symbol()] = coin;
                      this._numberOfCoins++;
                    }
                }
            }
        }
    }
}
DCCoinList.prototype.count = function () { return this._numberOfCoins; }
DCCoinList.prototype.getCoinWithName = function (name) { return this._dictionary[name]; }
DCCoinList.prototype.getCoinWithSymbol = function (symbol) { return this._dictionary[symbol]; }
DCCoinList.prototype.symbolArray = function () {
  if (this.numberOfCoins === 0) return [];
  if (this._symbolArray !== null) return this._symbolArray;

  var sArray = [];
  for (var key in this._dictionary) {
      if (this._dictionary.hasOwnProperty(key)) {
        var coin = this._dictionary[key];
        if (key === coin.symbol()) sArray.push(key);
      }
  }
  this._symbolArray = sArray.sort();
  return this._symbolArray;
}


//- DCCoinPair --------------------------------------------------------------------------------------------------------------------
var DCCoinPair = function (shapeShiftCoinPair) {
    if (shapeShiftCoinPair) {
        this._limit = shapeShiftCoinPair.limit,
        this._maxLimit = shapeShiftCoinPair.maxLimit,
        this._minimum = shapeShiftCoinPair.minimum,
        this._minerFee = shapeShiftCoinPair.minerFee,
        this._name = shapeShiftCoinPair.pair,
        this._rate = shapeShiftCoinPair.rate
    } else {
        this._limit = 0,
        this._maxLimit = 0,
        this._minimum = 0,
        this._minerFee = 0,
        this._name = "",
        this._rate = 0
    }
}
DCCoinPair.prototype.limit = function () { return this._limit; }
DCCoinPair.prototype.maxLimit = function () { return this._maxLimit; }
DCCoinPair.prototype.minimum = function () { return this._minimum; }
DCCoinPair.prototype.minerFee = function () { return this._minerFee; }
DCCoinPair.prototype.name = function () { return this._name; }
DCCoinPair.prototype.rate = function () { return this._rate; }


//- DCCoinPairList ----------------------------------------------------------------------------------------------------------------
var DCCoinPairList = function(shapeShiftCoinPairs) {
    this._dictionary = {};
    this._numberOfCoinPairs = 0;

    if (shapeShiftCoinPairs) {
        for (var key in shapeShiftCoinPairs) {
            if (shapeShiftCoinPairs.hasOwnProperty(key)) {
                var coinPair = new DCCoinPair(shapeShiftCoinPairs[key]);

                if ((coinPair.limit() !== 0 && coinPair.maxLimit() !== 0)) {
                    this._dictionary[coinPair.name()] = coinPair;
                    this._numberOfCoinPairs++;
                }
            }
        }
    }
}
DCCoinPairList.prototype.count = function(){ return this._numberOfCoinPairs; }
DCCoinPairList.prototype.getCoinPairWithCombination = function(coinSymbol1, coinSymbol2){
    if (coinSymbol1 && conSymbol1.length && coinSymbol2 && coinSymbol2.length) {
        return this._dictionary[coinSymbol1.toUpperCase() + "_" + coinSymbol2.toUpperCase()];
    }
    return null;
}
DCCoinPairList.prototype.getCoinPairWithName = function(name){ return this._dictionary[name]; }

var jaxx;
(function (jaxx) {
    var CryptoToFiatButtonComponent = (function () {
        function CryptoToFiatButtonComponent() {
            var _this = this;
            this.isFiat = false;
            this.$view = $('#fiatToCrypto');
            this.$view.on('click', function (evt) {
                _this.onClick();
            });
            this.$symbol = this.$view.find('.symbol').first();
        }
        return CryptoToFiatButtonComponent;
    }());
    jaxx.CryptoToFiatButtonComponent = CryptoToFiatButtonComponent;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=send-transaction-fiat-controller.js.map
// global instance handle for in-console testing
var global_send_controller;
var jaxx;
(function (jaxx) {
    var SendTransactionsController = (function () {
        function SendTransactionsController() {
            var _this = this;
            global_send_controller = this;
            SendTransactionsController.instance = this;
            this.receiveTransactionsView = new jaxx.ReceiveTransactionView(this);
            this.$view = $('#SendTransactionView');
            this.$view.load('js/app/send-transaction/send-transaction.html', null, function (res) {
                setTimeout(function () { return _this.init(); }, 1000);
            });
            this.confirmScreen = new jaxx.SendConfirmationView(this);
            this.confirmScreen.emitter$.on(this.confirmScreen.ON_CANCEL, function (evt) {
            });
            this.fiatController = jaxx.FiatPriceController.instance;
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE_ANIMATION_END, function () {
                _this.setUseFiat(_this.cryptoToFiatButton.isFiat);
                _this.spendableView.update(0);
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE, function () {
                // When a new "From" coin is selected in the ShapeShift menu, we need to temporarily set all the
                // values in the menu window to placeholders while the new wallet is initializing to communicate
                // to the user that a switch is happening and to hide old wallet values
                _this.spendableView.spendable = '0';
                _this.spendableView.$amount.text('- - -');
                _this.spendableView.$spendableCryptoSymbol.text(jaxx.Registry.getCurrentCryptoController().symbol);
            });
        }
        SendTransactionsController.prototype.init = function () {
            var _this = this;
            setTimeout(function () { return _this.resetAll(); }, 100);
            this.$sendAddressView = $('#SendAddressView');
            this.$receiveTabBtn = $('#ReceiveTabBtn');
            this.$sendTabBtn = $('#SendTabBtn');
            this.$shapeShiftFoxBtn = $('#ShapeSiftFoxBtn');
            this.$inputCustomGasLimit = $('.inputCustomGasLimit');
            this.$inputCustomData = $('#inputCustomData');
            this.$keyBoardSectionHideMe = $('#keyBoardSectionHideMe');
            this.$advanceSendArrow = $('#advanceSendArrow');
            this.$advancedTabButton = $('#advancedTabButton');
            this.$receiveTabLabel = $('#receiveTabLabel');
            this.$exchangeTabLabel = $('#exchangeTabLabel');
            this.$sendTabLabel = $('#sendTabLabel');
            this.$receiveTabImage = $('#receiveTabImage');
            this.$exchangeTabImage = $('#exchangeTabImage');
            this.$sendTabImage = $('#sendTabImage');
            this.$qrCodeButton = this.$sendAddressView.children('.imageQR');
            this.$receiveTabBtn.on('click', function () {
                _this.setState('receive');
            });
            this.$sendTabBtn.on('click', function () {
                _this.setState('send');
            });
            this.$gasForSpendableWarning = $('#GasForSpendableWarning');
            this.$receiverAddress = $('#receiver_address');
            // save initial CSS width of the receiving address
            // it will be used to restore the receiving address box to its designed state when QR code should be visible
            var currentCssWidth = this.$receiverAddress.css('width');
            this.$receiverAddress.data('jaxx-css-initial-width', currentCssWidth);
            this.$sendLabel = $('#sendLabel');
            this.shapeShift = new jaxx.ShapeShiftController(this);
            this.spendableView = new jaxx.SpendableView();
            this.$maxBtn = $('#MaxButton');
            this.$mainInputField = $('#amountInput');
            this.$amount = $('#amountSendInput');
            this.$fiatAmount = $('#fiatSendValue');
            this.$sendToAddress = $('#receiver_address');
            this.$helpSpendable = $('#SpendableHelp');
            this.sendButton = new jaxx.SendButtonComponent(this);
            this.$sendButtonLabel = this.sendButton.$view.find('#sendLabel');
            this.$receiveButtonLabel = this.sendButton.$view.find('#receiveLabel');
            this.$sendButtonAnimation = this.sendButton.$view.find('.shiftingProgress.cssShiftingProgress');
            this.validToSend = false;
            this.advanceGas = new jaxx.AdvanceGasController();
            this.advanceGas.setUpdateCallback(function () {
                setTimeout(function () {
                    _this.evaluateSendButton();
                }, 100);
            });
            this.confirmScreen.onCancel = function () {
                if (_this.shapeShift.currentShift) {
                    _this.shapeShift.currentShift = null;
                }
                _this.confirmScreen.hide();
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CANCEL_TRANSACTION);
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CONFIRM_TRANSACTION_CLOSED);
                _this.setState('send');
                _this.$amount.val(_this.previousValuesSend);
                _this.$receiverAddress.val(_this.previousAddress);
                _this.addressToSend = String(_this.$sendToAddress.val());
                var ctr = jaxx.Registry.getCurrentCryptoController();
                _this.addressIsValid = ctr.validateAddress(_this.addressToSend);
                _this.amountDidChangeListener();
            };
            jaxx.Registry.application$.on(jaxx.Registry.UI_CANCEL_TRANSACTION, function (evt, type) {
                if (type === 'shapeShift') {
                    _this.setState('restore');
                    _this.activateShapeshift(function () {
                        _this.activateSend();
                        _this.$shapeShiftFoxBtn.addClass("tabHighlighted");
                        _this.$exchangeTabLabel.addClass('whiteText');
                        _this.$exchangeTabImage.addClass('whiteSVG');
                        _this.$sendLabel.text('EXCHANGE');
                        _this.$view.addClass("tabHighlighted");
                        _this.show();
                        _this.$sendAddressView.hide();
                        _this.$maxBtn.hide();
                        _this.$advancedTabButton.hide();
                        _this.$amount.val(_this.previousValuesSend);
                        _this.shapeShift.setLastToSelected();
                        _this.amountDidChangeListener();
                    });
                }
            });
            this.shapeShift.clickShapeShiftInfoToggle = function () {
                Navigation.openModal('shapeShiftInfo');
            };
            this.shapeShift.clickShapeShiftClose = function () {
                Navigation.closeModal();
            };
            /*this.spendableView.update = (delta: number) => {
                let ctr = jaxx.Registry.getCurrentCryptoController();

                if (ctr) {
                    if (!this.cryptoToFiatButton.isFiat) {
                        let spendable: string = ctr.getSpendable();

                        if (isNaN(+spendable)) {
                            console.log('Should be a number!');
                            spendable = '0';
                        }

                        console.log(' spendable   ' + spendable + ' delta   ' + delta);
                        MATH.subtract(spendable, String(delta));

                        if (Number(spendable) < 0) {
                            this.spendableView.spendable = '0';
                        } else {
                            this.spendableView.spendable = spendable;
                        }
                    }

                    if (this.cryptoToFiatButton.isFiat) {
                        if (this.shapeShift.isVisible()) {
                            this.shapeShift.updateSpendable();
                        } else {
                            let spendable = Registry.getCurrentCryptoController().getSpendable();
                            let coinSymbol = Registry.getCurrentCryptoController().symbol;
                            let fiatCode = FiatPriceController.instance.getActiveFiatCurrency();
                            this.spendableView.spendable = FiatPriceController.coinToFiat(spendable, coinSymbol, fiatCode);
                            this.spendableView.$amount.text(Formatters.balanceForDisplay(this.spendableView.spendable, 2));
                        }
                    } else {
                        if (this.shapeShift.isVisible()) {
                            this.shapeShift.updateSpendable();
                        } else {
                            this.spendableView.spendable = Registry.getCurrentCryptoController().getSpendable();
                            this.spendableView.$amount.text(Formatters.balanceForDisplay(this.spendableView.spendable, 8));
                        }
                    }

                } else {
                    console.error(' no current controller ')
                }

                // if our data layer hasn't cached UTXOs already
                // let's keep refreshing every 1 sec
                //if (localStorage.getItem(ctr.name + '-UTXOs') == null)
                //{
                //    setTimeout(this.spendableView.update, 1000, 0);
                //}
            };*/
            // bind these two to avoid any misreference caused by a context issue
            var boundSpendableView = this.spendableView;
            var boundSendTXCtrl = this;
            this.spendableView.update = function () {
                var currentCoinController = jaxx.Registry.getCurrentCryptoController();
                var showLoadingUICanceled = false;
                // Set a 150 nsec timer on showing the UI loading component.
                // Instead of showing it directly, arange this timer and then if the results in getSpendableBalance method below come up faster than
                // these 150 msecs we cancel it there, thus avoiding a DOM update if no loading indicator is necessary
                var timerUntilLoadingIsShown = null;
                timerUntilLoadingIsShown = setTimeout(function () {
                    if (timerUntilLoadingIsShown === null)
                        boundSpendableView.showLoadingIndicator();
                }, 150);
                currentCoinController.getSpendableBalance(function (amount) {
                    if (amount !== null) {
                        var finalAmountToBeDisplayedInUI = void 0;
                        if (boundSendTXCtrl.cryptoToFiatButton.isFiat) {
                            finalAmountToBeDisplayedInUI = jaxx.FiatPriceController.coinToFiat(amount, currentCoinController.symbol, jaxx.FiatPriceController.instance.getActiveFiatCurrency());
                        }
                        else {
                            finalAmountToBeDisplayedInUI = amount;
                        }
                        if (boundSendTXCtrl.shapeShift.isVisible()) {
                            boundSendTXCtrl.shapeShift.setSpendableAmount(finalAmountToBeDisplayedInUI, function () { updateDone(); });
                        }
                        else {
                            boundSendTXCtrl.spendableView.setSpendableAmount(finalAmountToBeDisplayedInUI, boundSendTXCtrl.cryptoToFiatButton.isFiat);
                            updateDone();
                        }
                    }
                    else {
                        updateDone();
                    }
                    function updateDone() {
                        clearTimeout(timerUntilLoadingIsShown);
                        timerUntilLoadingIsShown = null;
                        boundSpendableView.hideLoadingIndicator();
                    }
                });
            };
            this.cryptoToFiatButton = new jaxx.CryptoToFiatButtonComponent();
            this.cryptoToFiatButton.onClick = function () {
                _this.toggleCryptoToFiatButton();
            };
            this.confirmScreen.onConfirm = function () {
                _this.confirmScreen.hide();
                // A wrapper function that wrap the complete send transaction logic
                var completedSendTransaction = function () {
                    jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CONFIRM_TRANSACTION);
                    var ctr = jaxx.Registry.getCurrentCryptoController();
                    // Perform send transaction
                    ctr.sendTransaction(_this.transaction).done(function (result) {
                        if (result.success === 'success') {
                            Navigation.flashBanner('Transaction sent', 2, 'success');
                            jaxx.Registry.application$.trigger(jaxx.Registry.ON_SEND_TRANSACTION, _this.transaction); // notify UI that a transaction was successfully sent
                        }
                        else {
                            Navigation.flashBanner('Transaction failed', 2);
                            console.error(result);
                        }
                    }).fail(function (err) {
                        Navigation.flashBanner('Transaction failed', 2);
                        console.error(err);
                    });
                };
                //If user has pin setup then show the pin input screen
                if (g_JaxxApp.getUser().hasPin()) {
                    g_JaxxApp.getUI().showEnterPinModal(function (error) {
                        //If input pin error, return without proceed to transaction
                        if (error) {
                            console.log("enter pin error :: " + error);
                            return;
                        }
                        //Pin enter succeed, proceed to complete transaction
                        completedSendTransaction();
                    });
                } // If no pin setup then proceed to complete transaction
                else {
                    completedSendTransaction();
                }
                jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CONFIRM_TRANSACTION_CLOSED);
            };
            this.sendButton.onClick = function () {
                _this.evaluateSendButton();
                if (!_this.validToSend)
                    return;
                if (_this.shapeShift.isActive()) {
                    // Enable the Send button and remove any loading icon
                    _this.exhaustSendButton();
                    _this.shapeShift.shift(_this.amountToSend, function (response) {
                        if (response.error) {
                            console.error('Shapefshift Response', response);
                            _this.readySendButton();
                            Navigation.flashBanner('Unable to Shift. Please try again later.', 4, 'error');
                            return;
                        }
                        var addressDeposit = response.deposit;
                        if (!jaxx.Registry.getCurrentCryptoController().validateAddress(addressDeposit) && !isNaN(Number(_this.amountToSend))) {
                            console.error('Not valid data', response);
                            jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CANCEL_TRANSACTION);
                            Navigation.flashBanner('ShapeShift Failed', 2);
                            return;
                        }
                        jaxx.Registry.getCurrentCryptoController().buildTransaction(String(response.amountToDeposit), addressDeposit, _this.isMax()).done(function (transaction) {
                            console.log(transaction);
                            _this.transaction = transaction;
                            // Show confirmation screen
                            jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CONFIRM_TRANSACTION);
                            // Show loading icon and disable the button
                            _this.readySendButton();
                            var currentCrypto = jaxx.Registry.getCurrentCryptoController();
                            var coinBalanceToDisplay = '';
                            if (currentCrypto) {
                                coinBalanceToDisplay = currentCrypto.getBalanceDisplay(transaction.amountInt);
                            }
                            _this.hide();
                            _this.setState('restore', function () {
                                // Callback delay is needed to avoid UI glitches when measuring element sizes
                                _this.shapeShift.confirmScreen.showShapeShiftConfirmation(response, _this.cryptoToFiatButton.isFiat, coinBalanceToDisplay);
                            });
                        }).fail(function (error) {
                            jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CANCEL_TRANSACTION);
                            Navigation.flashBanner('ShapeShift Failed', 2);
                            _this.readySendButton();
                        });
                    });
                }
                else if (_this.currentState === 'receive') {
                    _this.generateReceiveToken();
                }
                else {
                    _this.readySendButton();
                    var customData = _this.advanceGas.getCustomData();
                    var customGasLimit = _this.advanceGas.getCustomGasLimit();
                    _this.sendTransaction(_this.amountToSend, _this.addressToSend, _this.isMax(), customGasLimit, customData);
                }
            };
            this.$sendToAddress.on('change paste keyup', function () {
                _this.addressToSend = String(_this.$sendToAddress.val());
                _this.previousAddress = _this.addressToSend;
                var ctr = jaxx.Registry.getCurrentCryptoController();
                _this.addressIsValid = ctr.validateAddress(_this.addressToSend);
                _this.evaluateSendButton();
            });
            this.$sendToAddress.on('blur', function () {
                if (!_this.addressIsValid && String(_this.$sendToAddress.val()).trim().length)
                    Navigation.flashBanner('Receiving Address is Invalid', 3, 'error');
            });
            this.$amount.on('input', function () {
                _this.amountDidChangeListener();
            });
            this.$amount.on('focus', function () {
                // When amount field is in focus, remove the placeholder text
                _this.$amount.attr("placeholder", "");
            });
            this.$amount.on('blur', function () {
                // When amount field is not in focus, add the placeholder text
                _this.$amount.attr("placeholder", "Enter Amount");
            });
            this.$receiverAddress.on('focus', function () {
                // When receive field is in focus, remove the placeholder text
                _this.$receiverAddress.attr("placeholder", "");
            });
            this.$receiverAddress.on('blur', function () {
                // When receive field is not in focus, add the placeholder text
                _this.$receiverAddress.attr("placeholder", "Enter Receiving Address");
            });
            this.$maxBtn.on('click', function () {
                _this.updateFieldWithBalance(_this.$amount, _this.spendableView.getSpendable());
                _this.amountDidChangeListener();
                // When max is input into the amount field, remove the placeholder text
                _this.$amount.attr("placeholder", "");
            });
            jaxx.Registry.application$.on(jaxx.Registry.UI_SHOW_TAB, function (evt, tabname) {
                if (tabname === 'send') {
                    _this.start();
                }
            });
            /**
             * When the user changes their main currency from the quick fiat currency selector (the round arrow next to the main fiat balance)
             * Look if the user also inserted some value in the send coin input and update the calculation there too.
             */
            jaxx.Registry.application$.on(jaxx.Registry.ON_FIAT_MAIN_CURRENCY_CHANGE, function () {
                var text_in_send_amount = String(_this.$amount.val());
                if (text_in_send_amount.length > 0 && _this.cryptoToFiatButton.isFiat === false) {
                    var currentCrypto = jaxx.Registry.getCurrentCryptoController();
                    if (currentCrypto && currentCrypto['symbol']) {
                        var convertedFiatAmount_1 = '';
                        var coinSymbol = currentCrypto.symbol;
                        convertedFiatAmount_1 = _this.coinToActiveFiatDisplay(text_in_send_amount, coinSymbol);
                        // The code below calculates the text width's of the main amount and the fiat amount
                        // it then makes sure that the two do not overlap.
                        // We're using a setTimeout so we don't block the UI thread when the user types their amount
                        setTimeout(function () {
                            var widthFittingFiatAmount = _this.resizeFiatAmountTextToMakeItFit(convertedFiatAmount_1);
                            _this.$fiatAmount.text(widthFittingFiatAmount);
                        }, 50);
                    }
                }
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_ACTIVATED, function () {
                if (jaxx.Registry.getCurrentCryptoController().shapeshift) {
                    _this.showShapeShift();
                }
                else {
                    _this.hideShapeShift();
                }
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_FIAT_MAIN_CURRENCY_CHANGE, function () {
                if (_this.cryptoToFiatButton.isFiat) {
                    var code = jaxx.FiatPriceController.instance.getActiveFiatCurrency();
                    var symbol = jaxx.FiatPriceController.prependFiatSymbolToString(code, '');
                    $('#fiatToCrypto > .symbol').text(symbol);
                    _this.updateOnTheFlyCoinAmountInsideAmountBox();
                }
            });
            jaxx.Registry.walletValue$.on(jaxx.Registry.ON_WALLET_VALUE_CHANGE, function () {
                if (_this.cryptoToFiatButton.isFiat) {
                    _this.showFiatSpendable();
                }
                else {
                    _this.showCryptoSpendable();
                }
                _this.spendableView.update(0);
            });
            this.$inputCustomGasLimit.on("focus", function () {
                if (jaxx.Registry.iPhone || jaxx.Registry.android) {
                    _this.$keyBoardSectionHideMe.hide();
                    _this.$advanceSendArrow.css("opacity", 1);
                }
            });
            this.$inputCustomGasLimit.on("blur", function () {
                if (jaxx.Registry.iPhone || jaxx.Registry.android) {
                    _this.$keyBoardSectionHideMe.show();
                    _this.$advanceSendArrow.css("opacity", 0);
                }
            });
            this.$inputCustomData.on("focus", function () {
                if (jaxx.Registry.iPhone || jaxx.Registry.android) {
                    _this.$keyBoardSectionHideMe.hide();
                    _this.$advanceSendArrow.css("opacity", 1);
                }
            });
            this.$inputCustomData.on("blur", function () {
                if (jaxx.Registry.iPhone || jaxx.Registry.android) {
                    _this.$keyBoardSectionHideMe.show();
                    _this.$advanceSendArrow.css("opacity", 0);
                }
            });
            this.attachClickEvents();
            this.$shapeShiftFoxBtn.on('click', function () {
                _this.setState('ShapeShift');
            });
        };
        SendTransactionsController.prototype.isMax = function () {
            /// check if value in fields  match  spendable
            var spendable = String($('#SpendableAmount').text());
            var input = String($('#amountSendInput').val());
            var ar = input.split('.');
            if (ar.length === 2)
                ar[1] = ar[1].substr(0, 8);
            input = ar.join('.');
            return spendable === input;
            /*
                        if (this.amountToSend === spendable) {
                            isMaxValue = true;
                        }
            
                        return isMaxValue;
                        */
        };
        SendTransactionsController.prototype.readySendButton = function () {
            this.sendButton.$view.find('#sendLabel').show();
            this.sendButton.$view.find('.shiftingProgress').hide();
        };
        SendTransactionsController.prototype.exhaustSendButton = function () {
            this.sendButton.$view.find('#sendLabel').hide();
            this.sendButton.$view.find('.shiftingProgress').show();
        };
        SendTransactionsController.prototype.attachClickEvents = function () {
            var elements = this.$view.find(".scriptAction").not(".scrollHeaderContainer .rightArrow").not(".scrollHeaderContainer .leftArrow"); // Exclude carousel arrows
            this.attachClickEventForScriptAction(elements);
        };
        SendTransactionsController.prototype.attachClickEventForScriptAction = function (jquerySelector) {
            $(jquerySelector).off('click');
            $(jquerySelector).click(function (event) {
                scriptAction(event);
            });
        };
        SendTransactionsController.prototype.showShapeShift = function () {
            this.$shapeShiftFoxBtn.show();
            this.$sendTabBtn.width('29.5%');
            this.$receiveTabBtn.width('29.5%');
        };
        SendTransactionsController.prototype.hideShapeShift = function () {
            this.$shapeShiftFoxBtn.hide();
            this.$sendTabBtn.width('49.5%');
            this.$receiveTabBtn.width('49.5%');
        };
        SendTransactionsController.prototype.toggleCryptoToFiatButton = function () {
            if (this.cryptoToFiatButton.isFiat) {
                this.showCryptoButton();
            }
            else {
                this.showFiatButton();
            }
            this.$fiatAmount.text('');
            console.log('is this fiat? ' + this.cryptoToFiatButton.isFiat);
        };
        SendTransactionsController.prototype.showFiatButton = function () {
            this.showFiatSpendable();
            this.cryptoToFiatButton.isFiat = true;
            this.setUseFiat(this.cryptoToFiatButton.isFiat);
            this.spendableView.update(0);
        };
        SendTransactionsController.prototype.showFiatSpendable = function () {
            var currentCryptoController = jaxx.Registry.getCurrentCryptoController();
            var coinValue = currentCryptoController.getSpendable();
            if (Number(coinValue) < 0) {
                console.error(jaxx.Registry.getCurrentCryptoController().symbol + " getSpendable is returning a negative value when it should be zero");
                coinValue = '0';
            }
            if (isNaN(+coinValue)) {
                console.log("It should be a number!");
                coinValue = '0';
            }
            var coinSymbol = currentCryptoController.symbol;
            var fiatCode = jaxx.FiatPriceController.instance.getActiveFiatCurrency();
            var fiatAmount = jaxx.FiatPriceController.coinToFiat(coinValue, coinSymbol, fiatCode);
            this.spendableView.spendable = fiatAmount;
            this.spendableView.$spendableFiatSymbol.text(jaxx.FiatPriceController.getFiatUnitPrefix(fiatCode));
            this.spendableView.$spendableCryptoSymbol.text('');
            console.log(jaxx.FiatPriceController.makeDisplayFiat(fiatAmount, fiatCode));
        };
        SendTransactionsController.prototype.showCryptoButton = function () {
            this.showCryptoSpendable();
            this.cryptoToFiatButton.isFiat = false;
            this.setUseFiat(this.cryptoToFiatButton.isFiat);
            this.spendableView.update(0);
        };
        SendTransactionsController.prototype.showCryptoSpendable = function () {
            var currentCryptoController = jaxx.Registry.getCurrentCryptoController();
            var spendable = currentCryptoController.getSpendable();
            if (Number(spendable) < 0) {
                console.error(jaxx.Registry.getCurrentCryptoController().symbol + " getSpendable is returning a negative value when it should be zero");
                spendable = '0';
            }
            if (isNaN(+spendable)) {
                console.log("It should be number!");
                spendable = '0';
            }
            this.spendableView.spendable = spendable;
            this.spendableView.$spendableCryptoSymbol.text(currentCryptoController.threeLetterCode);
            this.spendableView.$spendableFiatSymbol.text('');
        };
        SendTransactionsController.prototype.setUseFiat = function (isFiat) {
            this.$amount.val('');
            if (isFiat) {
                this.cryptoToFiatButton.$view.data('fiat', isFiat);
            }
            if (isFiat) {
                this.cryptoToFiatButton.$symbol.text(jaxx.FiatPriceController.getFiatUnitPrefix());
            }
            else {
                // Set the symbol
                var coinSymbol = jaxx.Registry.getCurrentCryptoController().threeLetterCode; // HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).uiComponents['coinSymbol'];
                this.cryptoToFiatButton.$symbol.text(coinSymbol);
            }
        };
        ;
        SendTransactionsController.prototype.generateReceiveToken = function () {
            console.log('MINING FEES | specialAction :: ');
            this.walletSendReceive();
        };
        SendTransactionsController.prototype.walletSendReceive = function () {
            var coinAbbreviatedNameCur = jaxx.Registry.getCurrentCryptoController().symbol;
            var qrCodeImage;
            qrCodeImage = jaxx.Utils.generateQRCode(this.amountToSend, true);
            if (qrCodeImage != null) {
                if (Navigation.isUseFiat()) {
                    $('.modal.receive .amountAbbreviatedName').text(wallet.getHelper().getFiatUnit());
                }
                else {
                    $('.modal.receive .amountAbbreviatedName').text(coinAbbreviatedNameCur);
                }
                $('.modal.receive .amount').text(jaxx.Formatters.balanceForDisplay(this.amountToSend));
                $(".modal.receive .qrCode img").attr("src", qrCodeImage);
                Navigation.openModal('receive');
            }
            else {
                console.log("!! error :: could not create qr code for :: " + coinAbbreviatedNameCur + " !!");
            }
        };
        SendTransactionsController.prototype.enableAdvanceGasIfRequired = function () {
            if (this.isAdvancedOptionsAvaialble()) {
                var ctr = jaxx.Registry.getCurrentCryptoController();
                this.advanceGas.setActive(true, ctr.advancedMiningOption.options);
            }
            else {
                this.advanceGas.setActive(false);
            }
        };
        SendTransactionsController.prototype.evaluateSendButton = function () {
            this.validToSend = false;
            if (this.addressIsValid && this.amountIsValid) {
                var customDataValid = false;
                if (this.isAdvancedOptionsAvaialble() && this.advanceGas.isOptionsActive()) {
                    if (this.advanceGas.isCustomDataValid()) {
                        customDataValid = true;
                    }
                }
                else {
                    customDataValid = true;
                }
                if (customDataValid) {
                    this.validToSend = true;
                    this.sendButton.update('active');
                }
            }
            if (!this.validToSend && this.sendButton) {
                this.sendButton.update('disabled');
            }
        };
        SendTransactionsController.prototype.isAdvancedOptionsAvaialble = function () {
            var ctr = jaxx.Registry.getCurrentCryptoController();
            if (ctr.advancedMiningOption && (ctr.advancedMiningOption.type === "AdvanceGasController")) {
                return true;
            }
            return false;
        };
        SendTransactionsController.prototype.sendTransaction = function (amountToSend, addressTo, isMax, customGasLimit, customData) {
            var _this = this;
            if (this.cryptoToFiatButton.isFiat) {
                amountToSend = String(jaxx.FiatPriceController.fiatToCoin(amountToSend, jaxx.FiatPriceController.instance.getActiveFiatCurrency(), jaxx.Registry.getCurrentCryptoController().symbol));
            }
            var ctr = jaxx.Registry.getCurrentCryptoController();
            if (!ctr) {
                console.error(' no current controller ');
            }
            console.log(amountToSend);
            ctr.buildTransaction(amountToSend, addressTo, isMax, customGasLimit, customData)
                .done(function (transaction) {
                //ask user to confirm
                if (transaction) {
                    _this.transaction = transaction;
                    if (_this.cryptoToFiatButton.isFiat) {
                        console.log("Amount " + _this.$amount.val());
                        transaction.displayAmount = jaxx.Formatters.balanceForDisplay(String(_this.$amount.val()), 2);
                        console.log(transaction);
                        transaction.fiatSymbol = jaxx.FiatPriceController.getFiatUnitPrefix(jaxx.FiatPriceController.instance.getActiveFiatCurrency());
                    }
                    _this.setState('restore');
                    setTimeout(function () {
                        // This delay was added to avoid any rendering glitches when a keyboard is up on mobile
                        _this.confirmScreen.showConfirmation(transaction);
                    }, 500);
                }
            })
                .fail(function (response) {
                _this.readySendButton();
                Navigation.flashBanner("Failed to build transaction.", 3, 'error');
                console.error(response);
            });
            this.isInit = true;
        };
        /** Converts the given coin to ready for display fiat currency according to the user's current active fiat code. */
        SendTransactionsController.prototype.coinToActiveFiatDisplay = function (coinAmount, coinSymbol) {
            var retVal = '';
            if (coinAmount != "") {
                var dotPosition = coinAmount.lastIndexOf('.');
                if (dotPosition > 21 || (dotPosition == -1 && coinAmount.length > 20)) {
                    coinAmount = coinAmount.substr(0, 20);
                }
                // currently the fiat convertor is using numbers to do math
                // until we conver it to using strings for big numbers support we will aproximate down to 6 decimals
                var activeFiatCurrencyCode = jaxx.FiatPriceController.instance.getActiveFiatCurrency();
                var onTheFlyFiatConvertedAmount = jaxx.FiatPriceController.coinToFiat(coinAmount, coinSymbol, activeFiatCurrencyCode);
                // we can get a null here if the user started Jaxx first time and they don't have a local cache and the fiat pricing hasn't loaded yet
                if (onTheFlyFiatConvertedAmount != null) {
                    var formattedNumber = jaxx.Formatters.balanceForDisplay(onTheFlyFiatConvertedAmount, 2); // this one makes sure we have anly two decimals 
                    formattedNumber = jaxx.Formatters.formatFinancialNumber(formattedNumber); // this one puts the commas every 3 digits
                    var displayFiat = jaxx.FiatPriceController.prependFiatSymbolToString(activeFiatCurrencyCode, formattedNumber); // this one adds the currency prefix for ex US$
                    retVal = displayFiat;
                }
            }
            return retVal;
        };
        /** Measures the text in the send amount box to find out how much space is left for the fiat to display
         * so they don't overlap. Then it shortens the fiat amount text to fit in and leaves a spacing in between the two
         * amounts as set in fiatTextSpacingInPixels.
         *
         * @param fiatAmountString {string} - The raw converted fiat amount
         * @return {string} - The fiat amount string guaranteed to fit in the UI
         */
        SendTransactionsController.prototype.resizeFiatAmountTextToMakeItFit = function (fiatAmountString) {
            var fiatTextSpacingInPixels = 25; // this is the space left between the coin amount and fiat amount in the send transaction amount box
            var amountLeftPaddingInPixels = Number(this.$amount.css('padding-left').replace('px', ''));
            var fiatAmountRightPaddingInPixels = Number(this.$fiatAmount.css('right').replace('px', ''));
            var resultingFiatString = fiatAmountString;
            var fontFamily = this.$amount.css('font-family');
            var fontSize = this.$amount.css('font-size');
            var amountTextContent = String(this.$amount.val());
            var amountTextWidth = this.measureTextWidth(amountTextContent, fontFamily, fontSize);
            var amountInputElementWidth = this.$amount.outerWidth(true);
            var fiatAmountWidthAvailableInPixels = (amountInputElementWidth - (fiatTextSpacingInPixels + amountTextWidth + amountLeftPaddingInPixels)) - fiatAmountRightPaddingInPixels;
            var fiatAmountText = fiatAmountString;
            if (fiatAmountText.length != 0) {
                var fiatAmountFontFamily = this.$fiatAmount.css('font-family');
                var fiatAmountFontSize = this.$fiatAmount.css('font-size');
                var fiatAmountTextWidthInPixels = this.measureTextWidth(fiatAmountText, fiatAmountFontFamily, fiatAmountFontSize);
                if (fiatAmountTextWidthInPixels > fiatAmountWidthAvailableInPixels) {
                    var fiatCharacterWidth = fiatAmountTextWidthInPixels / fiatAmountText.length;
                    var fiatAmountFittingCharacters = fiatAmountWidthAvailableInPixels / fiatCharacterWidth;
                    if (fiatAmountFittingCharacters < 4) {
                        resultingFiatString = '';
                    }
                    else {
                        resultingFiatString = fiatAmountString.substr(0, fiatAmountFittingCharacters);
                        if (fiatAmountFittingCharacters != fiatAmountString.length) {
                            resultingFiatString += '..';
                        }
                    }
                }
            }
            return resultingFiatString;
        };
        /**
         * Make sure there are maximum 10 digits before the decimal dot (.) and 10 digits after.
         *
         * To allow more digits, just change the first to const's.
         */
        SendTransactionsController.prototype.amountImposeDigitLimit = function () {
            var integer_part_limit = 10;
            var decimal_part_limit = 10;
            var amount_input = String(this.$amount.val());
            var decimal_position = amount_input.indexOf('.');
            if (decimal_position == -1) {
                decimal_position = amount_input.length;
            }
            var integer_part = amount_input.substr(0, decimal_position);
            var decimal_part = amount_input.substr(decimal_position + 1);
            if (integer_part.length > integer_part_limit) {
                integer_part = integer_part.substr(0, integer_part_limit);
            }
            if (decimal_part.length > decimal_part_limit) {
                decimal_part = decimal_part.substr(0, decimal_part_limit);
            }
            var computed_amount = integer_part;
            if (decimal_part.length > 0) {
                computed_amount = computed_amount + '.' + decimal_part;
            }
            this.$amount.val(computed_amount);
        };
        SendTransactionsController.prototype.updateFiatAmountInsideCoinAmountBox = function () {
            var _this = this;
            // The code below calculates the text width's of the main amount and the fiat amount
            // it then makes sure that the two do not overlap
            // We're using a setTimeout so we don't block the UI thread when the user types their amount
            setTimeout(function () {
                var onTheFlyFiatAmountReadyForDisplay = '';
                var currentCrypto = jaxx.Registry.getCurrentCryptoController();
                if (currentCrypto['symbol']) {
                    var coinSymbol = currentCrypto.symbol;
                    onTheFlyFiatAmountReadyForDisplay = _this.coinToActiveFiatDisplay(_this.amountToSend, coinSymbol);
                }
                var widthFittingFiatAmount = _this.resizeFiatAmountTextToMakeItFit(onTheFlyFiatAmountReadyForDisplay);
                _this.$fiatAmount.text(widthFittingFiatAmount);
            }, 50);
        };
        SendTransactionsController.prototype.updateOnTheFlyCoinAmountInsideAmountBox = function () {
            var _this = this;
            setTimeout(function () {
                var onTheFlyCoinAmount = '';
                var currentCrypto = jaxx.Registry.getCurrentCryptoController();
                if (currentCrypto['symbol']) {
                    var coinSymbol = currentCrypto.symbol;
                    var activeFiatCode = jaxx.FiatPriceController.instance.getActiveFiatCurrency();
                    onTheFlyCoinAmount = jaxx.FiatPriceController.fiatToCoin(_this.amountToSend, activeFiatCode, coinSymbol);
                    onTheFlyCoinAmount = jaxx.Formatters.balanceForDisplay(onTheFlyCoinAmount, 10);
                    onTheFlyCoinAmount = jaxx.FiatPriceController.prependCoinSymbolLetterToString(coinSymbol, onTheFlyCoinAmount);
                }
                var widthFittingCoinAmount = _this.resizeFiatAmountTextToMakeItFit(onTheFlyCoinAmount);
                _this.$fiatAmount.text(widthFittingCoinAmount);
            }, 50);
        };
        /*
        * Format the user input to the correct format our app needs to build transactions correctly
        * @method formatAmountInput
        * */
        SendTransactionsController.prototype.formatAmountInput = function () {
            var decimals = 18;
            var val = String(this.$amount.val());
            if (isNaN(+val))
                return null;
            var ar = val.split('.');
            if (ar.length > 2)
                return null;
            if (ar.length === 2) {
                var dec = ar[1];
                if (dec.length > decimals) {
                    ar[1] = ar[1].substr(0, decimals);
                    //this.$amount.val(ar.join('.'));
                }
            }
            /* let requestType: string = Registry.getCurrentCryptoController().config.cluster;
             console.log(' requestType ' +requestType);
             if(requestType === 'ETH') {
                 userInput = parseFloat(String(this.$amount.val())).toFixed(18);
             } else {
                 userInput = parseFloat(String(this.$amount.val())).toFixed(8);
             }*/
            return ar.join('.');
        };
        SendTransactionsController.prototype.amountDidChangeListener = function () {
            var _this = this;
            this.amountIsValid = false;
            this.amountToSend = null;
            var userInput = this.formatAmountInput();
            if (userInput.length === 0 || userInput === "0") {
                this.$fiatAmount.text('');
                return this.evaluateSendButton();
            }
            else if (!userInput) {
                return;
            }
            this.amountToSend = userInput;
            this.previousValuesSend = this.amountToSend;
            var spendable = this.spendableView.getSpendable();
            // Check if user input is above max or below min and show respective warning styles
            this.shapeShift.updateMinMaxWarnings(userInput);
            if (!jaxx.MATH.isZero(spendable) && !jaxx.MATH.isZero(this.amountToSend) && Number(this.amountToSend) <= Number(spendable)) {
                this.amountIsValid = true;
            }
            /** Start on the fly fiat conversion and display ---------------*/
            // if the toggle unit button is set to cryto coin
            if (!this.cryptoToFiatButton.isFiat) {
                this.updateFiatAmountInsideCoinAmountBox();
            }
            else {
                this.updateOnTheFlyCoinAmountInsideAmountBox();
            }
            /** End on the fly fiat conversion -----------------------------*/
            if (this.amountIsValid) {
                if (this.shapeShift.isActive()) {
                    this.shapeShift.isReady(Number(this.amountToSend), function (response) {
                        console.log(' Shapeshift is valid ' + response);
                        if (response.error) {
                            if (!_this.amountIsValid) {
                                return Navigation.flashBanner("Amount is not valid for current fees/spendable limit.", 3, 'error');
                            }
                            if (!_this.addressIsValid) {
                                return Navigation.flashBanner("Receiving Address is not valid.", 3, 'error');
                            }
                        }
                        else {
                            if (_this.cryptoToFiatButton.isFiat) {
                                userInput = jaxx.FiatPriceController.fiatToCoin(userInput, jaxx.FiatPriceController.instance.getActiveFiatCurrency(), jaxx.Registry.getCurrentCryptoController().symbol);
                            }
                            if (_this.shapeShift.meetsShapeShiftMinMax(userInput)) {
                                _this.addressIsValid = true;
                                _this.amountIsValid = true;
                            }
                            else {
                                _this.addressIsValid = false;
                                _this.amountIsValid = false;
                            }
                            _this.evaluateSendButton();
                        }
                    });
                }
                else if (this.currentState === 'receive') {
                    if (Number(this.amountToSend) > 0) {
                        this.addressIsValid = true;
                        this.amountIsValid = true;
                        this.evaluateSendButton();
                    }
                }
                else {
                    this.evaluateSendButton();
                }
            }
            else {
                this.evaluateSendButton();
            }
            console.log('JN - amountToSend blur amount - User Entered: ' + userInput + ', Jaxx using: ' + this.amountToSend + ' amountIsValid: ' + this.amountIsValid);
        };
        SendTransactionsController.prototype.start = function () {
            console.error('SendTransactionsController START');
            this.spendableView.update(0);
        };
        SendTransactionsController.prototype.resetAll = function (callback) {
            var _this = this;
            console.log('Resetting...');
            if (!this.currentState) {
                return;
            }
            this.$gasForSpendableWarning.hide();
            this.amountToSend = '';
            this.$receiverAddress.val('');
            this.$fiatAmount.text('');
            this.$sendLabel.text('SEND');
            this.currentState = 'reset';
            this.validToSend = false;
            this.deactivate();
            this.advanceGas.setActive(false);
            this.evaluateSendButton();
            this.$sendTabBtn.removeClass("tabHighlighted");
            this.$receiveTabBtn.removeClass("tabHighlighted");
            this.$shapeShiftFoxBtn.removeClass("tabHighlighted");
            this.$view.removeClass("tabHighlighted");
            this.$receiveTabLabel.removeClass('whiteText');
            this.$receiveTabImage.removeClass('whiteSVG');
            this.$exchangeTabLabel.removeClass('whiteText');
            this.$exchangeTabImage.removeClass('whiteSVG');
            this.$sendTabLabel.removeClass('whiteText');
            this.$sendTabImage.removeClass('whiteSVG');
            this.shapeShift.hideList();
            this.receiveTransactionsView.disable();
            if (callback) {
                // If a callback is required, call hide with the callback
                this.hide(function () {
                    callback();
                    _this.shapeShift.deactivate();
                    _this.deactivateShapeShift();
                    _this.shapeShift.hide();
                });
            }
            else {
                // Otherwise, just call hide normally
                this.hide(function () {
                    _this.shapeShift.deactivate();
                    _this.deactivateShapeShift();
                    _this.shapeShift.hide();
                });
            }
        };
        SendTransactionsController.prototype.renderAmountInput = function () {
            // Adjusting the height of the amount field to match the adjacent buttons
            var amountHeight = $('#fiatToCrypto').height();
            var iDeviceAdjust = 0.88;
            if (PlatformUtils.mobileIpadCheck || PlatformUtils.mobileiOSCheck) {
                // You must evoke a scroll to fix mobile Safari glitch
                $(window).scrollTop(-1);
                // Also reduced to 90% due to false height calculation
                this.$amount.css("height", iDeviceAdjust * amountHeight);
            }
            else {
                this.$amount.css("height", amountHeight);
            }
        };
        SendTransactionsController.prototype.deactivate = function () {
            this.isActive = false;
            this.isVisible = false;
            this.addressIsValid = false;
            this.amountIsValid = false;
        };
        SendTransactionsController.prototype.activateShapeshift = function (callback) {
            var _this = this;
            this.shapeShift.shapeShiftIsAvailable(function () {
                _this.shapeShift.isReady(+_this.amountToSend, function (result) {
                    console.log(result);
                });
                if (_this.isShapeShiftActive) {
                    return;
                }
                _this.isShapeShiftActive = true;
                _this.$receiverAddress.val("ShapeShift");
                _this.shapeShift.activate();
                _this.shapeShift.show();
                _this.$sendButtonLabel.text('EXCHANGE');
                _this.spendableView.update(0);
                _this.$mainInputField.addClass('mainAmountInputShift');
                _this.renderAmountInput();
                // while the ShapeShift module is active we hide the QR scanner because we have to send the funds
                // to the specific address ShapeShift API provide.
                // the QR scanner on ShapeShift address UI element isn't any useful
                if (PlatformUtils.mobileCheck) {
                    _this.hideQRCode();
                }
                if (callback) {
                    callback();
                }
            });
        };
        SendTransactionsController.prototype.deactivateShapeShift = function () {
            if (!this.isShapeShiftActive) {
                return;
            }
            if (PlatformUtils.mobileCheck) {
                this.showQRCode();
            }
            this.isShapeShiftActive = false;
            this.$sendAddressView.css('display', 'block');
            this.$sendButtonLabel.text('SEND');
            this.shapeShift.deactivate();
            this.shapeShift.hide();
            this.$mainInputField.removeClass('mainAmountInputShift');
            // ShapeShift UI module goes away, we show the QR code if we're on mobile
        };
        // Show QR Code and resize receiver address input box to properly align with the new elements
        SendTransactionsController.prototype.hideQRCode = function () {
            this.$receiverAddress.css('width', 'calc(100% - 10px)');
            this.$sendAddressView.children('.imageQR').hide();
        };
        // Show QR Code and resize receiver address input box to properly align with the shown QR code
        SendTransactionsController.prototype.showQRCode = function () {
            this.$qrCodeButton.show();
            this.$receiverAddress.css('width', 'calc(100% - 50px)');
        };
        SendTransactionsController.prototype.setState = function (newState, callback) {
            var _this = this;
            var prevSatate = this.currentState;
            this.currentState = newState;
            this.addressIsValid = false;
            this.amountIsValid = false;
            this.evaluateSendButton();
            switch (prevSatate) {
                case 'reset':
                    switch (newState) {
                        case 'send':
                            this.deactivateShapeShift();
                            this.activateSend();
                            this.renderAmountInput();
                            this.show();
                            this.$sendTabBtn.addClass("tabHighlighted");
                            this.$sendTabLabel.addClass('whiteText');
                            this.$sendTabImage.addClass('whiteSVG');
                            this.$view.addClass("tabHighlighted");
                            this.$maxBtn.show();
                            switch (this.isAdvancedOptionsAvaialble()) {
                                case true:
                                    this.$advancedTabButton.show();
                                    break;
                            }
                            break;
                        case 'ShapeShift':
                            this.activateShapeshift(function () {
                                _this.activateSend();
                                _this.$shapeShiftFoxBtn.addClass("tabHighlighted");
                                _this.$exchangeTabLabel.addClass('whiteText');
                                _this.$exchangeTabImage.addClass('whiteSVG');
                                _this.$sendLabel.text('EXCHANGE');
                                _this.$view.addClass("tabHighlighted");
                                _this.show();
                                _this.$sendAddressView.hide();
                                _this.$maxBtn.hide();
                                _this.$advancedTabButton.hide();
                            });
                            break;
                        case 'receive':
                            this.resetAll();
                            this.currentState = newState;
                            this.deactivateShapeShift();
                            this.activateReceive();
                            this.$sendAddressView.hide();
                            this.$maxBtn.hide();
                            this.spendableView.hide();
                            this.$sendButtonLabel.text('GENERATE');
                            this.$receiveTabBtn.addClass("tabHighlighted");
                            this.$receiveTabLabel.addClass('whiteText');
                            this.$receiveTabImage.addClass('whiteSVG');
                            this.$view.addClass("tabHighlighted");
                            this.receiveTransactionsView.enable();
                            this.renderAmountInput();
                            this.show();
                            break;
                        case 'restore':
                            this.resetAll();
                            this.currentState = 'reset';
                            break;
                    }
                    break;
                case 'send':
                    switch (newState) {
                        case 'send':
                            this.resetAll(function () {
                                jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CONFIRM_TRANSACTION_CLOSED);
                            });
                            break;
                        case 'ShapeShift':
                            this.activateShapeshift(function () {
                                _this.$shapeShiftFoxBtn.addClass("tabHighlighted");
                                _this.$exchangeTabLabel.addClass('whiteText');
                                _this.$exchangeTabImage.addClass('whiteSVG');
                                _this.$sendLabel.text('EXCHANGE');
                                _this.$sendTabBtn.removeClass("tabHighlighted");
                                _this.$sendTabLabel.removeClass('whiteText');
                                _this.$sendTabImage.removeClass('whiteSVG');
                                _this.amountToSend = '';
                                _this.$amount.val('');
                                _this.amountDidChangeListener();
                                _this.$advancedTabButton.hide();
                                _this.$sendAddressView.hide();
                                _this.$maxBtn.hide();
                            });
                            break;
                        case 'receive':
                            this.resetAll();
                            this.currentState = newState;
                            this.deactivateShapeShift();
                            this.$sendAddressView.hide();
                            this.$maxBtn.hide();
                            this.spendableView.hide();
                            this.$sendButtonLabel.text('GENERATE');
                            this.$receiveTabBtn.addClass("tabHighlighted");
                            this.$receiveTabLabel.addClass('whiteText');
                            this.$receiveTabImage.addClass('whiteSVG');
                            this.$view.addClass("tabHighlighted");
                            this.receiveTransactionsView.enable();
                            this.renderAmountInput();
                            this.show();
                            break;
                        case 'restore':
                            this.resetAll(callback);
                            this.currentState = 'reset';
                            break;
                    }
                    break;
                case 'ShapeShift':
                    switch (newState) {
                        case 'ShapeShift':
                            this.resetAll(function () {
                                jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CONFIRM_TRANSACTION_CLOSED);
                            });
                            this.currentState = '';
                            break;
                        case 'send':
                            this.deactivateShapeShift();
                            this.spendableView.update(0);
                            this.amountToSend = '';
                            this.$amount.val('');
                            this.$receiverAddress.val('');
                            this.amountDidChangeListener();
                            this.$shapeShiftFoxBtn.removeClass("tabHighlighted");
                            this.$exchangeTabLabel.removeClass('whiteText');
                            this.$exchangeTabImage.removeClass('whiteSVG');
                            this.$sendLabel.text('SEND');
                            this.$sendTabBtn.addClass("tabHighlighted");
                            this.$sendTabLabel.addClass('whiteText');
                            this.$sendTabImage.addClass('whiteSVG');
                            this.$maxBtn.show();
                            switch (this.isAdvancedOptionsAvaialble()) {
                                case true:
                                    this.$advancedTabButton.show();
                                    break;
                            }
                            break;
                        case 'receive':
                            this.deactivateShapeShift();
                            this.resetAll();
                            this.currentState = newState;
                            this.activateReceive();
                            this.$sendAddressView.hide();
                            this.$maxBtn.hide();
                            this.spendableView.hide();
                            this.$sendButtonLabel.text('GENERATE');
                            this.$receiveTabBtn.addClass("tabHighlighted");
                            this.$receiveTabLabel.addClass('whiteText');
                            this.$receiveTabImage.addClass('whiteSVG');
                            this.$sendTabBtn.removeClass("tabHighlighted");
                            this.$sendTabLabel.removeClass('whiteText');
                            this.$sendTabImage.removeClass('whiteSVG');
                            this.$view.addClass("tabHighlighted");
                            this.renderAmountInput();
                            this.show();
                            this.receiveTransactionsView.enable();
                            break;
                        case 'restore':
                            this.resetAll(callback);
                            this.currentState = 'reset';
                            break;
                    }
                    break;
                case 'receive':
                    switch (newState) {
                        case 'receive':
                            this.resetAll(function () {
                                jaxx.Registry.application$.triggerHandler(jaxx.Registry.UI_CONFIRM_TRANSACTION_CLOSED);
                            });
                            break;
                        case 'send':
                            this.deactivateShapeShift();
                            this.$sendAddressView.show();
                            this.spendableView.show();
                            this.$sendLabel.text('SEND');
                            this.$receiveTabBtn.removeClass("tabHighlighted");
                            this.$receiveTabLabel.removeClass('whiteText');
                            this.$receiveTabImage.removeClass('whiteSVG');
                            this.$sendTabBtn.addClass("tabHighlighted");
                            this.$sendTabLabel.addClass('whiteText');
                            this.$sendTabImage.addClass('whiteSVG');
                            this.$view.addClass("tabHighlighted");
                            this.receiveTransactionsView.disable();
                            this.$maxBtn.show();
                            switch (this.isAdvancedOptionsAvaialble()) {
                                case true:
                                    this.$advancedTabButton.show();
                                    break;
                            }
                            break;
                        case 'ShapeShift':
                            this.$receiveTabBtn.removeClass("tabHighlighted");
                            this.$receiveTabLabel.removeClass('whiteText');
                            this.$receiveTabImage.removeClass('whiteSVG');
                            this.$shapeShiftFoxBtn.addClass("tabHighlighted");
                            this.$exchangeTabLabel.addClass('whiteText');
                            this.$exchangeTabImage.addClass('whiteSVG');
                            this.$sendLabel.text('EXCHANGE');
                            this.$view.addClass("tabHighlighted");
                            this.$sendAddressView.hide();
                            this.spendableView.show();
                            this.receiveTransactionsView.disable();
                            this.$advancedTabButton.hide();
                            this.activateShapeshift(function () {
                                _this.shapeShift.isReady(+_this.amountToSend, function (result) {
                                    console.log(result);
                                });
                                if (_this.isShapeShiftActive) {
                                    return;
                                }
                                _this.isShapeShiftActive = true;
                                _this.$receiverAddress.css({ backgroundImage: 'url(' + g_JaxxApp.getShapeShiftHelper()._avatarImage + ')' })
                                    .addClass('validShapeshift')
                                    .addClass('cssValidShapeshift ');
                                _this.$receiverAddress.val("ShapeShift");
                                _this.shapeShift.activate();
                                _this.shapeShift.show();
                                _this.$sendButtonLabel.text('EXCHANGE');
                                _this.spendableView.update(0);
                                _this.$sendAddressView.hide();
                                _this.$maxBtn.hide();
                            });
                            break;
                        case 'restore':
                            this.resetAll();
                            this.currentState = 'reset';
                            break;
                    }
                    break;
                default:
                    switch (newState) {
                        case 'receive':
                            this.resetAll();
                            this.currentState = newState;
                            this.activateReceive();
                            this.$sendAddressView.hide();
                            this.$maxBtn.hide();
                            this.spendableView.hide();
                            this.$sendButtonLabel.text('GENERATE');
                            this.$receiveTabBtn.addClass("tabHighlighted");
                            this.$receiveTabLabel.addClass('whiteText');
                            this.$receiveTabImage.addClass('whiteSVG');
                            this.$view.addClass("tabHighlighted");
                            this.receiveTransactionsView.enable();
                            this.renderAmountInput();
                            this.show();
                            break;
                        case 'send':
                            this.activateSend();
                            this.renderAmountInput();
                            this.show();
                            this.$sendTabBtn.addClass("tabHighlighted");
                            this.$sendTabLabel.addClass('whiteText');
                            this.$sendTabImage.addClass('whiteSVG');
                            this.$view.addClass("tabHighlighted");
                            this.$maxBtn.show();
                            switch (this.isAdvancedOptionsAvaialble()) {
                                case true:
                                    this.$advancedTabButton.show();
                                    break;
                            }
                            break;
                        case 'ShapeShift':
                            this.activateShapeshift(function () {
                                _this.activateSend();
                                _this.$sendAddressView.show();
                                _this.spendableView.show();
                                _this.$receiveTabBtn.removeClass("tabHighlighted");
                                _this.$receiveTabLabel.removeClass('whiteText');
                                _this.$receiveTabImage.removeClass('whiteSVG');
                                _this.$shapeShiftFoxBtn.addClass("tabHighlighted");
                                _this.$exchangeTabLabel.addClass('whiteText');
                                _this.$exchangeTabImage.addClass('whiteSVG');
                                _this.$sendLabel.text('EXCHANGE');
                                _this.$view.addClass("tabHighlighted");
                                _this.$advancedTabButton.hide();
                                _this.show();
                                _this.$sendAddressView.hide();
                                _this.$maxBtn.hide();
                            });
                            break;
                    }
            }
        };
        SendTransactionsController.prototype.hide = function (callback) {
            this.isVisible = false;
            this.$view.slideUp("slow", function () {
                // Callback functionality added to hide to prevent UI timing glitches
                if (callback) {
                    callback();
                }
            });
            this.advanceGas.hide();
        };
        SendTransactionsController.prototype.show = function () {
            this.isActive = true;
            if (this.cryptoToFiatButton.isFiat) {
                this.showFiatSpendable();
            }
            else {
                this.showCryptoSpendable();
            }
            this.setUseFiat(this.cryptoToFiatButton.isFiat);
            this.advanceGas.show();
            this.$view.slideDown();
            this.spendableView.update(0);
        };
        /// this function activate send state not receive state
        SendTransactionsController.prototype.activateSend = function () {
            this.isActive = false;
            this.enableAdvanceGasIfRequired();
            this.$sendAddressView.show();
            this.spendableView.update(0);
            this.spendableView.show();
            this.$sendButtonLabel.text('SEND');
            this.evaluateSendButton();
            this.checkIsTokenNeedEthereum();
        };
        //this function activate receive state only
        SendTransactionsController.prototype.activateReceive = function () {
            this.isActive = true;
        };
        SendTransactionsController.prototype.checkIsTokenNeedEthereum = function () {
            var ctr = jaxx.Registry.getCurrentCryptoController();
            if (ctr && ctr.isToken && !ctr.isEnoughGas()) {
                this.$gasForSpendableWarning.show();
            }
        };
        SendTransactionsController.prototype.updateFieldWithBalance = function (fieldElement, balance) {
            //TODO: need fiat check for formatting.
            //TODO: Determine if val or text.
            var formattedValue = jaxx.Formatters.balanceForDisplay(balance);
            if (this.cryptoToFiatButton.isFiat) {
                fieldElement.val(jaxx.Formatters.balanceForDisplay(formattedValue, 2));
            }
            else {
                fieldElement.val(formattedValue);
            }
            return formattedValue;
        };
        /**
         * Measures the actual width of a text string using the given size and font face.
         *
         * @param textContent {string} - The desired string to be measured.
         * @param fontFamily {string} - The font family name. Examples: "Comic Sans", "Webdings"
         * @param fontSize {string} - The font size and unit as used in CSS values. Examples: "12px", "10pt", "1em"
         */
        SendTransactionsController.prototype.measureTextWidth = function (textContent, fontFamily, fontSize) {
            var ret_val = 0;
            var $in_mem_canvas_element = $('<canvas></canvas>');
            var text_metrics;
            var in_mem_canvas_2d_context = $in_mem_canvas_element.get(0).getContext('2d');
            in_mem_canvas_2d_context.font = fontSize + ' ' + fontFamily;
            text_metrics = in_mem_canvas_2d_context.measureText(textContent);
            ret_val = text_metrics.width;
            return ret_val;
        };
        return SendTransactionsController;
    }());
    jaxx.SendTransactionsController = SendTransactionsController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=send-transaction-controller.js.map
var jaxx;
(function (jaxx) {
    var ReceiveTransactionTemplate = '<div id="ReceiveModalOverlay" class="modal receive cssModal cssReceive" style="opacity: 0; display: none; transition: opacity 1s;">\
        <div class="cssContent">\
            <div class="cssHeader" closemodal="true">Payment Request\
                <div class="cssClose cssNoSelect">x</div>\
            </div>\
            <div class="cssItem cssCenter"> Requesting <span class="amount">5</span> <span class="amountAbbreviatedName">BTC</span> to\
                <div class="cssPopCenter cssAligCenter"> <span class="populateAddress cssAddress"></span>\
                    <div class="populateAddressCopyLarge imageCopy cssImageCopy cssNoSelect" data-copylarge=""></div>\
                </div>\
                <div class="qrCode cssQRCode"><img class="QRCode" src=""></div>\
            </div>\
        </div>\
    </div>';
    var ReceiveTransactionView = (function () {
        function ReceiveTransactionView(sendController) {
            var _this = this;
            this.isEnabled = false;
            this.sendController = sendController;
            this.onGenerateClickHandler = this.onGenerateButtonClicked.bind(this);
            this.onAmountChangeInputHandler = this.onAmountBoxInputChange.bind(this);
            // due to how the legacy code initializes in parallel
            // it overrides all UI events that init before that legacy part
            // we delay as a quick fix
            setTimeout(function () {
                _this.init();
            }, 300);
        }
        ReceiveTransactionView.prototype.enable = function () {
            if (this.isEnabled) {
                return;
            }
            var generateBtn = this.$GenerateButton.get(0);
            var amountBox = this.$AmountInputBox.get(0);
            generateBtn.addEventListener('click', this.onGenerateClickHandler);
            amountBox.addEventListener('input', this.onAmountChangeInputHandler);
            this.isEnabled = true;
        };
        ReceiveTransactionView.prototype.disable = function () {
            if (!this.isEnabled) {
                return;
            }
            var generateBtn = this.$GenerateButton.get(0);
            var amountBox = this.$AmountInputBox.get(0);
            generateBtn.removeEventListener('click', this.onGenerateClickHandler);
            amountBox.removeEventListener('input', this.onAmountChangeInputHandler);
            this.isEnabled = false;
        };
        ReceiveTransactionView.prototype.init = function () {
            this.$ViewContainer = $('.wallet');
            this.$ReceiveTabButton = $('#ReceiveTabBtn');
            this.$SendTabButton = $('#SendTabBtn');
            this.$GenerateButton = $('#Send_Recieve_Btn');
            this.$AmountInputBox = $('#amountSendInput');
            this.$ReceiveLabel = $('#receiveLabel');
            this.$SendLabel = $('#sendLabel');
            this.render();
            this.$ModalOverlay = $('#ReceiveModalOverlay');
            this.$CloseButton = $('#ReceiveModalOverlay .cssClose');
            this.$QRCodeImage = $('#ReceiveModalOverlay .QRCode');
            this.$Amount = $('#ReceiveModalOverlay .cssContent span.amount');
            this.$CoinSymbol = $('#ReceiveModalOverlay .cssContent .amountAbbreviatedName');
            this.$CopyButton = $('#ReceiveModalOverlay .populateAddressCopyLarge');
            this.$Address = $('#ReceiveModalOverlay .populateAddress');
            //this.$ReceiveTabButton.on('click', this.onReceiveButtonTabClicked.bind(this));
            //this.$SendTabButton.on('click', this.onSendButtonTabClicked.bind(this));
            //this.$GenerateButton.on('click', this.onGenerateButtonClicked.bind(this));
            this.$CloseButton.on('click', this.onCloseButtonClicked.bind(this));
            this.$CopyButton.on('click', this.onCopyButtonClicked.bind(this));
            //this.$AmountInputBox.on('input', this.onAmountBoxInputChange.bind(this))
            // the .bind component above ensures that when the event fires and the handlers are called
            // our "this" context will be the instance of the ReceiveTransactionView class
        };
        ReceiveTransactionView.prototype.render = function () {
            this.$ViewContainer.append(ReceiveTransactionTemplate);
        };
        ReceiveTransactionView.prototype.show = function (coinSymbol, amountRequested, address) {
            var _this = this;
            this.$Amount.text(amountRequested);
            this.$CoinSymbol.text(coinSymbol);
            this.$Address.text(address);
            this.$CopyButton.attr('data-copylarge', address);
            var QRCodeData = jaxx.Utils.generateQRCode(address);
            this.$QRCodeImage.attr('src', QRCodeData);
            this.$ModalOverlay.css('display', 'initial');
            setTimeout(function () {
                _this.$ModalOverlay.css('opacity', '1');
            }, 10);
        };
        ReceiveTransactionView.prototype.hide = function () {
            var _this = this;
            this.$ModalOverlay.css('opacity', '0');
            setTimeout(function () {
                _this.$ModalOverlay.css('display', 'none');
            }, 500);
        };
        ReceiveTransactionView.prototype.onAmountBoxInputChange = function (event) {
            var _this = this;
            var inputData = this.$AmountInputBox.val();
            setTimeout(function () {
                if (inputData.length > 0 && Number(inputData) != 0) {
                    _this.$GenerateButton.addClass('enabled');
                    _this.$GenerateButton.addClass('cssEnabled');
                    _this.$SendLabel.addClass('whiteText');
                    _this.$ReceiveLabel.addClass('whiteText');
                    console.log('%c Enabling generate button.', 'font-weight: bold');
                }
                else {
                    _this.$GenerateButton.removeClass('enabled');
                    _this.$GenerateButton.removeClass('cssEnabled');
                    _this.$SendLabel.removeClass('whiteText');
                    _this.$ReceiveLabel.removeClass('whiteText');
                    console.log('%c Disabling generate button.', 'font-weight: bold');
                }
            }, 50);
            event.stopImmediatePropagation();
        };
        ReceiveTransactionView.prototype.onGenerateButtonClicked = function (event) {
            var amount = this.$AmountInputBox.val();
            if (amount.length > 0 && Number(amount) != 0) {
                var address = void 0;
                address = $('#AddressView-address').text();
                if (address.length > 6) {
                    var coinSymbol = void 0;
                    var currentCryptoMaster = jaxx.Registry.getCurrentCryptoController();
                    if (currentCryptoMaster && currentCryptoMaster.symbol) {
                        coinSymbol = currentCryptoMaster.symbol;
                        if (this.sendController.cryptoToFiatButton.isFiat) {
                            amount = jaxx.FiatPriceController.fiatToCoin(amount, jaxx.FiatPriceController.instance.getActiveFiatCurrency(), coinSymbol);
                            amount = jaxx.Formatters.balanceForDisplay(amount, 8);
                        }
                        this.show(coinSymbol, amount, address);
                    }
                }
            }
        };
        ReceiveTransactionView.prototype.onCloseButtonClicked = function (event) {
            this.hide();
            jaxx.SendTransactionsController.instance.setState('restore');
        };
        ReceiveTransactionView.prototype.onCopyButtonClicked = function (event) {
            var copyValue = this.$CopyButton.attr('data-copylarge');
            if (window.native && window.native.copyToClipboard) {
                window.native.copyToClipboard(copyValue);
            }
            else {
                var temp_textarea = document.getElementById('clipboard'); // we have a global text area ready to use for copying
                temp_textarea.value = copyValue;
                temp_textarea.select();
                if (document.execCommand('copy')) {
                    Navigation.flashBanner('Address copied to clipboard.', 2, 'success');
                }
                else {
                    Navigation.flashBanner("Couldn't copy.", 2, 'error');
                }
                return;
            }
        };
        return ReceiveTransactionView;
    }());
    jaxx.ReceiveTransactionView = ReceiveTransactionView;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=receive-transaction-view.js.map
/**
 * Created by jnewlands on 2017-SEP-01.
 */
var jaxx;
(function (jaxx) {
    var BCHClaimController = (function () {
        function BCHClaimController(callback) {
            var _this = this;
            this.checkClaimOnNotification = false;
            BCHClaimController.instance = this;
            this.confirmation = '.cssBCHConfirmation';
            this.$view = $('#ClaimBCHConfirmation');
            this.$view.load('js/app/bch-claim/bch-claim.html', "", function () {
                setTimeout(function () {
                    _this.init();
                    if (callback)
                        callback(BCHClaimController.instance);
                }, 1000);
            });
        }
        BCHClaimController.prototype.init = function () {
            var _this = this;
            this.$amountValue1 = $('#claimBCHModalValue1');
            this.$amountValue2 = $('#claimBCHModalValue2');
            this.hasLoaded = true;
            this.$cancel = $('#cancelClaimBCH');
            this.$cancel.on('click', function () {
                _this.hide();
            });
            this.$claim = $('#claimBCH');
            this.$claim.on('click', function () {
                _this.hide();
                if (g_JaxxApp.getUser().hasPin()) {
                    g_JaxxApp.getUI().showEnterPinModal(function (error) {
                        if (error) {
                            console.log("enter pin error :: " + error);
                        }
                        else {
                            _this.claimBitcoinCash();
                        }
                    });
                }
                else {
                    _this.claimBitcoinCash();
                }
            });
            var self = this;
            var performCheckBitcoinCash = function () {
                self.checkBitcoinCash(function (response) {
                    if (response && !jaxx.MATH.isZero(response.totalBCHBalance)) {
                        console.warn('JN - BCH Balance:', response);
                        self.show(response.totalBCHBalance);
                    }
                    else {
                        // console.warn('JN - Want to set claim modal to TRUE.');
                        BCHClaimController.setClaimModalForBCH(true);
                    }
                });
            };
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_ACTIVATED, function (evt, obj) {
                if (obj.symbol === 'BCH' && BCHClaimController.getClaimModalForBCH() === 'false') {
                    // console.warn('performCheckBitcoinCash');
                    performCheckBitcoinCash();
                }
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_DONE, function (evt, obj) {
                if (obj.symbol === 'BTC' && _this.checkClaimOnNotification) {
                    _this.checkClaimOnNotification = false;
                    performCheckBitcoinCash();
                }
            });
        };
        BCHClaimController.prototype.checkBitcoinCash = function (callback) {
            var _this = this;
            var ctrBCH = jaxx.Registry.getCryptoControllerBySymbol('BCH');
            if (!ctrBCH)
                return console.error("Unable to retrieve BCH Crypto Controller.");
            var ctrBTC = jaxx.Registry.getCryptoControllerBySymbol('BTC');
            if (!ctrBTC)
                return console.error("Unable to retrieve BTC Crypto Controller.");
            var hasRestoreHistory = ctrBTC.getHistoryTimestamp();
            var response = {
                balances: null,
                totalBCHBalance: "0",
                tx: null
            };
            var performCallback = function (responseValue) {
                jaxx.Application.instance.hideInitializeWallet();
                callback(responseValue);
            };
            var self = this;
            var calculateClaimFromHistory = function () {
                response.balances = ctrBTC.getAddressesAll();
                var addresses = response.balances || [];
                if (addresses.length === 0)
                    callback();
                ctrBCH.coinService.downlaodUTXOs(addresses).done(function (utxos) {
                    var amount = 0;
                    var totalSatoshis = 0;
                    var miningFee = jaxx.MATH.satoshiToBtc(ctrBCH.config.miningFee.toString());
                    utxos.forEach(function (item) {
                        amount += +item.amount;
                        totalSatoshis += +item.satoshis;
                    });
                    // If no amount to claim, no need to build the transaction.
                    if (amount === 0)
                        return performCallback(response);
                    amount = amount - +miningFee;
                    response.totalBCHBalance = String(amount);
                    var tx = BCHClaimController.buildBitcoinTransactionWithInputsAndOutputsTransition(totalSatoshis.toString(), utxos);
                    var BTCCtr = jaxx.Registry.getCryptoControllerBySymbol('BTC');
                    if (!BTCCtr) {
                        console.error('no controller ');
                        return;
                    }
                    response.tx = tx;
                    self.claimSendTransaction = tx;
                    callback(response);
                }).fail(function (error) {
                    console.error('checkBitcoinCash - downloadUTXO error:', error);
                    performCallback(null);
                });
            };
            if (hasRestoreHistory) {
                calculateClaimFromHistory();
            }
            else {
                ctrBTC.restoreHistory(function () {
                    _this.checkClaimOnNotification = true;
                    calculateClaimFromHistory();
                });
            }
        };
        BCHClaimController.prototype.claimBitcoinCash = function () {
            if (!this.claimSendTransaction)
                return Navigation.flashBanner("Missing BCH Send Transaction.", 5, 'error');
            var ctr = jaxx.Registry.getCryptoControllerBySymbol('BCH');
            if (!ctr)
                return console.error("Unable to retrieve BCH Crypto Controller.");
            ctr.sendTransaction(this.claimSendTransaction).done(function (result) {
                if (result.success === 'success') {
                    BCHClaimController.setClaimModalForBCH(true);
                    Navigation.flashBanner('Transaction sent', 2, 'success');
                }
                else {
                    Navigation.flashBanner('Transaction failed', 2);
                    console.error(result);
                }
            }).fail(function (err) {
                Navigation.flashBanner('Transaction failed', 2);
                console.error(err);
            });
        };
        BCHClaimController.getClaimModalForBCH = function () {
            if (getStoredData('bchclaimModal')) {
                return getStoredData('bchclaimModal');
            }
            else {
                BCHClaimController.setClaimModalForBCH(false);
                return getStoredData('bchclaimModal');
            }
        };
        BCHClaimController.prototype.hide = function () {
            Navigation.closeNotificationBanner(this.confirmation);
        };
        BCHClaimController.prototype.isLoaded = function () {
            return this.hasLoaded;
        };
        BCHClaimController.setClaimModalForBCH = function (flag) {
            storeData("bchclaimModal", flag);
        };
        BCHClaimController.prototype.show = function (amount) {
            this.$view.parent().removeClass('cssStartHidden');
            var amountValue = jaxx.Formatters.balanceForDisplay(amount);
            this.$amountValue1.html(amountValue);
            this.$amountValue2.html(amountValue);
            if ($('.tabContent.cssTabContent').hasClass(this.confirmation)) {
                setTimeout(function () {
                    Navigation.openNotificationBanner(this.confirmation);
                }, 800);
            }
            else {
                Navigation.openNotificationBanner(this.confirmation);
            }
        };
        BCHClaimController.buildBitcoinTransactionWithInputsAndOutputsTransition = function (amount, toSpend) {
            // This mimicks the data structure we keep our transactions in so we can
            // simulate instantly fulfilling the transaction
            var tx = new bitcore.Transaction();
            var BCHCtr = jaxx.Registry.getCryptoControllerBySymbol('BCH');
            var miningFee = BCHCtr.config.miningFee;
            var BTCCtr = jaxx.Registry.getCryptoControllerBySymbol('BTC');
            var receiveAddress = BCHCtr.getCurrentAddress();
            tx.to(receiveAddress, (+amount - miningFee));
            for (var i = 0; i < toSpend.length; i++) {
                var utxo = toSpend[i];
                var inputObj = {
                    txId: utxo.txid,
                    outputIndex: utxo.vout,
                    script: bitcore.Script.buildPublicKeyHashOut(utxo.address),
                    satoshis: +utxo.satoshis
                };
                tx.from(inputObj);
            }
            tx.sort();
            for (var i = 0; i < toSpend.length; i++) {
                var utxo = toSpend[i];
                var getPVKey = BTCCtr.getPrivateKeyWifByAddress(utxo.address); // wallet.getPouchFold(COIN_BITCOIN).getPrivateKey(utxo.addressInternal, utxo.addressIndex);
                var signKey = bitcore.PrivateKey.fromWIF(getPVKey);
                tx.sign(signKey.toString());
            }
            tx.fee(miningFee);
            var serialized = tx.serialize();
            return {
                txid: 'txid',
                requested: amount + '',
                amountInt: amount + '',
                amountDecimal: +jaxx.MATH.satoshiToBtc(amount + ''),
                amountDecimalDisplay: null,
                displayAmount: jaxx.MATH.satoshiToBtc(amount + ''),
                miningFeeInt: miningFee + '',
                miningFeeDecimal: 0.0002,
                miningFeeSymbol: null,
                changeAmount: '0',
                totalSpent: amount + '',
                size: 0,
                hex: serialized,
                targetTransactionFee: miningFee,
                transactionBTC: tx,
                changeAddress: null,
                // amountDecimal: +toSendSatoshi / 1e8,
                outputs: null,
                inputs: null,
                addressTo: receiveAddress,
                symbol: "BTC",
                isMax: true,
                success: {}
            };
        };
        return BCHClaimController;
    }());
    jaxx.BCHClaimController = BCHClaimController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=bch-claim-controller.js.map
var jaxx;
(function (jaxx) {
    var DisplayPairingCodeController = (function () {
        function DisplayPairingCodeController() {
            var _this = this;
            DisplayPairingCodeController.instance = this;
            this.$view = $('.settings.viewJaxxToken.cssSettings.cssShowMnemonic');
            this.$view.load('js/app/display-pairing-code/display-pairing-code.html', "", function () {
                setTimeout(function () {
                    _this.init();
                }, 1000);
            });
        }
        DisplayPairingCodeController.prototype.init = function () {
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.MODULE_REDY, this);
            this.attachClickEvents();
        };
        DisplayPairingCodeController.prototype.attachClickEvents = function () {
            var elements = this.$view.find(".scriptAction").not(".scrollHeaderContainer .rightArrow").not(".scrollHeaderContainer .leftArrow"); // Exclude carousel arrows
            this.attachClickEventForScriptAction(elements);
        };
        DisplayPairingCodeController.prototype.attachClickEventForScriptAction = function (jquerySelector) {
            $(jquerySelector).off('click');
            $(jquerySelector).click(function (event) {
                scriptAction(event);
            });
        };
        return DisplayPairingCodeController;
    }());
    jaxx.DisplayPairingCodeController = DisplayPairingCodeController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=display-pairing-code-controller.js.map
var Registry = jaxx.Registry;
var jaxx;
(function (jaxx) {
    var ViewBackupPhraseController = (function () {
        function ViewBackupPhraseController() {
            var _this = this;
            ViewBackupPhraseController.instance = this;
            this.$view = $('#ViewBackupPhrase');
            this.$view.load('js/app/view-backup-phrase/view-backup-phrase.html', '', function () {
                _this.init();
            });
        }
        ViewBackupPhraseController.prototype.init = function () {
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.MODULE_REDY, this);
        };
        return ViewBackupPhraseController;
    }());
    jaxx.ViewBackupPhraseController = ViewBackupPhraseController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=view-backup-phrase-controller.js.map
var jaxx;
(function (jaxx) {
    var PairRestoreWalletController = (function () {
        function PairRestoreWalletController() {
            var _this = this;
            PairRestoreWalletController.instance = this;
            this.$view = $('#PairRestoreWallet');
            this.$view.load('js/app/pair-restore-wallet/pair-restore-wallet.html', "", function () {
                setTimeout(function () {
                    _this.init();
                }, 1000);
            });
        }
        PairRestoreWalletController.prototype.init = function () {
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.MODULE_REDY, this);
            this.attachClickEvents();
        };
        PairRestoreWalletController.prototype.attachClickEvents = function () {
            var elements = this.$view.find(".scriptAction").not(".scrollHeaderContainer .rightArrow").not(".scrollHeaderContainer .leftArrow"); // Exclude carousel arrows
            this.attachClickEventForScriptAction(elements);
        };
        PairRestoreWalletController.prototype.attachClickEventForScriptAction = function (jquerySelector) {
            $(jquerySelector).off('click');
            $(jquerySelector).click(function (event) {
                scriptAction(event);
            });
        };
        return PairRestoreWalletController;
    }());
    jaxx.PairRestoreWalletController = PairRestoreWalletController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=pair-restore-wallet-controller.js.map
var jaxx;
(function (jaxx) {
    var PrivateKeyList = (function () {
        function PrivateKeyList() {
            var _this = this;
            PrivateKeyList.instance = this;
            this.$view = $('.dynamicPrivateKeyDisplay');
            $.get('js/app/private-key-list/private-key-list.html', '', function (res) {
                _this.stringViewTemplate = res;
            });
            $.get('js/app/private-key-list/private-key-list-item.html', '', function (res) {
                _this.privateKeyItemTemplate = res;
            });
        }
        PrivateKeyList.prototype.init = function () {
            var _this = this;
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.MODULE_REDY, this);
            this.$list = this.$view.find('.cssWrapperPrivateKeys .cssKeysPrice');
            this.$backButton = this.$view.find('.imageReturn.cssImageReturn');
            this.$exportButton = this.$view.find('.cssBtnIntroRight');
            this.$backButton.on('click', function () {
                Navigation.popSettings();
            });
            this.$closeButton = this.$view.find('.cssClose');
            this.$closeButton.on('click', function () {
                Navigation.clearSettings();
                jaxx.Registry.jaxxUI.closeMainMenu();
            });
            this.$exportButton.on('click', function () {
                _this.exportPrivateKeys();
            });
            this.addInfoButtonListeners();
        };
        PrivateKeyList.prototype.displayPrivateKeys = function (privateKeys, symbol) {
            // this.addScroll();
            // this.$view.empty();
            // this.$view.append(this.stringViewTemplate);
            var _this = this;
            this.init();
            this.clearPrivateKeyList();
            var html = '';
            this.generateExportPrivateKeys(privateKeys);
            privateKeys.forEach(function (item) {
                html += PrivateKeyList.listItemFormatter(item, _this.privateKeyItemTemplate, symbol);
            });
            this.$list.html(html);
            $('.cssWrapperPrivateKeys').each(function (index, element) {
                $(element).show();
            });
            this.hideLoadingMessage();
        };
        PrivateKeyList.prototype.addInfoButtonListeners = function () {
            var _this = this;
            var infoItem = this.$view.find('.toggler');
            $.each(infoItem, function (index, element) {
                var i = ($(element).closest('.cssInitialHeight.cssExpandableText')).find('.triangleArrow.cssTriangleArrow');
                var infoButton = $(element);
                i.on('click', function () {
                    _this.toggleInfoItem(infoButton, i);
                });
            });
        };
        PrivateKeyList.prototype.hideLoadingMessage = function () {
            var loadingMessage = this.$view.find('.textDisplayMessageForPrivateKeys.cssTextDisplayMessageForPrivateKeys');
            loadingMessage.hide();
        };
        PrivateKeyList.prototype.toggleInfoItem = function (infoText, infoItem) {
            if (infoText.hasClass('hide')) {
                infoText.removeClass('hide');
                infoText.animate({ maxHeight: 120 }, 500);
                infoItem.addClass('cssFlipped');
            }
            else {
                setTimeout(function () {
                    infoText.addClass('hide');
                }, 500);
                infoText.animate({ maxHeight: 0 }, 500);
                infoItem.removeClass('cssFlipped');
            }
        };
        PrivateKeyList.prototype.generateExportPrivateKeys = function (privateKeys) {
            var privateAddress = _.map(privateKeys, function (privateKey) {
                return privateKey.address + ",\n" + privateKey.privateKey;
            });
            var stringExportPrivateKeys = "addresss,privatekey,\n";
            stringExportPrivateKeys += privateAddress.join(",\n\n");
            jaxx.ExportPrivateKeysViewController.instance.setPrivateKeys(stringExportPrivateKeys);
        };
        PrivateKeyList.prototype.isDifferentWallet = function (symbol) {
            var oldSymbol = this.$view.find('.imgTransactionBrand').data('symbol');
            if (oldSymbol !== symbol) {
                return true;
            }
            else {
                return false;
            }
        };
        PrivateKeyList.prototype.clear = function () {
            this.$view.empty();
        };
        PrivateKeyList.prototype.show = function () {
            var parentHTML = '';
            parentHTML += PrivateKeyList.viewFormatter(this.stringViewTemplate, this.strCoinName);
            this.$view.html(parentHTML);
        };
        PrivateKeyList.prototype.clearPrivateKeyList = function () {
            this.$view.find('.accountDataTableBitcoin.cssKeysPrice').empty();
        };
        PrivateKeyList.viewFormatter = function (template, coinName) {
            // let strHTML = '';
            // strHTML += this.stringViewTemplate;
            return template.replace('{{headerCoinName}}', coinName)
                .replace('{{optionCoinName}}', coinName)
                .replace('{{toggleCoinName}}', coinName);
            // this.$view.html(strHTML);
        };
        PrivateKeyList.listItemFormatter = function (privateKey, template, symbol) {
            var icon;
            var threeLetterCode = jaxx.Registry.getCryptoControllerBySymbol(symbol).threeLetterCode;
            icon = '<div class="imgTransactionBrand img' + threeLetterCode + '" data-symbol="' + symbol + '"></div>';
            return template.replace('{{amount}}', privateKey.balance)
                .replace('{{publicKey}}', privateKey.address)
                .replace('{{privateKey}}', privateKey.privateKey)
                .replace('{{symbol}}', symbol)
                .replace('{{icon}}', icon);
        };
        PrivateKeyList.prototype.exportPrivateKeys = function () {
            jaxx.ExportPrivateKeysViewController.instance.stringCoinName = this.strCoinName;
            jaxx.ExportPrivateKeysViewController.instance.hide();
            Navigation.pushSettings('exportPrivateKeysDynamically');
            jaxx.ExportPrivateKeysViewController.instance.show();
        };
        return PrivateKeyList;
    }());
    jaxx.PrivateKeyList = PrivateKeyList;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=private-key-list.js.map
var jaxx;
(function (jaxx) {
    var JaxxDatastoreController = (function () {
        function JaxxDatastoreController(config) {
            this.totalChange$ = $({}); // evt,number
            config.coins.forEach(function (item) {
                var ctr;
                if (item.enabled) {
                    if (item.controller === 'EthereumController') {
                        ctr = new jaxx.EthereumController(item);
                        if (item.name === 'Ethereum')
                            jaxx.Registry.Ethereum = ctr;
                    }
                    else
                        ctr = new jaxx.CoinController(item);
                    if (jaxx.Registry.jaxxApp._settings.isCryptoCurrencyEnabled(ctr.symbol) && _.isEmpty(localStorage.getItem('upgradeFrom1.2'))) {
                        localStorage.setItem('upgradeFrom1.2', 'true');
                        ctr.enabled = true;
                    }
                    jaxx.Registry.addCryptoController(ctr);
                }
            });
            config.tokens.forEach(function (item) {
                if (item.enabled) {
                    var ctr = new jaxx.TokenController(item);
                    jaxx.Registry.addCryptoController(ctr);
                    if (jaxx.Registry.jaxxApp._settings.isCryptoCurrencyEnabled(ctr.symbol) && _.isEmpty(localStorage.getItem('upgradeFrom1.2'))) {
                        localStorage.setItem('upgradeFrom1.2', 'true');
                        ctr.enabled = true;
                    }
                }
            });
            var ar = config.coins;
            ar = ar.concat(config.tokens);
            jaxx.Registry.setConfigCoins(ar);
            this.config = config;
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_SEQUENCE_CHANGED, function (evt, obj) {
                // console.log(obj);
                jaxx.Registry.getAllCryptoControllers().forEach(function (item) {
                    item.sort = obj[item.symbol];
                });
            });
            jaxx.Registry.datastore_controller_test = this;
            jaxx.Registry.application$.triggerHandler('JaxxDatastoreController', this);
        }
        JaxxDatastoreController.prototype.initialize = function (config) {
            console.log("[ JaxxDatastoreController :: Initialize ]");
        };
        JaxxDatastoreController.prototype.enableWallet = function () {
            // Registry.ja
        };
        JaxxDatastoreController.prototype.getHistory = function () {
            return null;
            //return this.currentModel.getTransactions();
        };
        JaxxDatastoreController.onNetworkError = function () {
            JaxxDatastoreController.emitter$.triggerHandler(JaxxDatastoreController.ON_NETWORK_ERROR, [arguments]);
        };
        JaxxDatastoreController.onNewTransactions = function () {
            JaxxDatastoreController.emitter$.triggerHandler(JaxxDatastoreController.ON_TRANSACTIONS_CHANGE, [arguments]);
        };
        return JaxxDatastoreController;
    }());
    /* setDefault(coinType: string): void {
         this.defaultName = coinType;
     }*/
    JaxxDatastoreController.ON_NETWORK_ERROR = 'ON_NETWORK_ERROR';
    JaxxDatastoreController.ON_TRANSACTIONS_CHANGE = 'ON_TRANSACTIONS_CHANGE';
    JaxxDatastoreController.emitter$ = $({});
    jaxx.JaxxDatastoreController = JaxxDatastoreController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=datastore_controller.js.map
var jaxx;
(function (jaxx) {
    var PrivateKeysViewController = (function () {
        function PrivateKeysViewController() {
            var _this = this;
            PrivateKeysViewController.instance = this;
            this.$view = $('.backupPrivateKeys');
            this.$view.load('js/app/private-keys/private-keys.html', "", function () {
                _this.init();
            });
        }
        PrivateKeysViewController.prototype.init = function () {
            var _this = this;
            // console.warn('Private Keys window has initialized!');
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.MODULE_REDY, this);
            $.get('js/app/private-keys/private-keys-list-item.html', '', function (res) {
                _this.privateKeysListItemTemplate = res;
            });
            this.$list = this.$view.find('.cssScrollableMenuListWrapper .privateKeyMenuList');
            this.$backButton = this.$view.find('.imageReturn.cssImageReturn');
            this.$backButton.on('click', function () {
                Navigation.popSettings();
            });
            this.$closeButton = this.$view.find('.cssClose');
            this.$closeButton.on('click', function () {
                Navigation.clearSettings();
                jaxx.Registry.jaxxUI.closeMainMenu();
            });
            this.addScroll();
        };
        PrivateKeysViewController.prototype.addScroll = function () {
            this.$view.find('.cssScrollableMenuListWrapper').height($(window).height() - 51);
        };
        PrivateKeysViewController.prototype.displayPrivateKeys = function () {
            var _this = this;
            this.clearPrivateKeysList();
            var coinController = jaxx.Registry.getAllSelectedPrivateKeyCryptoCrontrollers();
            var html = '';
            coinController.forEach(function (item) {
                html += PrivateKeysViewController.formatter(item.displayName, item.symbol, _this.privateKeysListItemTemplate);
                // if(item.displayPrivateKey)  g_JaxxApp.getUI().addCoinToPrivateKeyListIfMissing(item.symbol, item.displayName);
            });
            this.$list.html(html);
            this.displayPrivateKeysListItemClick();
            this.addInfoButtonListeners();
        };
        PrivateKeysViewController.prototype.displayPrivateKeysListItemClick = function () {
            var _this = this;
            this.$view.find('.optionTrigger.cssOptionTrigger').each(function (index, element) {
                element.addEventListener('click', function () {
                    // console.warn($(element).attr('data-symbol'));
                    // let coinType:string = $(element).attr('data-symbol');
                    var target = $(element).closest('.cssInitialHeight.cssExpandableText');
                    var symbol = target.data('symbol');
                    var displayName = target.data('displayname');
                    jaxx.PrivateKeyList.instance.strCoinName = displayName;
                    // let pageDisplayPrivateKeysName =  'backupPrivateKeys'; //HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents.pageDisplayPrivateKeysName;
                    // wallet.getPouchFold(coinType).getDataStorageController().activate();
                    $('.backupPrivateKeys .textDisplayMessageForPrivateKeys').show();
                    // $('.cssPrivateKeyViewportBox').show();
                    jaxx.PrivateKeyList.instance.clear();
                    jaxx.PrivateKeyList.instance.show();
                    Navigation.pushSettings('dynamicPrivateKeyDisplay', function () {
                        _this.setupBackupPrivateKeys(symbol);
                    });
                    // this.viewFormatter(this.$view, displayName);
                });
            });
        };
        PrivateKeysViewController.prototype.addInfoButtonListeners = function () {
            var _this = this;
            var infoItem = this.$list.find('.toggler');
            $.each(infoItem, function (index, element) {
                var i = ($(element).closest('.cssInitialHeight.cssExpandableText')).find('.triangleArrow.cssTriangleArrow');
                var infoButton = $(element);
                i.on('click', function () {
                    _this.toggleInfoItem(infoButton, i);
                });
            });
        };
        PrivateKeysViewController.prototype.setupBackupPrivateKeys = function (symbol) {
            var ctr = jaxx.Registry.getCryptoControllerBySymbol(symbol);
            ctr.getPrivateKeys().done(function (result) {
                jaxx.PrivateKeyList.instance.displayPrivateKeys(result, symbol);
            });
            // g_JaxxApp.getUI().updateAndLoadPrivateKeyList(symbol);
        };
        PrivateKeysViewController.formatter = function (displayName, symbol, template) {
            // let icon: string;
            // icon='<div class="imgTransactionBrand img'+ symbol +'" data-symbol="'+symbol+'"></div>';
            return template.replace('{{displayName}}', displayName)
                .replace('{{displaySymbol}}', symbol)
                .replace('{{walletName}}', displayName)
                .replace('{{walletNameHidden}}', displayName);
        };
        PrivateKeysViewController.prototype.clearPrivateKeysList = function () {
            this.$view.find('.cssScrollableMenuListWrapper .privateKeyMenuList').empty();
        };
        PrivateKeysViewController.prototype.toggleInfoItem = function (infoText, infoItem) {
            if (infoText.hasClass('hide')) {
                infoText.removeClass('hide');
                infoText.animate({ maxHeight: 120 }, 500);
                infoItem.addClass('cssFlipped');
            }
            else {
                setTimeout(function () {
                    infoText.addClass('hide');
                }, 500);
                infoText.animate({ maxHeight: 0 }, 500);
                infoItem.removeClass('cssFlipped');
            }
        };
        return PrivateKeysViewController;
    }());
    jaxx.PrivateKeysViewController = PrivateKeysViewController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=private-keys-view-controller.js.map
var jaxx;
(function (jaxx) {
    var ExportPrivateKeysViewController = (function () {
        function ExportPrivateKeysViewController() {
            var _this = this;
            ExportPrivateKeysViewController.instance = this;
            this.$view = $('#ExportPrivateKeysDynamically');
            $.get('js/app/export-private-keys/export-private-keys.html', '', function (res) {
                _this.stringViewTemplate = res;
            });
        }
        ExportPrivateKeysViewController.prototype.init = function () {
            var _this = this;
            this.$backButton = this.$view.find('.imageReturn.cssImageReturn');
            this.$backButton.on('click', function () {
                Navigation.popSettings();
            });
            this.$closeButton = this.$view.find('.cssClose');
            this.$closeButton.on('click', function () {
                Navigation.clearSettings();
                //TODO need to toggle main menu
            });
            this.$textArea = this.$view.find('textarea');
            this.addPrivateKeysToTextArea();
            this.$buttonCopyAll = this.$view.find('.cssBtnIntroRight');
            this.$buttonCopyAll.on('click', function () {
                _this.copyPrivateKeys();
            });
        };
        ExportPrivateKeysViewController.prototype.show = function () {
            var parentHTML = '';
            parentHTML += ExportPrivateKeysViewController.viewFormatter(this.stringViewTemplate, this.stringCoinName);
            this.$view.html(parentHTML);
            this.init();
        };
        ExportPrivateKeysViewController.prototype.hide = function () {
            this.$view.empty();
        };
        ExportPrivateKeysViewController.prototype.copyPrivateKeys = function () {
            jaxx.Utils.copyClipboard(this.stringExportPrivateKeys);
        };
        ExportPrivateKeysViewController.prototype.addPrivateKeysToTextArea = function () {
            this.$textArea.val(this.stringExportPrivateKeys);
        };
        ExportPrivateKeysViewController.prototype.setPrivateKeys = function (privateKeys) {
            this.stringExportPrivateKeys = privateKeys;
        };
        ExportPrivateKeysViewController.prototype.getPrivateKeys = function () {
            return this.stringExportPrivateKeys;
        };
        ExportPrivateKeysViewController.viewFormatter = function (template, coinName) {
            return template.replace('{{headerCoinName}}', coinName)
                .replace('{{contenCoinName}}', coinName);
        };
        return ExportPrivateKeysViewController;
    }());
    jaxx.ExportPrivateKeysViewController = ExportPrivateKeysViewController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=export-private-keys-view-controller.js.map
var jaxx;
(function (jaxx) {
    var ModalViewController = (function () {
        function ModalViewController() {
            var _this = this;
            var isWalletBeingCreated = false;
            var showAllBulletin = true;
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_ACTIVATED, function (evt, ctr) {
                if (!isWalletBeingCreated) {
                    _this.showCoinBulletin(ctr.symbol);
                    if (showAllBulletin) {
                        // If the "Don't Show This Bulletin Again" option is clicked, on close, for one coin bulletin;
                        // it should never show the generic bulletin again for other coins
                        _this.showCoinBulletin("ALL");
                    }
                }
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_NEW_WALLET_START, function () {
                isWalletBeingCreated = true;
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_NEW_WALLET_END, function () {
                isWalletBeingCreated = false;
            });
            // If "Don't Show This Bulletin Again" option is clicked, on close, for any coin: set the boolean to false
            jaxx.Registry.application$.on(jaxx.Registry.HIDE_ALL_BULLETIN, function () {
                showAllBulletin = false;
            });
        }
        ModalViewController.prototype.showCoinBulletin = function (symbol) {
            var coinBulletinData = g_JaxxApp.getUI().getCoinBulletinData();
            var coinsInBulletin = Object.keys(coinBulletinData);
            var bulletinData = coinBulletinData[symbol];
            if (typeof (bulletinData) !== "undefined" && bulletinData !== null) {
                var version = bulletinData["version"];
                if (!g_JaxxApp.getSettings().isCoinBulletinHideOnSelect(version)) {
                    if (coinsInBulletin.indexOf(symbol) > -1) {
                        $(".coinBulletinTitle").text(bulletinData.title);
                        $(".coinBulletinDescription").html(bulletinData.description);
                        $(".coinBulletinCloseButton").attr("value", symbol);
                        Navigation.openModal("jaxxNews");
                    }
                }
            }
        };
        ModalViewController.prototype.showCoinBulletinFromMenu = function (symbol) {
            var coinBulletinData = g_JaxxApp.getUI().getCoinBulletinData();
            var coinsInBulletin = Object.keys(coinBulletinData);
            var bulletinData = coinBulletinData[symbol];
            if (typeof (bulletinData) !== "undefined" && bulletinData !== null) {
                if (coinsInBulletin.indexOf(symbol) > -1) {
                    $(".coinBulletinTitle").text(bulletinData.title);
                    $(".coinBulletinDescription").html(bulletinData.description);
                    $(".coinBulletinCloseButton").attr("value", symbol);
                    Navigation.openModal("jaxxNews");
                }
            }
        };
        return ModalViewController;
    }());
    jaxx.ModalViewController = ModalViewController;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=modal-view-controller.js.map
/**
 * Created by Vlad on 10/11/2016.
 **/
var jaxx;
(function (jaxx) {
    var Application = (function () {
        function Application() {
            this.appVersion = '1.3.11';
            this.configVersion = '';
            this.configUsingLocalFile = false;
            this.configLastUpdateTimestamp = 0;
            Application.instance = this;
            jaxx.Registry.application = this;
            this.init();
        }
        Application.prototype.setConfig = function (config) {
            this.config = config;
            this.configVersion = config.ver;
            var usingLocal = localStorage.getItem('useAppConfig');
            if (usingLocal && usingLocal['toLowerCase'] && usingLocal.toLowerCase() === 'true') {
                this.configUsingLocalFile = true;
            }
            else {
                this.configUsingLocalFile = false;
            }
            this.configLastUpdateTimestamp = Number(localStorage.getItem('lastJaxxConfigUpdate'));
            this.bitCoinMiningFeeController = new jaxx.MiningFeeView();
            this.fiatPriceController.init(config);
            this.setWakeApTimer();
            this.navigationToolMenuController.updateUIConfigInformation(this.configVersion, this.configLastUpdateTimestamp, this.configUsingLocalFile);
        };
        Application.prototype.init = function () {
            var _this = this;
            jaxx.Registry.application$.on(jaxx.Registry.MODULE_REDY, function (evt, obj) {
                console.log(jaxx.Registry.MODULE_REDY + ' ' + obj.constructor.name);
            });
            this.bchClaimController = new jaxx.BCHClaimController();
            this.fiatPriceController = new jaxx.FiatPriceController();
            this.coinsMenu = new jaxx.CoinsMenu();
            this.spinner = new jaxx.Spinner();
            this.balanceController = new jaxx.BalanceView();
            this.addressView = new jaxx.AddressView();
            //TODO  rename transactionsView into TransactionsHistory
            this.transactionsView = new jaxx.TransactionsView();
            jaxx.Registry.platformCheck();
            this.sendTransactionsViewController = new jaxx.SendTransactionsController();
            this.paperWalletTransactionController = new jaxx.PaperWalletTransactionController();
            this.transferPaperWalletMenu = new jaxx.TransferPaperWalletMenu();
            this.transferPaperWalletWarning = new jaxx.TransferPaperWalletWarning();
            this.transferPaperWallet = new jaxx.TransferPaperWallet();
            this.sweepPrivateKey = new jaxx.SweepPrivateKey();
            this.navigationToolMenuController = new jaxx.NavigationToolMenuController();
            this.privateKeyList = new jaxx.PrivateKeyList();
            this.intro = new jaxx.IntroPagesMain(jaxx.Registry.registry['JaxxUIIntro']);
            this.displayPairingCodeController = new jaxx.DisplayPairingCodeController();
            this.privateKeysViewController = new jaxx.PrivateKeysViewController();
            this.viewBackupPhraseController = new jaxx.ViewBackupPhraseController();
            this.pairRestoreWalletController = new jaxx.PairRestoreWalletController();
            this.exportPrivateKeysViewController = new jaxx.ExportPrivateKeysViewController();
            this.modalViewController = new jaxx.ModalViewController();
            jaxx.Registry.setFiatPriceController(this.fiatPriceController);
            jaxx.Registry.application$.on(jaxx.Registry.KILL_HISTORY, function () {
                _this.hideInitializeWallet();
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_COIN_ACTIVATED, function (evt, obj) {
                _this.activeCoin = obj.symbol;
            });
            jaxx.Registry.application$.on(jaxx.Registry.SHOW_INIT_WALLET, function () {
                _this.isWalletInitializing = true;
            });
            jaxx.Registry.application$.on(jaxx.Registry.HIDE_INIT_WALLET, function () {
                _this.isWalletInitializing = false;
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_START, function (evt, obj) {
                var ctr = jaxx.Registry.getCurrentCryptoController();
                if (!ctr || ctr.symbol !== obj.symbol) {
                    return;
                }
                _this.showInitializeWallet();
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_RESTORE_HISTORY_DONE, function (evt, obj) {
                var ctr = jaxx.Registry.getCurrentCryptoController();
                if (!ctr || ctr.symbol !== obj.symbol) {
                    return;
                }
                _this.hideInitializeWallet();
                Navigation.flashBanner('Wallet Initialized!', 2, 'success', { close: false });
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_CONFIG_UPDATED, function () {
                if (!localStorage.getItem('useAppConfig')) {
                    location.reload();
                }
            });
            /*
                This is a UI only event triggered by the coin carousel. The Spinner activates transition-out and in
                animations on all wallet elements, while it also shows a spinning washed out coin in the middle.
            */
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_COIN_ACTIVATE_START, function (ev, coinToBeActivated) {
                //Deactivates itself with a timer until an app-wide event will be established
                _this.spinner.showSpinnerBySymbol(coinToBeActivated);
            });
            jaxx.Registry.application$.on(jaxx.Registry.ON_UI_SHAPE_SHIFT_FROM_CHANGE, function (ev, coinToBeActivated) {
                _this.spinner.showShapeShiftSpinnerBySymbol(coinToBeActivated);
            });
        };
        Application.prototype.setWakeApTimer = function () {
            var _this = this;
            var timeout = this.config.defaults.goSleep || 160000;
            $(document).on('mousedown', function () {
                console.log('Sleep Timer: ' + timeout / 1000 + ' s');
                clearTimeout(_this.wakeUpTimer);
                _this.wakeUpTimer = setTimeout(function () {
                    jaxx.Registry.application$.triggerHandler(jaxx.Registry.GO_SLEEP);
                }, timeout);
            });
            jaxx.Registry.application$.on(jaxx.Registry.GO_SLEEP, function () {
                console.log("-- SLEEP MODE --");
                $('.cssSuspendOverlay').remove();
                var overlay = $('<div>').addClass('cssSuspendOverlay').appendTo('body').click(function () {
                    overlay.remove();
                    jaxx.Registry.application$.triggerHandler(jaxx.Registry.WAKE_UP);
                });
                if (_this.isSleeping) {
                    return;
                }
                _this.isSleeping = true;
                jaxx.Registry.getAllCryptoControllers().forEach(function (ctr) {
                    ctr.goSleep();
                });
            });
            jaxx.Registry.application$.on(jaxx.Registry.WAKE_UP, function () {
                if (!_this.isSleeping) {
                    return;
                }
                _this.isSleeping = false;
                jaxx.Registry.getAllCryptoControllers().forEach(function (ctr) {
                    ctr.wakeUp();
                });
            });
        };
        Application.prototype.showInitializeWallet = function (ignoreAddressView) {
            $('#refresh-loading').hide();
            $('.initializingLoading').show().removeClass('cssStartHidden');
            $('#WalletFiatBalance').css("opacity", "0");
            $('.decimalPoint.cssDecimalPoint').hide();
            $('.decimalPortion cssDecimalPortion').hide();
            if (!ignoreAddressView) {
                $('#AddressView-address').text("-----");
                $('#CopyToClipboardBtn').css("opacity", "0");
            }
            $('#overlay').css({
                "height": "100%",
                "position": "absolute",
                "width": "100%",
                "z-index": "999999999999999"
            }).show();
            // Used to determine whether a coin is being loaded for the first time or simply switching to coins already initialized
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.WALLET_FIRST_INIT);
        };
        Application.prototype.hideInitializeWallet = function () {
            $('#refresh-loading').show();
            $('.initializingLoading').hide().addClass('cssStartHidden');
            $('#WalletFiatBalance').css("opacity", "1");
            $('#CopyToClipboardBtn').css("opacity", "1");
            $('.decimalPoint.cssDecimalPoint').show();
            $('.decimalPortion cssDecimalPortion').show();
            $('#overlay').css({
                "height": "initial",
                "position": "initial",
                "width": "initial",
                "z-index": "initial"
            }).hide();
        };
        Application.prototype.applicationReady = function () {
            if (this.isStart) {
                return;
            }
            this.isStart = true;
            $("#ApplicationStartScreen").fadeOut('fast', function () {
                $("#ApplicationStartScreen").remove();
            });
        };
        Application.prototype.showWallets = function () {
            jaxx.Registry.jaxxUI.generateSettingsCryptoCurrencyRows();
        };
        Application.prototype.switchToCoin = function (symbol) {
            jaxx.Registry.setCurrentControllerBySymbol(symbol);
        };
        Application.prototype.setSendButtonState = function (state) {
            switch (state) {
                case 'active':
                    $('.tabContent .amount .button').addClass('cssEnabled').addClass('enabled');
                    break;
                case 'disabled':
                    $('.tabContent .amount .button').removeClass('cssEnabled').removeClass('enabled');
                    break;
            }
        };
        return Application;
    }());
    jaxx.Application = Application;
})(jaxx || (jaxx = {}));
//# sourceMappingURL=Application.js.map
/* @note: @info: 
for shapeshift api:

shapeshift.io/shift

For your first question, are you asking how long market rates are good for?  Or are you asking how long the receiving address is good for?  For the `/shift` api, a permanent conduit is created between the receiving ShapeShift address and the user’s destination address.  The user can send to the receiving address at any time into the future and a ‘shift’ will be made at market rates and sent to the destination address.


shapeshift.io/marketinfo 's limit/maxLimit returned as zero with status okay

Yes I see now.  That is normal behavior for our system when a node goes down on the backend.  Recently as you might be aware Ethereum has undergone a couple network attacks and we had to take our nodes down temporarily.  We do our best to also turn off the affected coin on the website and in the API, but sometimes a node goes down unexpectedly before we have the chance to properly disable it.  In the case that a node is down, then the system will report a limit of zero which is basically saying that no incoming amounts can be processed for that currency pair.  Once the node is back up and running then the system automatically begins to report normal values.  I hope that’s not too confusing.  Let me know if that helps.

*/

var JaxxShapeShiftHelper = function() {
    this._base = "https://shapeshift.io/";
    this._entrypoint_marketinfo = this._base + "marketinfo/";
    this._entrypoint_shift = this._base + "shift/";
    this._avatarImage = 'img/shapeshift_64x64.png';

    this._triggered = false;
    
    this._currentShiftParams = null;

    this._updateShiftMarketTaskID = null;
    //----------------------Update market info -------------------------------------------------------------------------------------------------------------- 
    //{pair:"btc_eth", depositMax:null, depositMin:null,exchangeRate:null, lastupdated: 0, depositAddress: null, shiftInitiated : false };
    this._receivePair = [];

    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
        if (i === COIN_BITCOIN) {
            this._receivePair[i] = COIN_ETHEREUM;
        } else {
            this._receivePair[i] = COIN_BITCOIN;
        }
    }
    
    this._initMarketData = [];
  /*
    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
        this._initMarketData[i] = [];
        
        for (var j = 0; j < COIN_NUMCOINTYPES; j++) {
            if (j !== i) {
                var coinAbbreviatedNameA = HDWalletPouch.getStaticCoinPouchImplementation(i).pouchParameters['coinAbbreviatedName'];
                
                var coinAbbreviatedNameB = HDWalletPouch.getStaticCoinPouchImplementation(j).pouchParameters['coinAbbreviatedName'];
                
                var pairName = coinAbbreviatedNameA.toLowerCase() + "_" + coinAbbreviatedNameB.toLowerCase();
                
                this._initMarketData[i][j] = {pair: pairName, depositMax: null, depositMin: null, exchangeRate: null, lastupdated: 0, depositAddress: null, shiftInitiated: false, multiShift: [{depositAddress: null, timestamp: 0}]};
            }
        }
    }
    */
//    console.log("_initMarketData :: " + JSON.stringify(this._initMarketData));
    
    //this._marketData = JSON.parse(JSON.stringify(this._initMarketData));

//    
//    this._market_sendBTCgetETH = {pair:"btc_eth", depositMax:null, depositMin:null,exchangeRate:null, lastupdated: 0, depositAddress: null, shiftInitiated : false };
//    
//    this._market_sendETHgetBTC = {pair:"eth_btc", depositMax:null, depositMin:null,exchangeRate:null, lastupdated: 0, depositAddress: null, shiftInitiated : false };
}

JaxxShapeShiftHelper.networkDefinitions = {
    "apiKey": "180aaede8f5451a52847824f4965cc25f43a5d2bb49f483c1f1ecc8afad661b65e22a01046bfd67257e31189b48f5a1ec35207653bd017f8203f4241c763074a",
};

JaxxShapeShiftHelper.prototype.initialize = function() {
    
}

JaxxShapeShiftHelper.prototype.getIsTriggered = function() {
    return this._triggered;
}

JaxxShapeShiftHelper.prototype.setIsTriggered = function(triggered) {
    this._triggered = triggered;
}

JaxxShapeShiftHelper.prototype.reset = function() {
//    console.log("shapeshift helper :: reset");
    
    this.clearUpdateIntervalIfNecessary();
    
    //@note: @here: deep clone the initialization array.
    this._marketData = JSON.parse(JSON.stringify(this._initMarketData));

//    this._market_sendBTCgetETH = {pair:"btc_eth", depositMax:null, depositMin:null,exchangeRate:null, lastupdated: 0, depositAddress: null, shiftInitiated : false };
//    this._market_sendETGgetBTC = {pair:"eth_btc", depositMax:null, depositMin:null,exchangeRate:null, lastupdated: 0, depositAddress: null, shiftInitiated : false };
    
    this._triggered = false;
}

JaxxShapeShiftHelper.prototype.loadReceivePairForCoinType = function(symbolSend, symbolReceive, callBack) {

    var pair = symbolSend+'_'+symbolReceive;
    var self = this;
    RequestSerializer.getJSON(this._entrypoint_marketinfo + pair, function(data, status, param) {
       // console.log(data);

        callBack(data);
       //var receiveAddress = wallet.getPouchFold(coinTypeDict.receive).getCurrentReceiveAddress();
       // var returnAddress = wallet.getPouchFold(coinTypeDict.send).getCurrentReceiveAddress();


       // self.updateShapeshiftMarketInfoCallback(data, status, param);

    }, true, null);

   // this._receivePair[coinType] = receiveType;
}

JaxxShapeShiftHelper.prototype.getReceivePairForCoinType = function(coinType) {

    return this._receivePair[coinType];
}

JaxxShapeShiftHelper.prototype.getMarketForCoinTypeSend = function(coinType) {
    var coinPair = this.getReceivePairForCoinType(coinType);

    return this._marketData[coinType][coinPair];
}

JaxxShapeShiftHelper.prototype.getMarketMinimumForCoinTypeSend = function(coinType) {


    return this._marketData[coinType][this.getReceivePairForCoinType(coinType)].depositMin;
}

//JaxxShapeShiftHelper.prototype.startShapeshift = function() {


   /* var ssMarket = this.getMarketForCoinTypeSend(coinType);


    if (this._updateShiftMarketTaskID === null) {
        console.log("setting up shapeshift market info");
        this.updateShapeShiftMarket(ssMarket);
        
        var self = this;
        //Schedule a task to update values every 30 seconds (that is how often ss updates it)
        this._updateShiftMarketTaskID = setInterval(function() {
            self.updateShapeShiftMarket(ssMarket);
        }, 30000);
    }*/
//}

JaxxShapeShiftHelper.prototype.clearUpdateIntervalIfNecessary = function(coinType) {
    clearInterval(this._updateShiftMarketTaskID);
    this._updateShiftMarketTaskID = null;
}

JaxxShapeShiftHelper.prototype.updateShapeShiftMarket = function(curMarketData) {
    var self = this;
    
    RequestSerializer.getJSON(this._entrypoint_marketinfo + curMarketData.pair, function(data, status, param) {
        self.updateShapeshiftMarketInfoCallback(data, status, param);
    }, true, curMarketData);
    
//    if (ssMarket.pair == "btc_eth") {
//        RequestSerializer.getJSON(this._entrypoint_marketinfo + this._market_sendBTCgetETH.pair, function(data, status, param) {
//            self.updateShapeshiftMarketinfoCallbackBTCETH(data, status);
//        }, true, ssMarket);
//    } else if (ssMarket.pair == "eth_btc") {
//        RequestSerializer.getJSON(this._entrypoint_marketinfo + this._market_sendETHgetBTC.pair, function(data, status, param) {
//            self.updateShapeshiftMarketinfoCallbackETHBTC(data, status);
//        }, true, ssMarket);
//    }
}
/*
JaxxShapeShiftHelper.prototype.getCoinTypeForAbbreviatedName = function(abbreviatedName) {
    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
        var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(i).pouchParameters['coinAbbreviatedName'];
        
        if (coinAbbreviatedName.toLowerCase() === abbreviatedName) {
            return i;
        }
    }
    
    console.log("JaxxShapeShiftHelper.prototype.getCoinTypeForAbbreviatedName :: error :: abbreviatedName :: " + abbreviatedName + " not found");
    
    return 0;
}*/
/*

JaxxShapeShiftHelper.prototype.getPairCoinTypeDict = function(pair) {
    var coinArray = pair.split("_");

    var coinTypeSend = this.getCoinTypeForAbbreviatedName(coinArray[0]);
    var coinTypeReceive = this.getCoinTypeForAbbreviatedName(coinArray[1]);
    
    return {send: coinTypeSend, receive: coinTypeReceive};
}
*/


/*

JaxxShapeShiftHelper.prototype.updateShapeshiftMarketInfoCallback = function(ssMarket, status, curMarketData) {
    if (!ssMarket || status !== 'success') {
        console.warn("Error while updating " + ssMarket.pair + " market")
        return;
    }
    
    this.updateShapeshiftMarketInfo(curMarketData.pair, ssMarket);
}
*/

/*JaxxShapeShiftHelper.prototype.updateShapeshiftMarketInfo = function(pair, ssMarket) {
    var timestamp = new Date().getTime();
//    var temp = {pair: pair, depositMax: ssMarket.limit, depositMin: ssMarket.minimum, exchangeRate: ssMarket.rate, lastupdated: timestamp};

    var coinTypeDict = this.getPairCoinTypeDict(pair);


    console.log(" updateShapeshiftMarketInfo coinTypeDict:", coinTypeDict);

    var curMarketData = this._marketData[coinTypeDict['send']][coinTypeDict['receive']];
    curMarketData.depositMax = ssMarket.limit;
    curMarketData.depositMin = ssMarket.minimum;
    curMarketData.exchangeRate = ssMarket.rate;
    curMarketData.lastupdated = timestamp;

   // console.log("marketData :: " + JSON.stringify(this._marketData) + " :: ssMarket :: " + JSON.stringify(ssMarket, null, 4));

   // console.log("Shapeshift : market info [" + pair + "] updated  :" + JSON.stringify(curMarketData));

    //TODO Refresh shapeshift bar values

    //prepare shift

    var receiveAddress = wallet.getPouchFold(coinTypeDict.receive).getCurrentReceiveAddress();
    var returnAddress = wallet.getPouchFold(coinTypeDict.send).getCurrentReceiveAddress();

console.warn('receiveAddress ' + receiveAddress +' returnAddress ' + returnAddress );

    g_JaxxApp.getUI().updateShapeShiftDisplay(coinTypeDict, curMarketData);
}*/

JaxxShapeShiftHelper.prototype.isMultiShiftValid = function(coinType, numShiftsRequired) {
    var timestamp = new Date().getTime();

    var curMarketData = this.getMarketForCoinTypeSend(coinType);

    var coinTypeDict = this.getPairCoinTypeDict(curMarketData.pair);


    var receiveAddress = wallet.getPouchFold(coinTypeDict.receive).getCurrentReceiveAddress();    
    var returnAddress = wallet.getPouchFold(coinTypeDict.send).getCurrentReceiveAddress();
    var depositeAddress = wallet.getPouchFold(curCoinType).getShapeShiftDepositAddress(); 

    var isPreviousMultiShiftInvalid = false;

    if (this._currentShiftParams !== null) {
        var shiftHasTimedOut = (timestamp - this._currentShiftParams.timestamp) > 3 * 60 * 1000;

        if (this._currentShiftParams.numShiftsTotal !== numShiftsRequired ||
            this._currentShiftParams.receiveAddress !== receiveAddress ||
            this._currentShiftParams.returnAddress !== returnAddress ||
            this._currentShiftParams.shiftMarketData.depositAddress !== depositeAddress ||
            shiftHasTimedOut
           ) { 
            isPreviousMultiShiftInvalid = true;
        }
    } else {
        isPreviousMultiShiftInvalid = true;
    }

    return !isPreviousMultiShiftInvalid;
}

JaxxShapeShiftHelper.prototype.getMultiShiftResults = function(coinType, numShiftsRequired) {
    var isShiftComplete = true;
    
    if (this.isMultiShiftValid(coinType, numShiftsRequired)) {
        for (var i = 0; i < numShiftsRequired; i++) {
            if (this._currentShiftParams.shiftMarketData.multiShift[i].depositAddress === null) {
                isShiftComplete = false;
            }
        }
    } else {
        console.log("getMultiShiftResults :: invalid multi shift :: coinType :: " + coinType + " :: numShiftsRequired :: " + numShiftsRequired);
        
        isShiftComplete = false;
    }
    
    if (isShiftComplete) {
        return this._currentShiftParams.shiftMarketData;
    } else {
        return null;
    }
}

JaxxShapeShiftHelper.prototype.requestMultiShift = function(coinType, numShiftsRequired, callback) {

    // This function makes a request to Shapeshift's API for the target coin and then after saving the deposit address and request timestamp it uses the callback given in our parameters
    var timestamp = new Date().getTime();

    var curMarketData = this.getMarketForCoinTypeSend(coinType);

    var coinTypeDict = this.getPairCoinTypeDict(curMarketData.pair);
    
    var receiveAddress = wallet.getPouchFold(coinTypeDict.receive).getCurrentReceiveAddress();    
    var returnAddress = wallet.getPouchFold(coinTypeDict.send).getCurrentReceiveAddress();    
    
    var isPreviousMultiShiftInvalid = !this.isMultiShiftValid(coinType, numShiftsRequired);

    
    if (isPreviousMultiShiftInvalid === true) {

       // console.log("requestMultiShift receiveAddress:" + receiveAddress + " returnAddress: " + returnAddress + " numShiftsRequired: " + numShiftsRequired + " curMarketData: " , curMarketData);
        
        if (curMarketData.depositMax == null || curMarketData.depositMin == null || curMarketData.exchangeRate == null) {
            //@note: @todo: @here: refresh the shapeshift info.
        } else {
            var self = this;

            g_JaxxApp.getUI().beginShapeShiftMultiShift();

            curMarketData.multiShift = [];

            var shiftOptions = {withdrawal: receiveAddress, pair: curMarketData.pair, returnAddress: returnAddress, apiKey: JaxxShapeShiftHelper.networkDefinitions.apiKey};
            
            for (var i = 0; i < numShiftsRequired; i++) {
                curMarketData.multiShift.push({depositAddress: null, timestamp: null});
            }

            var shiftParams = {numShiftsTotal: numShiftsRequired, numShiftsPassed: 0, numShiftsFailed: 0, completionCallback: callback, shiftMarketData: curMarketData, receiveAddress: receiveAddress, returnAddress: returnAddress, timestamp: timestamp};
            
            this._currentShiftParams = shiftParams;
            
            for (var i = 0; i < numShiftsRequired; i++) {
                var passthroughParams = {curMarketData: curMarketData, multiShiftDataIndex: i, shiftParams: shiftParams}
                
               // console.warn('postJSON ' + this._entrypoint_shift, shiftOptions);


                jaxx.Registry.currentTransactionTemp = shiftOptions;


                // Example parameters:
                // this._entrypoint_shift: "https://shapeshift.io/shift/"
                // shiftOptions: "{"withdrawal":"XvHvaMPkcz5bUSd5wMfFBYpWFCDTGR1SSa","pair":"btc_dash","returnAddress":"13cs8tXBGEGCFXY88o9MgE4asmMZhNYSG7","apiKey":"180aaede8f5451a52847824f4965cc25f43a5d2bb49f483c1f1ecc8afad661b65e22a01046bfd67257e31189b48f5a1ec35207653bd017f8203f4241c763074a"}"


                RequestSerializer.postJSON(this._entrypoint_shift, shiftOptions, function(shiftInfo, status, passthroughParams) {


                   // console.log("shapeShift  received status :: " + status + " :: shiftInfo :: ", shiftInfo);
                    
                    // "{"orderId":"45ca0f79-4261-42c7-8e5f-83339c100e1e","deposit":"0x6920cb9c7a62d0fc50653c847c0016bb457dec82","depositType":"ETH","withdrawal":"1LuB2pccTJoUSpUaTHgSMYqyoe4pHtzL18","withdrawalType":"BTC","public":null,"apiPubKey":"180aaede8f5451a52847824f4965cc25f43a5d2bb49f483c1f1ecc8afad661b65e22a01046bfd67257e31189b48f5a1ec35207653bd017f8203f4241c763074a","returnAddress":"0x1c456dd323fdc73a32a32d7b7c977eea8bac2dea","returnAddressType":"ETH"}" // console.log(JSON.stringify(shiftInfo))
                    // "{"curMarketData":{"pair":"eth_btc","depositMax":180.36469944,"depositMin":0.11009174,"exchangeRate":0.01083367,"lastupdated":1481231517929,"depositAddress":null,"shiftInitiated":false,"multiShift":[{"depositAddress":null,"timestamp":null}]},"multiShiftDataIndex":0,"shiftParams":{"numShiftsTotal":1,"numShiftsPassed":0,"numShiftsFailed":0,"shiftMarketData":{"pair":"eth_btc","depositMax":180.36469944,"depositMin":0.11009174,"exchangeRate":0.01083367,"lastupdated":1481231517929,"depositAddress":null,"shiftInitiated":false,"multiShift":[{"depositAddress":null,"timestamp":null}]},"receiveAddress":"1LuB2pccTJoUSpUaTHgSMYqyoe4pHtzL18","returnAddress":"0x1c456dd323fdc73a32a32d7b7c977eea8bac2dea","timestamp":1481231528896}} // console.log(JSON.stringify(passthroughParams))

                    
                    
                    if (!shiftInfo || status !== 'success' || shiftInfo.error) {
                        console.error("JaxxShapeShiftHelper :: requestMultiShift :: error :: while attempting the shift :: " + (shiftInfo && shiftInfo.error) ? " :: shiftInfo.error :: " + shiftInfo.error : "");

                        jaxx.Registry.currentTransactionTemp = null;
                        passthroughParams.shiftParams.numShiftsFailed++;
                    } else {
                        passthroughParams.shiftParams.numShiftsPassed++;

                        var sendType = self.getCoinTypeForAbbreviatedName(shiftInfo.depositType.toLowerCase());
                        var receiveType = self.getCoinTypeForAbbreviatedName(shiftInfo.withdrawalType.toLowerCase());

                        self._marketData[sendType][receiveType].depositAddress = shiftInfo.deposit; // An error here means that Shapeshift was not able to fetch a valid address to deposit the bitcoins.
                        self._marketData[sendType][receiveType].timestamp = new Date().getTime();
                        
                        self._marketData[sendType][receiveType].multiShift[passthroughParams.multiShiftDataIndex].depositAddress = shiftInfo.deposit;
                        self._marketData[sendType][receiveType].multiShift[passthroughParams.multiShiftDataIndex].timestamp = new Date().getTime();

                        //console.log("shapeShift ready: " + shiftInfo.deposit + " Type: " + sendType + " receiveType: " +
                        //    "" + receiveType + " multiShiftDataIndex: " + passthroughParams.multiShiftDataIndex);

//                        var numMultiShift = self._marketData[sendType][receiveType].multiShift.length;
//                        console.log("shapeShift :: numMultiShift :: " + numMultiShift + " :: data :: " + JSON.stringify(this._marketData[sendType][receiveType].multiShift));

                        
                        //@note: @todo: @next: @here: only callback when actually completed.
                    
                       // console.log("partial multishift passthroughParams :: ",passthroughParams);
                    }
                    
                    if (passthroughParams.shiftParams.numShiftsTotal === passthroughParams.shiftParams.numShiftsPassed + passthroughParams.shiftParams.numShiftsFailed) {
                       // console.log("finished multishift :: passthroughParams :: ", passthroughParams);
                        g_JaxxApp.getUI().endShapeShiftMultiShift();


                        passthroughParams.shiftParams.completionCallback(passthroughParams.shiftParams);
                    }

                }, true, passthroughParams); 
            }
        }
    } else {
        console.log("JaxxShapeShiftHelper :: requestMultiShift unnecessary");
    }
}

//@note: I'm not sure if the following @TODO is still relevant.
// @TODO: Handle dust properly - only necessary because blockchain.info remembers bad transactions through its pushtx
// https://github.com/bitcoin/bitcoin/blob/9fa54a1b0c1ae1b12c292d5cb3158c58c975eb24/src/primitives/transaction.h#L138

//@note: @context:
//the allegory is a "wallet"
//there are a number of "pouches" in this "wallet", which relate to different currency types.
//there are a number of "folds" inside this "pouch" which relate to subcurrencies (tokens). the primary "fold" is always the main currency that all the tokens are derived from.
//there are a number of "account" types that are the equivalent of a savings/chequing account for the same currency type.


var ACCOUNT_HD = 0;
var ACCOUNT_REGULAR = 1;
var ACCOUNT_WATCH = 2;
var ACCOUNT_NUMACCOUNTTYPES = 3;

var w_gObj;

var HDWalletMain = function() {
    this._mnemonic = "";
    
    this._pouches = [];
    this._helper = new HDWalletHelper();
    
    this._legacyEthereumWallet = null;
    this._hasGlitchedLegacyEthereumWallet = false;
    this._hasShownLegacySweep = false;
    this._shouldSetUpLegacyEthereumSweep = false;
    this._hasSetupLegacyEthereumSweep = false;
    
    this._legacyEthereumWalletLoadCallback = null;
    this._legacyEthereumWalletUpdateCallback = null;
    
    this._etcEthAddressesToSplit = {};
    
    this._preparedTransactionPrivateKeyInput = "";
}

//HDWalletMain.TESTNET = TESTNET;

/*
HDWalletMain.ON_SEND_TRANSACTION = 'ON_SEND_TRANSACTION';
HDWalletMain.ON_USER_TRANSACTION_COFIRMED = 'ON_USER_TRANSACTION_COFIRME';
HDWalletMain.DATA_FROM_RELAY = 'DATA_FROM_RELAY';
HDWalletMain.ON_TRANSACTIONS_OBJECT = 'ON_TRANSACTIONS_OBJECT';
HDWalletMain.BEGIN_SWITCH_TO_COIN_TYPE = 'BEGIN_SWITCH_TO_COIN_TYPE';
HDWalletMain.COMPLETE_SWITCH_TO_COIN_TYPE = 'COMPLETE_SWITCH_TO_COIN_TYPE';
///////////TODO remove duplicates
HDWalletMain.TRANSACTION_BEFORE_SEND = 'TRANSACTION_BEFORE_SEND';
HDWalletMain.TRANSACTION_SENT = 'TRANSACTION_SENT';
HDWalletMain.TRANSACTION_FAILED = 'TRANSACTION_FAILED';
HDWalletMain.TRANSACTION_ASSEPTED = 'TRANSACTION_ASSEPTED';
HDWalletMain.TRANSACTION_CONFIRMED = 'TRANSACTION_CONFIRMED';
*/



/*HDWalletMain.prototype.initialize = function() {
    //this._helper.initialize();
    console.log('TODO');
    return;

    //var pouchesToSetup = [];
    var self = this;
/!*
    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
//    for (var i = 0; i < 1; i++) {
        var coinIsTokenSubtype = HDWalletPouch.getStaticCoinPouchImplementation(i).pouchParameters['coinIsTokenSubtype'];
        
        if (coinIsTokenSubtype !== true) {
          var hdWalletPouch = new HDWalletPouch();
            this._pouches[i] = hdWalletPouch;
            this._pouches[i].initialize(i, false, this._helper);
            //pouchesToSetup.push(i);

        }
    }*!/

    //g_JaxxApp.getDataStoreController().clearAndReset();
  ///  g_JaxxApp.getDataStoreController().setCoinTypes(this._pouches);

    /////________________________________________________
    //jaxx.Registry.application$.triggerHandler(jaxx.Registry.BEGIN_SWITCH_TO_COIN_TYPE,jaxx.Registry.currentCoinType);
    /!*
    var cryptoControllers = g_JaxxApp.getDataStoreController().getControllersAll();
    cryptoControllers.forEach(function(controller) {
        controller.emitter$.off(controller.ON_RESTORE_HISTORY_START);
        ontroller.emitter$.off(controller.ON_RESTORE_HISTORY_DONE);
        controller.emitter$.on(controller.ON_RESTORE_HISTORY_START, function (evt) {
            self.onRestoreHistoryStart(evt.currentTarget);
        });
        ontroller.emitter$.on(controller.ON_RESTORE_HISTORY_DONE, function (evt) {
            self.onRestoreHistoryDone(evt.currentTarget);
        });

    });
    *!/
//    console.log("this._pouches.length :: " + this._pouches.length);

    this.setup();
}*/
/*
HDWalletMain.prototype.setupWithEncryptedMnemonic = function(encMnemonic, callback) {


   // console.error("g_Vault :: " + g_Vault + " :: this._pouches :: " + this._pouches.length);


    console.error(encMnemonic);

 // console.error(getStoredData('mnemonic',true));


    var self = this;
    
    g_Vault.decrypt(encMnemonic, function(error, res) {

        if (!error) {
            //
            //   console.log("decrypt success :: " + self._pouches.length);
            // HDWalletPouch.storedDeriveData = JSON.parse(getStoredData('PouchDerivedData', true));
          /!*  for (var i = 0; i < self._pouches.length; i++) {
                var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(i).pouchParameters['coinAbbreviatedName'];

                console.log("pouch :: " + coinAbbreviatedName + " :: " + self._pouches[i]);
                if (typeof(self._pouches[i]) !== 'undefined' && self._pouches[i] !== null) {
                    self._pouches[i].setupWithMnemonic(encMnemonic, res);
                }
            }
            *!/
            console.error(res);
            self._mnemonic = res;

            // HDWalletPouch.pushStoredDeriveDataToLocalStorage();
            callback();
        } else {
            var errStr = "error decoding mnemonic :: " + error;
            console.log("error decoding mnemonic :: " + error);
            
            callback(errStr);
        }
    });
}*/

HDWalletMain.prototype.switchToCoinType = function(targetCoinType) {
    jaxx.Registry.application$.triggerHandler(jaxx.Registry.BEGIN_SWITCH_TO_COIN_TYPE,targetCoinType);
    //    if (targetCoinType === COIN_BITCOIN) {
    //
    //    } else if (targetCoinType === COIN_ETHEREUM) {
    //        if (this._mnemonic !== "") {
    //            this.setupLegacyEthereumSweep();
    //        } else {
    //            if (this._hasSetupLegacyEthereumSweep === false) {
    //                this._shouldSetUpLegacyEthereumSweep = true;
    //            }
    //        }
    //    }
}

HDWalletMain.prototype.completeSwitchToCoinType = function(targetCoinType) {
    this.getPouchFold(targetCoinType).refreshIfNecessary();
}

HDWalletMain.prototype.getHasSetupLegacyEthereumSweep = function() {
    return this._hasSetupLegacyEthereumSweep;
}

HDWalletMain.prototype.setShouldSetUpLegacyEthereumSweep = function(loadCallback, updateCallback) {
    this._shouldSetUpLegacyEthereumSweep = true;
    this._legacyEthereumWalletLoadCallback = loadCallback;
    this._legacyEthereumWalletUpdateCallback = updateCallback;
    this.setupLegacyEthereumSweep();
}

HDWalletMain.prototype.update = function() {
    for (var i = 0; i < this._pouches.length; i++) {
        this._pouches[i].update();
    }
}

HDWalletMain.prototype.setup = function() {
    if (getStoredData('fiat') === null) {
        storeData('fiat', 'USD');
    }

    w_gObj = this;

    this._log = [];
    this._logger = console;

    this._onenameAddress = null;
    this._onenamePrivateKey = null;

    this._privateKeyCache = {};

    this._spendable = null;


    var self = this;
}

HDWalletMain.prototype.confirmBackup = function() {
    storeData('lastBackupTimestamp', (new Date()).getTime());
}

HDWalletMain.prototype.shutDown = function(updateListener) {
    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
        this.getHelper().removeExchangeRateListener(i, updateListener);

        this.getPouchFold(i).shutDown();

        this.getPouchFold(i).removeListener(updateListener);
        this.getPouchFold(i).setLogger(null);
    }
}



HDWalletMain.prototype.getPouchFold = function(coinType) {
    if(!this.collection)this.collection  = [];
    if(!this.collection[coinType]){
        var ctr =  jaxx.Registry.getCryptoControllerByCoinType(coinType);
        if(ctr && ctr.pouch) this.collection[coinType] = ctr.pouch;
        else  this.collection[coinType] = ctr;
    }

return this.collection[coinType];



//    console.log("this._pouches[coinType] :: " + this._pouches[coinType] + " :: coinType :: " + coinType);
    
  /*  if (coinType >= 0 && coinType < COIN_NUMCOINTYPES) {
        var coinIsTokenSubtype = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinIsTokenSubtype'];
        
        if (coinIsTokenSubtype !== true) {
            return this._pouches[coinType];
        } else {
            return this._pouches[CoinToken.getMainTypeToTokenCoinHolderTypeMap(coinType)].getToken(CoinToken.getMainTypeToTokenMap(coinType));
        }
    }
    
    return null;*/
}

HDWalletMain.prototype.getHelper = function() {
    return this._helper;
}

HDWalletMain.prototype.getMnemonic = function() {
//    console.log("mnemonic :: " + this._mnemonic);
    return this._mnemonic;
}

HDWalletMain.prototype.setupLegacyEthereumSweep = function() {
//    console.log("[ethereum] :: setup legacy sweep :: load callback :: " + this._legacyEthereumWalletLoadCallback);

    this._shouldSetUpLegacyEthereumSweep = false;
    this._hasSetupLegacyEthereumSweep = true;
    
    var setupTimeout = 1.5 * 60 * 1000;
    var legacyEthereumSweepRan = getStoredData("ethereum_legacySweepRan", false);

    if (!legacyEthereumSweepRan || legacyEthereumSweepRan !== "true" || this._legacyEthereumWalletLoadCallback !== null) {
        storeData("ethereum_legacySweepRan", "true", false);
        setupTimeout = 1500;
    }


    var self = this;
    
    setTimeout(function() {
        console.log("[ethereum] :: loading legacy wallet support");
        self._legacyEthereumWallet = new EthereumWallet();
        self._legacyEthereumWallet._finishedLoadingEthereumCallback = function(isGlitchedWallet) {
            self._hasGlitchedLegacyEthereumWallet = isGlitchedWallet;
            if (self._legacyEthereumWalletLoadCallback !== null) {
                self._legacyEthereumWalletLoadCallback();
            }
        }
        self._legacyEthereumWallet.addTXListener(function() {
            if (self._legacyEthereumWalletUpdateCallback) {
                self._legacyEthereumWalletUpdateCallback();
            }
        });
        
        self._legacyEthereumWallet.addBalanceListener(function() {
//            console.log("[ethereum] :: legacy balance :: " + self._legacyEthereumWallet.getBalance());(
            if (self._legacyEthereumWalletUpdateCallback) {
                self._legacyEthereumWalletUpdateCallback();
            }

            var legacyEthereumSpendableBalance = self._legacyEthereumWallet.getSpendableBalance();
            
            if (legacyEthereumSpendableBalance > 0) {
                if (self._hasShownLegacySweep === false) {
                    self._hasShownLegacySweep = true; Navigation.showEthereumLegacySweep(legacyEthereumSpendableBalance);
                }
            }
        });
        self._legacyEthereumWallet.initAndLoadAsync();
    }, setupTimeout);
}

HDWalletMain.prototype.hasGlitchedLegacyEthereumWallet = function() {
//    return true;
    return this._hasGlitchedLegacyEthereumWallet;
}

HDWalletMain.prototype.transferLegacyEthereumAccountToHDNode = function() {
    if (this._legacyEthereumWallet) {
        if (this._legacyEthereumWallet._address && this._legacyEthereumWallet._private) {
            var tx = this._legacyEthereumWallet.buildTransaction(this.getPouchFold(COIN_ETHEREUM).getCurrentReceiveAddress().toLowerCase(), this._legacyEthereumWallet.getSpendableBalance());
            
            if (tx) {
                this._legacyEthereumWallet.sendTransaction(tx, function(err, res) {
                    if (err) {
                        Navigation.flashBanner('Error: ' + err.message, 3);
                        console.log("transferLegacyEthereumAccountToHDNode :: error :: " + err.message);
                    } else {
                        Navigation.flashBanner('Successfully Transferred', 3);
                        console.log("transferLegacyEthereumAccountToHDNode :: success :: " + res);
                    }
                });
            } else {
                Navigation.flashBanner('Error: Invalid Transaction', 3);
            }
        }
    }
}

HDWalletMain.prototype.getAddressesAndKeysCSVForCoinType = function(coinType) {
    var returnStr = "";

    console.log(this.getPouchFold(coinType)._coinFullName + " :: export private keys");

    var accounts = this.getPouchFold(coinType).getAccountList();

    console.log("number of accounts :: " + accounts.length);
    
    for (var i = 0; i < accounts.length; i++) {
        returnStr += accounts[i].pubAddr + ", " + accounts[i].pvtKey;
        if (i !== accounts.length - 1) {
            returnStr += ",\n";
        } else {
        }
    }
    
    return returnStr;
}

HDWalletMain.prototype.getEthereumLegacyLightwalletAccount = function(coinType) {
    if (this._legacyEthereumWallet && this._legacyEthereumWallet._address && this._legacyEthereumWallet._private) {
        var accountItem = {};
        
        accountItem.pubAddr = this._legacyEthereumWallet._address;
        accountItem.pvtKey = this._legacyEthereumWallet._private.toString('hex');
        accountItem.balance = this._legacyEthereumWallet.getBalance();
//        accountItem.coinType = COIN_ETHEREUM;
        accountItem.isTheDAOAssociated = this._legacyEthereumWallet.isTheDAOAssociated();
        accountItem.isAugurAssociated = this._legacyEthereumWallet.isAugurAssociated();

//        console.log("ethereum legacy :: account :: " + JSON.stringify(accountItem));

        return accountItem;
    } else {
        return null;
    }    
}

//HDWalletMain.prototype.getEthereumLegacyStableKeypair = function(coinType) {
//    return this.getPouchFold(COIN_ETHEREUM).getEthereumLegacyStableKeypair();
//}


//@note: this is an equivalence function I build for the lightwallet fiasco, it may be relevant
//at some point in the future, but isn't actually called by anything at the moment.
HDWalletMain.prototype.checkAddress = function() {

    var checkNode = HDWallet._derive(this._receiveNode, 0, false);

    console.log("private key :: " + checkNode.keyPair.toWIF() + " :: " + this._privateKey(false, 0).toWIF());

    var keyPair = checkNode.keyPair;//this._privateKey(false, 0);

    var keyPairB = thirdparty.bitcoin.ECPair.fromWIF("KxxUwg3CwN8YjpnV8TzFRHmwrzP2vbkD9TymbdFM8EQnzpnRHDra", keyPair.network);

    console.log("WIFCheck :: " + (keyPair.getPublicKeyBuffer().toString('hex') == keyPairB.getPublicKeyBuffer().toString('hex')));

    //    console.log("CryptoJS :: " + thirdparty.CryptoJS.enc.Hex.parse);
    console.log("PRE :: keyPair.compressed :: " + keyPair.compressed);

    //using the keypair, get the public key buffer.
    //then, run that through the ethereum sha3 methodology.

    var pubKey = keyPair.getPublicKeyBuffer();
    var privateKey = keyPair.d.toBuffer(32);

    console.log("A :: pubKey :: " + pubKey + " :: " + pubKey.toString('hex'));
    console.log("privateKey :: " + privateKey + " :: " + privateKey.toString('hex'));

    var pubKeyHash = thirdparty.bitcoin.crypto.hash160(pubKey);

    console.log("A2 :: pubKeyHash :: " + pubKeyHash + " :: " + pubKeyHash.length);

    var payload = new thirdparty.Buffer.Buffer(21);
    payload.writeUInt8(keyPair.network.pubKeyHash, 0);
    pubKeyHash.copy(payload, 1);

    console.log("A3 :: pubKeyHash :: " + pubKeyHash + " :: " + pubKeyHash.length);

    console.log("thirdparty.bitcoin.base58 :: " + thirdparty.bs58check);

    var address = thirdparty.bs58check.encode(payload);

    console.log("A4 :: address :: " + address + " :: " + checkNode.keyPair.getAddress());


    //@note: this looks fine, the fromWIF with a bitcoin private key does relate to the proper output public address.



    //    console.log("A2 :: .network.pubKeyHash :: " + keyPair.network.pubKeyHash)
    //    var pubKeyHex = pubKey.toString('hex');

    //    console.log("thirdparty.elliptic :: " + thirdparty.elliptic);
    //    console.log("thirdparty.elliptic.ec :: " + thirdparty.elliptic.ec);

    var secp256k1Curve = new thirdparty.elliptic.ec('secp256k1');

    //    console.log("secp256k1Curve :: " + secp256k1Curve.genKeyPair);

    var kp = secp256k1Curve.genKeyPair();

    console.log("kp :: " + kp);

    kp._importPrivate("1dd2359ba67c76414c22b068a131caba6fe4f85a918f93a263cfd4a59f7e0f77", 'hex');

    var compact = false;

    var pubKeyHex = kp.getPublic(compact, 'hex').slice(2);
    console.log("A :: pubKeyHex :: " + pubKeyHex);

    var pubKeyWordArray = thirdparty.CryptoJS.enc.Hex.parse(pubKeyHex);
    console.log("B :: pubKeyWordArray :: " + pubKeyWordArray);

    var hash = thirdparty.CryptoJS.SHA3(pubKeyWordArray, { outputLength: 256 });
    console.log("C :: hash :: " + hash);

    var address = hash.toString(thirdparty.CryptoJS.enc.Hex).slice(24);
    console.log("D :: address :: " + address);

    //@note: this looks fine, the importprivate with an ethereum private key does relate to the proper output public address.



    kp = secp256k1Curve.genKeyPair();

    //    var b58res = thirdparty.bs58check.decode("KxxUwg3CwN8YjpnV8TzFRHmwrzP2vbkD9TymbdFM8EQnzpnRHDra");

    //    console.log("b58res :: " + b58res.toString('hex'));

    //    kp._importPrivate(b58res.toString('hex'), 'hex');
    kp._importPrivate(privateKey.toString('hex'), 'hex');

    compact = true;
    pubKeyHex = kp.getPublic(compact, 'hex');//.slice(2);

    console.log("R :: " + pubKeyHex + " :: " + pubKey.toString('hex'));


    //@note: okay, so this works.


    var ethRootNode = HDWallet._derive(HDWallet._derive(HDWallet._derive(w_gObj._rootNode, 44, true), 60, true), 0, true);

    var ethAccountNode = HDWallet._derive(ethRootNode, 0, false);

    var ethKeyPair = ethAccountNode.keyPair;

    //@note: @here: hack to get the Q to regenerate on the next 'get', triggered by getPublicKeyBuffer.
    ethKeyPair.__Q = null;
    ethKeyPair.compressed = false;

    var ethKeyPairPublicKey = ethKeyPair.getPublicKeyBuffer();

    console.log("ethKeyPairPublicKey :: " + ethKeyPairPublicKey + " :: " + ethKeyPairPublicKey.toString('hex').slice(2));


    var pubKeyHexEth = ethKeyPairPublicKey.toString('hex').slice(2);
    console.log("M :: pubKeyHexEth :: " + pubKeyHexEth);

    var pubKeyWordArrayEth = thirdparty.CryptoJS.enc.Hex.parse(pubKeyHexEth);
    console.log("N :: pubKeyWordArrayEth :: " + pubKeyWordArrayEth);

    var hashEth = thirdparty.CryptoJS.SHA3(pubKeyWordArrayEth, { outputLength: 256 });
    console.log("O :: hashEth :: " + hashEth);

    var addressEth = hashEth.toString(thirdparty.CryptoJS.enc.Hex).slice(24);
    console.log("P :: addressEth :: " + addressEth + " :: " + address);

    console.log("proper conversion :: " + (addressEth === address) );




    // var gatheredBitcoinAddress = this.getBitcoinAddress(checkNode);
    // var gatheredEthereumAddress = this.getEthereumAddress(ethAccountNode);


    //    var bigNumC = thirdparty.BigInteger.fromBuffer(
    //    var keyPairC = thirdparty.bitcoin.ECPair(keyPair.network





    //    pubKeyWordArray = thirdparty.CryptoJS.enc.Hex.parse(pubKeyHex);
    //    console.log("B :: pubKeyWordArray :: " + pubKeyWordArray);
    //    hash = thirdparty.CryptoJS.SHA3(pubKeyWordArray, { outputLength: 256 });
    //    console.log("C :: hash :: " + hash);
    //    address = hash.toString(thirdparty.CryptoJS.enc.Hex).slice(24);
    //    console.log("D :: address :: " + address);

    console.log("" + this.totally.wont.exist)

    //https://github.com/ConsenSys/eth-lightwallet/blob/master/lib/keystore.js
    //    KeyStore._computeAddressFromPrivKey = function (privKey) {
    //        var keyPair = ec.genKeyPair();
    //        keyPair._importPrivate(privKey, 'hex');
    //        var compact = false;
    //        var pubKey = keyPair.getPublic(compact, 'hex').slice(2);
    //        var pubKeyWordArray = CryptoJS.enc.Hex.parse(pubKey);
    //        var hash = CryptoJS.SHA3(pubKeyWordArray, { outputLength: 256 });
    //        var address = hash.toString(CryptoJS.enc.Hex).slice(24);
    //
    //        return address;
    //    };

    //https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/src/ecpair.js

    //    ECPair.prototype.getAddress = function () {
    //        var pubKey = this.getPublicKeyBuffer()
    //        var pubKeyHash = bcrypto.hash160(pubKey)
    //
    //        var payload = new thirdparty.Buffer.Buffer(21)
    //        payload.writeUInt8(this.network.pubKeyHash, 0)
    //        pubKeyHash.copy(payload, 1)
    //
    //        return bs58check.encode(payload)
    //    }
}



HDWalletMain.prototype.setOnename = function(onename) {
    storeData('onename-' + this._storageKey, onename);
}

HDWalletMain.prototype.getOnename = function() {
    return getStoredData('onename-' + this._storageKey);
}

HDWalletMain.prototype.getOnenameAddress = function() {
    this._load();
    if (!this._onenameAddress) {
        this._onenamePrivateKey = this._privateKey(true, 0x7fffffff);
        this._onenameAddress = this._onenamePrivateKey.getAddress();
    }
    return this._onenameAddress;
}

/*
HDWallet.prototype.registerOnename = function(passname, name, callback) {
    this._load();

    if (this.getOnename()) {
        throw new Error('Already have a onename registered');
    }
    if (!passname.match(/^[a-z]([a-z0-9-]{0,62}[a-z0-9])?$/)) {
        throw new Error('Invalid onename');
    }

    var url = 'https://glacial-plains-9083.herokuapp.com/v2/onename/register/' + passname;
    url += '?recipientAddress=' + this.getNamecoinAddress();
    url += '&bitcoinAddress=' + this._currentReceiveAddress;
    url += '&name=' + encodeURI(name);

    var self = this;
    RequestSerializer.getJSON(url, function (data) {
        self.log(data);
        //storeData('onename-' + this.getNamecoinAddress(), onename);
    });

}
*/

HDWalletMain.prototype.setEtcEthAddressesToSplit = function(addressDictToSplit) {
    console.log("HDWalletMain :: setEtcEthAddressesToSplit :: " + JSON.stringify(addressDictToSplit, null, 4));
    
    var ethTargetAddress = HDWalletHelper.toEthereumNakedAddress(wallet.getPouchFold(COIN_ETHEREUM).getCurrentReceiveAddress().toLowerCase());

    var etcTargetAddress = HDWalletHelper.toEthereumNakedAddress(wallet.getPouchFold(COIN_ETHEREUM_CLASSIC).getCurrentReceiveAddress().toLowerCase());
    
    this._etcEthAddressesToSplit = {};
    this._etcEthAddressesToSplit.targetEthAddress = ethTargetAddress;
    this._etcEthAddressesToSplit.targetEtcAddress = etcTargetAddress;

    var addressesList = [];
    
    for (var i = 0; i < addressDictToSplit.length; i++) {
        var curAddressDict = addressDictToSplit[i];
        
        var curItem = {};
        curItem.ethAddress = curAddressDict.address;
        curItem.etcBalance = curAddressDict.etcBalance;
        curItem.ethAddressIndex = parseInt(wallet.getPouchFold(COIN_ETHEREUM).getInternalIndexAddressDict(curItem.ethAddress).index);
        
        addressesList.push(curItem);
    }

    this._etcEthAddressesToSplit.addressesList = addressesList;
}

HDWalletMain.prototype.getEtcEthAddressesToSplit = function() {
    var returnVal = [];
    
    if (typeof(this._etcEthAddressesToSplit.addressesList) !== 'undefined' && this._etcEthAddressesToSplit.addressesList !== null) {
        for (var i = 0; i < this._etcEthAddressesToSplit.addressesList.length; i++) {
            returnVal.push(this._etcEthAddressesToSplit.addressesList[i].ethAddress);
        }
    }
    
    return returnVal;
}

HDWalletMain.prototype.processEtcEthSplit = function(callback) {
    var gasPrice = HDWalletHelper.getDefaultEthereumGasPrice();
    var gasLimit = thirdparty.web3.toBigNumber(100000);

    var splitOpCode = HDWalletHelper.etcEthSplitOpCode;

    var txArray = [];
    var totalTXCost = 0;

    var baseGasCost = gasPrice.mul(gasLimit).toNumber();

    var ABIForkedTargetParameter = HDWalletHelper.zeroPadLeft(this._etcEthAddressesToSplit.targetEthAddress, 64);

    var ABIUnforkedTargetParameter = HDWalletHelper.zeroPadLeft(this._etcEthAddressesToSplit.targetEtcAddress, 64);

    var splitTXData = splitOpCode + ABIForkedTargetParameter + ABIUnforkedTargetParameter;
    
    var threadingParams = {totalEtcTransactions: 0, processedEtcTransactions: 0, numEtcTransactionsPassed: 0, numEtcTransactionsFailed: 0, txData: {totalTXCost: 0, txArray: []}};
    
    for (var i = 0; i < this._etcEthAddressesToSplit.addressesList.length; i++) {
        threadingParams.totalEtcTransactions++;
        
        //@note: @here: @critical: this is definitely incorrect: (parseInt(150154021000000020) === parseInt(152254021000000030)) === true
        var bigNum_valueToSendMinusBaseTxCost = thirdparty.web3.toBigNumber(this._etcEthAddressesToSplit.addressesList[i].etcBalance).minus(thirdparty.web3.toBigNumber(baseGasCost));
        
//        console.log("this._etcEthAddressesToSplit.addressesList[i].etcBalance :: " + this._etcEthAddressesToSplit.addressesList[i].etcBalance + " :: bigNum_valueToSendMinusBaseTxCost :: " + bigNum_valueToSendMinusBaseTxCost);
        
        var passthroughParams = {};
        wallet.getPouchFold(COIN_ETHEREUM_CLASSIC).getPouchFoldImplementation()._buildEthereumTransactionWithCustomEthereumLikeBlockchain(wallet.getPouchFold(COIN_ETHEREUM), false, this._etcEthAddressesToSplit.addressesList[i].ethAddressIndex, HDWalletHelper.etcEthSplitContractAddress, bigNum_valueToSendMinusBaseTxCost, gasPrice, gasLimit, splitTXData, null, function(newTx, passthroughParams) {
            if (typeof(newTx) !== 'undefined' && newTx !== null) {
                passthroughParams.txData.txArray.push(newTx);
                passthroughParams.numEtcTransactionsPassed++;
            } else {
                console.log("error :: ethereum transaction :: account failed to build :: " + this._etcEthAddressesToSplit[i]);
                passthroughParams.numEtcTransactionsFailed++;
            }
            
            passthroughParams.processedEtcTransactions++
            
            passthroughParams.txData.totalTXCost += baseGasCost;
            
            if (passthroughParams.processedEtcTransactions === passthroughParams.totalEtcTransactions) {
                console.log("HDWalletMain :: processEtcEthSplit :: txArray.length :: " + passthroughParams.txData.txArray.length + " :: txArray :: " + JSON.stringify(passthroughParams.txData.txArray, null, 4));

                if (passthroughParams.numEtcTransactionsPassed, passthroughParams.totalEtcTransactions) {
                    callback(null, passthroughParams.txData);
                } else {
                    callback("error", null)
                }
            }
        }, threadingParams);
    }
}

HDWalletMain.prototype.performEtcEthSplit = function() {
    
//    console.log("HDWalletMain :: performEtcEthSplit :: " + JSON.stringify(this._etcEthAddressesToSplit, null, 4));
    
    this.processEtcEthSplit(function(err, splitTxDict) {
        if (err) {
            console.log("HDWalletMain :: performEtcEthSplit failed to build all necessary transactions :: " + JSON.stringify(this._etcEthAddressesToSplit, null, 4));
        } else {
//            console.log("HDWalletMain :: performEtcEthSplit :: success :: " + JSON.stringify(splitTxDict, null, 4));
//            return;
            
            g_JaxxApp.getTXManager().sendEthereumLikeTXList(COIN_ETHEREUM_CLASSIC, splitTxDict, function(result) {
                console.log("performEtcEthSplit :: sendTransaction :: result :: " + result);
                if (result === 'success') {
                    $('.tabContent .address input').val('');
                    $('.tabContent .amount input').val('').trigger('keyup');

                    playSound("snd/balance.wav", null, null);
                    Navigation.flashBanner('Successfully Sent', 5);

                    //@note: @todo: @here: maybe ignore for this case.
                    //            for (var i = 0; i < data.txArray.length; i++) {
                    //                //@note: @here: @next: tx members.
                    //                //                                    g_JaxxApp.getTXManager().addTXOfType(g_JaxxApp.getTXManager().getCurrentTXType(), COIN_ETHEREUM, data.txArray[i].hash);
                    //            }

                    Navigation.returnToDefaultView();
                    Navigation.hideTransactionHistoryDetails();
                } else if (result === 'failure') {
                    //@note: all of the batch failed:
                    Navigation.flashBanner('Error: ' + status, 5);
                    console.log('Error', status);
                } else { //@note: partial failure.
                    //@note: some of the batch succeeded, some failed:

                    $('.tabContent .address input').val('');
                    $('.tabContent .amount input').val('').trigger('keyup');

                    playSound("snd/balance.wav", null, null);
                    Navigation.flashBanner('Batch Transaction: Some Failed', 5);

                    Navigation.returnToDefaultView();
                    Navigation.hideTransactionHistoryDetails();
                }

                Navigation.closeModal();

                //@note: @here: always update the tx history for sends.
                forceUpdateWalletUI();
            });
        }
    });
}

HDWalletMain.prototype.convertFiatToFiat = function(sourceFiatAmount, targetFiatUnit, sourceFiatUnit, noPrefix){
    if (sourceFiatUnit === null || typeof(sourceFiatUnit) === 'undefined'){
        sourceFiatUnit = this.getHelper().getFiatUnit();
    }
    var valueInBitcoins = parseFloat(this.getPouchFold(COIN_BITCOIN).getPouchFoldImplementation().convertFiatToCoin(sourceFiatAmount, COIN_UNITLARGE));
    return wallet.getHelper().convertCoinToFiatWithFiatType(COIN_BITCOIN, valueInBitcoins, COIN_UNITLARGE, targetFiatUnit, noPrefix);
}

HDWalletMain.prototype.exportAllKeypairs = function(callback) {
    var self = this;
    
    var threadingParams = {numWalletsProcessed: 0, totalWalletsToProcess: 0, walletKeypairs: []};
    
    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
        if (HDWalletHelper.isCryptoCurrencyAllowed(i) && !this.getPouchFold(i).isToken()){
            threadingParams.totalWalletsToProcess++;

            var passthroughParams = {curWalletIndex: i, threadingParams: threadingParams};

            this.getPouchFold(i).exportKeypairsSynched(function(result, passthroughParams) {
                passthroughParams.threadingParams.numWalletsProcessed++;
                passthroughParams.threadingParams.walletKeypairs[passthroughParams.curWalletIndex] = result;

                if (passthroughParams.threadingParams.numWalletsProcessed === passthroughParams.threadingParams.totalWalletsToProcess) {
                    var allUserKeypairs = "";

                    for (var j = 0; j < passthroughParams.threadingParams.walletKeypairs.length; j++) {
                        if (typeof(passthroughParams.threadingParams.walletKeypairs[j]) !== 'undefined' && passthroughParams.threadingParams.walletKeypairs[j] !== null) { // If data was fetched for this coin
                            var coinFullName = "";
                            if (self.getPouchFold(j).isTokenType()) {
                              coinFullName = self.getPouchFold(j)._tokenName;
                            } else {
                              coinFullName = self.getPouchFold(j)._coinFullName;
                            }

                            var accounts = passthroughParams.threadingParams.walletKeypairs[j];

                            console.log("[" + coinFullName + "] :: number of accounts :: " + accounts.length);

                            var keyPairStr = "";

                            for (var k = 0; k < accounts.length; k++) {
                              keyPairStr += coinFullName + ", " + accounts[k].pubAddr + ", " + accounts[k].pvtKey;
                              if (i !== accounts.length - 1) {
                                keyPairStr += ",\n";
                              } else {

                              }
                            }

                            allUserKeypairs += keyPairStr;
                        }
                    }
                  callback(allUserKeypairs);
                }
            }, passthroughParams);
        }
    }
}

HDWalletMain.createWallet = function(mnemonicEncrypted, callback){
    Navigation.closeModal();
    Navigation.startBlit();
    Navigation.clearSettings();
    Navigation.openModal('creatingWallet');


    g_JaxxApp.getUI()._jaxxUIIntro._setWalletType = "newWallet";

    jaxx.Registry.setWalletLasttState('ready');

    initializeJaxx(function() {
        Navigation.closeModal();
    });

    //@note: ignore existing architecture and use js side securerandom.
    //var  mnemonic = thirdparty.bip39.generateMnemonic();
    //storeData('mnemonic', mnemonic, true);
    // jaxx.seed.getEncryptedSeed();


   /* setTimeout(function(mnemonicEncrypted) {
        if (typeof(mnemonicEncrypted) === 'undefined' || mnemonicEncrypted === null){
            var mnemonicEncrypted = g_Vault.encryptSimple(thirdparty.bip39.generateMnemonic());
        }
       // loadFromEncryptedMnemonic(mnemonicEncrypted, callback);
        Navigation.closeModal();
        Navigation.startBlit();
    }, 1000, mnemonicEncrypted);
    // Clean up.
    Navigation.clearSettings();
    Navigation.openModal('creatingWallet');    */
}

HDWalletMain.getMnemonicFromJaxxToken = function(jaxxToken){
    var comps = HDWalletMain.getCompsFromJaxxToken(jaxxToken);
    return thirdparty.bip39.entropyToMnemonic(comps[0]);
}

HDWalletMain.getCompsFromJaxxToken = function(jaxxToken){
    // Return example: "imitate unknown again gasp lab work token zoo boy silly guess require"
    if (!jaxxToken) { return null; }

    // Support all valid entropy sizes (128-bit, 160-bit, 192-bit, 224-bit, 256-bit)
    // if (!jaxxToken.match(/^jaxx:[0-9a-f]{32,64}\/[0-9a-zA-Z]*$/) && ((jaxxToken.length - 5) % 8) == 0) {
    if (!jaxxToken.match(/^jaxx:[0-9a-f]{32,64}\/*$/) && ((jaxxToken.length - 5) % 8) == 0) {
        console.log("No match: " + jaxxToken);
        return null;
    }
    jaxxToken = jaxxToken.substring(5);

    return jaxxToken.split('/');   
}

HDWalletMain.prototype.onFinishedDownloadingTransactionsForBlockchain = function(coinType){
    this.getPouchFold(coinType).setHasFinishedFinalBalanceUpdate(true);
}

HDWalletMain.prototype.onRestoreHistoryStart = function(cryptoController) {
    console.log("restore history start hdWallet main", cryptoController)
}

HDWalletMain.prototype.onRestoreHistoryDone = function(cryptoController) {
    console.log("restore history stop hdWallet main", cryptoController)
}

HDWalletMain.prototype.getPreparedTransactionPrivateKeyInput = function(){
    return this._preparedTransactionPrivateKeyInput;
}

HDWalletMain.prototype.setPreparedTransactionPrivateKeyInput = function(newTransaction){
    this._preparedTransactionPrivateKeyInput = newTransaction;
}
/**
 * Created by Daniel on 2017-03-02.
 */

var JaxxInitializer = function() {

}

JaxxInitializer.prototype.initialize = function(){

}

JaxxInitializer.prototype.startJaxx = function(){
    g_JaxxApp.getUI().showApplicationLoadingScreen(); // splash
    g_JaxxApp.getUI().fetchAndStoreCoinBulletinData();
    this.startJaxxWithReleaseNotesPage();
}

JaxxInitializer.prototype.startJaxxWithReleaseNotesPage = function() {
    // Consider
    g_JaxxApp.getUI().getReleaseBulletin(function() {
        //g_JaxxApp.getUI().hideApplicationLoadingScreen(); // splash
        g_JaxxApp.getUI().displayJaxxReleaseBulletinIfUnseen();
    });
//    g_JaxxApp.getUI().startJaxxIfNoReleaseNotesAreShown();

}

JaxxInitializer.prototype.startJaxxWithTermsOfServicePage = function() {
    //console.error('xxInitializer.prototype.startJaxxWithTermsOfServicePage');
    // This is run when the user clicks 'Continue' on release notes.
    g_JaxxApp.getUser().setupWithWallet(null);
    g_JaxxApp.getUI().setStartJaxxWithTermsOfServicePageWasRun(true);
    if (getStoredData('hasShownTermsOfService')){
        initializeJaxx(function() { // Initialize Jaxx is certain to get called at least one before the main wallet screen.
            // g_JaxxApp.getUI().hideApplicationLoadingScreen(); // splash
            g_JaxxApp.getUI().hideSplashScreen();
        });
    } else {

        g_JaxxApp.getUI().getIntro().startJaxxFromTermsOfServicePage();
    }
}
var JaxxController = function() {
    /*
    this._jaxxUIIntro = new JaxxUIIntro();

    this._wWidth = 0;
    */
}

JaxxController.allWindows = {
    "somevar1": false,
    "somevar2": false
};
/*
JaxxUI.runAfterNextFrame = function(callback, passthroughParams) {
    //@note: this causes the tx list to behave strangely.
    //    var callbackNextFrame = function() {
    callback(passthroughParams);
    //    }
    /
    //    requestAnimationFrame(callbackNextFrame);
}*/

JaxxController.prototype.initialize = function() {
    /*
    console.log("[ Jaxx :: UI Initialize ]");

    this._jaxxUIIntro.initialize();
    JaxxUI._sUI = this;

    this._mainPinPadElementName = '';

    this._pinEntryFocus = 0;
    this._f_onPinSuccess = function() {};
    this._f_onPinFailure = function() {};

    this._temporaryPin = "";

    this._miningFeeModalSetup = {};

    this.refreshSizes();
    this.initializeElements();

    this.mainMenuShowMenu();

    //    console.log("JaxxUI.allWindows :: " + JSON.stringify(JaxxUI.allWindows, null, 4) + " :: " + Object.keys(JaxxUI.allWindows));

    var allKeys = Object.keys(JaxxUI.allWindows);

    for (var i = 0; i < allKeys.length; i++) {
        var curKey = allKeys[i];

        console.log("change key :: " + key + " :: " + JaxxUI.allWindows[key]);
        this._windowsActive[key] = JaxxUI.allWindows[key];
    }
    */
}

JaxxController.prototype.keyUpOnSweepPrivateKey = function (){
    var coinType = g_JaxxApp.getUI().getTransferPaperWalletCoinType();
    var value = $('.settings.sweepPrivateKey input').val();

    function disableButton() {
        var element = $('.sweepNextButton');
        element.addClass('cssStartHidden')
        //element.removeClass('cssEnabled');
        //element.removeClass('cssBlueButton');
        //element.addClass('cssGreyButton');
        element.css('cursor', 'default');
        //element.attr('specialAction', null);
        //element.attr('pushSettings', null);
    }

    function enableButton() {
        var element = $('.sweepNextButton');
        element.removeClass('cssStartHidden');
        //element.addClass('cssBlueButton');
        //element.removeClass('cssGreyButton');
        element.css('cursor', 'pointer');
        //element.attr('specialAction', 'sweepPrivateKey.prepare');
        //element.attr('pushSettings', 'confirmSweepPrivateKey');
    }

    function enableButtonEncrypted() {
        var element = $('.sweepNextButton');
        element.removeClass('cssStartHidden');
        //element.addClass('cssBlueButton');
        //element.removeClass('cssGreyButton');
        element.css('cursor', 'pointer');
        //element.attr('specialAction', 'sweepPrivateKey.showDecrypt');
        //element.attr('pushSettings', 'sweepPrivateKeyPasswordEntry');
    }

    if (value === "") {
        disableButton();
        return;
    }

    //    console.log("value :: " + value);

    var isPlainPrivateKey = false;

    isPlainPrivateKey = HDWalletPouch.isValidPrivateKey(coinType, value);

    if (isPlainPrivateKey === true) {
        //        console.log("regular private key detected");
        enableButton();
    } else {
        //check if is encrypted private key
        var isEncryptedPrivateKey = false;
        if (coinType === COIN_BITCOIN) {
            isEncryptedPrivateKey = isValidBIP38key(value);
        } else if (coinType === COIN_ETHEREUM) {
            isEncryptedPrivateKey = isValidETHAESkey(value);
        } else if (coinType === COIN_DASH) {
            //@note: @here: this should work.
            isEncryptedPrivateKey = isValidBIP38key(value);
        }

        if (isEncryptedPrivateKey ){
            //            console.log("encrypted private key detected")
            enableButtonEncrypted();
        } else{
            //            console.log("invalid private key detected");
            disableButton();
        }
    }
}

JaxxController.prototype.someExampleFunction = function(element){
    console.log("Some Example");
}

JaxxController.prototype.clickBackExpressWalletSetup = function(element){
    Navigation.popSettings();

    $('.pageExpressWalletSetup .coinListExpress tbody').off('click', 'tr');
}

JaxxController.prototype.clickMiningOption = function(element){
    jaxx.MiningFeeView.instance.onSelect(element);
}

/*
 * Handles clicks over mining fee selector popup
*/
JaxxController.prototype.clickMiningOptionPopup = function(element){

    var pouch = wallet.getPouchFold(curCoinType);
    var elementToTrigger = $(element).find("input:radio");
    var coinId = 0;
    if (elementToTrigger[0].id === 'averageMiningFeeMainMenu') coinId = 1;
    if (elementToTrigger[0].id === 'fastMiningFeeMainMenu') coinId = 2;

    // console.log('CLICK MINING FEES | clickMiningOptionPopup :: ', element);

    if(pouch.hasOwnProperty('setMiningFeeLevel')) pouch.setMiningFeeLevel(coinId);

    $(element).find('.cssMiningFeeRadioBtn input').prop('checked', true);
    $(elementToTrigger).trigger('change');
    g_JaxxApp.getUI().pushBTCMiningFeeFromPouchToModal();
}

JaxxController.prototype.keyupCustomMiningOption = function(element){
    var customMiningFee = $(".enterCustomMiningFee").val();
    wallet.getPouchFold(0).setCustomMiningFee(customMiningFee);
    // g_JaxxApp.getUI().setupMiningFeeSelector('MainMenu');
}

JaxxController.prototype.clickContinueButtonForTransferPaperWallet = function(){
    // This is the 'Transfer to Jaxx' Button
    specialAction("sweepPrivateKey.execute");
    g_JaxxApp.getUI().setStandardMessageForTransferPaperWallet();
}

JaxxController.prototype.clickContinueButtonForInputPrivateKey = function(){
    // This is run when the 'Next' button is clicked on sweepPrivateKey page
    $('.confirmSweepPrivateKey .continueButton').hide();
    specialAction('sweepPrivateKey.prepare');
}

JaxxController.prototype.clickDisplayPrivateKeysMenuOption = function(element){
    // if (coinType === COIN_ETHEREUM){
    //     $(".backupPrivateKeyListETHLegacyWarning").hide();
    //     $(".accountDataEthereumLegacyKeypair").hide(); // This
    //     $(".nonHDMessage").hide(); // This
    //     $(".wrapperDisplayMessageForPrivateKeys").hide();
    // }
    var coinType = parseInt($(element).attr("value"));
    var symbol = $(element).data("symbol");
    var displayName = $(element).data('displayname');
    var pageDisplayPrivateKeysName =  'backupPrivateKeys' + displayName; //HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents.pageDisplayPrivateKeysName;
    // wallet.getPouchFold(coinType).getDataStorageController().activate();
    $('.' + pageDisplayPrivateKeysName + ' .textDisplayMessageForPrivateKeys').show();
    Navigation.pushSettings(pageDisplayPrivateKeysName, function(){
        setupBackupPrivateKeys(coinType, symbol)
    });
}

JaxxController.prototype.clickAddMoreTransactionsToTransactionList = function(element) {
    var coinAbbreviatedName = $(element).attr('value');
    var coinType = HDWalletHelper.dictCryptoCurrency[coinAbbreviatedName].index;
    wallet.getPouchFold(coinType).increaseNumberOfTransactionsInHistory();
    g_JaxxApp.getUI().updateTransactionListWithCoin(coinType);
}
/*
* Function fired when user hits continue after entering mnemonic on the pair restore wallet screen
* @method clickContinuePairFromDevice
* @param {DOM Element} element
* */
JaxxController.prototype.clickContinuePairFromDevice = function(element){
    g_JaxxApp.getUI().hideHamburgerMenu();
    g_JaxxApp['_isPairingNewWallet'] = true;
    var mnemonic = $(element.attr('targetInput')).val();
    $(element.attr('targetInput')).val('') ; //Clear HTML field or it stays there


    //Handle the case where navigation malfunction and did not proceed to the next screen
    $(element).removeClass('cssEnabled').removeClass('enabled');
    //Ensure when mnemonic is blank, no proceeding to the next step and give user warning.
    if(mnemonic == ''){
        Navigation.flashBanner("UI Error (UI001) occurred, please restart the application and try again.");
        return;
    }

    jaxx.Registry.pairDeviceMnemonic(mnemonic);
    Navigation.pushSettings('pressContinuePairDevices');
    //sets a flag that will notify the app that is in wallet setup mode.
    localStorage.setItem('wallet_setup', true);
};

JaxxController.prototype.resetPairFromDeviceInput = function(element){
    $(".loadJaxxToken .validateMnemonic").val("");
    $(".loadJaxxToken .validateMnemonic").trigger('keyup');
};

JaxxController.prototype.generatePrivateKeysBasedOnCheckedCoinsInMenu = function(){
    jaxx.PrivateKeysViewController.instance.displayPrivateKeys();
};

JaxxController.prototype.clickReleaseNotesContinueButton = function(){
    Navigation.pushSettings('pageTermsOfService');
};

JaxxController.prototype.resetTimerForTimeLastActive = function() {
    jaxx.Registry.timeLastActive = new Date();
    jaxx.Registry.application$.triggerHandler(jaxx.Registry.WAKE_UP);
};

JaxxController.prototype.showCoinBulletin = function(element){
    var coinAbbreviatedName = $(element).attr('value');
    jaxx.Application.instance.modalViewController.showCoinBulletinFromMenu(coinAbbreviatedName);
};

JaxxController.prototype.clickCoinBulletinCheckmark = function(element){
    if ($(".coinBulletinCheckmark").hasClass("enabled")){
        $(".coinBulletinCheckmark").removeClass("cssEnabled");
        $(".coinBulletinCheckmark").removeClass("enabled");
        $(".coinBulletinCheckmark .cssCircleUnchecked").removeClass("cssCurrencyisChecked");

    } else {
        $(".coinBulletinCheckmark").addClass("cssEnabled");
        $(".coinBulletinCheckmark").addClass("enabled");
        $(".coinBulletinCheckmark .cssCircleUnchecked").addClass("cssCurrencyisChecked");
    }
};

JaxxController.prototype.clickCoinBulletinCloseButton = function(element){
    var coinAbbreviatedName = $(element).attr("value");
    var bulletinData = g_JaxxApp.getUI().getCoinBulletinData()[coinAbbreviatedName];
    var version = bulletinData["version"];

    // If check-mark is checked then hide for switch coin forever

    if ($(".coinBulletinCheckmark").hasClass("enabled")){
        g_JaxxApp.getSettings().addVersionToCoinBulletinListHideOnSelect(coinAbbreviatedName, version);

        if($("#bulletinCloseButton").attr("value") === "ALL") {
            // If "Don't Show This Bulletin Again" option is clicked, on close, for a generic bulletin: trigger this
            jaxx.Registry.application$.triggerHandler(jaxx.Registry.HIDE_ALL_BULLETIN);
        }
    }

    Navigation.closeModal();
};

var TESTNET = false;

var JaxxUser = function() {
    this._firstName = "John";
    this._lastName = "Smythe, Esquire";
    
    this._storageKey = "";
    
    this._pinCodeHash = "";
}

JaxxUser.prototype.initialize = function() {
    
}

JaxxUser.prototype.setupWithWallet = function() {
    var hashedPIN = this.getStoredPinHash();

    if (hashedPIN === null) {
        hashedPIN = "";
//        userPIN = thirdparty.bitcoin.crypto.sha256("0012").toString('hex');
//
//        console.log("store user pin :: " + userPIN);
//
//        storeData("userPin_" + storageKey, userPIN);
    }
    
    this._pinCodeHash = hashedPIN;
}

JaxxUser.prototype.checkForValidPin = function(pinCode) {
    //checks argument pinCode against hashed pin

    var hashedPIN = thirdparty.bitcoin.crypto.sha256(pinCode).toString('hex');

    if (this._pinCodeHash === hashedPIN) {
//        console.log("PIN correct");
        return true;
    } else {
//        console.log("PIN incorrect");
        return false;
    }
}

JaxxUser.prototype.hasPin = function() {
//    return false;
    if (this._pinCodeHash !== "") {
        return true;
    } else {
        return false;
    }
}

JaxxUser.prototype.clearPin = function() {
    console.log("[ User :: Clear PIN ]");
    
    removeStoredData("userPin_" + this._storageKey);

    this._pinCodeHash = "";
}

JaxxUser.prototype.setPin = function(pinCode) {
    console.log("[ User :: Set PIN ]");
    
    //@note: if this is ever augmented, there should be a salt + vector and a bunch
    //of hash passes.
    this.setStorageKey();
    var hashedPIN = thirdparty.bitcoin.crypto.sha256(pinCode).toString('hex');
    storeData("userPin_" + this._storageKey, hashedPIN);
    this._pinCodeHash = hashedPIN;
}
/*
This function calculates storage key used to store pin.
 */
JaxxUser.prototype.setStorageKey = function() {
    var mnemonic = getStoredData('mnemonic', true); //Get mnemonic from localstorage
    var hashMnemonicKey = mnemonic + (TESTNET ? '-test' : '-main'); //legacy options
    this._storageKey = thirdparty.bitcoin.crypto.sha256(hashMnemonicKey).toString('hex');
}
/*
This function reads stored PIN hash from local storage for current mnemonic
 */
JaxxUser.prototype.getStoredPinHash = function() {
    this.setStorageKey();
    var hashedPIN = getStoredData("userPin_" + this._storageKey);
    return hashedPIN;
}

JaxxUser.prototype.manuallyStoreHashedPin = function(hashedPIN) {
    storeData("userPin_" + this._storageKey, hashedPIN);   
}

/*
This function iterate through all 10000 possible integers, compute hashes for each of them and compare them with
the hash saved in local storage. If a match found, indicates the stored pin has is valid. Otherwise hash could be
corrupted and no possible 4-digit PIN will unlock the wallet.
 */
JaxxUser.prototype.checkPINHashIntegrity = function() {
    var pinCode = "";
    var currentHashedPIN;
    var storedPINHash = this.getStoredPinHash();

    console.log("Stored pin hash is" + storedPINHash);
    //Perform padding and stringification to transfer numbers into 4-digit string
    for(var i=0; i<10000; i++){
        //Padding
        if(i<10){
            pinCode = "000" + i;
        }
        else if(i<100){
            pinCode = "00" + i;
        } else if (i<1000){
            pinCode = "0" + i;
        } else {
            pinCode = "" + i;
        }

        currentHashedPIN = thirdparty.bitcoin.crypto.sha256(pinCode).toString('hex');

        console.log(pinCode + ":" + currentHashedPIN);

        if(storedPINHash == currentHashedPIN){
            return true;
        }
    }

    Navigation.flashBanner("Invalid PIN hash detected and removed");

    return false;
}

var JaxxUIIntro = function(){
    this._hasSetupCustomCoinList = false;
    this._hasSetupCustomCurrencyList = false;
    this._hasSetupExpressCoinList = false;
    this._incorrectPINTimeout = null;
    this._jaxxTermsOfService = null;
    this._pinIsCorrect = false;
    this._introScreenWalletSelected = "";
    this._mnemonicEncrypted = "";
    this._temporaryPin = "";
    this._tempEncryptedMnemonic = ""; // This is the mnemonic that is stored for pairing from devices.
    this._collapsedHeightOfCustomCurrenciesList = 0;
    this._setOptionSelected = ""; //this is a wallet setup option express or custom
    this._setWalletType = ""; // this is wallet type variable create new wallet or pair/restore
    this._jaxxPrivacyPolicy = null;


}

JaxxUIIntro.prototype.getCollapsedHeightOfCustomCurrenciesList = function(){
    return this._collapsedHeightOfCustomCurrenciesList;
}

JaxxUIIntro.prototype.initialize = function(){
    var self = this;
    this.initializeElements();
    this.getTermsOfServiceVerbatim(function(){
        self.populateTermsOfServiceVerbatim();
    });
    this.getPrivacyPolicyVerbatim(function(){
        self.populatePrivacyPolicyVerbatim();
    });
}

JaxxUIIntro.prototype.initializeElements = function(){
    console.log('TODO');
   // if (g_JaxxApp.getSettings().isMnemonicStored()) {
      //  $(".settings.pageAttentionMessage .hideForExistingUsers").hide();
   // } else {
      //  $(".settings.pageAttentionMessage .hideForNewUsers").hide();
      //  $(".settings.pageAttentionMessage .clickableViewKeysBanner").hide();
   // }

}

JaxxUIIntro.prototype.toggleExpandPDOption = function(strSetupOption){
    //this function is used on the pair devices page
    //strSetupOption is the html value, in this case 'PDExpress' or 'PDCustom'
    g_JaxxApp.getUI().toggleTextExpansion('.settings.pressContinuePairDevices .btnOpenClose' + strSetupOption, '.settings.createNewWallet .btnOpenClose' + strSetupOption + ' .triangleArrow','190px', '60px', 500);
}

JaxxUIIntro.prototype.toggleExpandSetupOption = function(strSetupOption){
    // strSetupOption should be 'Express' or 'Custom'.
    // cssExpanded will denote an element that has been expanded.

    // Run something like // strSetupOption should be 'express' or 'custom'.
    var customHeight  = "175";
    if(strSetupOption == "Express"){
        customHeight = "155";
    }
    else if(strSetupOption == "Custom"){
        customHeight = "175";
    }

    customHeight += "px";

    g_JaxxApp.getUI().toggleTextExpansion('.settings.createNewWallet .btnOpenClose' + strSetupOption, '.settings.createNewWallet .btnOpenClose' + strSetupOption + ' .triangleArrow', customHeight, '60px', 500);
}

JaxxUIIntro.prototype.pressContinueSetupOption = function() {
    // Store the setup option that has been selected and push settings based on that selection.
    var setupOptionChosen = $('.settings.createNewWallet .radioBtnExpressCustom:checked').attr('value');
    if (setupOptionChosen === 'Express') {
        jaxx.CoinsListSetup.instance.selectCurrency(0);
        this.optionSelected("Express");
        Navigation.pushSettings('pageExpressWalletSetup');
    } else if (setupOptionChosen === 'Custom') {
        jaxx.CoinsListSetup.instance.selectCurrency(1);
        this.optionSelected("Custom");
        Navigation.pushSettings('pageCustomWalletSetup');
    }
}
JaxxUIIntro.prototype.optionSelected = function(option) {
    //check if express set up is selected
    this._setOptionSelected = option;
}
JaxxUIIntro.prototype.customWalletsSetup = function(){
    if (!this._hasSetupCustomCoinList) {
        // Populate the crypto currency rows.
        $('.pageCustomWalletSetup .coinListCustom tbody').empty(); // - Just in case we want to clear the table.
        for (var i = 0; i < COIN_NUMCOINTYPES; i++){
            $('.pageCustomWalletSetup .coinListCustom tbody').append(this.generateCoinRowCustom(i));
        }
        $(".pageCustomWalletSetup .coinList tbody").sortable({
            /*items: "> tr:not(:first)",*/
            appendTo: "parent",
            axis: 'y',
            helper: "clone",
            handle: ".handle",
            update: function(event, ui) {

            }
        }).disableSelection();
        this.attachScriptActionCoinCustom();
        // Push the currency list to the settings.
        this._hasSetupCustomCoinList = true;
    }
    Navigation.pushSettings('pageCustomWalletSetup');

}

JaxxUIIntro.prototype.selectWalletsSetupOption = function(strSetupOption){
    // strSetupOption should be 'Express' or 'Custom'.

    //  - this command will become useful for the animation.
///////////////////////////////
   // console.error(strSetupOption);
    if(!jaxx.Registry.appState) jaxx.Registry.appState = {};

    jaxx.Registry.appState.createType = strSetupOption;

   /// console.log(jaxx.Registry.appState);

    $('.settings.createNewWallet .radioBtnExpressCustom').prop('checked', false);
    $('.settings.createNewWallet .radioButton' + strSetupOption).prop('checked', true);


    this.makeContinueAppearOnPage('.settings.createNewWallet');
    // Remove grey class from the 'Continue' button.
}

JaxxUIIntro.prototype.pairDevicesWalletsSetupOption = function(strSetupOption){
    // strSetupOption should be the value of the radio buttons
    $('.settings.pressContinuePairDevices .radioBtnPDExpressCustom').prop('checked', false);
    $('.settings.pressContinuePairDevices .radioButton' + strSetupOption).prop('checked', true);
    this.makeContinueAppearOnPage('.settings.pressContinuePairDevices');
}

JaxxUIIntro.prototype.attachScriptActionCoinCustom = function(){
    $('.pageCustomWalletSetup .coinListCustom .scriptAction').click(function (event) { // Add the scriptAction triggers again.
        try {
            scriptAction(event);
        } catch (err) {
            console.error(err);
        }
    });
}

JaxxUIIntro.prototype.attachScriptActionCoinExpress = function(){
    $('.pageExpressWalletSetup .coinListExpress .scriptAction').click(function (event) { // Add the scriptAction triggers again.
        try {
            scriptAction(event);
        } catch (err) {
            console.error(err);
        }
    });
}

JaxxUIIntro.prototype.isCoinEnabledCustom = function(coinType) {
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    return $('.pageCustomWalletSetup .coinList .coinType' + coinAbbreviatedName+' .cssSelectedCurrency .cssCircleUnchecked').hasClass('cssCurrencyisChecked');
}

JaxxUIIntro.prototype.toggleCoinIsEnabledCustom = function(coinType){
    if (this.isCoinEnabledCustom(coinType)){
        this.disableCoinCustom(coinType);
    } else {
        this.enableCoinCustom(coinType);
    }
    if ($('.pageCustomWalletSetup .cssCurrencyisChecked').length > 0) {
        this.makeContinueAppearOnPage('.pageCustomWalletSetup');
    } else {
        this.makeContinueDisappearOnPage('.pageCustomWalletSetup');
    }
}

JaxxUIIntro.prototype.enableCoinCustom = function(coinType){
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    $('.pageCustomWalletSetup .coinList .coinType' + coinAbbreviatedName + ' .cssSelectedCurrency .cssCircleUnchecked').addClass('cssCurrencyisChecked');
    $('.pageCustomWalletSetup .coinList .coinType' + coinAbbreviatedName).addClass('cssCurrencyHighlightText');
}

JaxxUIIntro.prototype.disableCoinCustom = function(coinType) {
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    $('.pageCustomWalletSetup .coinList .coinType' + coinAbbreviatedName + ' .cssSelectedCurrency .cssCircleUnchecked').removeClass('cssCurrencyisChecked');
    $('.pageCustomWalletSetup .coinList .coinType' + coinAbbreviatedName).removeClass('cssCurrencyHighlightText');
}

JaxxUIIntro.prototype.pressContinueCustomWallets = function(arrayWalletsPosition, dictWalletsEnabled){
    // Example Parameters ([1, 2, 3, 4], {1: true, 2: true, 3 : false, 4: false})
    // Store wallet data here.
    if ($('.pageCustomWalletSetup .coinList .cssCurrencyisChecked').length > 0) {
        this.pushCustomCoinOrderToSettings();
        //this.pushCustomCoinEnabledValuesToSettings(); // #GMS This function call doesn't seem to be necessary anymore with the new modular structure
        this.customCurrenciesSetup();
        Navigation.pushSettings('pageCustomCurrenciesSetup');
        this._collapsedHeightOfCustomCurrenciesList = parseInt($('.pageCustomCurrenciesSetup .exchangeRateList').css('height'));
        this.disableAllFiatUnitsCustom(); // We need to make the appropriate changes later because this should really be an empty list by the time we get here.
    }
}

JaxxUIIntro.prototype.generateCoinRowCustom = function(coinType){console.warn("USED");
    var extraCss = "";
    var isTestnet = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['isTestnet'];

    (isTestnet === true) ? extraCss = 'cssTestnet' : "";

    var coinWalletSelector3LetterSymbol = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinWalletSelector3LetterSymbol'];
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    var coinFullDisplayName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).uiComponents['coinFullDisplayName'];
    var column1 = '<td class="cssSelectedCurrency"><div class="cssCircleUnchecked"></div></td>';
    var column2 = '<td class="itemNumberLabel cssItemNumberLabel"></td>';
    var column3 = '<td class="coinIcon cssCoinIcon cssImageLogoIcon'+coinAbbreviatedName+' cssHighlighted"><div class="image"></div></td>';
    var column4 = '<td class="coinLabel cssCoinLabel">' + coinWalletSelector3LetterSymbol + ' - ' + coinFullDisplayName + '</td>';
    var column5 = '<td class="handle cssHandle"><img src="images/dragAndDrop.svg" alt="" height="13" width="13" style="position:absolute; padding-top:12px;"></td>';
    return '<tr class="cssCoinCurrency cssOpacity scriptAction coinType' + coinAbbreviatedName + " " + extraCss + '" specialAction ="toggleCoinIsEnabledCustom" value="' + coinAbbreviatedName + '">' + column1 + column2 + column3 + column4 + column5 + '</tr>';
}

JaxxUIIntro.prototype.pushCustomCoinOrderToSettings = function(){
    // Extract ordering
    var rows = $('.pageCustomWalletSetup .coinList tbody tr');
    var currencyArray = [];
    for (var i = 0; i < rows.length; i++){
        currencyArray.push($($('.pageCustomWalletSetup .coinList tbody tr').get(i)).attr('value'));
    }
    g_JaxxApp.getSettings().setCryptoCurrencyPositionData(currencyArray); // Change settings
}

JaxxUIIntro.prototype.pushCustomCoinEnabledValuesToSettings = function(){

    var rows = $('.pageCustomWalletSetup .coinList tbody tr');
    for (var i = 0; i < rows.length; i++){
        // isCoinEnabledCustom()
        var coinType = HDWalletHelper.dictCryptoCurrency[$($('.pageCustomWalletSetup .coinList tbody tr').get(i)).attr('value')].index;
        var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
        if (this.isCoinEnabledCustom(coinType)) {
            g_JaxxApp.getSettings().enableCryptoCurrency(coinAbbreviatedName);
            g_JaxxApp.getUI().enableCryptoCurrencyInUI(coinAbbreviatedName);
        } else {
            g_JaxxApp.getSettings().disableCryptoCurrency(coinAbbreviatedName);
            g_JaxxApp.getUI().disableCryptoCurrencyInUI(coinAbbreviatedName);
        }
    }
}

JaxxUIIntro.prototype.pressContinueCustomCurrencies = function(){
    // Example Parameters (['USD', 'CAD', ...], {'USD': false, 'CAD' : true, ...} )
    if ($('.pageCustomCurrenciesSetup .exchangeRateList .cssCurrencyisChecked').length > 0) {
        Navigation.disableAllCurrencies();
        var rows = $('.pageCustomCurrenciesSetup .exchangeRateList tbody').children();
        var currencyOrder = [];
        for (var i = 0; i < rows.length; i++){
            var fiatUnit = $(rows[i]).attr('value');
            currencyOrder.push(fiatUnit);
            Navigation.updateCurrencyList();
            /*
            if (this.isFiatUnitEnabledCustom(fiatUnit)) {
                Navigation.updateCurrencyList(fiatUnit);
            } else {
                Navigation.disableCurrencyInData(fiatUnit);
            }
            */
        }
        storeData('currencies_position_order', JSON.stringify(currencyOrder));
        if (this._tempEncryptedMnemonic === ""){
            Navigation.pushSettings('backupMnemonicCustomIntroOption');
        } else {
            Navigation.pushSettings('pageSetupSecurityPinCode');
        }
        if (typeof(wallet) !== undefined && wallet !== null){ // Pair from device setup
            wallet.getHelper().setFiatUnit(g_JaxxApp.getSettings().getDefaultCurrency());
        }
        this.disableAllFiatUnitsCustom();
    }
}

JaxxUIIntro.prototype.toggleFiatUnitCustom = function(fiatUnit){
    //
    if (this.isFiatUnitEnabledCustom(fiatUnit)){
        this.disableFiatUnitCustom(fiatUnit);
    } else {
        this.enableFiatUnitCustom(fiatUnit);
    }
    if ($('.pageCustomCurrenciesSetup .cssCurrencyisChecked').length > 0) {
        this.makeContinueAppearOnPage('.pageCustomCurrenciesSetup');
    } else {
        this.makeContinueDisappearOnPage('.pageCustomCurrenciesSetup');
    }
}

JaxxUIIntro.prototype.disableAllFiatUnitsCustom = function(){
    var rows = $('.pageCustomCurrenciesSetup .exchangeRateList tbody').children();
    var currencyOrder = [];
    for (var i = 0; i < rows.length; i++){
        var fiatUnit = $(rows[i]).attr('value');
        if (this.isFiatUnitEnabledCustom(fiatUnit)) {
            this.disableFiatUnitCustom(fiatUnit);
        }
    }
}

JaxxUIIntro.prototype.showCreateWalletNotifications = function(){
    if(this._setWalletType === "newWallet") {
        setTimeout(function() {
            Navigation.flashBanner("Interface Successfully Created", 3, 'success');
        }, 1500);
    } else {
        setTimeout(function() {
            Navigation.flashBanner("Successfully Initialized Wallet!", 3, 'success');
        }, 1500);
    }

}
JaxxUIIntro.prototype.createWalletWithCallbackCustom = function(){
    var self = this;
    g_JaxxApp._settings.resetJaxxCache();
    /*
    *  I do not know if the code below is important code it seems that it doesn't fire anything.
    *  TODO: remove this function and see if it breaks anything.
    *  */
    var additionalCallback = function(){
       var defaultCoinType = 0;// HDWalletHelper.dictCryptoCurrency[g_JaxxApp.getSettings().getListOfEnabledCryptoCurrencies()[0]].index;
        setupDefaultCoinType(defaultCoinType);
        Navigation.setupCoinUI(defaultCoinType);
    };

    HDWalletMain.createWallet(this._mnemonicEncrypted, function(err, wallet){
        if (err) {
            console.log("createWallet :: error :: " + err);
            console.log('Failed To Create HD Wallet');
        } else {
            //storeData('mnemonic', wallet.getMnemonic(),true);
            jaxx.seed.getEncryptedSeed();
            self.showCreateWalletNotifications();

            Navigation.startBlit();

            setTimeout(function() {
                if (PlatformUtils.extensionChromeCheck()) {

                } else if (PlatformUtils.extensionFirefoxCheck()) {
                    Navigation.openModal('firefoxWarningPopupFirstFrame');
                }
            }, 500);

            removeStoredData('fiat');
            additionalCallback();
        }
    });
}

JaxxUIIntro.prototype.createWalletWithCallbackCustomUsingPIN = function(){
    var self = this;
    g_JaxxApp._settings.resetJaxxCache();
    var additionalCallback = function(){
        localStorage.setItem('wallet_setup', false);
        var defaultCoinType =  jaxx.Registry.getDefaultWalletType();// HDWalletHelper.dictCryptoCurrency[g_JaxxApp.getSettings().getListOfEnabledCryptoCurrencies()[0]].index;
        g_JaxxApp.getUser().setupWithWallet();
        g_JaxxApp.getUser().setPin(self._temporaryPin);
        setupDefaultCoinType(defaultCoinType);
        Navigation.setupCoinUI(defaultCoinType);
    };
    HDWalletMain.createWallet(this._mnemonicEncrypted, function(err, wallet){
        if (err) {
            console.log("createWallet :: error :: " + err);
            console.log('Failed To Create HD Wallet');
        } else {
            //storeData('mnemonic', wallet.getMnemonic(), true);
            jaxx.seed.getEncryptedSeed();
            self.showCreateWalletNotifications();

            Navigation.startBlit();

            setTimeout(function() {
                if (PlatformUtils.extensionChromeCheck()) {

                } else if (PlatformUtils.extensionFirefoxCheck()) {
                    Navigation.openModal('firefoxWarningPopupFirstFrame');
                }
            }, 500);

            removeStoredData('fiat');
            additionalCallback();
        }
    });
}

JaxxUIIntro.prototype.enableFiatUnitCustom = function(fiatUnit){
    $('.pageCustomCurrenciesSetup .exchangeRateList .fiatUnit' + fiatUnit + ' .cssSelectedCurrency .cssCircleUnchecked').addClass('cssCurrencyisChecked');
    $('.pageCustomCurrenciesSetup .exchangeRateList .fiatUnit' + fiatUnit).addClass('cssCurrencyHighlightText');
}

JaxxUIIntro.prototype.disableFiatUnitCustom = function(fiatUnit){
    $('.pageCustomCurrenciesSetup .exchangeRateList .fiatUnit' + fiatUnit + ' .cssSelectedCurrency .cssCircleUnchecked').removeClass('cssCurrencyisChecked');
    $('.pageCustomCurrenciesSetup .exchangeRateList .fiatUnit' + fiatUnit).removeClass('cssCurrencyHighlightText');

}

JaxxUIIntro.prototype.isFiatUnitEnabledCustom = function(fiatUnit) {
    return $('.pageCustomCurrenciesSetup .exchangeRateList .fiatUnit' + fiatUnit + ' .cssSelectedCurrency .cssCircleUnchecked').hasClass('cssCurrencyisChecked');
}



JaxxUIIntro.prototype.generateCurrencyRowCustom = function(fiatUnit) {
    var column1 = '<td class="cssSelectedCurrency"><div class="cssCircleUnchecked"></div></td>';
    var column2 = '<td class="cssUnitAndCurrency"><div class="cssUnit">' + fiatUnit + '</div><div class="name">' + jaxx.FiatPriceController.fiatDictionary[fiatUnit].name + '</div></td>'
    var column4 = '<td class="rate rate' + fiatUnit.trim().toUpperCase() + '"></td>';
    var column5 = '<td class="handle cssHandle"><img src="images/dragAndDrop.svg" alt="" height="13" width="13" style="position:absolute; padding-top:12px;"></td>';
    var tableRow = '<tr class="currency cssCurrency scriptAction fiatUnit' + fiatUnit +'" value="' + fiatUnit + '" specialAction="toggleFiatUnitCustom">' + column1 + column2 + column4 + column5 + '</tr>';
    return tableRow;
}


JaxxUIIntro.prototype.customCurrenciesSetup = function(){
    console.log(' JaxxUIIntro.prototype.customCurrenciesSetup   ');
    if (!this._hasSetupCustomCurrencyList) {
        $('.pageCustomCurrenciesSetup .exchangeRateList tbody').empty();
        for (var key in jaxx.FiatPriceController.fiatDictionary){
                $('.pageCustomCurrenciesSetup .exchangeRateList tbody').append(this.generateCurrencyRowCustom(key));

        }

        $('.pageCustomCurrenciesSetup .exchangeRateList tbody').sortable({
            appendTo: "parent",
            axis: 'y',
            helper: "clone",
            handle: ".handle",
            update: function(event, ui) {

            },
        }).disableSelection();
        $('.pageCustomCurrenciesSetup .exchangeRateList .scriptAction').click(function (event) { // Add the scriptAction triggers again.
            try {
                scriptAction(event);
            } catch (err) {
                console.error(err);
            }
        });

        this._hasSetupCustomCurrencyList = true;
    }
}

JaxxUIIntro.prototype.expressWalletsSetup = function(){
    console.error('JaxxUIIntro.prototype.expressWalletsSetup    ');
    // Populate the currency rows.
    if (!this._hasSetupExpressCoinList) {
        // Populate the crypto currency rows.
        g_JaxxApp.getSettings().getListOfCryptoCurrenciesAllowed();
        $('.pageExpressWalletSetup .coinListExpress tbody').empty() // - Just in case we want to clear the table.

        for (var i = 0; i < COIN_NUMCOINTYPES; i++){
            //if (cryptoCurrenciesAllowed.indexOf(HDWalletPouch.getStaticCoinPouchImplementation(i).pouchParameters['coinAbbreviatedName']) > -1) {
                $('.pageExpressWalletSetup .coinListExpress tbody').append(this.generateCoinRowExpress(i));
           // }
        }

        this.attachScriptActionCoinExpress();
        // Push the currency list to the settings.
        this._hasSetupExpressCoinList = true;
    }
    Navigation.pushSettings('pageExpressWalletSetup');
};

JaxxUIIntro.prototype.getTempEncryptedMnemonic = function() {
    return this._tempEncryptedMnemonic;
};

JaxxUIIntro.prototype.takeMeToMyWallet = function() {
    if (g_JaxxApp['_isPairingNewWallet'] && g_JaxxApp['_isPairingNewWallet'] == true) {
        g_JaxxApp._settings.resetJaxxCache();
        window.location.reload(true);
    }

    g_JaxxApp['__newWalletFromScratch'] = true;
    // preapre the CSS of the CREATING INTERFACE OVERALY
    var creatingWalletOverlay = $('.creatingWallet');
    creatingWalletOverlay.css('opacity', '0');
    creatingWalletOverlay.css('display', 'initial');
    creatingWalletOverlay.css('transition', 'opacity 0.5s');
    // Fade In element after the CSS changes have made the DOM
    creatingWalletOverlay.css('opacity', '1');
    // goint with native transitions as jQuery.fadeIn, fadeOut was not very smooth during testing
    jaxx.Registry.setWalletLasttState('ready');
    Navigation.startBlit();
    Navigation.clearSettings();
    this._setWalletType = "newWallet";
    this._setWalletType = "newWallet";

    initializeJaxx(function() {
        Navigation.closeMainMenu()
        //sets a flag that will notify the app that is out of setup mode.
        localStorage.setItem('wallet_setup', false);
    });
};

JaxxUIIntro.prototype.pushExpressCoinOrderToSettings = function(){
    // Extract ordering
    var rows = $('.pageExpressWalletSetup .coinList tbody tr');
    var currencyArray = [];

    for (var i = 0; i < rows.length; i++){
        currencyArray.push($($('.pageExpressWalletSetup .coinList tbody tr').get(i)).attr('value'));
    }

    g_JaxxApp.getSettings().setCryptoCurrencyPositionData(currencyArray);
};

JaxxUIIntro.prototype.selectCoinOptionExpress = function(coinType){
    if (this.isCoinEnabledExpress(coinType)){
        this.disableCoinExpress(coinType);
    } else {
        this.enableCoinExpress(coinType);
    }

    if ($('.pageExpressWalletSetup .cssCurrencyisChecked').length > 0) {
        $('.pageExpressWalletSetup .btnContinue').removeClass('cssStartHidden');
    } else {
        $('.pageExpressWalletSetup .btnContinue').addClass('cssStartHidden');
    }
};

JaxxUIIntro.prototype.isCoinEnabledExpress = function(coinType){
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    return $('.pageExpressWalletSetup .coinList .coinType' + coinAbbreviatedName+' .cssSelectedCurrency .cssCircleUnchecked').hasClass('cssCurrencyisChecked');
};

JaxxUIIntro.prototype.enableCoinExpress = function(coinType){
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    $('.pageExpressWalletSetup .coinList .coinType' + coinAbbreviatedName + ' .cssSelectedCurrency .cssCircleUnchecked').addClass('cssCurrencyisChecked');
    $('.pageExpressWalletSetup .coinList .coinType' + coinAbbreviatedName).addClass('cssCurrencyHighlightText');
};

JaxxUIIntro.prototype.disableCoinExpress = function(coinType) {
    var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
    $('.pageExpressWalletSetup .coinList .coinType' + coinAbbreviatedName + ' .cssSelectedCurrency .cssCircleUnchecked').removeClass('cssCurrencyisChecked');
    $('.pageExpressWalletSetup .coinList .coinType' + coinAbbreviatedName).removeClass('cssCurrencyHighlightText');
};

JaxxUIIntro.prototype.makeContinueAppearOnPage = function(strPageSelector){
    // $(strPageSelector + ' .btnContinue').text('CONTINUE');
    $(strPageSelector + ' .btnContinue').fadeIn();
}

JaxxUIIntro.prototype.makeContinueDisappearOnPage = function(strPageSelector) {
    // $(strPageSelector + ' .btnContinue').text('');
    $(strPageSelector + ' .btnContinue').fadeOut();
}

JaxxUIIntro.prototype.pressNextButtonAtVerifyMnemonic = function(){
    Navigation.clearSettings();
}

JaxxUIIntro.prototype.showEnterNewPinSettingsCustom = function(successMessage) {
    var self = this;

    JaxxUI._sUI.setupPinPad('.changePinCodeCustomIntroOption .settingsEnterPinPad', function(keyPressed){
        self.callbackForPIN(keyPressed);
    });

    $('.changePinCodeCustomIntroOption .settingsEnterPinPadText').text('Create a new PIN');
    $('.changePinCodeCustomIntroOption .settingsEnterNewPinConfirmButton').hide();

    var checkForValid = function() {
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();

        //        console.log("entered pin :: " + enteredPin);

        if (enteredPin.length === JaxxUI._sUI._numPinEntryFields) {
            JaxxUI._sUI.setupTemporaryPin(JaxxUI._sUI.getEnteredPINCode());

            self.enableContinueSetupPIN();
        }
    }

    JaxxUI._sUI.setOnPinSuccess(checkForValid);
    JaxxUI._sUI.setOnPinFailure(checkForValid);

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);
    inputElement.trigger('keyup');
    inputElement.focus();
}

JaxxUIIntro.prototype.setupTempEncryptedMnemonic = function(tempEncryptedMnemonic) {
    this._tempEncryptedMnemonic = tempEncryptedMnemonic;
}

JaxxUIIntro.prototype.showConfirmNewPinSettingsCustom = function(successMessage) {
    var self = this;

    this.setConfirmPinCirclesToOrangeBorder();

    JaxxUI._sUI.setupPinPad('.confirmPinCodeCustomIntroOption .settingsEnterPinPad', function(keyPressed){
        self.callbackForPIN(keyPressed);
    });

    this.resetConfirmPINTextForIntroScreen();
    $('.confirmPinCodeCustomIntroOption .settingsEnterNewPinConfirmButton').hide();

    var checkForMatchingPin = function() {
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();

        if (enteredPin === JaxxUI._sUI._temporaryPin) {
            self._temporaryPin = enteredPin;
            self.setConfirmPinCirclesToBlueBorder();
            clearTimeout(self._incorrectPINTimeout);
            $('.confirmPinCodeCustomIntroOption .settingsEnterPinPadText').text('PIN Verified')
            //Navigation.flashBanner(successMessage, 5);
            self.enableContinueConfirmPIN();
        } else if (enteredPin.length === 4) {
            self.incorrectPinIsEntered();
        }
    }

    JaxxUI._sUI.setOnPinSuccess(checkForMatchingPin);
    JaxxUI._sUI.setOnPinFailure(checkForMatchingPin);

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);
    inputElement.trigger('keyup');

    inputElement.focus();
}

JaxxUIIntro.prototype.incorrectPinIsEntered = function(){
    var self = this;
    this.setConfirmPinCirclesToRedBorder();

    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPadText').text('Incorrect PIN');
    clearTimeout(this._incorrectPINTimeout);
    this._incorrectPINTimeout = setTimeout(function(){
        self.resetConfirmPINTextForIntroScreen();
    }, 5000);
}


JaxxUIIntro.prototype.clickCheckboxTermsOfService = function(blnCheckboxValue){
    /*
    if (blnCheckboxValue){
        $('.pageTermsOfService .btnContinue').text('CONTINUE');
    } else {
        $('.pageTermsOfService .btnContinue').text('');
    }
    */
}

JaxxUIIntro.prototype.getTermsOfService = function(){
    return this._jaxxTermsOfService;
}

/*
* Obtain Terms of Service from local storage
* @method getTermsOfServiceVerbatim
* @param {Function} callback - function to fire after obtaining terms of service.
* */
JaxxUIIntro.prototype.getTermsOfServiceVerbatim = function(callback){
    var self = this;
    var url;
    if(Registry.application.config.utils) {
        url = Registry.application.config.utils.termsOfService;
        var filePath = Registry.application.config.utils.localTermsOfService;
        //need to assign key direcly as it seems that Registy has not initialized yet and this is a quicker fix for the
        // time being.
        var key = 'jaxxReleaseNotes';
        jaxx.FileManager.updateLocalStorage(url, filePath, key, function(err) {
            if(err) {
                console.error(err);
            } else {
            var data = jaxx.FileManager.getLocalStorage(key);
            self._jaxxTermsOfService = data[0];
            callback(data);
            }
        });
    } else {
      url = "https://jaxx.io/jaxx-data/jaxx-terms-of-service.php"

      $.getJSON( url, function( data ) {
        if (data && data[0]) {
          self._jaxxTermsOfService = data[0];
          callback(data);
        }
      });
    }

}

JaxxUIIntro.prototype.populateTermsOfServiceVerbatim = function(data){
//    console.log("terms of service data :: " + unescape(this._jaxxTermsOfService.description));

    var scrubbedTitleString = JaxxUtils.scrubInput(this._jaxxTermsOfService.title);
    $('.termsOfServiceModal .title').text(scrubbedTitleString);

    var scrubbedBodyString = JaxxUtils.scrubInput(unescape(this._jaxxTermsOfService.description));
    $('.termsOfServiceModal .termsOfServiceVerbatim').html(scrubbedBodyString);

    // $('.pageTermsOfService .btnContinue').show(); // Enable continue button.
}

JaxxUIIntro.prototype.showTermsOfService = function(){
    $('.termsOfServiceModal').fadeIn(500);
}

JaxxUIIntro.prototype.hideTermsOfService = function(){
    $('.termsOfServiceModal').fadeOut(500);
}

JaxxUIIntro.prototype.getPrivacyPolicy = function(){
    return this._jaxxPrivacyPolicy;
}

JaxxUIIntro.prototype.getPrivacyPolicyVerbatim = function(callback){
    var self = this;
    var url;
  if(Registry.application.config.utils) {
    url = Registry.application.config.utils.jaxxPrivacyPolicy;
    var filePath = Registry.application.config.utils.localChangeLog;
    var key = UTILS_PRIVACY_POLICY;
    jaxx.FileManager.updateLocalStorage(url, filePath, key, function(err) {
      if(err) {
        console.error(err);
      } else {
        var data = jaxx.FileManager.getLocalStorage(key);
        if(data && data[0]) {
          self._jaxxPrivacyPolicy = data[0];
          callback(data);
        }
      }
    });
  } else {
    url = "https://jaxx.io/jaxx-data/jaxx-privacy-policy.php"
    $.getJSON( url, function( data ) {
        if (data && data[0]) {
            self._jaxxPrivacyPolicy = data[0];
            callback(data);
        }
    });
  }

}

JaxxUIIntro.prototype.populatePrivacyPolicyVerbatim = function(data){
//    console.log("terms of service data :: " + unescape(this._jaxxTermsOfService.description));

    var scrubbedTitleString = JaxxUtils.scrubInput(this._jaxxPrivacyPolicy.title);
    $('.privacyPolicyModal .title').text(scrubbedTitleString);

    var scrubbedBodyString = JaxxUtils.scrubInput(unescape(this._jaxxPrivacyPolicy.description));
    $('.privacyPolicyModal .privacyPolicyVerbatim').html(scrubbedBodyString);

    // $('.pageTermsOfService .btnContinue').show(); // Enable continue button.
}

JaxxUIIntro.prototype.showPrivacyPolicy = function(){
    $('.privacyPolicyModal').fadeIn(500);
}

JaxxUIIntro.prototype.hidePrivacyPolicy = function(){
    $('.privacyPolicyModal').fadeOut(500);
}

JaxxUIIntro.prototype.btnContinueTermsOfService = function(){
    //if ($('.pageTermsOfService .checkboxAgreeToTerms:checked').length > 0) {
    //Navigation.clearSettings();

    // Navigation.openModal('loading');
    storeData('hasShownTermsOfService', true, false);
    setTimeout(function() {
        initializeJaxx(function() {
            // $('.pageTermsOfService').hide();
        });
    }, 500);
    //}
}

JaxxUIIntro.prototype.clickCancelTermsOfService = function(){
    this.hideTermsOfService();
    Navigation.pushSettings('pageAttentionMessage');
}

JaxxUIIntro.prototype.toggleCheckboxTermsOfService = function() {
    /*
    if ($('.pageTermsOfService .checkboxAgreeToTerms:checked').length > 0){
        $('.pageTermsOfService .checkboxAgreeToTerms').prop('checked', false);
        this.clickCheckboxTermsOfService($('.pageTermsOfService .checkboxAgreeToTerms').prop('checked'));
    } else {
        $('.pageTermsOfService .checkboxAgreeToTerms').prop('checked', true);
        this.clickCheckboxTermsOfService($('.pageTermsOfService .checkboxAgreeToTerms').prop('checked'));
    }*/
}

JaxxUIIntro.prototype.enableContinueSetupPIN = function(){

    $('.changePinCodeCustomIntroOption .btnContinue').text('CONTINUE');
}

JaxxUIIntro.prototype.disableContinueSetupPIN = function(){
    $('.changePinCodeCustomIntroOption .btnContinue').text('');
}

JaxxUIIntro.prototype.isContinueEnabledSetupPIN = function(){
    return ($('.changePinCodeCustomIntroOption .btnContinue').text() === 'CONTINUE');
}

JaxxUIIntro.prototype.enableContinueConfirmPIN = function(){
    this._pinIsCorrect = true;
    $('.confirmPinCodeCustomIntroOption .btnContinue').text('CONTINUE');
}

JaxxUIIntro.prototype.disableContinueConfirmPIN = function(){
    this._pinIsCorrect = false;
    $('.confirmPinCodeCustomIntroOption .btnContinue').text('');
}

JaxxUIIntro.prototype.isContinueEnabledConfirmPIN = function(){
    return ($('.confirmPinCodeCustomIntroOption .btnContinue').text() === 'CONTINUE');
}

/*
* This is the action fired when user hits continue on custom pair restore wallet after picking currencies & wallets
* */
JaxxUIIntro.prototype.clickContinueSetupPIN = function(){
    if (this.isContinueEnabledSetupPIN()){
        this.showConfirmNewPinSettingsCustom();
        Navigation.pushSettings('confirmPinCodeCustomIntroOption');
        JaxxUI._sUI.clearAllNumPadData();
    }
}

/*
* After entering the pin for the first time in the pin wizard the continue button fires this function.
* */
JaxxUIIntro.prototype.clickContinueConfirmPIN = function(){
    if (this.isContinueEnabledConfirmPIN()){
        Navigation.clearSettings();
        g_JaxxApp.getUser().setPin(this._temporaryPin);
        if (this._tempEncryptedMnemonic === ""){
            this.createWalletWithCallbackCustomUsingPIN();
        } else {
            // this.loadFromTemporarilyStoredMnemonic();
            this.takeMeToMyWallet();
        }
    }
}

JaxxUIIntro.prototype.clickBackConfirmPinScreen = function(){
    Navigation.popSettings();
    this.disableContinueButtonsOnPINScreens();
    g_JaxxApp.getUI().setupTemporaryPin("");
    this.showEnterNewPinSettingsCustom();
    JaxxUI._sUI.clearAllNumPadData();
}

JaxxUIIntro.prototype.callbackForPIN = function(keyPressed){
    // Parameter is string or integer.
    if (keyPressed === 'DEL'){
        this.clickDELOnPIN();
    } else if (keyPressed === 'CLR') {
        this.clickCLROnPIN();
    } else {
        // Number pressed
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();
        // console.log("JaxxUIIntro :: callbackForPIN :: A number was entered into the PIN.");
        if (enteredPin.length === 4 && !(this._pinIsCorrect)){
            this.clickCLROnPIN();
            g_JaxxApp.getUI().clearAllNumPadData();
        }
    }
}

JaxxUIIntro.prototype.clickDELOnPIN = function(){
    var enteredPin = JaxxUI._sUI.getEnteredPINCode();
    if (enteredPin.length === 1){
        this.setConfirmPinCirclesToOrangeBorder();
    }
    if (enteredPin.length === 4 && this.isConfirmPinCircleBorderBlue()){
        this.resetConfirmPINTextForIntroScreen();
        this.setConfirmPinCirclesToOrangeBorder();
    }
    this.disableContinueButtonsOnPINScreens();
}

JaxxUIIntro.prototype.clickCLROnPIN = function(){
    this.resetConfirmPINTextForIntroScreen();
    this.setConfirmPinCirclesToOrangeBorder();
    this.disableContinueButtonsOnPINScreens();
}

JaxxUIIntro.prototype.resetConfirmPINTextForIntroScreen = function(){
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPadText').text('Please verify your PIN');
}

JaxxUIIntro.prototype.disableContinueButtonsOnPINScreens = function(){
    this.disableContinueConfirmPIN();
    this.disableContinueSetupPIN();
}

/*
* This function activates displays the pin screen in the intro screen custom user flow
* */
JaxxUIIntro.prototype.enterPinCodeCustomIntroOption = function(){
    Navigation.pushSettings('changePinCodeCustomIntroOption');
    this.showEnterNewPinSettingsCustom();
    JaxxUI._sUI.initializePinPad();
    JaxxUI._sUI.clearAllNumPadData();
    this.disableContinueButtonsOnPINScreens();

}

JaxxUIIntro.prototype.isConfirmPinCircleBorderBlue = function(){
    return ($('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input.cssBlueBorder').length > 0);
}

JaxxUIIntro.prototype.setConfirmPinCirclesToRedBorder = function(){
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').addClass('cssRedBorder');
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').removeClass('cssOrangeBorder');
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').removeClass('cssBlueBorder');
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').css('color', '#F45B82 !important');
}

JaxxUIIntro.prototype.setConfirmPinCirclesToBlueBorder = function(){
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').removeClass('cssRedBorder');
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').removeClass('cssOrangeBorder');
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').addClass('cssBlueBorder');
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').css('color', '#2681FF !important');
}

JaxxUIIntro.prototype.setConfirmPinCirclesToOrangeBorder = function(){
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').removeClass('cssRedBorder');
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').addClass('cssOrangeBorder');
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').removeClass('cssBlueBorder');
    $('.confirmPinCodeCustomIntroOption .settingsEnterPinPad input').css('color', '#E76F22 !important');
}

JaxxUIIntro.prototype.startJaxxFromTermsOfServicePage = function(){

    var mnemonic = getStoredData('mnemonic', true);

    if (typeof(mnemonic) !== 'undefined' && mnemonic !== null){
        $('.pageViewKeysTermsOfService .populateMnemonic').text(mnemonic);
    }
    Navigation.pushSettings('pageTermsOfService');
}

JaxxUIIntro.prototype.mnemonicEnteredIsNotValidCustomIntroOption = function(){
    $('.verifyMnemonicCustomIntroOption .btnNext').hide();
}

JaxxUIIntro.prototype.mnemonicEnteredIsValidCustomIntroOption = function(){
    $('.verifyMnemonicCustomIntroOption .btnNext').show();
}

/* Will include later if requirements change.
JaxxUIIntro.prototype.clickNextOnVerifyMnemonicCustomIntroOption = function(){
    wallet.confirmBackup();
    updateWalletUI();
}
*/

JaxxUIIntro.prototype.toggleExpandSetupSecurityPinDescription = function(){
    g_JaxxApp.getUI().toggleTextExpansion('.settings.pageSetupSecurityPinCode .expandableText', '.settings.pageSetupSecurityPinCode .triangleArrow','240px', '60px', 500);
}

JaxxUIIntro.prototype.toggleExpandBackupMnemonicDescription = function(){
    g_JaxxApp.getUI().toggleClosestAncestorExpandableText('.settings.backupMnemonicCustomIntroOption .triangleArrow');
}

JaxxUIIntro.prototype.clickCustomCurrencies = function(){
    g_JaxxApp.getUI().toggleClosestAncestorExpandableText('.pageCustomCurrenciesSetup .triangleArrow');
    if ($('.pageCustomCurrenciesSetup .expandableText').hasClass('cssExpanded')){
        $('.pageCustomCurrenciesSetup .exchangeRateList').css('height', (this._collapsedHeightOfCustomCurrenciesList + 90).toString() + 'px');
    } else {
        $('.pageCustomCurrenciesSetup .exchangeRateList').css('height', (this._collapsedHeightOfCustomCurrenciesList).toString() + 'px');
    }
    // height: calc(100% - 172px) !important;
}

JaxxUIIntro.prototype.populateAllUserKeys = function() {

    $('.allUserKeys').text("gathering all private and public keypairs.. please wait.");

    if (!wallet) {
        setTimeout(function() {
            var mnemonicEncrypted = getStoredData('mnemonic', false);
            if (mnemonicEncrypted) {
                var newWallet = new HDWalletMain();
                newWallet.initialize();
                jaxx.Registry.tempWallet = newWallet;
                newWallet.setupWithEncryptedMnemonic(mnemonicEncrypted, function(err) {
                    if (err) {
                        console.log("JaxxUIIntro.populateAllUserKeys :: loadFromEncryptedMnemonic :: error :: " + err);
                    } else {
                        newWallet.exportAllKeypairs(function(allUserKeypairs) {

                            var allUserKeysCSV = "coinName, publicAddress, privateKey, \n" + allUserKeypairs;

                            console.log("allUserKeysCSV :: \n" + allUserKeysCSV);
                            $('.allUserKeys').text(allUserKeysCSV);
                            $('.allUserKeysCopy').attr('copy', allUserKeysCSV);
                        });
                    }
                });
            }
        }, 100);
//        $('.allUserKeys').text("there is no previous wallet.");
    } else {
        wallet.exportAllKeypairs(function(allUserKeypairs) {
            var allUserKeysCSV = "coinName, publicAddress, privateKey, \n" + allUserKeypairs;

            console.log("allUserKeysCSV :: \n" + allUserKeysCSV);

            $('.allUserKeys').text(allUserKeysCSV);
            $('.allUserKeysCopy').attr('copy', allUserKeysCSV);
        });
    }
}

JaxxUIIntro.prototype.showContinueOnSplashScreen = function(){
    $('.settings.splash .btnContinue').fadeIn();
}

JaxxUIIntro.prototype.splashOptionClicked = function(strSplashOption){
    this.showContinueOnSplashScreen();
}

JaxxUIIntro.prototype.selectSplashSetupOption = function(strSplashOption){
    $('.settings.createNewWallet .radioBtnSplashOption').prop('checked', false);
    $('.settings.splash .optionBox .option' + strSplashOption + ' .optionHeading input').prop('checked', true);
    this.showContinueOnSplashScreen();
}

JaxxUIIntro.prototype.pressContinueSplashOption = function(){

    if( !jaxx.Registry.appState) jaxx.Registry.appState = {};
    var splashOptionChosen = $('.settings.splash .radioBtnSplashOption:checked').attr('value');

    if (splashOptionChosen === 'CreateNewWallet'){

        jaxx.Registry.appState.create = {};
        jaxx.Registry.appState.pair = null;
        jaxx.Registry.generateMnemonic();

        localStorage.setItem('walletType','new-wallet');

        $(".btnOpenCloseExpress").trigger('click');
        Navigation.pushSettings('createNewWallet');

        this._setWalletType = "newWallet";
        //storeData('walletType', this._setWalletType);

    } else if (splashOptionChosen === 'PairFromDeviceStart'){

        jaxx.Registry.appState.pair = {};
        jaxx.Registry.appState.create = null;
        localStorage.setItem('walletType','pair-device');
        Navigation.pushSettings('introLoadJaxxToken');
        this._setWalletType = "pairedWallet";
        //Navigation.pushSettings('pairFromDeviceStart');
        //Navigation.pushSettings('pairFromDeviceCustomOrExpress');
    }
    jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_NEW_WALLET_START);

   // console.log(jaxx.Registry.appState);
}

/*JaxxUIIntro.prototype.setTempMnemonic = function(tempEncryptedMnemonic) {
    console.error(tempEncryptedMnemonic);

    this._tempEncryptedMnemonic = tempEncryptedMnemonic;
}*/

JaxxUIIntro.prototype.pressContinuePairDevices = function(element){
    var mnemonic  = $(element.attr('targetInput')).val();
    $(element.attr('targetInput')).val('');
    jaxx.Registry.pairDeviceMnemonic(mnemonic);
    this._tempEncryptedMnemonic = g_Vault.encryptSimple(mnemonic);

    if (wallet === null){
        Navigation.pushSettings('pressContinuePairDevices');
    }
    else {
        Navigation.pushSettings('pressContinuePairDevices');
    }
};

JaxxUIIntro.prototype.pressContinueCustomOrExpress = function(){
    //after pair devices is chosen, option to create wallet custom or express
    var splashOptionChosen = $('.settings.pressContinuePairDevices .radioBtnSplashOption:checked').attr('value');
    if (splashOptionChosen === 'pairWalletExpress'){
        //this.prepareMnemonicForWalletCreation();
        console.log("express chosen")
        Navigation.pushSettings('createNewWallet');
    } else if (splashOptionChosen === 'pairWalletCustom'){
        Navigation.pushSettings('pairFromDeviceStart');
        console.log('custom chosen')
        //Navigation.pushSettings('pairFromDeviceCustomOrExpress');
    }
}

JaxxUIIntro.prototype.toggleExpandSplashOption = function(strSplashOption){
    var strSelectorForTextBox = '.settings.splash .optionBox .option' + strSplashOption;
    var strSelectorForTriangleArrow = '.settings.splash .optionBox .option' + strSplashOption + ' .triangleArrow';
    if ($(strSelectorForTextBox).hasClass('cssExpanded')){
        g_JaxxApp.getUI().closeTextExpansion(strSelectorForTextBox, strSelectorForTriangleArrow, '60px', 500);
    } else {
        if (strSplashOption === 'CreateNewWallet'){
            g_JaxxApp.getUI().closeTextExpansion('.settings.splash .optionBox .optionPairFromDeviceStart', '.settings.splash .optionBox .optionPairFromDeviceStart .triangleArrow', '60px', 500);
            g_JaxxApp.getUI().openTextExpansion(strSelectorForTextBox, strSelectorForTriangleArrow, '160px', 500);
        } else if (strSplashOption === 'PairFromDeviceStart'){
            g_JaxxApp.getUI().closeTextExpansion('.settings.splash .optionBox .optionCreateNewWallet', '.settings.splash .optionBox .optionCreateNewWallet .triangleArrow', '60px', 500);
            g_JaxxApp.getUI().openTextExpansion(strSelectorForTextBox, strSelectorForTriangleArrow, '160px', 500);
        }
    }
}

JaxxUIIntro.prototype.showConfirmNewPinSettingsFromViewKeys = function(){
    var self = this;
    var successCallback = function(){
        self.correctPinIsEnteredInViewKeysConfirm();
    };
    g_JaxxApp.getUI().showConfirmExistingPinSettings(successCallback);

    /*
    // this.setConfirmPinCirclesToOrangeBorder();

    JaxxUI._sUI.setupPinPad('.viewMnemonicConfirmPinViewKeys .settingsEnterPinPad', function(keyPressed){
        self.callbackForPIN(keyPressed);
    });

    //$('.settings.viewMnemonicConfirmPinViewKeys .settingsEnterPinPadText').text('Verify Current PIN');
    //$('.viewMnemonicConfirmPinViewKeys .settingsEnterNewPinConfirmButton').hide();

    var checkForMatchingPin = function() {
        var enteredPin = JaxxUI._sUI.getEnteredPINCode();

        if (enteredPin === JaxxUI._sUI._temporaryPin) {
            //self.setConfirmPinCirclesToBlueBorder();
            //clearTimeout(self._incorrectPINTimeout);
            //$('.confirmPinCodeCustomIntroOption .settingsEnterPinPadText').text('PIN Verified')
            //Navigation.flashBanner(successMessage, 5);
            self.correctPinIsEnteredInViewKeysConfirm();
        } else if (enteredPin.length === 4) {
            self.incorrectPinIsEnteredInViewKeysConfirm();
        }
    }

    JaxxUI._sUI.setOnPinSuccess(checkForMatchingPin);
    JaxxUI._sUI.setOnPinFailure(checkForMatchingPin);

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);
    inputElement.trigger('keyup');

    inputElement.focus();

    //
    */
    /*
    JaxxUI._sUI.setupPinPad('.viewMnemonicConfirmPinViewKeys .settingsEnterPinPad');

    $('.settingsEnterPinPadText').text('Confirm PIN')

    JaxxUI._sUI.setOnPinSuccess(function() {
        JaxxUI._sUI.deinitializePinPad();
        successCallback();
    });

    JaxxUI._sUI.setOnPinFailure(function() {

    });

    JaxxUI._sUI.clearAllNumPadData();

    var inputElement = $(JaxxUI._sUI._mainPinPadElementName + ' .pinEntry' + JaxxUI._sUI._pinEntryFocus);
    inputElement.trigger('keyup');
    inputElement.focus();
    */

}

JaxxUIIntro.prototype.incorrectPinIsEnteredInViewKeysConfirm = function(){

}

JaxxUIIntro.prototype.correctPinIsEnteredInViewKeysConfirm = function(){
    this.prepareAllUserKeysPage();
}

JaxxUIIntro.prototype.prepareAllUserKeysPage = function(){
    //this.populateAllUserKeys();
    Navigation.pushSettings("pageViewKeysTermsOfService");
}



JaxxUIIntro.prototype.clickViewKeysButton = function(){
    if (g_JaxxApp.getUser().hasPin()){
        this.showConfirmNewPinSettingsFromViewKeys();
        Navigation.pushSettings("viewMnemonicConfirmPinViewKeys");
    } else {
        this.prepareAllUserKeysPage();
    }
}

JaxxUIIntro.prototype.toggleHeightForCurrenciesListCustomIntroOption = function(){
    // @Note: Special action runs before script action which causes expansion.
    strSourceElementSelector = ".pageCustomCurrenciesSetup .expandableText";
    intHeightDifference = parseInt($(strSourceElementSelector).attr("expandedHeight")) - parseInt($(strSourceElementSelector).attr("collapsedHeight"));
    strTargetElementSelector = ".pageCustomCurrenciesSetup .cssList";
    if ($(strSourceElementSelector).hasClass("cssExpanded")){
        g_JaxxApp.getUI().changeHeightOfElement(strTargetElementSelector, -intHeightDifference);
    } else {
        g_JaxxApp.getUI().changeHeightOfElement(strTargetElementSelector, intHeightDifference);
    }
}

JaxxUIIntro.prototype.clickProceedToBackupToShowMnemonic = function(){
    var mnemonic = getStoredData('mnemonic', true);
    $('.viewMnemonicCustomIntroOption .populateMnemonic').text(mnemonic);
    Navigation.pushSettings('viewMnemonicCustomIntroOption');
};

JaxxUIIntro.prototype.clickSkipMnemonicPromptPinSetup = function(){
    Navigation.pushSettings('pageSetupSecurityPinCode');
}

JaxxUIIntro.prototype.getMnemonicEncrypted = function(){
    return this._mnemonicEncrypted;
}

JaxxUIIntro.prototype.clickCheckboxSecurityPinSetup = function(){
    g_JaxxApp.getUI().clickCheckboxToContinue($(".pageSetupSecurityPinCode .cssCheckboxContainer"), $(".pageSetupSecurityPinCode .btnContinue"));
}

JaxxUIIntro.prototype.clickCheckboxDisplayBackupPhraseInIntro = function(){
    g_JaxxApp.getUI().clickCheckboxToContinue($(".backupMnemonicCustomIntroOption .cssCheckboxContainer"), $(".backupMnemonicCustomIntroOption .btnContinue"));
}

JaxxUIIntro.prototype.toggleCoinIsEnabledExpress = function(element){
    // This function listens for a checkbox click.
    var coinType = HDWalletHelper.dictCryptoCurrency[$(element).attr('value')].index;
    this.selectCoinOptionExpress(coinType)
}

JaxxUIIntro.prototype.loadFromTemporarilyStoredMnemonic = function(){

    // console.log('TODO');
    // g_JaxxApp.getUI().loadWalletFromEncryptedMnemonic(this._tempEncryptedMnemonic);
    /*
    Navigation.clearSettings(); // This is where we add the loading wallet screen.
    loadFromEncryptedMnemonic(, function(err, wallet) {
        if (err) {
            console.log("importMnemonic.import :: error :: " + err);

            Navigation.flashBanner("Error on Import Attempt", 5);
            Navigation.closeModal();
            Navigation.startBlit();
        } else {
            storeData('mnemonic', wallet.getMnemonic(),true);

            Navigation.flashBanner("Successfully Imported!", 5);

            Navigation.closeModal();
            Navigation.startBlit();

            forceUpdateWalletUI();
        }
    });*/
}

JaxxUIIntro.prototype.pressContinueCustomOrExpressPairDevices = function(element) {
    // Store the setup option that has been selected and push settings based on that selection.
    var setupOptionChosen = $('.settings.pressContinuePairDevices .radioBtnPDExpressCustom:checked').attr('value');
    if (setupOptionChosen === 'PDExpress') {
        jaxx.CoinsListSetup.instance.selectCurrency(0);
        this.optionSelected("Express");
        Navigation.pushSettings('pageExpressWalletSetup');
    } else if (setupOptionChosen === 'PDCustom') {
        jaxx.CoinsListSetup.instance.selectCurrency(1);
        this.optionSelected("Custom");
        Navigation.pushSettings('pageCustomWalletSetup');
    }
    $('.takeMeToWallet').hide(); // hacky way to ensure the button is hidden
}

JaxxUIIntro.prototype.clickSkipOnIntroScreens = function(){
    if (this._tempEncryptedMnemonic === ""){
        // this.createWalletWithCallbackCustom();
        Navigation.pushSettings('pageSetupSecurityPinCode'); // Requirement change
    } else {
        this.takeMeToMyWallet();
        // Navigation.closeModal();
        // this.loadFromTemporarilyStoredMnemonic();
    }
}

JaxxUIIntro.prototype.pairFromDeviceScanQR = function() {
    var callback = function(jaxxToken){
        var mnemonic = HDWalletMain.getMnemonicFromJaxxToken(jaxxToken);
        $(".settings.introLoadJaxxToken .validateMnemonic").val(mnemonic);
        $(".settings.introLoadJaxxToken .validateMnemonic").trigger('keyup')
    }
    g_JaxxApp.getUI().scanJaxxToken(callback);
}

JaxxUIIntro.prototype.skipToCreateWalletWithoutPinCustomSetup = function(){
    if (this._tempEncryptedMnemonic === ""){
        this.createWalletWithCallbackCustom();
        // Navigation.pushSettings('pageSetupSecurityPinCode'); // Requirement change
    } else {
        this.takeMeToMyWallet();
        // this.loadFromTemporarilyStoredMnemonic();
    }
}

JaxxUIIntro.prototype.setSizeOfScrollableListForCustomCoins = function(){
    setTimeout(function (totalHeight) {
        // jaxx_ui.toggleNearbyExpandableDetails
        var expandableTextHeight = $(".pageCustomWalletSetup .expandableText").height();
        var footerHeight = $(".pageCustomWalletSetup .cssBackContinue").height();
        var headerHeight = $(".pageCustomWalletSetup .cssHeader").height();
        var heightToSubtract = expandableTextHeight + footerHeight + headerHeight;
        var totalHeight = window.innerHeight - heightToSubtract;
        $('.pageCustomWalletSetup .cssCustomWalletsCoinListOverlay').css('height', totalHeight.toString() + 'px');
    }, 500);
}

JaxxUIIntro.prototype.showWarningPageBeforeViewKeys = function(element){
    var element = $('.settings.pageWarningBeforeViewKeys .pairDeviceShowMnemonicButton');
    //element.removeClass('cssBlueButtonWide');
    //element.addClass('cssGreyButtonWide');
    //element.css('cursor', 'default');
    //element.attr('pushSettings', null);
    element.hide();

    countdownButtonUpdate(element, 'I Understand: ', 6, null, function() {
      element.show();
      //element.removeClass('cssGreyButtonWide');
      //element.addClass('cssBlueButtonWide');
      //element.text('I Understand');
      //element.css('cursor', 'pointer');
      //element.attr('pushSettings', 'viewJaxxToken');
    });

    var elementTwo = $('.settings.pageWarningBeforeViewKeys .pairDeviceShowMnemonicCount');
    elementTwo.fadeIn();

    countdownButtonUpdate(elementTwo, '', 5, function(timeRemaining) {
      elementTwo.text(timeRemaining);
    }, function() {
      elementTwo.fadeOut();
    });
    Navigation.pushSettings('pageWarningBeforeViewKeys');
}
var JaxxApp = function() {
    this._appVersion = "1.3.0";
    this._settings = new JaxxAppSettings();
    this._controller = new JaxxController();

    var ui  = new JaxxUI();
    jaxx.Registry.jaxxUI = ui;
    this._ui = ui;

    this._ui.addListeners();

    this._user = new JaxxUser();
   // this._txManager = new JaxxTXManager();
    this._shapeShiftHelper = new JaxxShapeShiftHelper();
    //this.//cryptoDispatcher$= $({});

   // this._globalDispatcher = new JaxxGlobalDispatcher();
    this._initializer = new JaxxInitializer();

  //  this._cryptoEnableDisable = new jaxx.CryptoEnableDisable();
   // this._relayManagerForCoin = {};
    
   // this._relayManagerBitcoin = null;
   // this._relayManagerLitecoin = null;
   // this._relayManagerZCash = null;
    //this._relayManagerDoge = null;
    
    //this._relayManagerImplementationBitcoin = null;
    //this._relayManagerImplementationLitecoin = null;
    //this._relayManagerImplementationZCash = null;
    //this._relayManagerImplementationDoge = null;
}

JaxxApp.prototype.initialize = function(config) {
///    //this._relayManagerBitcoin = new RelayManager();
    //this._relayManagerLitecoin = new RelayManager();
   // this._relayManagerZCash = new RelayManager();
   // this._relayManagerDoge = new RelayManager();

    this._settings.initialize();

    this._dataStoreController = new jaxx.JaxxDatastoreController(config);
    
    //this._relayManagerImplementationBitcoin = new RelayManagerBitcoin();
    //this._relayManagerImplementationLitecoin = new RelayManagerLitecoin();
   // this._relayManagerImplementationZCash = new RelayManagerZCash();
    //this._relayManagerImplementationDoge = new RelayManagerDoge();

    this._initializer.initialize();
    this._controller.initialize();

    this._ui.initialize();
    this._user.initialize();
   // this._txManager.initialize();
    this._shapeShiftHelper.initialize();
    this._dataStoreController.initialize(config);
   // this._globalDispatcher.initialize();
    //this._relayManagerBitcoin.initialize(this._relayManagerImplementationBitcoin);
    //this._relayManagerLitecoin.initialize(this._relayManagerImplementationLitecoin);
    //this._relayManagerZCash.initialize(this._relayManagerImplementationZCash);
   // this._relayManagerDoge.initialize(this._relayManagerImplementationDoge);
    
    //this._relayManagerForCoin[COIN_BITCOIN] = this._relayManagerBitcoin;
    ///this._relayManagerForCoin[COIN_LITECOIN] = this._relayManagerLitecoin;
    //this._relayManagerForCoin[COIN_ZCASH] = this._relayManagerZCash;
    ///this._relayManagerForCoin[COIN_DOGE] = this._relayManagerDoge;
    
}

/*JaxxApp.prototype.getRelays = function(coinType) {
    return coinType ? this._relayManagerForCoin[coinType] : this._relayManagerForCoin;
}*/
/*JaxxApp.prototype.setRelays = function(coinType, relayManager) {
    this._relayManagerForCoin[coinType] = relayManager;
}*/

JaxxApp.prototype.setupWithWallet = function(wallet) {
    // JaxxUser setup wallet does not even use wallet as a parameter so consider deleting it.
    this._user.setupWithWallet(wallet);
}

JaxxApp.prototype.getVersionCode = function() {
    return this._appVersion;
}

JaxxApp.prototype.getSettings = function() {
    return this._settings;
}

JaxxApp.prototype.getUI = function() {
    return this._ui;
}

JaxxApp.prototype.getUser = function() {
    return this._user;
}

JaxxApp.prototype.getTXManager = function() {
    return this._txManager;
}

JaxxApp.prototype.getShapeShiftHelper = function() {
    return this._shapeShiftHelper;
}

JaxxApp.prototype.getDataStoreController = function() {
    return this._dataStoreController;
}

JaxxApp.prototype.getCryptoControllerByCoinType = function(coinType) {
    return this._dataStoreController.getCryptoControllerById(coinType);
}

JaxxApp.prototype.getCryptoControllerByName = function(name) {
    return this._dataStoreController.getCryptoControllerByName(name);
}

JaxxApp.prototype.getGlobalDispatcher = function() {
    return this._globalDispatcher;
}

/*JaxxApp.prototype.getBitcoinRelays = function() {
    return this.getRelayManagerForCoin(COIN_BITCOIN);
}*/

/*JaxxApp.prototype.getLitecoinRelays = function() {
    return this.getRelayManagerForCoin(COIN_LITECOIN);
}*/

/*JaxxApp.prototype.getZCashRelays = function() {
    return this.getRelayManagerForCoin(COIN_ZCASH);
}*/

/*JaxxApp.prototype.getDogeRelays = function() {
    return this.getRelayManagerForCoin(COIN_DOGE);
}*/

JaxxApp.prototype.isReleaseVersion = function(){
    return IS_RELEASE_VERSION;
}

JaxxApp.prototype.getController = function(){
    return this._controller;
}

/*
JaxxApp.prototype.getRelayManagerForCoin = function(coinType){
    return this._relayManagerForCoin[coinType];
}
*/

JaxxApp.prototype.startJaxxWithReleaseNotesPage = function(){

}

JaxxApp.prototype.getInitializer = function(){
    return this._initializer;
}
var g_JaxxApp = new JaxxApp();
var g_ready;

$(document).ready(function () {
    console.log('ready');

    var app = new jaxx.Application({});
    var jaxxconfig = null;

    if (g_ready) return;

    jaxx.Registry.jaxxApp = g_JaxxApp;

    getJaxxConfig(function (error, config) {
        if (error) {
            console.error(error);
            updateCurrentConfig(config);
        } else {
            app.setConfig(config);
            initializeJaxxAppWithConfig(config);
            updateCurrentConfig(config);
        }
    });
});

function updateCurrentConfig(config) {

    var version = config.ver;

    var latestJaxxVersion = JSON.parse(localStorage.getItem('jaxxconfig')).jaxxClient;
    if (latestJaxxVersion) {
        if (latestJaxxVersion !== Number(Registry.getJaxxVersion())) {
            jaxx.Registry.setJaxxVersion(latestJaxxVersion);
        }
    }

      var jaxxVersion = jaxx.Registry.getJaxxVersion();
      var env = 'prod';
      var url = 'https://utils.jaxx.io/api/' + env + '/jaxx-config/'+version+'/'+jaxxVersion;

    //only make a call to retrieve latest jaxx config when it is available for download
    if (jaxxVersion) {
        $.getJSON(url).done(function (result) {
            if (typeof result === 'object') {
                try {
                    var config = result;
                    if (config.ver) {
                        if (config.ver > JSON.parse(localStorage.getItem('jaxxconfig')).ver) {
                            localStorage.setItem('jaxxconfig', JSON.stringify(config));
                            localStorage.setItem('lastJaxxConfigUpdate', String(Date.now()));
                            jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_CONFIG_UPDATED, config);
                            console.warn(jaxx.Registry.ON_CONFIG_UPDATED);
                        }
                    }
                } catch (e) {
                    console.error(e);
                }
            }
        }).fail(function (err) {
            console.error(err);
        });
    }
}

function getJaxxConfig(callBack) {
    var currentConfig;
    var localStorageJaxxConfig = localStorage.getItem('jaxxconfig');
    var useAppConfig = localStorage.getItem('useAppConfig');

    if (useAppConfig && (useAppConfig.toLowerCase() === 'true')) {
        console.warn('Using App Configuration.');
        new jaxx.JaxxDeveloper();
        $.getJSON('js/app/jaxx-config.json').done(function (result) {
            callBack(null, result);
        }).fail(function (jqXHR) {
            jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, new VOError('jaxx.updateCurrentConfig', url, result))
            console.error(e);
            console.error('error load config loading from applicaton ', jqXHR);
            callBack('no config file in local ', {ver: 1.0});
        });
    } else {
        if (!localStorageJaxxConfig) {
            $.getJSON('js/app/jaxx-config.json').done(function (result) {
                localStorage.setItem('jaxxconfig', JSON.stringify(result));
                callBack(null, result);
            }).fail(function (jqXHR) {
                console.error('error load config loading from server ', jqXHR);
                jaxx.Registry.error$.triggerHandler(jaxx.Registry.ON_ERROR, new VOError('jaxx.updateCurrentConfig', url, result))
                console.error(e);
                callBack('no config file in local ', {ver: 1.0});
            });
        } else {
            currentConfig = JSON.parse(localStorageJaxxConfig);
            callBack(null, currentConfig);
        }
    }
}

function initializeJaxxAppWithConfig(config) {
    console.log('initializeJaxxAppWithConfig');
    console.log('loaded in ' + (Date.now() - starttime) + ' ms');
    g_initialized = true;
    g_JaxxApp.initialize(config);
    PlatformUtils.outputAllChecks();
    startJaxx();
}

//@note: @todo: move into JaxxApp object
var refreshHistoryTimer = null;
var historyRefreshTime = 5000;

// Move to tools?
function isDecimal(value) {
    return (value + '').match(/^([0-9]+|[0-9]+\.[0-9]*|[0-9]*\.[0-9]+)$/);
}


var Vault = function () {
    //Encrypt using google crypto-js AES-base cypher
    this._key = "6Le0DgMTAAAAANokdfEial"; //length=22
    this._iv = "mHGFxENnZLbienLyALoi.e"; //length=22
    this._keyB;
    this._ivB;
}

Vault.prototype.encryptSimple = function (clearTxt) {
    this._keyB = thirdparty.CryptoJS.enc.Base64.parse(this._key);
    this._ivB = thirdparty.CryptoJS.enc.Base64.parse(this._iv);
    var encrypted = thirdparty.CryptoJS.AES.encrypt(clearTxt, this._keyB, {iv: this._ivB});
    var encryptedString = encrypted.toString();
    return encryptedString;
}

Vault.prototype.decryptSimple = function (encryptedTxt) {
    this._keyB = thirdparty.CryptoJS.enc.Base64.parse(this._key);
    this._ivB = thirdparty.CryptoJS.enc.Base64.parse(this._iv);
    var decrypted = thirdparty.CryptoJS.AES.decrypt(encryptedTxt, this._keyB, {iv: this._ivB});
    var decryptedText = decrypted.toString(thirdparty.CryptoJS.enc.Utf8);
    return decryptedText;
}

Vault.prototype.decrypt = function (encVal, callback) {
    var error = null;

    var decryptedVal = this.decryptSimple(encVal, true);

    callback(error, decryptedVal);
}


function truncate(text, frontCount, backCount, delimiter) {

    if (!text) {
        text = 'null';
    }

    if (!delimiter) {
        delimiter = '...';
    }

    var l = frontCount + backCount + delimiter.length;

    if (text.length < l) {
        return text;
    }

    return text.substring(0, frontCount) + delimiter + text.substring(text.length - backCount);
}

const transitionElementNames = ['.tab.send',
    '.tab.receive',
    '.mainBalanceBox',
    '.refresh',
    '.mainAddressBox',
    '.qrCode',
    '.cameraTab',
    '.balanceBoxSeperator',
    '.mainTransactionHistoryHeader',
    '.transactionHistorySeperator',
    '.noTransactions',
    '.landscapeQRSeperator',
    '.landscapeRight'];

const portraitTransitionsIn = [];
const portraitTransitionsOut = [];

const landscapeTransitionsIn = [];
const landscapeTransitionsOut = [];

portraitTransitionsIn['.tab.send'] = 'slideInRight';
portraitTransitionsIn['.tab.receive'] = 'slideInLeft';
portraitTransitionsIn['.mainBalanceBox'] = 'fadeInLeft';
portraitTransitionsIn['.refresh'] = 'fadeIn';
portraitTransitionsIn['.mainAddressBox'] = 'zoomIn';
portraitTransitionsIn['.qrCode'] = ''; //fadeIn
portraitTransitionsIn['.cameraTab'] = 'fadeIn';
portraitTransitionsIn['.balanceBoxSeperator'] = 'fadeIn';
portraitTransitionsIn['.mainTransactionHistoryHeader'] = 'fadeInUp';
portraitTransitionsIn['.transactionHistorySeperator'] = 'fadeInUp';
portraitTransitionsIn['.noTransactions'] = 'fadeInUp';
portraitTransitionsOut['.landscapeQRSeperator'] = 'fadeIn';
portraitTransitionsOut['.landscapeRight'] = 'fadeIn';

portraitTransitionsOut['.tab.send'] = 'slideOutRight';
portraitTransitionsOut['.tab.receive'] = 'slideOutLeft';
portraitTransitionsOut['.mainBalanceBox'] = 'fadeOutLeft';
portraitTransitionsOut['.refresh'] = 'fadeOut';
portraitTransitionsOut['.mainAddressBox'] = 'zoomOut';
portraitTransitionsOut['.qrCode'] = 'fadeOutRight';
portraitTransitionsOut['.cameraTab'] = 'fadeOut';
portraitTransitionsOut['.balanceBoxSeperator'] = 'fadeOut';
portraitTransitionsOut['.mainTransactionHistoryHeader'] = 'fadeOutDown';
portraitTransitionsOut['.transactionHistorySeperator'] = 'fadeOutDown';
portraitTransitionsOut['.noTransactions'] = 'fadeOutDown';
portraitTransitionsOut['.landscapeQRSeperator'] = 'fadeOut';
portraitTransitionsOut['.landscapeRight'] = 'fadeOut';

landscapeTransitionsIn['.tab.send'] = 'fadeInUp';
landscapeTransitionsIn['.tab.receive'] = 'fadeInUp';
landscapeTransitionsIn['.mainBalanceBox'] = 'zoomIn';
landscapeTransitionsIn['.refresh'] = 'zoomIn';
landscapeTransitionsIn['.mainAddressBox'] = 'zoomIn';
landscapeTransitionsIn['.qrCode'] = 'zoomIn';
landscapeTransitionsIn['.cameraTab'] = 'fadeInUp';
landscapeTransitionsIn['.balanceBoxSeperator'] = 'fadeIn';
landscapeTransitionsIn['.mainTransactionHistoryHeader'] = 'fadeInUp';
landscapeTransitionsIn['.transactionHistorySeperator'] = 'fadeInUp';
landscapeTransitionsIn['.noTransactions'] = 'fadeInUp';
landscapeTransitionsIn['.landscapeQRSeperator'] = 'fadeIn';
landscapeTransitionsIn['.landscapeRight'] = 'fadeIn';

landscapeTransitionsOut['.tab.send'] = 'fadeOutDown';
landscapeTransitionsOut['.tab.receive'] = 'fadeOutDown';
landscapeTransitionsOut['.mainBalanceBox'] = 'zoomOut';
landscapeTransitionsOut['.refresh'] = 'zoomOut';
landscapeTransitionsOut['.mainAddressBox'] = 'zoomOut';
landscapeTransitionsOut['.qrCode'] = 'zoomOut';
landscapeTransitionsOut['.cameraTab'] = 'fadeOutDown';
landscapeTransitionsOut['.balanceBoxSeperator'] = 'fadeOut';
landscapeTransitionsOut['.mainTransactionHistoryHeader'] = 'fadeOutDown';
landscapeTransitionsOut['.transactionHistorySeperator'] = 'fadeOutDown';
landscapeTransitionsOut['.noTransactions'] = 'fadeOutDown';
landscapeTransitionsOut['.landscapeQRSeperator'] = 'fadeOut';
landscapeTransitionsOut['.landscapeRight'] = 'fadeOut';

if (PlatformUtils.extensionCheck() || PlatformUtils.desktopCheck()) {
} else if (PlatformUtils.mobileCheck()) {
    $('.wallet').fadeTo(0, 1);
} else {
    //@note: desktop
}

var lastSentTimestampSeconds = 0; //timestamp or last sent tx
var prevBalance = [];
var hasUpdatedBalance = [];
var pageScanAddresses = [];

for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
    prevBalance[i] = 0;
    hasUpdatedBalance[i] = false;
    pageScanAddresses[i] = [];
}

const PROFILE_PORTRAIT = 0;
const PROFILE_LANDSCAPE = 1;
var scanImportWallet = null;
var forceTransactionRefresh = true;
var lastTransactionRefreshTime = new Date().getTime();
var curCoinType = COIN_BITCOIN;
var ethereumSecretProgress = 0;
var ethereumUnlocked = true;//getStoredData('ethereum_unlocked');
var curProfileMode = -1;
var canUpdateWalletUI = true;
var hasBlit = false;

function switchToProfileMode(profileMode) {
    if (profileMode === curProfileMode) {
        return;
    }

    if (curProfileMode == PROFILE_PORTRAIT) {
        $('.landscapeQRCode').fadeTo(0, 1);
        $('.landscapeQRCode').show();
        $('.landscapeQRCode').removeClass('cssNoSizeOverride');
        $('.copied').css('left', '');
    } else if (curProfileMode == PROFILE_LANDSCAPE) {
        $('.landscapeLeft').removeClass('cssTabletLeft');
        $('.cameraTab').css('right', '');
        $('.shapeshiftTab').css('right', '');
        $('.mainBalanceBox').removeClass('cssFloatNoneOverride');
        $('.landscapeBalanceCenteringA').removeClass('cssCenter');
        $('.landscapeBalanceCenteringB').removeClass('cssTabletBalance');
        $('.portraitCurrency').addClass('cssCurrencyFloat');
        $('.landscapeQRSeperator').removeClass('cssSeparator');
        $('.wrapTableCurrencySelectionMenu').removeClass('cssZeroMarginLeftOverride');
        $('.landscapeRight').removeClass('cssTabletRight');
        $('.portraitQRCode').fadeTo(0, 1);
        $('.portraitQRCode').removeClass('cssPortraitQRCodeLandscapeOverride');
        $('.populateQRCode').removeClass('cssLandscapeQRSizing')
    }

    curProfileMode = profileMode;

    if (profileMode == PROFILE_PORTRAIT) {
        $('.landscapeQRCode').fadeTo(0, 0);
        $('.landscapeQRCode').hide();
        $('.landscapeQRCode').addClass('cssNoSizeOverride');
        $('.copied').css('left', '26%');
    } else if (profileMode == PROFILE_LANDSCAPE) {
        $('.landscapeLeft').addClass('cssTabletLeft');
        var wWidth = g_JaxxApp.getUI().getLargerScreenDimension() / 2;
        var leftWindowWidth = wWidth;
        $('.cameraTab').css('right', leftWindowWidth + 'px');
        $('.shapeshiftTab').css('right', leftWindowWidth + 'px');
        $('.mainBalanceBox').addClass('cssFloatNoneOverride');
        $('.landscapeBalanceCenteringA').addClass('cssCenter');
        $('.landscapeBalanceCenteringB').addClass('cssTabletBalance');
        $('.portraitCurrency').removeClass('cssCurrencyFloat');
        $('.populateBalanceFiat').addClass('cssLandscapePopulateBalanceFiatFix');
        $('.landscapeQRSeperator').addClass('cssSeparator');
        $('.wrapTableCurrencySelectionMenu').addClass('cssZeroMarginLeftOverride');
        $('.landscapeRight').addClass('cssTabletRight');
        $('.portraitQRCode').fadeTo(0, 0);
        $('.portraitQRCode').addClass('cssPortraitQRCodeLandscapeOverride');
        $('.populateQRCode').addClass('cssLandscapeQRSizing')
    }
}

function setDefaultProfileMode(profileMode) {
    if (profileMode == PROFILE_LANDSCAPE) {
        var transitionBasePortraitIn = portraitTransitionsIn;
        var transitionBaseLandscapeIn = landscapeTransitionsIn;

        for (var eID in transitionElementNames) {
            var curElement = transitionElementNames[eID];

            $(curElement).removeClass(transitionBasePortraitIn[curElement]);
            $(curElement).addClass(transitionBaseLandscapeIn[curElement]);
        }
    }
}

var wallet = null;
var openUrl = null;

function checkOpenUrl(url) {
    console.log("< wallet :: " + wallet + " :: url :: " + url + " >");
    if (wallet) {
        var result = HDWalletHelper.parseURI(url);
        var output = '';

        for (var property in result) {
            output += property + ': ' + result[property] + '; ';
        }

        Navigation.showTab('send');
        $('.tabContent .address input').val(result.address).trigger('keyup');

        if (result.amount) {
            $('.tabContent .amount input').val(result.amount).trigger('keyup');
        }
    }
    else {
        openUrl = url;
    }
}

function switchToCoinType(oldController, newController, firstUnlock, callback) {

    var targetCoinType = newController._coinType;
    $('.initializingLoading').hide();
    g_JaxxApp.getUI().resetShapeShift();
    g_JaxxApp.getUI().resetTXHistory(curCoinType);
    g_JaxxApp.getUI().beginSwitchToCoinType(curCoinType, targetCoinType);
    g_JaxxApp.getUI().showHideFoxOnFrontEndOfWallet(targetCoinType);
    wallet.switchToCoinType(targetCoinType);
    g_JaxxApp.getUI().switchToSolidCoinButton(targetCoinType);

    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
        if (i !== targetCoinType) {
            g_JaxxApp.getUI().resetCoinButton(i);
        }
    }

    canUpdateWalletUI = false;
    var tCoinType = targetCoinType;

    Navigation.hideUI(curProfileMode, curProfileMode, function () {

        completeSwitchToCoin(targetCoinType, callback);

    }, firstUnlock, curCoinType);

    curCoinType = targetCoinType;
    wallet.getPouchFold(curCoinType).activateCoinPouchIfInactive();
    g_JaxxApp.getUI().updateTransactionListWithCurrentCoin();
    callback();
    g_JaxxApp.getUI().setTransferPaperWalletHeader(curCoinType);
}

function completeSwitchToCoin(targetCoinType, callback) {

    Navigation.setUseFiat(Navigation.isUseFiat());
    Navigation.setupCoinUI(targetCoinType);
    wallet.completeSwitchToCoinType(targetCoinType);
    g_JaxxApp.getUI().completeSwitchToCoinType(curCoinType, targetCoinType);
    canUpdateWalletUI = true;
    forceUpdateWalletUI();
    g_JaxxApp.getUI().populateCurrencyList(targetCoinType);
    wallet.getPouchFold(targetCoinType).getSpendableBalance(); // This populates the spendable balance cache.
    Navigation.showUI(curProfileMode, curProfileMode, function () {
        callback();
        showPageScanAddresses(targetCoinType);
    });
}

function updateWalletUI(coinType) {
    //@note: for landscape/portrait rotation
    if (!wallet) {
        return;
    }
    if (!canUpdateWalletUI) {
        return;
    }
    if (coinType == null || typeof(coinType) === "undefined") {
        coinType = COIN_BITCOIN;
    }
    g_JaxxApp.getUI().updateAddressElementsInUI();
    g_JaxxApp.getUI().applyTriggersForAmountSendInputUpdateWalletUI();
    g_JaxxApp.getUI().updateFullDisplayBalanceInWallet(coinType);
    g_JaxxApp.getUI().updateWalletUISetCurrency();
    g_JaxxApp.getUI().updateMainMenuConversionAmount();
    g_JaxxApp.getUI().updateTransactionHistoryOnUIUpdate();
    g_JaxxApp.getUI().updateCoinToFiatExchangeRates(); // Here we update the exchange rates in the table.
}

function checkForAllAddresses(docBody) {
    var allResults = [];

    for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
        allResults[i] = checkForAddresses(docBody, i);
    }

    return allResults;
}

function checkForAddresses(docBody, targetCoinType) {
    var results = {};

    if (targetCoinType == COIN_BITCOIN) {
        var bitcoinAddresses = docBody.match(/(^|[^A-Za-z0-9])[13mn][1-9A-HJ-NP-Za-km-z]{26,33}($|[^A-Z-z0-9])/g);

        if (!bitcoinAddresses) {
            bitcoinAddresses = [];
        }

        for (var i = 0; i < bitcoinAddresses.length; i++) {
            var bitcoinAddress = bitcoinAddresses[i].match(/[13mn][1-9A-HJ-NP-Za-km-z]{26,33}/);
            if (bitcoinAddress) {
                results[bitcoinAddress] = 0;
            }
        }

        //@note: @details: https://regex101.com/
        var uris = docBody.match(/bitcoin:(\/\/)?[13mn][1-9A-HJ-NP-Za-km-z]{26,33}(\?[A-Za-z0-9._&=-]*&amount=|\?amount=)[0-9\.]+/g);

        if (!uris) {
            uris = [];
        }

        for (var i = 0; i < uris.length; i++) {
            var uri = uris[i];
            var comps = uri.split('?');
            var address = comps[0].match(/[13mn][1-9A-HJ-NP-Za-km-z]{26,33}/);
            var amount = null;
            var amountError = false;
            var pairs = comps[1].split('&');

            for (var pairIndex = 0; pairIndex < pairs.length; pairIndex++) {
                var pair = pairs[pairIndex];
                if (amount !== null) {
                    amountError = true;
                }
                else if (pair.substring(0, 7) === 'amount=') {
                    amount = pair.substring(7);
                }
            }

            if (amountError) {
                amount = null;
            }
            results[address] = (amount !== null) ? amount : "";
        }
    }
    else if (targetCoinType == COIN_ETHEREUM) {
        var ethereumAddresses = docBody.match(/(0x[0-9a-fA-F]{40})/g);
        console.log("check :: " + ethereumAddresses);

        if (!ethereumAddresses) {
            ethereumAddresses = [];
        }

        for (var i = 0; i < ethereumAddresses.length; i++) {
            var isValidEthereumLikeAddress = false;
            var validAddressTypes = getAddressCoinTypes(ethereumAddresses[i]);

            if (validAddressTypes[COIN_ETHEREUM] === true ||
                validAddressTypes[COIN_ETHEREUM_CLASSIC] === true ||
                validAddressTypes[COIN_TESTNET_ROOTSTOCK] === true) {
                isValidEthereumLikeAddress = true;
            }

            console.log("found :: " + ethereumAddresses[i] + " :: " + JSON.stringify(validAddressTypes));

            var ethereumAddress = ethereumAddresses[i];

            if (isValidEthereumLikeAddress) {
                results[ethereumAddress] = 0;
            }
        }
        //@note: @todo: ethereum uri support.
    }

    for (resultAddress in results) {
        var validAddressTypes = getAddressCoinTypes(resultAddress);

        if (validAddressTypes[targetCoinType] !== true) {
            delete results[resultAddress];
        }
    }

    return results;
}

function populateScanAddresses(coinScanAddresses) {
    $('.populatePageAddresses').empty();
    var template = $('.pageAddressTemplate > .pageAddress');
    var foundValidAddresses = 0;
    var foundAddressCoinType = -1;

    for (var address in coinScanAddresses) {
        console.log("found address :: " + address);
        var link = template.clone(true);
        var amount = coinScanAddresses[address];
        $('.address', link).text(address);
        $('.amount', link).text(amount);

        link.click((function (address, amount) {
            return function () {
                Navigation.showTab('send');
                if (amount) {
                    $('.tabContent .amount input').val(amount)
                }
                $('.tabContent .address input').val(address).trigger('keyup');
            };
        })(address, amount));

        console.log("populating to :: " + $('.populatePageAddresses') + " :: " + link);
        $('.populatePageAddresses').append(link);
    }

    if (Object.keys(coinScanAddresses).length < 3) {
        $('.pageAddressScrollContainer').css('overflow-y', 'hidden');
        $('.pageAddressScrollContainer').css('display', 'hidden');
    } else {
        $('.pageAddressScrollContainer').css('overflow-y', 'scroll');
    }

    $('.pageAddresses').data('addresses', Object.keys(coinScanAddresses).length);
}

function showPageScanAddresses(targetCoinType) {
    populateScanAddresses(pageScanAddresses[targetCoinType]);

    if (Object.keys(pageScanAddresses[targetCoinType]).length > 0) {
        $('.pageAddressesHeader').show();
        $('.pageAddresses').show();
        Navigation.showTab('send');
    }
}

function countdownButtonUpdate(element, prefixText, timeRemaining, onUpdateCallback, onFinishCallback) {
    if (onUpdateCallback) {
        onUpdateCallback(timeRemaining - 1);
    }

    var strTimerName = $(element).selector;
    clearTimeout(g_JaxxApp.getUI().UITimer(strTimerName));
    var objTimer = setTimeout(function () {
        if (timeRemaining > 1) {
            countdownButtonUpdate(element, prefixText, timeRemaining - 1, onUpdateCallback, onFinishCallback);
        } else {
            onFinishCallback();
        }
    }, 1000);

    g_JaxxApp.getUI().UITimer(strTimerName, objTimer);
}

//this is only called when wallet is restored or created
function _loadWallet(loadedWallet) {
    console.log('_loadWallet');
    jaxx.Registry.loadMnemonic();

    if (wallet) {
        if ($(window).unload) {
            $(window).trigger('unload');
        }
    }

    wallet = loadedWallet;
    g_JaxxApp.getUI().generateProgrammaticElementsInUI();
    Navigation.setUseFiat(false);
    // if we are loading a new wallet
    if (g_JaxxApp['__newWalletFromScratch'] === true) {

        jaxx.Registry.application$.on(jaxx.Registry.ON_UI_INTERWALLET_ANIMATION_END, function () { // once the wallet UI should be ready to get in place
            var creatingWalletOverlay = $('.creatingWallet');
            $('.settings').hide(); // this hides the wallet configuraiton screen
            g_JaxxApp['__newWalletFromScratch'] = false;
            setTimeout(function () // we place the fade out behind a 2 sec timer to as the wallet UI sometimes takes longer to settle
            {
                creatingWalletOverlay.css('transition', 'opacity 1.5s');
                creatingWalletOverlay.css('opacity', '0');

                setTimeout(function () { // once the transition has ended
                    creatingWalletOverlay.css('display', 'none');
                }, 2000);

            }, 2000);
        });
    } else { // here we are not startin a wallet from scratch
        $('.settings').hide();
    }
    $('.wallet').show();

    if (openUrl) {
        checkOpenUrl(openUrl);
        openUrl = null;
    }

    resize();

    // Jaxx bulletin should trigger after tips notification footer is closed on express mode. See hideNotificationFooter function
    if (g_JaxxApp.getUI()._jaxxUIIntro._setOptionSelected !== "Express") {
        g_JaxxApp.getUI().getJaxxNews(function () {
            g_JaxxApp.getUI().displayJaxxNewsIfCritical();
        });
    }

    if (typeof(currencyListArray) === 'undefined' || currencyListArray === null) {
        currencyListArray = [];
    }

    if (currencyListArray.length === 0) {
        currencyListArray.push('USD');
    }

    console.log('currencies_selected resource data is ', currencyListArray);

    // @Note: Set wallet unit
    var default_currency = g_JaxxApp.getSettings().getListOfEnabledCurrencies()[0];
    wallet.getHelper().setFiatUnit(default_currency);
    g_JaxxApp.getUI().showHamburgerMenu();
    var getUIIntro = g_JaxxApp.getUI()._jaxxUIIntro;
    // if(getUIIntro._setWalletType === "newWallet" && getUIIntro._setOptionSelected === "Express")
    //g_JaxxApp.getUI().setTransferPaperWalletHeader(curCoinType); // Just sets the text for transfer paper wallet to give more specific instructions.

    return wallet;
}

/**
 *  User Interface - Tabs
 *
 */

var Navigation = (function () {
    this.ignoreUpdateFromInputFieldEntry = false;
    var _currenciesEnabled = []; // This keeps a record of all currencies the user has enabled

    var closeModal = function (callback) {
        var visible = $('.modal.visible');
        visible.removeClass('visible').animate({opacity: 0}, 300, function () {
            visible.hide();
            if (callback) callback();
        });
        if (window.native && window.native.setIsModalOpenStatus) {
            window.native.setIsModalOpenStatus(false);
        }
    }

    var openModal = function (modalName) {
        $('.modal.visible').hide(); // replaces closeModal();
        var modal = $('.modal.' + modalName);
        modal.find('.imageCopy').on('click', function () {
        });
        modal.css({opacity: 0}).show().animate({opacity: 1}).addClass('visible');
        modal.click(function (e) {
            if ($(e.target).hasClass('modal')) {
                closeModal();
            }
        });

        if (window.native && window.native.setIsModalOpenStatus) {
            window.native.setIsModalOpenStatus(true);
        }
    };

    var openNotificationBanner = function (bannerName) {
        var bannerHeight = (JaxxUI._sUI._wHeight - $('.landscapeRight').position().top) + 5;
        var banner = $('.cssNotificationFooter' + bannerName);
        banner.parent().removeClass("hideNotificationFooter").addClass('visibleNotificationFooter');
        banner.slideDown(400, "swing").animate({height: bannerHeight});
        if (window.native && !!window.native.getAndroidSoftNavbarHeight()) {
            $('.modal-bottom').addClass('softKeys');
        }
    };

    var closeNotificationBanner = function (bannerName) {
        var banner = $('.cssNotificationFooter' + bannerName);
        setTimeout(function () {
            banner.slideUp(400, 'swing', function () {
                banner.parent().removeClass('visibleNotificationFooter');
                banner.parent().addClass('hideNotificationFooter');
            }).animate({height: 0});
        }, 500);
    };

    var futureResize = function () {
        setTimeout(resize, 10);
    };

    // Show a tab
    // @TODO: add an "amiated" parameter
    var showTab = function (tabName) {
        console.error('showTab ' + tabName);
        $('.tab').removeClass('cssSelected').removeClass('selected');
        $('.tab.' + tabName).addClass('cssSelected').addClass('selected');

        if ((tabName === 'send') || (tabName === 'shapeShift')) {
            g_JaxxApp.getUI().updateHighlightingInSendTransactionButton();

            if ($('.tabContent').hasClass('selected')) {
                $('.tabContent .address').slideDown();
                $('.tabContent .spendable').slideDown();

                if ($('.tabContent .pageAddresses').data('addresses')) {
                    $('.tabContent .pageAddressesHeader').slideDown();
                    $('.tabContent .pageAddresses').slideDown();
                }

                if (curCoinType === COIN_ETHEREUM) {
                    if (!(g_JaxxApp.getShapeShiftHelper().getIsTriggered())) {
                        $('.tabContent .advancedTabButton').slideDown();
                    }
                }
            }
            else {
                $('.tabContent .address').show();
                $('.tabContent .spendable').show();

                if ($('.tabContent .pageAddresses').data('addresses')) {
                    $('.tabContent .pageAddressesHeader').show();
                    $('.tabContent .pageAddresses').show();
                }

                if (curCoinType === COIN_ETHEREUM) {
                    if (!(g_JaxxApp.getShapeShiftHelper().getIsTriggered())) {
                        $('.tabContent .advancedTabButton').show();
                    }
                }

                updateSpendable();
            }

            $('.tabContent .amount .button span.send').css({opacity: 1});
            $('.tabContent .amount .button span.receive').css({opacity: 0});
            $('.tabs .tab.send .icon').fadeTo(0, 1);
            $('.tabs .tab.receive .icon').fadeTo(0, 0.5);
        }
        else {
            if ($('.tabContent').hasClass('selected')) {
                $('.tabContent .address').slideUp();
                $('.tabContent .pageAddressesHeader').slideUp();
                $('.tabContent .pageAddresses').slideUp();
                $('.tabContent .spendable').slideUp();

                if (curCoinType === COIN_ETHEREUM) {
                    $('.tabContent .advancedTabButton').slideUp();
                    Navigation.hideEthereumAdvancedMode();
                }
            }
            else {
                $('.tabContent .address').hide();
                $('.tabContent .pageAddressesHeader').hide();
                $('.tabContent .pageAddresses').hide();
                $('.tabContent .spendable').hide();

                if (curCoinType === COIN_ETHEREUM) {
                    $('.tabContent .advancedTabButton').hide();
                    $('.tabContent .advancedTabContentEthereum').hide();
                }
            }

            $('.tabContent .amount .button span.receive').css({opacity: 1});
            $('.tabContent .amount .button span.send').css({opacity: 0});
            $('.tabs .tab.send .icon').fadeTo(0, 0.5);
            $('.tabs .tab.receive .icon').fadeTo(0, 1);
            ethereumAdvancedModeHidden = true;
        }

        if ($('.tabContent').hasClass('selected')) {
            $('.tabContent .amount').slideDown();
        }
        else {
            $('.tabContent .amount').show();
        }

        $('.tabContent').slideDown(futureResize).addClass('cssSelected').addClass('selected');

        if (window.native && window.native.setTabName) {
            window.native.setTabName(Navigation.getTab()); // Push data to Android app.
        }
    };

    //TODO remove all instances
    var getTab = function () {
    };

    var collapseTabs = function () {
        jaxx.SendTransactionsController.instance.resetAll();
    };

    //TODO remove all instances
    var toggleTab = function (tabName) {
    };


    var isUseFiat = function () {
        return ($('.unitToggle').data('fiat') === true);
    };

    var setUseFiat = function (useFiat) {
        $('.tabContent .amount input').val('');
        $('.unitToggle').data('fiat', (useFiat === true));
        $('.tabContent .amount input').trigger('keyup');

        if (useFiat) {
            $('.unitToggle .symbol').text(wallet.getHelper().getFiatUnitPrefix());
        }
        else {
            var ctr = Registry.getCurrentCryptoController();

            if (ctr) {
                var coinSymbol = jaxx.Registry.getCurrentCryptoController().symbol;// HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).uiComponents['coinSymbol'];
                $('.unitToggle .symbol').text(coinSymbol);
            }
        }
    };

    var toggleUseFiat = function () {
        setUseFiat(!isUseFiat());
    };

    var settingsStack = [];

    var getSettingsStack = function () {
        return settingsStack;

        if (window.native && window.native.setSettingsStackStatusSize) {
            window.native.setSettingsStackStatusSize(settingsStack.length);
        }

        if (window.native && window.native.createLogMessage) {
            window.native.createLogMessage("The settings stack size is " + settingsStack.length);
        }
    };

    var clearSettings = function (callback) {
        settingsStack = [];
        $('#privateKeySweep').val('').trigger('keyup');
        $('.settings').removeClass('cssHideUsingSettingsFramework'); // Related to optimizations framework.
        $('.wallet').removeClass('cssHideUsingSettingsFramework'); // Related to optimizations framework.
        $('.menu').removeClass('cssHideUsingSettingsFramework'); // Related to optimizations framework.

        if (window.native && window.native.setSettingsStackStatusSize) {
            window.native.setSettingsStackStatusSize(settingsStack.length);
        }

        // Log message to Android Studio:
        if (window.native && window.native.createLogMessage) {
            window.native.createLogMessage("The settings stack size is " + settingsStack.length);
        }

        $('.settings').hide();
        setTimeout(function () {
            if (callback) callback();
        }, 500)
    };

    var isMenuAnimating = false;

    var pushSettings = function (settingsName, callback) {

        if (settingsName === 'backupMnemonic') {
            var lastBackUpTimeStamp = parseInt(getStoredData('lastBackupTimestamp'));

            if (lastBackUpTimeStamp) {
                var dateTime = new Date(lastBackUpTimeStamp);
                var hours = dateTime.getHours();
                var minutes = dateTime.getMinutes();
                hours = hours % 12;
                hours = hours ? hours : 12;
                minutes = minutes < 10 ? '0' + minutes : minutes;
                var ampm = (dateTime.getHours() >= 12) ? "PM" : "AM";
                var $el = $('.cssBackup .cssOptionHeading label');
                var backUpNote = "Note: Backing up your wallet entails writing down your Backup Phrase. You will not be creating a \"backup\" copy of your wallet on this device.";
                $el.text('Would you like to backup your wallet again?');
                dateTime = dateTime.format('DD/MM/YY');
                $('.cssBackup .cssLastBackUpDate').text('Previous Backup: ' + dateTime + ' ' + hours + ':' + minutes + ' ' + ampm);
                $('.cssBackup .cssBackUpNote').text(backUpNote);
            }

            var element = $('.settings.backupMnemonic .proceedToBackupMnemonicButton');
            element.hide();

            countdownButtonUpdate(element, 'Proceed to Backup', 1000, null, function () {
                element.show();
            });

            var elementTwo = $('.settings.backupMnemonic .proceedToBackupMnemonicCount');
            elementTwo.fadeIn();

            countdownButtonUpdate(elementTwo, '', 1000, function (timeRemaining) {
                elementTwo.text(timeRemaining);
            }, function () {
                elementTwo.fadeOut();
            });

            $(".checkboxSettingsBackupMnemonicPage").removeClass("cssChecked");
            $(".checkboxSettingsBackupMnemonicPage").removeClass("checked");
        }

        if (settingsName === 'pairToDevice') {
            var element = $('.settings.pairToDevice .pairDeviceShowMnemonicButton');
            element.hide();

            countdownButtonUpdate(element, 'I Understand: ', 6, null, function () {
                element.show();
            });

            var elementTwo = $('.settings.pairToDevice .pairDeviceShowMnemonicCount');
            elementTwo.fadeIn();

            countdownButtonUpdate(elementTwo, '', 5, function (timeRemaining) {
                elementTwo.text(timeRemaining);
            }, function () {
                elementTwo.fadeOut();
            });
        }

        if (settingsName === 'pairFromDevice') {
            var element = $('.settings.pairFromDevice .cssBtnIntroRight');
            element.hide();

            countdownButtonUpdate(element, 'I Understand: ', 6, null, function () {
                element.show();
            });

            var elementTwo = $('.settings.pairFromDevice .pairDeviceShowMnemonicCount');
            elementTwo.fadeIn();

            countdownButtonUpdate(elementTwo, '', 5, function (timeRemaining) {
                elementTwo.text(timeRemaining);
            }, function () {
                elementTwo.fadeOut();
            });
        }

        //Handles call to SetBitcoinMiningFee view (Settings view)
        if (settingsName === 'pageSetBitcoinMiningFee') {
            jaxx.MiningFeeView.instance.onOpen(this);
        }

        if (settingsName === 'viewBackupPhrase') {
            var element = $('.settings.viewBackupPhrase .pairDeviceShowMnemonicButton');
            element.hide();

            countdownButtonUpdate(element, 'I Understand: ', 6, null, function () {
                element.show();
            });

            var elementTwo = $('.settings.viewBackupPhrase .pairDeviceShowMnemonicCount');
            elementTwo.fadeIn();

            countdownButtonUpdate(elementTwo, '', 5, function (timeRemaining) {
                elementTwo.text(timeRemaining);
            }, function () {
                elementTwo.fadeOut();
            });
        }

        if (settingsName === 'displayPrivateKeysWarning') {
            var element = $('.settings.cssDisplayPrivateKeysWarning .pairDeviceShowMnemonicButton');
            element.hide();

            countdownButtonUpdate(element, 'I Understand: ', 6, null, function () {
                element.show();
            });

            var elementTwo = $('.settings.cssDisplayPrivateKeysWarning .pairDeviceShowMnemonicCount');
            elementTwo.fadeIn();

            countdownButtonUpdate(elementTwo, '', 5, function (timeRemaining) {
                elementTwo.text(timeRemaining);
            }, function () {
                elementTwo.fadeOut();
            });
        }

        if (settingsName === 'exportPrivateKeysBitcoin') {
            setupExportPrivateKeys(COIN_BITCOIN);
        }

        if (settingsName === 'exportPrivateKeysEthereum') {
            setupExportPrivateKeys(COIN_ETHEREUM);
        }

        if (settingsName === 'exportPrivateKeysEthereumClassic') {
            setupExportPrivateKeys(COIN_ETHEREUM_CLASSIC);
        }

        if (settingsName === 'exportPrivateKeysDash') {
            setupExportPrivateKeys(COIN_DASH);
        }

        if (settingsName === 'exportPrivateKeysLitecoin') {
            setupExportPrivateKeys(COIN_LITECOIN);
        }

        if (settingsName === 'exportPrivateKeysLisk') {
            setupExportPrivateKeys(COIN_LISK);
        }

        if (settingsName === 'exportPrivateKeysZCash') {
            setupExportPrivateKeys(COIN_ZCASH);
        }

        if (settingsName === 'exportPrivateKeysTestnetRootstock') {
            setupExportPrivateKeys(COIN_TESTNET_ROOTSTOCK);
        }

        if (settingsName === 'exportPrivateKeysDoge') {
            setupExportPrivateKeys(COIN_DOGE);
        }

        if (settingsName === 'viewMnemonic') {
            if (g_JaxxApp.getUser().hasPin()) {
                settingsName = 'viewMnemonicConfirmPin';
                JaxxUI._sUI.showSettingsMnemonicConfirmPin('.settingsViewMnemonicConfirmPinPad', function () {
                    Navigation.pushSettings('viewMnemonicConfirmed');
                });
            }
            else {
                var mnemonic = getStoredData('mnemonic', true);
                $('.populateMnemonic').text(mnemonic);
            }
        }
        else if (settingsName === 'viewMnemonicConfirmed') {
            settingsName = 'viewMnemonic';
        }

        if (settingsName === 'viewJaxxToken') {
            if (g_JaxxApp.getUser().hasPin()) {
                settingsName = 'pairToDeviceConfirmPin';
            }
        }
        else if (settingsName === 'pairToDeviceConfirmed') {
            settingsName = 'viewJaxxToken';
        }

        if (settingsName === 'viewJaxxBackupPhrase') {
            if (g_JaxxApp.getUser().hasPin()) {
                settingsName = 'pairToDeviceConfirmPin';
            }
        }
        else if (settingsName === 'pairToDeviceConfirmed') {
            settingsName = 'viewJaxxBackupPhrase';
        }

        if (settingsName === 'setupPINCode') {

            if (!(g_JaxxApp.getUser().hasPin())) {
                settingsName = 'changePinCode';
            } else if (!(g_JaxxApp.getUser().checkPINHashIntegrity())) {
                g_JaxxApp.getUser().clearPin();
                settingsName = 'changePinCode';
            }
        }

        if (settingsName === 'backupPrivateKeys') {
            if (g_JaxxApp.getUser().hasPin()) {
                settingsName = 'backupPrivateKeysConfirmPin';
            }
        }
        else if (settingsName === 'backupPrivateKeysConfirmed') {
            settingsName = 'backupPrivateKeys';
        }

        //todo: android back button support for submenus.
        if (settingsStack.length) {
            var topSettings = $('.settings.' + settingsStack[settingsStack.length - 1]);
        }

        var settings = $('.settings.' + settingsName);

        // Boolean set to check if the animation process is in effect, in which case it prevents the next block
        // of code from running; this is to prevent double animation from quick tapping the same UI element
        if (!isMenuAnimating) {
            isMenuAnimating = true;
            settingsStack.push(settingsName);
            settings.css({left: '100%'}).show().animate({left: 0}, 400, 'swing', function () {
                // Optimization stuff.
                // Explicitly remove the hide class from the top page and add it to the previous page.
                var localSettingsStack = Navigation.getSettingsStack();
                $('.settings.' + localSettingsStack[localSettingsStack.length - 1]).removeClass('cssHideUsingSettingsFramework');

                if (localSettingsStack.length > 1) {
                    $('.settings.' + localSettingsStack[localSettingsStack.length - 2]).addClass('cssHideUsingSettingsFramework');
                }
                else {
                    $('.menu').addClass('cssHideUsingSettingsFramework');
                }

                isMenuAnimating = false;

                if (typeof(callback) !== 'undefined' && callback !== null) {
                    callback();
                }
            }); // Hide previous setting screen in callback.
        }

        if (settingsName === 'pairToDeviceConfirmPin') {
            JaxxUI._sUI.showPairDeviceConfirmPin('.settingsPairToDeviceConfirmPinPad', function () {
                Navigation.pushSettings('pairToDeviceConfirmed');
            });
        }

        if (settingsName === 'backupPrivateKeysConfirmPin') {
            JaxxUI._sUI.showPrivateKeysConfirmPin('.settingsBackupPrivateKeysConfirmPinPad', function () {
                Navigation.pushSettings('backupPrivateKeysConfirmed');
            });
        }

        if (settingsName === 'changePinCode') {
            g_JaxxApp.getUI().showEnterPinSettings();
        }

        if (settingsName === 'removePinCode') {
            g_JaxxApp.getUI().showRemovePinSettings();
        }

        if (window.native && window.native.setSettingsStackStatusSize) {
            window.native.setSettingsStackStatusSize(settingsStack.length);
        }

        // Log message to Android Studio:
        if (window.native && window.native.createLogMessage) {
            window.native.createLogMessage("The settings stack is " + settingsStack.join(','));
        }

        Navigation.clearFlashBanner();
    };

    var popSettings = function () {
        //@note: don't pop if the splash or terms of service are on the top of the stack.
        if (['splash', 'pageTermsOfService'].indexOf(settingsStack[settingsStack.length - 1]) === -1) {
            var settingsName = settingsStack.pop();

            if (settingsStack.length) {
                // This code block runs if popSettings stack IS NOT returning to the wallet itself.
                var nextSettings = $('.settings.' + settingsStack[settingsStack.length - 1]);
                nextSettings.removeClass('cssHideUsingSettingsFramework');
                nextSettings.animate({left: 0});
            }
            else {
                // This code block runs if popSettings stack IS returning to the wallet itself.
                $('.wallet').removeClass('cssHideUsingSettingsFramework');
                $('.menu').removeClass('cssHideUsingSettingsFramework');
            }

            var settings = $('.settings.' + settingsName);
            // Optimization related: Make sure that the top element is not hidden anymore.

            settings.animate({left: '100%'}, function () {
                settings.hide();
            });

            console.log("pop settingsName :: " + settingsName);

            if (settingsName === 'viewMnemonic') {
                if (g_JaxxApp.getUser().hasPin()) {
                    JaxxUI._sUI.showSettingsMnemonicConfirmPin('.settingsViewMnemonicConfirmPinPad', function () {
                        Navigation.pushSettings('viewMnemonicConfirmed');
                    });
                }
            }

            if (settingsName === 'viewJaxxToken' || settingsName === 'viewJaxxBackupPhrase') {
                if (g_JaxxApp.getUser().hasPin()) {
                    JaxxUI._sUI.showSettingsMnemonicConfirmPin('.settingsPairToDeviceConfirmPinPad', function () {
                        Navigation.pushSettings('pairToDeviceConfirmed');
                    });
                }
            }

            if (settingsName === 'backupPrivateKeys') {
                if (g_JaxxApp.getUser().hasPin()) {
                    JaxxUI._sUI.showSettingsMnemonicConfirmPin('.settingsBackupPrivateKeysConfirmPinPad', function () {
                        Navigation.pushSettings('backupPrivateKeysConfirmed');
                    });
                }
            }

            if (window.native && window.native.setSettingsStackStatusSize) {
                window.native.setSettingsStackStatusSize(settingsStack.length);
            }

            // Log message to Android Studio:
            if (window.native && window.native.createLogMessage) {
                window.native.createLogMessage("The settings stack size is " + settingsStack.length);
            }

            Navigation.clearFlashBanner();
        }
    };

    // switch the inputs selector for MiningFeeMainMenu
    var changeMiningViewSelector = function (miningFeeOption) {
        if (miningFeeOption === HDWalletPouch.MiningFeeLevelSlow) {
            $('input#slowMiningFeeMainMenu').prop('checked', true);
        }

        if (miningFeeOption === HDWalletPouch.MiningFeeLevelFast) {
            $('input#fastMiningFeeMainMenu').prop('checked', true);
        }

        if (miningFeeOption === HDWalletPouch.MiningFeeLevelAverage) {
            $('input#averageMiningFeeMainMenu').prop('checked', true);
        }
    };

    var flashBanner = function (text, timeout, messageType, options) {
        //flashes an orange banner on the bottom of the screen
        var options = (!!options) ? options : {};
        var getTimeout = timeout * 1000;
        var closeButton = (!!options && options.close === false) ? false : true;
        getTimeout.toString();
        toastr.options = {
            "closeButton": closeButton,
            "debug": false,
            "newestOnTop": false,
            "progressBar": true,
            "positionClass": "toast-bottom",
            "preventDuplicates": true,
            "onclick": null,
            "showDuration": "400",
            "hideDuration": "400",
            "timeOut": getTimeout,
            "showEasing": "swing",
            "hideEasing": "linear",
            "showMethod": "slideDown",
            "hideMethod": "slideUp",
            "closeOnHover": false
        };

        switch (messageType) {
            case "success":
                toastr.success(text);
                break;
            case "warning":
                toastr.warning(text);
                break;
            case "error":
                toastr.error(text);
                break;
            default:
                toastr.info(text);
                break;
        }

        if (!!$('#toast-container').length) {
            var getHeight, el = document.getElementById('transactionHistoryStart');
            getHeight = (el) ? (window.innerHeight - el.offsetTop) / 2 : 0;
            getHeight = (getHeight < 300) ? getHeight : 185;
        }
    };

    var flashBannerMultipleMessages = function (textArray, timeout) {
        /*
            Calls Navigation.flashBanner at an interval, to flash multiple messages one after another
            intervalTime is slightly longer than timeout so that messages aren't on the screen at once
            if calling this at a place in the app where Navigation.flashBanner is used, I recommend using the same timeout
        */
        var intervalTime = (parseInt(timeout) * 1000) + 600;
        var i = 0;
        var interval = setInterval(function () {
            Navigation.flashBanner(textArray[i], timeout);
            i++;
            if (i >= textArray.length) clearInterval(interval);
        }, intervalTime);
    };

    var clearFlashBanner = function () {
        $('.flashBannerNotificationFooter').empty();
    };

    var hideUI = function (fromProfileMode, toProfileMode, callbackFunc, firstUnlock, coinType) {
        JaxxUI.runAfterNextFrame(function (coinType) {
            var animSpeed = 250;
            var completionOffset = 750;

            if (firstUnlock === true) {
                completionOffset = 1250;
            }

            Navigation.clearInputFields();
            Navigation.returnToDefaultView();
            $('.theDaoInsufficientGasForSpendableWarningText').slideUp();
            $('.ethereumTokenInsufficientGasForSpendableWarningText').slideUp();

            var transitionBaseIn;
            var transitionBaseOut;

            //@note: @todo: consider switching from landscape to portrait and vise-versa.
            //would need to have a flag on hide to use portrait/landscape in/out selectively.

            transitionBaseIn = (fromProfileMode === PROFILE_PORTRAIT) ? portraitTransitionsIn : landscapeTransitionsIn;
            transitionBaseOut = (toProfileMode === PROFILE_PORTRAIT) ? portraitTransitionsOut : landscapeTransitionsOut;

            for (var eID in transitionElementNames) {
                var curElement = transitionElementNames[eID];
                $(curElement).removeClass(transitionBaseIn[curElement]);
                $(curElement).addClass(transitionBaseOut[curElement]);
            }

            setTimeout(callbackFunc, animSpeed + completionOffset);
        }, coinType);
    };

    var showUI = function (fromProfileMode, toProfileMode, callback) {
        JaxxUI.runAfterNextFrame(function () {
            var animSpeed = 250;

            //@note: @todo: consider switching from landscape to portrait and vise-versa.
            //would need to have a flag on hide to use portrait/landscape in/out selectively.

            var transitionBaseIn;
            var transitionBaseOut;

            transitionBaseIn = (fromProfileMode === PROFILE_PORTRAIT) ? portraitTransitionsIn : landscapeTransitionsIn;
            transitionBaseOut = (toProfileMode === PROFILE_PORTRAIT) ? portraitTransitionsOut : landscapeTransitionsOut;

            for (var eID in transitionElementNames) {
                var curElement = transitionElementNames[eID];
                $(curElement).removeClass(transitionBaseOut[curElement]);
                $(curElement).addClass(transitionBaseIn[curElement]);
            }
            resize();
            console.log('curTransactionTable')
            curTransactionTable = '#TransactionsTable';

            if (callback) {
                $(curTransactionTable).slideDown({complete: callback});
            }
            else {
                $(curTransactionTable).slideDown();
            }
        });
    };

    var returnToDefaultView = function () {
        var sendTab = $('.tab.' + 'send');
        var receiveTab = $('.tab.' + 'receive');

        if (g_JaxxApp.getShapeShiftHelper().getIsTriggered()) {
            g_JaxxApp.getUI().resetShapeShift();
        }

        if (sendTab.hasClass('selected') || receiveTab.hasClass('selected')) {
            Navigation.collapseTabs();
        }

        g_JaxxApp.getUI().closeQuickFiatCurrencySelector();
        g_JaxxApp.getUI().closeShapeshiftCoinList();
    };

    var clearInputFields = function () {
        Navigation.ignoreUpdateFromInputFieldEntry = true;

        clearAndTriggerIfNotEmpty = function (inputFieldName) {
            if ($(inputFieldName).val() != '') {
                $(inputFieldName).val('').trigger('keyup');
            }
        };

        clearAndTriggerIfNotEmpty('.settings.sweepPrivateKey input');
        clearAndTriggerIfNotEmpty('.settings.sweepPrivateKeyPasswordEntry input');
        clearAndTriggerIfNotEmpty('.tabContent .address input');
        clearAndTriggerIfNotEmpty('.tabContent .amount input');
        clearAndTriggerIfNotEmpty('.advancedTabContentEthereum .customGasLimit input');
        clearAndTriggerIfNotEmpty('.advancedTabContentEthereum .customData input');
        $('.ethereumChecksumAddressWarningText').slideUp();
        Navigation.ignoreUpdateFromInputFieldEntry = false;
    };

    var setupCoinUI = function (targetCoinType) {
        Navigation.hideEthereumAdvancedMode();

        //@note: @here: @token: this seems necessary.
        if (targetCoinType === COIN_BITCOIN ||
            targetCoinType === COIN_THEDAO_ETHEREUM ||
            targetCoinType === COIN_DASH ||
            targetCoinType === COIN_AUGUR_ETHEREUM ||
            targetCoinType === COIN_AUGUR_ETHEREUM ||
            targetCoinType === COIN_GOLEM_ETHEREUM ||
            targetCoinType === COIN_GNOSIS_ETHEREUM ||
            targetCoinType === COIN_ICONOMI_ETHEREUM ||
            targetCoinType === COIN_SINGULARDTV_ETHEREUM ||
            targetCoinType === COIN_DIGIX_ETHEREUM ||
            targetCoinType === COIN_BLOCKCHAINCAPITAL_ETHEREUM ||
            targetCoinType === COIN_CIVIC_ETHEREUM ||
            targetCoinType === COIN_LITECOIN ||
            targetCoinType === COIN_LISK ||
            targetCoinType === COIN_ZCASH ||
            targetCoinType === COIN_DOGE) {
            $('.tabContent .advancedTabButton').slideUp();
            $('.tabContent .advancedTabButton').hide();
        }
        else if (targetCoinType === COIN_ETHEREUM ||
            targetCoinType === COIN_ETHEREUM_CLASSIC ||
            targetCoinType === COIN_TESTNET_ROOTSTOCK) {
            Navigation.setEthereumAdvancedModeCustomGasLimitSuggestion(0, null);
            $('.advancedTabButton').unbind();
            $('.advancedTabButton').bind('click', null, function () {
                if (Navigation.ethereumAdvancedModeHidden()) {
                    Navigation.showEthereumAdvancedMode();
                }
                else {
                    Navigation.hideEthereumAdvancedMode();
                }
                console.log("toggle advanced tab");
            });

            if (!(g_JaxxApp.getShapeShiftHelper().getIsTriggered())) {
                $('.tabContent .advancedTabButton').show();
            }
        }
    };

    var ethereumSecretSelectorActivate = function () {

        if (!PlatformUtils.mobileCheck() && !PlatformUtils.extensionCheck() && !PlatformUtils.desktopCheck()) {
            var newProfileMode = (curProfileMode === PROFILE_PORTRAIT) ? PROFILE_LANDSCAPE : PROFILE_PORTRAIT;
            Navigation.setProfileMode(newProfileMode);
        }

        if (typeof(ethereumUnlocked) === 'undefined' || ethereumUnlocked === null || ethereumUnlocked === false) {

            if (ethereumSecretProgress > 1 && ethereumSecretProgress < 4) {
                ethereumSecretProgress++;

                if (ethereumSecretProgress === 4) {
                    console.log("[Unlock Ethereum]");
                    ethereumUnlocked = true;
                    storeData('ethereum_unlocked', ethereumUnlocked);
                    $('.imageLogoBannerETH').fadeTo(0, 1);
                    Navigation.switchToEthereum(true);
                }
            }
            else {
                ethereumSecretProgress = 0;
            }
        }
    };

    var startBlit = function () {
        resize();
        setTimeout(function () {
            resize();
        }, 50);

        if (hasBlit === false) {
            hasBlit = true;
            Navigation.clearInputFields();

            if (PlatformUtils.mobileCheck()) {
                console.log("< mobile mode >");

                function stopAllAnimations() {
                    for (cName in transitionElementNames) {
                        var element = $(transitionElementNames[cName]);
                        element.removeClass('animated');
                        element.addClass('animatedInstant');
                    }
                }

                stopAllAnimations();
                Navigation.hideUI(curProfileMode, curProfileMode, function () {
                }, false, curCoinType);

                setTimeout(function () {
                    function playAllAnimations() {
                        for (cName in transitionElementNames) {
                            var element = $(transitionElementNames[cName]);
                            element.removeClass('animatedInstant');
                            element.addClass('animated');
                        }
                    }

                    playAllAnimations();
                    $('.wallet').fadeTo(0, 1);
                    Navigation.showUI(curProfileMode, curProfileMode);
                }, 10);
            }
        }
    };

    //@note: @here: this function will only set it to closed properly, and doesn't
    //take into account the submenus.
    var setMainMenuOpen = function (isMainMenuOpenStatus) {
        if (isMainMenuOpenStatus === false) {
            g_JaxxApp.getUI().closeMainMenu();
        }
        specialAction('toggleMainMenuOff', null);
    };

    var tryToOpenExternalLink = function (url) {
        console.log('open external link ' + url);
        if (PlatformUtils.desktopCheck()) {
            //Desktop
//            Navigation.flashBanner("Openning up desktop browser");
            require('electron').remote.shell.openExternal(url);
        }
        if (PlatformUtils.extensionChromeCheck()) {
            //           Navigation.flashBanner("Openning up Chrome browser");
            //Chrome extension
            chrome.tabs.create({url: url});
        }
        else if (PlatformUtils.mobileAndroidCheck || PlatformUtils.mobileiOSCheck()) {
            //           Navigation.flashBanner("Openning up mobile browser");
            //Android
            if (window.native && window.native.openExternalURL) {
                native.openExternalURL(url);
            } else {
                console.log("Appears that I'm a fake mobile device");
            }
        }
        else {
            console.log("Not supported yet for this platform");
        }
    };


    var tryToOpenExternalLinkMobile = function (event) {
        var urlToOpen = event.data.param1;
        Navigation.tryToOpenExternalLink(urlToOpen);
    };

    var setProfileMode = function (newProfileMode) {
        console.log("switch to profile mode :: " + newProfileMode);
        canUpdateWalletUI = false;
        Navigation.hideUI(curProfileMode, newProfileMode, function () {
            completeSwitchToProfileMode(newProfileMode)
        }, false);
    };

    var showEthereumAdvancedMode = function () {
        ethereumAdvancedModeHidden = false;
        // when advancedmode is showing...
        $('.advancedBtnImage').hover(mouseEnterAdvancedBtnImageShowing, mouseLeaveEnterAdvancedBtnImageShowing);
        $('.tabContent .advancedTabContentEthereum').slideDown();
    };

    var mouseEnterAdvancedBtnImageShowing = function () {
        $('.advancedBtnImage').attr('src', 'img/Icon_up_hover.svg');
        $('.cssAdvancedTabButton').css('background-color', 'transparent');
    };

    var mouseLeaveEnterAdvancedBtnImageShowing = function () {
        $('.advancedBtnImage').attr('src', 'img/Icon_up.svg');
    };

    var hideEthereumAdvancedMode = function () {
        ethereumAdvancedModeHidden = true;
        // When advancedmode is not showing...
        $('.advancedBtnImage').hover(mouseEnterAdvancedBtnImageHiding, mouseLeaveEnterAdvancedBtnImageHiding);
        $('.tabContent .advancedTabContentEthereum').slideUp();
    };

    var mouseEnterAdvancedBtnImageHiding = function () {
        $('.advancedBtnImage').attr('src', 'img/Icon_down_hover.svg');
        $('.cssAdvancedTabButton').css('background-color', 'transparent');
    };

    var mouseLeaveEnterAdvancedBtnImageHiding = function () {
        $('.advancedBtnImage').attr('src', 'images/Icon_down.svg');
    };

    var ethereumAdvancedModeHidden = function () {
        return ethereumAdvancedModeHidden;
    };

    var setEthereumAdvancedModeCustomGasLimitSuggestion = function (customGasLimit, addressTypeName) {
        if (customGasLimit > 0) {
            $('.gasLimitSuggestion').text("Suggested for this " + addressTypeName + ": " + customGasLimit);
        }
        else {
            $('.gasLimitSuggestion').text("(No valid address entered)");
        }
    };

    var showEthereumLegacySweep = function (legacyEthereumBalance) {
        console.log("[ethereum] :: loaded legacy wallet support :: hasGlitchedLegacyEthereumWallet :: " + wallet.hasGlitchedLegacyEthereumWallet());

        $('.ethereumLegacySweepEtherAmount').text(HDWalletHelper.convertWeiToEther(legacyEthereumBalance) + " ETH");
        $('.ethereumLegacySweepTXCost').text(HDWalletHelper.convertWeiToEther(HDWalletHelper.getDefaultEthereumGasLimit().mul(HDWalletHelper.getDefaultEthereumGasPrice()).toString()) + " ETH");
        $('.ethereumLegacySweepConfirmButton').off('click');
        $('.ethereumLegacySweepConfirmButton').on('click', function () {
            wallet.transferLegacyEthereumAccountToHDNode();
            Navigation.closeModal();
        });

        Navigation.openModal('ethereumLegacySweepModal');
    };

    var toggleCurrency = function (pCurrency, pEnabled) {
        //Parameters: pEnabled is optional.
        var activeCurrencies = getEnabledCurrencies();
        console.log("Toggling currency Currency: " + pCurrency + " Enabled: " + pEnabled);

        if (typeof pEnabled === 'undefined') {
            // In this case we remove the currency if it is in the list and add it to the list if it is not there.
            if ($.inArray(pCurrency, activeCurrencies) > -1) {
                pEnabled = false;
            }
            else {
                pEnabled = true;
            }
        }

        if (pEnabled && (!$.inArray(pCurrency, _currenciesEnabled) > -1)) {
            // Run this if block if the user ticked the box.
            console.log("Adding currency " + pCurrency);
            wallet.getHelper().setFiatUnit(pCurrency);
            $(".exchangeRateList").find('[value=' + pCurrency + ']').addClass('cssCurrencyHighlightText'); // Set currency block to orange F27221.
            $(".exchangeRateList").find('[value=' + pCurrency + ']').find('.cssSelectedCurrency').find('.cssCircleUnchecked').css('border', 'none');
            $(".exchangeRateList").find('[value=' + pCurrency + ']').find('.cssSelectedCurrency').find('.cssCircleUnchecked').addClass('cssCurrencyisChecked');
            Navigation.updateCurrencyList();
            _currenciesEnabled.sort();
        }
        else if (!pEnabled && ($.inArray(pCurrency, activeCurrencies) > -1)) {
            if (activeCurrencies.length > 1) {
                // Now set the default currency to the most recent element pushed to _currenciesEnabled.
                // Run this if block if the user unticked the box.
                $(".exchangeRateList").find('[value=' + pCurrency + ']').removeClass('cssCurrencyHighlightText'); // Set currency block to orange F27221.
                $(".exchangeRateList").find('[value=' + pCurrency + ']').find('.cssSelectedCurrency').find('.cssCircleUnchecked').css('border', '1px solid white');
                $(".exchangeRateList").find('[value=' + pCurrency + ']').find('.cssSelectedCurrency').find('.cssCircleUnchecked').removeClass('cssCurrencyisChecked');
                Navigation.updateCurrencyList();
            }
        }

        if (Navigation.isUseFiat()) {
            $('.unitToggle .symbol').text(wallet.getHelper().getFiatUnitPrefix());
        }

        Registry.application$.triggerHandler(Registry.ON_ACTIVE_CURRENCIES_CHANGED);
    };

    var isCurrencyEnabled = function (pCurrency) {
        if ($.inArray(pCurrency, _currenciesEnabled) > -1) {
            return true;
        }
        return false;
    };

    var getEnabledCurrencies = function () {
        return Registry.getFiatPriceController().getActiveFiatCurrencies();
    };

    var updateCurrencyList = function () {
        var arrCurrencyRowsInList = $('.exchangeRateList tbody').children();
        var arrActiveFiatUnits = [];

        for (var i = 0; i < arrCurrencyRowsInList.length; i++) {
            if ($(arrCurrencyRowsInList[i]).children('.cssSelectedCurrency').children('.cssCircleUnchecked').hasClass('cssCurrencyisChecked')) {
                arrActiveFiatUnits.push($(arrCurrencyRowsInList[i]).attr('value'))
            }
        }

        var fiatController = Registry.getFiatPriceController();
        fiatController.setActiveFiatCurrencies(arrActiveFiatUnits);
    };

    var disableAllCurrencies = function () {
        Registry.getFiatPriceController().setActiveFiatCurrencies([]);
    };

    var getTopOfSettingsStack = function () {
        if (settingsStack.length > 0) {
            return settingsStack[settingsStack.length - 1];
        }
        else {
            return null;
        }
    };

    var closeMainMenu = function () {
        g_JaxxApp.getUI().closeMainMenu();
    };

    return {

        // Modal
        openModal: openModal,
        closeModal: closeModal,

        // Menu
        closeMainMenu: closeMainMenu,

        // Notification banner
        openNotificationBanner: openNotificationBanner,
        closeNotificationBanner: closeNotificationBanner,

        // Switching coins
        clearInputFields: clearInputFields,

        // Using Fiat vs. Bitcoin for units
        isUseFiat: isUseFiat,
        setUseFiat: setUseFiat,
        toggleUseFiat: toggleUseFiat,

        // Tabs
        getTab: getTab,
        collapseTabs: collapseTabs,
        showTab: showTab,
        toggleTab: toggleTab,

        // Settings
        clearSettings: clearSettings,
        pushSettings: pushSettings,
        popSettings: popSettings,
        getTopOfSettingsStack: getTopOfSettingsStack,

        // Banner
        flashBanner: flashBanner,
        flashBannerMultipleMessages: flashBannerMultipleMessages,
        clearFlashBanner: clearFlashBanner,

        // UI
        hideUI: hideUI,
        showUI: showUI,

        // Returning to default view
        returnToDefaultView: returnToDefaultView,

        // Clearing input fields
        clearInputFields: clearInputFields,

        // Setting up coin-specific ui elements
        setupCoinUI: setupCoinUI,

        // Ethereum secret selector
        ethereumSecretSelectorActivate: ethereumSecretSelectorActivate,

        // Show animations
        startBlit: startBlit,

        // Opening external link support for various platforms
        tryToOpenExternalLink: tryToOpenExternalLink,
        tryToOpenExternalLinkMobile: tryToOpenExternalLinkMobile,

        // Profile mode portrait/landscape transition
        setProfileMode: setProfileMode,

        // Ethereum specific features
        showEthereumAdvancedMode: showEthereumAdvancedMode,
        hideEthereumAdvancedMode: hideEthereumAdvancedMode,
        ethereumAdvancedModeHidden: ethereumAdvancedModeHidden,
        setEthereumAdvancedModeCustomGasLimitSuggestion: setEthereumAdvancedModeCustomGasLimitSuggestion,

        // Ethereum legacy sweeping of funds
        showEthereumLegacySweep: showEthereumLegacySweep,

        // getSettingsStack for getting the stack settings variable when debugging
        getSettingsStack: getSettingsStack,

        // Quick fiat currency selection
        toggleCurrency: toggleCurrency,
        isCurrencyEnabled: isCurrencyEnabled,
        getEnabledCurrencies: getEnabledCurrencies,
        updateCurrencyList: updateCurrencyList,
        disableAllCurrencies: disableAllCurrencies
    };
})();


function completeSwitchToProfileMode(newProfileMode) {
    switchToProfileMode(newProfileMode);
    Navigation.showUI(curProfileMode, newProfileMode);
    canUpdateWalletUI = true;
    forceUpdateWalletUI();
    resize();
}

function setupBackupPrivateKeys(coinType, symbol) {
    g_JaxxApp.getUI().updateAndLoadPrivateKeyList(coinType, symbol);
}

function setupExportPrivateKeys(coinType) {
    var printStr = g_JaxxApp.getUI()._strKeyPair;
    $('.backupPrivateKeyListcopy').attr('copy', printStr);
    $(csvExportField).text(printStr);
}


//Returns the detected coin type
function checkAndSetupSendScan(uri, targetCoinType) {
    var parsed = HDWalletHelper.parseURI(uri);

    // Invalid
    if (!parsed) {
        return -1;
    }

    // Are we the type of coin we expect?
    var baseCoinFormatAddressType = {
        bitcoin: COIN_BITCOIN,
        'ether': COIN_ETHEREUM,
        'dash': COIN_DASH,
        'litecoin': COIN_LITECOIN,
        'lisk': COIN_LISK,
        'zcash': COIN_ZCASH,
        'dogecoin': COIN_DOGE
    }[parsed.coin];

    console.log("checkAndSetupSendScan :: " + JSON.stringify(parsed) + " :: baseCoinFormatAddressType :: " + baseCoinFormatAddressType + " :: targetCoinType :: " + targetCoinType);

    if (typeof(targetCoinType) !== 'undefined') {
        if (Registry.getCurrentCryptoController().name.toLowerCase() !== parsed.coin) {
            return -1;
        }
    }

    // Fill in the UI
    $('.tabContent .address input').val(parsed.address).trigger('keyup');
    if (parsed.amount) {
        $('.tabContent .amount input').val(parsed.amount).trigger('keyup');
    }

    return baseCoinType;
}

function checkSendScan(uri) {
    var parsed = HDWalletHelper.parseURI(uri);

    // Invalid
    if (!parsed) {
        return -1;
    }

    return {
        bitcoin: COIN_BITCOIN,
        'ether': COIN_ETHEREUM,
        'dash': COIN_DASH,
        'litecoin': COIN_LITECOIN,
        'lisk': COIN_LISK,
        'zcash': COIN_ZCASH,
        'doge': COIN_DOGE
    }[parsed.coin];
}

function prepareSweepTxCallbackForPrivateKeyImport(error, info, coinType) {
    // This is called when the user enters their private key and then hits 'Next'
    var feedbackMessage = "";
    if (error) {
        // Error
        // This code runs when the private key specified is simply invalid
        console.log('Sweep error: ' + error.message);
        $('.settings.confirmSweepPrivateKey .button').hide();
        feedbackMessage = "Error Scanning Private Key";
    }
    else if (info) {
        // Plenty of funds
        // This code runs when the private key specified has plenty of funds available for a transaction
        var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(coinType).pouchParameters['coinAbbreviatedName'];
        wallet.setPreparedTransactionPrivateKeyInput(info.signedTransaction);
        $('.settings.confirmSweepPrivateKey .button').addClass('enabled').addClass('cssEnabled');
        $('.settings.confirmSweepPrivateKey .button').show();
        feedbackMessage = "The Balance for this Private Key is " + info.totalValue + " " + coinAbbreviatedName;
    }
    else {
        // Not enough funds
        // This code runs when the private key specified does have enough funds for a transaction
        $('.settings.confirmSweepPrivateKey .button').hide();
        feedbackMessage = "Insufficient Balance";
    }

    $('.settings.confirmSweepPrivateKey .spinner').text(feedbackMessage);
}

function prepareSweepTxCallbackForPrivateKeyScansWithCamera(error, info) {
    // This is called when the user enters their private key and then hits 'Next'
    var feedbackMessage = "";
    if (error) {
        // Error
        // This code runs when the private key specified is simply invalid
        console.log('Sweep error: ' + error.message);
        g_JaxxApp.getUI().closeMainMenu();
        feedbackMessage = "Error Scanning Private Key";
    }
    else if (info) {
        // Plenty of funds
        // This code runs when the private key specified has plenty of funds available for a transaction
        var coinAbbreviatedName = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).pouchParameters['coinAbbreviatedName'];
        wallet.setPreparedTransactionPrivateKeyInput(info.signedTransaction);
        $('.settings.confirmSweepPrivateKey .button').addClass('enabled').addClass('cssEnabled');
        $('.settings.confirmSweepPrivateKey .button').show();
        feedbackMessage = "The Balance for this Private Key is " + info.totalValue + coinAbbreviatedName;
    }
    else {
        // Not enough funds
        // This code runs when the private key specified does have enough funds for a transaction

        // User feeback message when the balance is insufficient for the given Private Key
        $('.settings.confirmSweepPrivateKey .amount').text('Insufficient Balance');
        $('.settings.confirmSweepPrivateKey .button').hide();
        feedbackMessage = "Insufficient Balance";
    }

    $('.settings.confirmSweepPrivateKey .amount').text(feedbackMessage);
    $('.settings.confirmSweepPrivateKey .spinner').hide();
}

function sendTransaction() {
    var now = Math.floor(new Date().getTime() / 1000);
    if (Math.abs(now - lastSentTimestampSeconds) > 2) {
        //force two seconds before sending next tx
        lastSentTimestampSeconds = Math.floor(new Date().getTime() / 1000);
        var data = wallet.getPouchFold(curCoinType).getTransactionData();
        g_JaxxApp._dataStoreController.onSendTransactionStart(data);

        if (data) {
            if (curCoinType === COIN_BITCOIN) {
                wallet.getPouchFold(curCoinType).getPouchFoldImplementation().sendBitcoinTransaction(data.transaction, function (response, tx) {
                    if (response.status == 'success' || response == 'success') {
                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');

                        setTimeout(function () {
                            playSound("snd/balance.wav", null, null);
                            Navigation.flashBanner('Transaction Sent', 3, 'success');
                        }, 1500);

                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }
                    else {
                        Navigation.flashBanner('Error: ' + response.message, 5);
                        console.log('Error', response.message);
                    }

                    //Always update the tx history for sends
                    forceUpdateWalletUI();
                });
            }
            else if (curCoinType === COIN_ETHEREUM) {
                var txArray = wallet.getPouchFold(curCoinType).getPouchFoldImplementation().constructEthereumTransactionListFromReadyTransactionList(data.readyTxArray);

                if (typeof(txArray) !== 'undefined' && txArray !== null) {
                    g_JaxxApp.getTXManager().sendEthereumLikeTXList(COIN_ETHEREUM, {txArray: txArray}, function (result) {
                        console.log("sendTransaction :: result :: " + result);
                        if (result === 'success') {
                            $('.tabContent .address input').val('');
                            $('.tabContent .amount input').val('').trigger('keyup');

                            setTimeout(function () {
                                playSound("snd/balance.wav", null, null);
                                Navigation.flashBanner('Transaction Sent', 3, 'success');
                            }, 1500);

                            Navigation.returnToDefaultView();
                            Navigation.hideTransactionHistoryDetails();
                        }
                        else if (result === 'failure') {
                            //All of the batch failed
                            Navigation.flashBanner('Transaction Failed', 5, 'error');
                            console.log('Error', status);
                        }
                        else {
                            // Partial failure
                            // Some of the batch succeeded, some failed
                            $('.tabContent .address input').val('');
                            $('.tabContent .amount input').val('').trigger('keyup');
                            playSound("snd/balance.wav", null, null);
                            Navigation.flashBanner('Batch Transaction Failed', 5);
                            Navigation.returnToDefaultView();
                            Navigation.hideTransactionHistoryDetails();
                        }

                        //Always update the tx history for sends.
                        forceUpdateWalletUI();
                    });
                }
                else {
                    console.prepareAddresseslog("[ sendTransaction ] :: ethereum :: error :: cannot build txList for send :: " + txArray);
                }
            }
            else if (curCoinType === COIN_ETHEREUM_CLASSIC) {
                g_JaxxApp.getTXManager().sendEthereumLikeTXList(COIN_ETHEREUM_CLASSIC, data, function (result) {
                    console.log("sendTransaction :: result :: " + result);
                    if (result === 'success') {
                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');

                        setTimeout(function () {
                            playSound("snd/balance.wav", null, null);
                            Navigation.flashBanner('Transaction Sent', 3, 'success');
                        }, 1500);

                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }
                    else if (result === 'failure') {
                        //All of the batch failed
                        Navigation.flashBanner('Transaction Failed', 5, 'error');
                        console.log('Error', status);
                    }
                    else {
                        //Partial failure.
                        //Some of the batch succeeded, some failed

                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');
                        playSound("snd/balance.wav", null, null);
                        Navigation.flashBanner('Batch Transaction Failed', 5);
                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }

                    //Always update the tx history for sends.
                    forceUpdateWalletUI();
                });
            }
            else if (curCoinType === COIN_THEDAO_ETHEREUM ||
                curCoinType === COIN_AUGUR_ETHEREUM ||
                curCoinType === COIN_GOLEM_ETHEREUM ||
                curCoinType === COIN_GNOSIS_ETHEREUM ||
                curCoinType === COIN_ICONOMI_ETHEREUM ||
                curCoinType === COIN_SINGULARDTV_ETHEREUM ||
                curCoinType === COIN_DIGIX_ETHEREUM ||
                curCoinType === COIN_BLOCKCHAINCAPITAL_ETHEREUM ||
                curCoinType === COIN_CIVIC_ETHEREUM) {
                g_JaxxApp.getTXManager().sendEthereumLikeTXList(COIN_ETHEREUM, data, function (result) {
                    console.log("sendTransaction :: result :: " + result);
                    if (result === 'success') {
                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');

                        setTimeout(function () {
                            playSound("snd/balance.wav", null, null);
                            Navigation.flashBanner('Transaction Sent', 3, 'success');
                        }, 1500);

                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }
                    else if (result === 'failure') {
                        //All of the batch failed:
                        Navigation.flashBanner('Error: Please check to ensure you have enough ether on this address', 15, 'error');
                        console.log('Error', status);
                    }
                    else {
                        //Partial failure.
                        //Some of the batch succeeded, some failed
                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');
                        playSound("snd/balance.wav", null, null);
                        Navigation.flashBanner('Batch Transaction: Some Failed', 5);
                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }

                    //Always update the tx history for sends.
                    forceUpdateWalletUI();
                });
            }
            else if (curCoinType === COIN_DASH) {
                wallet.getPouchFold(curCoinType).getPouchFoldImplementation().sendDashTransaction(data.transaction, function (response, tx) {
                    if (response.status == 'success' || response == 'success') {
                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');

                        setTimeout(function () {
                            playSound("snd/balance.wav", null, null);
                            Navigation.flashBanner('Transaction Sent', 3, 'success');
                        }, 1500);

                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }
                    else {
                        Navigation.flashBanner('Transaction Failed', 3, 'error');
                        console.log('Error', response.message);
                    }

                    //Always update the tx history for sends.
                    forceUpdateWalletUI();
                });
            }
            else if (curCoinType === COIN_LITECOIN) {
                wallet.getPouchFold(curCoinType).getPouchFoldImplementation().sendLitecoinTransaction(data.transaction, function (response, tx) {
                    if (response.status == 'success' || response == 'success') {
                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');

                        setTimeout(function () {
                            playSound("snd/balance.wav", null, null);
                            Navigation.flashBanner('Transaction Sent', 3, 'success');
                        }, 1500);

                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }
                    else {
                        Navigation.flashBanner('Transaction Failed', 3, 'error');
                        console.log('Error', response.message);
                    }

                    //Always update the tx history for sends.
                    forceUpdateWalletUI();
                });
            }
            else if (curCoinType === COIN_ZCASH) {
                wallet.getPouchFold(curCoinType).getPouchFoldImplementation().sendZCashTransaction(data.transaction, function (response, tx) {
                    if (response.status == 'success' || response == 'success') {
                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');

                        setTimeout(function () {
                            playSound("snd/balance.wav", null, null);
                            Navigation.flashBanner('Transaction Sent', 3, 'success');
                        }, 1500);

                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }
                    else {
                        Navigation.flashBanner('Transaction Failed', 3, 'error');
                        console.log('Error', response.message);
                    }

                    //Always update the tx history for sends.
                    forceUpdateWalletUI();
                });
            }
            else if (curCoinType === COIN_TESTNET_ROOTSTOCK) {
                g_JaxxApp.getTXManager().sendEthereumLikeTXList(COIN_TESTNET_ROOTSTOCK, data, function (result) {
                    console.log("sendTransaction :: result :: " + result);
                    if (result === 'success') {
                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');

                        setTimeout(function () {
                            playSound("snd/balance.wav", null, null);
                            Navigation.flashBanner('Transaction Sent', 3, 'success');
                        }, 1500);

                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }
                    else if (result === 'failure') {
                        //All of the batch failed:
                        Navigation.flashBanner('Transaction Failed', 3, 'error');
                        console.log('Error', status);
                    }
                    else {
                        //Partial failure.
                        //Some of the batch succeeded, some failed:

                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');
                        playSound("snd/balance.wav", null, null);
                        Navigation.flashBanner('Batch Transaction: Some Failed', 3);
                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }

                    //Always update the tx history for sends.
                    forceUpdateWalletUI();
                });
            }
            else if (curCoinType === COIN_DOGE) {
                wallet.getPouchFold(curCoinType).getPouchFoldImplementation().sendDogeTransaction(data.transaction, function (response, tx) {
                    if (response.status == 'success' || response == 'success') {
                        $('.tabContent .address input').val('');
                        $('.tabContent .amount input').val('').trigger('keyup');

                        setTimeout(function () {
                            playSound("snd/balance.wav", null, null);
                            Navigation.flashBanner('Transaction Sent', 3, 'success');
                        }, 1500);

                        Navigation.returnToDefaultView();
                        Navigation.hideTransactionHistoryDetails();
                    }
                    else {
                        console.log('Error', response.message);
                    }

                    //Always update the tx history for sends.
                    forceUpdateWalletUI();
                });
            }
        }
    }
    else {
        console.log("Already sending another tx. Please wait a few seconds");
    }
}

function specialAction(actionName, element) {

    console.log('%c specialAction ' + actionName + ' ' + element[0].className, 'color:green');

    if (actionName.indexOf(',') > -1) {
        // For multiple actions
        specialAction(actionName.slice(0, actionName.lastIndexOf(',')), element);
        actionName = actionName.slice(actionName.lastIndexOf(',') + 1, actionName.length);
    }

    if (typeof(element) !== 'undefined' && element !== null) {
        var classes = element.attr("class");

        if (classes.indexOf('optionPairFromDeviceStart') !== -1) {
            localStorage.setItem('on-start', 'pair-device');

        }
        else if (classes.indexOf('optionCreateNewWallet') !== -1) {
            localStorage.setItem('on-start', 'new-wallet');
        }

        if (classes === 'cssMenuWindowOptionItem menuWindowOptionWallets scriptAction') {
            jaxx.Registry.application.showWallets();
        }

    }
    else {

    }

    if (typeof(ethereumUnlocked) === 'undefined' || ethereumUnlocked === null || ethereumUnlocked === false) {
        if (actionName !== 'refresh' && ethereumSecretProgress !== 4) {
            ethereumSecretProgress = 0;
        }
    }

    if (actionName.substr(0, actionName.indexOf('.')) === 'jaxx_ui') {
        if (actionName.indexOf('.') < actionName.length - 1) {
            var strFunctionToCallInModule = actionName.substr(actionName.indexOf('.') + 1);
            g_JaxxApp.getUI()[strFunctionToCallInModule](element);
        }
    }

    if (actionName.substr(0, actionName.indexOf('.')) === 'jaxx_ui_intro') {
        if (actionName.indexOf('.') < actionName.length - 1) {
            var strFunctionToCallInModule = actionName.substr(actionName.indexOf('.') + 1);
            g_JaxxApp.getUI().getIntro()[strFunctionToCallInModule](element);
        }
    }

    if (actionName.substr(0, actionName.indexOf('.')) === 'jaxx_controller') {
        if (actionName.indexOf('.') < actionName.length - 1) {
            var strFunctionToCallInModule = actionName.substr(actionName.indexOf('.') + 1);
            g_JaxxApp.getController()[strFunctionToCallInModule](element);
        }
    }

    if (actionName === 'testActionopen') {
        g_JaxxApp.getUI().openSendModal();
    }

    if (actionName === 'testActionclose') {
        g_JaxxApp.getUI().closeSendModal();
    }

    if (actionName === 'refresh') {
        jaxx.Registry.current_crypto_controller.downloadBalancesAll(function (error) {
            //console.log(error);
        });

        $('.refresh').addClass('cssActive');

        setTimeout(function () {
            $('.refresh').removeClass('cssActive');
        }, 400);

    }
    else if (actionName === 'sendConfirm') {
        Navigation.closeModal();
        Navigation.closeNotificationBanner('.cssSendConfirmation');
        Navigation.closeNotificationBanner('.cssShapeShiftConfirmation');

        if (g_JaxxApp.getUser().hasPin()) {
            g_JaxxApp.getUI().showEnterPinModal(function (error) {
                if (error) {
                    console.log("enter pin error :: " + error);
                }
                else {
                    sendTransaction();
                }
            });
        }
        else {
            sendTransaction();
        }
    }
    else if (actionName === 'scanPayment') {

        if (window.native && window.native.scanCode) {

            function queryStringToJSON(input) {
                var pairs = input.slice(1).split('&');

                var result = {};
                pairs.forEach(function (pair) {
                    pair = pair.split('=');
                    result[pair[0]] = decodeURIComponent(pair[1] || '');
                });

                return result;
            }

            var processScan = function (uri) {
                console.log("scanPayment :: found uri :: " + uri);
                var foldMainCoinType = curCoinType;
                var currentCrypto = Registry.getCurrentCryptoController();

                var uriValidationRegex = new RegExp('^([A-z0-9]*):([A-z0-9]*)(\\?.*)?$');
                var address = "";
                var parameters = null;
                var isValid = false;
                var inputComponents = uriValidationRegex.exec(uri);

                if (inputComponents !== null) // did the QR code we just scanned have a form of <coinName>:<address>?parameters?
                {
                    address = inputComponents[2];
                    if (inputComponents.length >= 3 && inputComponents[3] !== undefined && inputComponents[3] !== null) {
                        var sanitzerRegex = new RegExp(/^[\%A-z0-9\=\-\_\&\?\.\"]+$/); // allows only A to z 0 to 9, =-_&?%."
                        if (sanitzerRegex.test(inputComponents[3])) // we'll only process the parameters if they pass the sanitizing test
                        {
                            parameters = queryStringToJSON(inputComponents[3])
                        }
                    }
                } else { // QR form not recognized, let's take whatever looks like a crypto address
                    var addressLookingRegex = new RegExp('([A-z0-9]{14,})'); // that means at least 14 characters with no spaces in between them
                    var detectionResult = addressLookingRegex.exec(uri);
                    if (detectionResult !== null && detectionResult.length >= 1) {
                        address = detectionResult[1];
                    }
                }

                var isValid = false;
                try {
                    isValid = currentCrypto.validateAddress(address);
                } catch (e) {
                    isValid = false;
                }
                if (isValid) {
                    $('.tabContent .address input').val(address).trigger('keyup');

                    if (parameters !== null && parameters['amount']) {
                        var amountGuardRegex = new RegExp(/^[0-9\.]+$/);

                        if (amountGuardRegex.test(parameters['amount'])) {
                            $('#amountSendInput').val(parameters['amount']);
                        }
                    }
                } else {
                    Navigation.flashBanner("QR input could not be validated.", 2, 'error', {close: false});
                }

            };

            Navigation.clearInputFields();
            native.scanCode(processScan);
        }
    }
    else if (actionName === 'scanPrivateKey') {
        if (window.native && window.native.scanCode) {
            var processScan = function (uri) {
                console.log("scanPrivateKey :: found qr :: " + uri);
                $('#privateKeySweep').val(uri).trigger('keyup');
            };

            $('#privateKeySweep').val('').trigger('keyup');
            Navigation.clearInputFields();
            native.scanCode(processScan);
        }
    }
    else if (actionName === 'quickVerifyMnemonic.prepare') {
        var words = wallet.getMnemonic().split(' ');
        var index = parseInt(Math.random() * words.length);

        var ordinalIndex = [
            'first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth',
            'ninth', 'tenth', 'eleventh', 'twelfth', 'thirteenth', 'fourteenth', 'fifteenth', 'sixteenth',
            'seventeenth', 'eighteenth', 'nineteenth', 'twentieth', ' twenty-first', 'twenty-second',
            'twenty-third', 'twenty-fourth'
        ][index];

        var input = $('.settings.quickVerifyMnemonic input');
        input.data('word', words[index]);
        input.attr('placeholder', input.attr('placeholderFormat').replace('%s', ordinalIndex));
        input.val('');

    }
    else if (actionName === 'viewJaxxToken.prepare') {
        var mnemonic = getStoredData('mnemonic', true);
        var uri = "jaxx:" + thirdparty.bip39.mnemonicToEntropy(mnemonic);

        var qrCodeImage = thirdparty.qrImage.imageSync(uri, {
            type: "png",
            ec_level: "H"
        }).toString('base64');

        $(".settings.viewJaxxToken .jaxxToken img").attr("src", "data:image/png;base64," + qrCodeImage);
        $('.populateMnemonic').text(mnemonic);
    }
    else if (actionName === 'viewJaxxBackupPhrase.prepare') {
        var mnemonic = getStoredData('mnemonic', true);
        var uri = "jaxx:" + thirdparty.bip39.mnemonicToEntropy(mnemonic);

        var qrCodeImage = thirdparty.qrImage.imageSync(uri, {
            type: "png",
            ec_level: "H"
        }).toString('base64');

        $(".settings.viewJaxxToken.cssSettings.cssShowMnemonic img").attr("src", "data:image/png;base64," + qrCodeImage);
        $(".settings.viewJaxxBackupPhrase .jaxxToken img").attr("src", "data:image/png;base64," + qrCodeImage);
        $('.populateMnemonic').text(mnemonic);
    }
    else if (actionName === 'importMnemonic.import') {
        g_JaxxApp.getController().clickContinuePairFromDevice(element);
    }
    else if (actionName === 'confirmBackup') {
        $('#backupTextBox').val('');
        g_JaxxApp.getUI().closeMainMenu();
        wallet.confirmBackup();
    }
    else if (actionName === 'sweepPrivateKey.prepare') {
        g_JaxxApp.getUI().setStandardMessageForTransferPaperWallet();
        var privateKey = $('#privateKeySweep').val();
        var coinType = g_JaxxApp.getUI().getTransferPaperWalletCoinType();
        wallet.getPouchFold(coinType).prepareSweepTransaction(privateKey, prepareSweepTxCallbackForPrivateKeyImport);
        var privateKey = $('#privateKeySweep').val('').trigger('keyup');
    }
    else if (actionName === 'sweepPrivateKey.tryToDecrypt') {
        $('#bip38ProgressDiv').show();
        var pass = $('.settings.sweepPrivateKeyPasswordEntry input').val();
        var pvtkey = $('#privateKeySweep').val();
        var nextSweepPassBehaviours = buttonBehaviours['nextSweepPass'];
        nextSweepPassBehaviours.disableButton();

        setTimeout(function () {
            var unencrypted = "";
            var validResult = false;
            if (curCoinType === COIN_BITCOIN) {
                unencrypted = tryToDecryptBIP38KeySync(pvtkey, pass);
                // Currently there is no way to tell if the pass is wrong
                if (isValidBTCPrivateKey(unencrypted)) {
                    validResult = true;
                }
            }
            else if (curCoinType === COIN_ETHEREUM) {
                unencrypted = decryptETHKey(pvtkey, pass);
                if (isValidETHPrivateKey(unencrypted)) {
                    validResult = true;
                }
            }
            else if (curCoinType === COIN_DASH) {
                unencrypted = tryToDecryptBIP38KeySync(pvtkey, pass);
                // Currently there is no way to tell if the pass is wrong
                // This should work properly
                if (isValidBTCPrivateKey(unencrypted, HDWalletPouchDash.networkDefinitions.mainNet)) {
                    validResult = true;
                }
            }

            $('#bip38ProgressDiv').hide();

            if (validResult === true) {
                $('#privateKeySweep').val(unencrypted);
                specialAction('sweepPrivateKey.prepare');
                Navigation.pushSettings('confirmSweepPrivateKey');
                $('.settings.sweepPrivateKeyPasswordEntry input').val('').trigger('keyup');
            }
            else {
                console.log("invalid password");
                shake($('.nextSweepPass'));
            }

            var nextSweepPassBehaviours = buttonBehaviours['nextSweepPass'];
            nextSweepPassBehaviours.enableButton();

        }, 500);
    }
    else if (actionName === 'sweepPrivateKey.execute') {
        // Paper wallet replace
        var signedTransaction = wallet.getPreparedTransactionPrivateKeyInput();
        var coinType = g_JaxxApp.getUI().getTransferPaperWalletCoinType();
        var callback = g_JaxxApp.getUI().sweepPrivateKeyExecuteCallback;
        wallet.getPouchFold(coinType).getPouchFoldImplementation().sendTransaction(signedTransaction, callback, null, -1);
    }
    else if (actionName === 'onename.register') {
        var onename = $(element).data('onename');
        Onename.registerUsername(onename, wallet.getOnenameAddress(), function (error, success) {
            console.log(success, error);
            if (error) {
                console.log('Onename error', error);
            }
            else {
                wallet.setOnename(onename);
                Navigation.flashBanner('Onename request sent', 5);
                Navigation.clearSettings();
            }
        });

    }
    else if (actionName === 'scan') {
        // Middle camera button functionality
        var processScan = function (uri) {
            console.log("scan :: found uri :: " + uri);
            //Check for sending uri
            var foundScanSendCoinType = checkSendScan(uri);

            if (foundScanSendCoinType != -1) {
                console.log("scan send :: found coin type :: " + foundScanSendCoinType);
                switchToCoinType(foundScanSendCoinType, null, function () {
                    Navigation.showTab('send');
                    checkAndSetupSendScan(uri);
                });
            }
            else if (isValidBTCPrivateKey(uri)) {
                //Check this out for dash & other bitcoin-like coins
                console.log("scan ::  valid private key for BTC :: ");
                wallet.getPouchFold(COIN_BITCOIN).prepareSweepTransaction(uri, prepareSweepTxCallbackForPrivateKeyScansWithCamera);

                if (curCoinType != COIN_BITCOIN) {
                    switchToCoinType(COIN_BITCOIN, null, function () {
                        Navigation.pushSettings('confirmSweepPrivateKey');
                    });
                }
                else {
                    Navigation.pushSettings('confirmSweepPrivateKey');
                }
            }
            else if (isValidBTCPrivateKey(uri, HDWalletPouchDash.networkDefinitions.mainNet)) {
                console.log("scan ::  valid private key for DASH :: ");
                wallet.getPouchFold(COIN_DASH).prepareSweepTransaction(uri, prepareSweepTxCallbackForPrivateKeyScansWithCamera);

                if (curCoinType != COIN_DASH) {
                    switchToCoinType(COIN_DASH, null, function () {
                        Navigation.pushSettings('confirmSweepPrivateKey');
                    });
                }
                else {
                    Navigation.pushSettings('confirmSweepPrivateKey');
                }
            }
            else if (isValidBTCPrivateKey(uri, HDWalletPouchLitecoin.networkDefinitions.mainNet)) {
                console.log("scan ::  valid private key for LITECOIN :: ");
                wallet.getPouchFold(COIN_LITECOIN).prepareSweepTransaction(uri, prepareSweepTxCallbackForPrivateKeyScansWithCamera);

                if (curCoinType != COIN_LITECOIN) {
                    switchToCoinType(COIN_LITECOIN, null, function () {
                        Navigation.pushSettings('confirmSweepPrivateKey');
                    });
                }
                else {
                    Navigation.pushSettings('confirmSweepPrivateKey');
                }
            }
            else if (isValidBTCPrivateKey(uri, HDWalletPouchZCash.networkDefinitions.mainNet)) {
                console.log("scan ::  valid private key for ZCASH :: ");
                wallet.getPouchFold(COIN_ZCASH).prepareSweepTransaction(uri, prepareSweepTxCallbackForPrivateKeyScansWithCamera);

                if (curCoinType != COIN_ZCASH) {
                    switchToCoinType(COIN_ZCASH, null, function () {
                        Navigation.pushSettings('confirmSweepPrivateKey');
                    });
                }
                else {
                    Navigation.pushSettings('confirmSweepPrivateKey');
                }
            }
            else if (isValidETHPrivateKey(uri)) {
                console.log("scan ::  valid private key for ETH :: ");
                wallet.getPouchFold(COIN_ETHEREUM).prepareSweepTransaction(uri, prepareSweepTxCallbackForPrivateKeyScansWithCamera);

                if (curCoinType != COIN_ETHEREUM) {
                    switchToCoinType(COIN_ETHEREUM, null, function () {
                        Navigation.pushSettings('confirmSweepPrivateKey');
                    });
                }
                else {
                    Navigation.pushSettings('confirmSweepPrivateKey');
                }

            }
            else if (isValidETHAESkey(uri)) {
                console.log("scan ::  valid encrypted private key for ETH :: ");
                if (curCoinType != COIN_ETHEREUM) {
                    switchToCoinType(COIN_ETHEREUM, null, function () {
                        $('#privateKeySweep').val(uri).trigger('keyup');
                        Navigation.pushSettings('sweepPrivateKeyPasswordEntry');
                    });
                }
                else {
                    $('#privateKeySweep').val(uri).trigger('keyup');
                    Navigation.pushSettings('sweepPrivateKeyPasswordEntry');
                }
            }
            else if (isValidBIP38key(uri)) {
                console.log("scan ::  valid encrypted BIP38 private key for BTC :: ");
                loadScript('js/thirdparty/bip38-dist.js', callBackOnLoadBIP38Internal, callBackOnErrLoadBIP38);
                if (curCoinType != COIN_BITCOIN) {
                    switchToCoinType(COIN_BITCOIN, null, function () {
                        $('#privateKeySweep').val(uri).trigger('keyup');
                        Navigation.pushSettings('sweepPrivateKeyPasswordEntry');
                    });
                }
                else {
                    $('#privateKeySweep').val(uri).trigger('keyup');
                    Navigation.pushSettings('sweepPrivateKeyPasswordEntry');
                }
            }
            else if (isValidBTCPrivateKey(uri, HDWalletPouchDoge.networkDefinitions.mainNet)) {
                console.log("scan ::  valid private key for DOGE :: ");
                wallet.getPouchFold(COIN_DOGE).prepareSweepTransaction(uri, prepareSweepTxCallbackForPrivateKeyScansWithCamera);
                if (curCoinType != COIN_DOGE) {
                    switchToCoinType(COIN_DOGE, null, function () {
                        Navigation.pushSettings('confirmSweepPrivateKey');
                    });
                }
                else {
                    Navigation.pushSettings('confirmSweepPrivateKey');
                }
            }
            else {
                var jaxxToken = uri;

                parseJaxxToken(jaxxToken, function (err, newWallet) {
                    if (err) {
                        console.log("scan for Jaxx token :: error :: " + err);
                    }
                    else {
                        scanImportWallet = newWallet;
                        Navigation.openModal('scanPrivate');
                    }
                });
            }
        };

        Navigation.clearInputFields();
        native.scanCode(processScan);
    }
    else if (actionName === 'confirmImportPrivateKey') {
        if (typeof(scanImportWallet) !== 'undefined' && scanImportWallet != null) {
            setTimeout(function () {

                setTimeout(function () {
                    _loadWallet(scanImportWallet);
                    scanImportWallet = null;
                    Navigation.closeModal();
                }, 1000);

                Navigation.clearSettings();
                Navigation.openModal('loading');
            }, 500);
        }
        else {
            console.log("no private key code to import");
        }
    }
    else if (actionName === 'cancelImportPrivateKey') {
        scanImportWallet = null;
    }
    else if (actionName === 'resetCache') {
        g_JaxxApp._settings.resetJaxxCache();
        localStorage.setItem('walletType', 'pair-device');
        location.reload();
    }
    else if (actionName === 'showJaxxNews') {
        g_JaxxApp.getUI().closeMainMenu();
        g_JaxxApp.getUI().displayJaxxNews();
    }
    else if (actionName === "toggleQuickFiatCurrencySelector") {
        g_JaxxApp.getUI().toggleQuickFiatCurrencySelector();
    }
    else if (actionName === "setDefaultCurrencyFromMenu") {
        g_JaxxApp.getUI().setDefaultCurrencyFromMenu(element);
    }
    else if (actionName === 'quickFiatCurrencySwitch') {
        g_JaxxApp.getUI().quickFiatCurrencySwitch(element);
    }
    else if (actionName === 'showDAORefund') {
        g_JaxxApp.getUI().showDAORefund(element);
    }
    else if (actionName === 'confirmDAORefund') {
        g_JaxxApp.getUI().confirmDAORefund(element);
    }
    else if (actionName === 'toggleShapeshiftCoinSelector') {
        g_JaxxApp.getUI().toggleShapeshiftCoinList();
    }
    else if (actionName === 'toggleMainMenu') {
        g_JaxxApp.getUI().toggleMainMenu();
    }
    else if (actionName === 'enableOptionTab') {
        if (element.attr('value') === 'menu') {
            g_JaxxApp.getUI().mainMenuShowMenu();
        }
        else if (element.attr('value') === 'wallets') {
            g_JaxxApp.getUI().mainMenuShowWallets();
        }
        else if (element.attr('value') === 'currencies') {
            g_JaxxApp.getUI().mainMenuShowCurrencies();
        }
    }
    else if (actionName === 'toggleCurrency') {
        Navigation.toggleCurrency(element.attr("value"));
    }
    else if (actionName === 'toggleCryptoCurrency') {
        g_JaxxApp.getUI().toggleCryptoCurrencyIsEnabled(element.attr("value"));
    }
    else if (actionName === 'slideBannerLeft') {
        g_JaxxApp.getUI().slideBannerLeft();
    }
    else if (actionName === 'slideBannerRight') {
        g_JaxxApp.getUI().slideBannerRight();
    }
    else if (actionName === 'leftCoinBannerClicked') {
        g_JaxxApp.getUI().leftCoinBannerClicked(element.attr('value'));
    }
    else if (actionName === 'centerCoinBannerClicked') {
        g_JaxxApp.getUI().centerCoinBannerClicked(element.attr('value'));
    }
    else if (actionName === 'rightCoinBannerClicked') {
        g_JaxxApp.getUI().rightCoinBannerClicked(element.attr('value'));
    }
    else if (actionName === 'selectShapeshiftCoin') {
        g_JaxxApp.getUI().selectShapeshiftCoin(element.attr('value'));
    }
    else if (actionName === 'changeShapeshiftCoinToNextCoinType') {
        g_JaxxApp.getUI().changeShapeshiftCoinToNextCoinType(element.attr('value'));
    }
    else if (actionName === 'toggleIgnoreEtcEthSplit') {
        g_JaxxApp.getUI().toggleIgnoreEtcEthSplit();
    }
    else if (actionName === 'checkForEtcEthSplit') {
        g_JaxxApp.getUI().checkForEtcEthSplit();
    }
    else if (actionName === 'confirmEtcEthSplit') {
        g_JaxxApp.getUI().confirmEtcEthSplit();
    }
    else if (actionName === 'selectWalletsSetupOption') {
        g_JaxxApp.getUI().getIntro().selectWalletsSetupOption($(element).find('.radioBtnExpressCustom').attr('value'));
        var selectedOption = $(element).find('.radioBtnExpressCustom').attr('value');
        storeData("setUpTypeSelectedOption", selectedOption);
    }
    else if (actionName === 'pairDevicesWalletsSetupOption') {
        g_JaxxApp.getUI().getIntro().pairDevicesWalletsSetupOption($(element).find('.radioBtnPDExpressCustom').attr('value'));
    }
    else if (actionName === 'pressContinueSetupOption') {
        g_JaxxApp.getUI().getIntro().pressContinueSetupOption();
    }
    else if (actionName === 'toggleExpandSetupOption') {
        g_JaxxApp.getUI().getIntro().toggleExpandSetupOption($(element).attr('value'));
    }
    else if (actionName === 'toggleExpandPDOption') {
        g_JaxxApp.getUI().getIntro().toggleExpandPDOption($(element).attr('value'));
    }
    else if (actionName === 'TakeMeToMyWallet') {
        g_JaxxApp.getUI().getIntro().takeMeToMyWallet();
    }
    else if (actionName === 'pressContinueCustomWallets') {
        g_JaxxApp.getUI().getIntro().pressContinueCustomWallets();
    }
    else if (actionName === 'pressContinueCustomCurrencies') {
        g_JaxxApp.getUI().getIntro().pressContinueCustomCurrencies();
    }
    else if (actionName === 'toggleCoinIsEnabledCustom') {
        g_JaxxApp.getUI().getIntro().toggleCoinIsEnabledCustom(HDWalletHelper.dictCryptoCurrency[$(element).attr('value')].index);
    }
    else if (actionName === 'toggleFiatUnitCustom') {
        g_JaxxApp.getUI().getIntro().toggleFiatUnitCustom($(element).attr('value'));
    }
    else if (actionName === 'selectCoinOptionExpress') {
        g_JaxxApp.getUI().getIntro().selectCoinOptionExpress(HDWalletHelper.dictCryptoCurrency[$(element).attr('value')].index);
    }
    else if (actionName === 'pressNextButtonAtVerifyMnemonic') {
        g_JaxxApp.getUI().getIntro().pressNextAtVerifyMnemonic();
    }
    else if (actionName === 'skipPINSetup') {
        g_JaxxApp.getUI().getIntro().skipPINSetup();
    }
    else if (actionName === 'clickCheckboxTermsOfService') {
        g_JaxxApp.getUI().getIntro().clickCheckboxTermsOfService($(element).prop('checked'));
    }
    else if (actionName === 'showTermsOfService') {
        g_JaxxApp.getUI().getIntro().showTermsOfService();
    }
    else if (actionName === 'hideTermsOfService') {
        g_JaxxApp.getUI().getIntro().hideTermsOfService();
    }
    else if (actionName === 'btnContinueTermsOfService') {
        g_JaxxApp.getUI().getIntro().btnContinueTermsOfService();
    }
    else if (actionName === 'clickCancelTermsOfService') {
        g_JaxxApp.getUI().getIntro().clickCancelTermsOfService();
    }
    else if (actionName === 'toggleCheckboxTermsOfService') {
        g_JaxxApp.getUI().getIntro().toggleCheckboxTermsOfService();
    }
    else if (actionName === 'clickContinueSetupPIN') {
        g_JaxxApp.getUI().getIntro().clickContinueSetupPIN();
    }
    else if (actionName === 'clickContinueConfirmPIN') {
        g_JaxxApp.getUI().getIntro().clickContinueConfirmPIN();
    }
    else if (actionName === 'clickBackConfirmPinScreen') {
        g_JaxxApp.getUI().getIntro().clickBackConfirmPinScreen();
    }
    else if (actionName === 'enterPinCodeCustomIntroOption') {
        g_JaxxApp.getUI().getIntro().enterPinCodeCustomIntroOption();
    }
    else if (actionName === 'toggleExpandSetupSecurityPinDescription') {
        g_JaxxApp.getUI().getIntro().toggleExpandSetupSecurityPinDescription();
    }
    else if (actionName === 'toggleExpandBackupMnemonicDescription') {
        g_JaxxApp.getUI().getIntro().toggleExpandBackupMnemonicDescription();
    }
    else if (actionName === 'populateAllUserKeys') {
        g_JaxxApp.getUI().getIntro().populateAllUserKeys();
    }
    else if (actionName === 'toggleExpandSplashOption') {
        g_JaxxApp.getUI().getIntro().toggleExpandSplashOption($(element).attr('value'));
    }
    else if (actionName === 'selectSplashSetupOption') {
        g_JaxxApp.getUI().getIntro().selectSplashSetupOption($(element).find('.radioBtnSplashOption').attr('value'));
    }
    else if (actionName === 'splashOptionClicked') {
        g_JaxxApp.getUI().getIntro().splashOptionClicked($(element).attr('value'));
    }
    else if (actionName === 'pressContinueSplashOption') {
        g_JaxxApp.getUI().getIntro().pressContinueSplashOption();
    }
    else if (actionName === 'clickViewKeysButton') {
        g_JaxxApp.getUI().getIntro().clickViewKeysButton();
    }
    else if (actionName === 'toggleHeightForCurrenciesListCustomIntroOption') {
        g_JaxxApp.getUI().getIntro().toggleHeightForCurrenciesListCustomIntroOption();
        g_JaxxApp.getUI().toggleClosestAncestorExpandableText(element);
    }
    else if (actionName === 'toggleClosestAncestorExpandableText') {
        g_JaxxApp.getUI().toggleClosestAncestorExpandableText(element);
    }
    else if (actionName === 'jaxxClearAppDataIfAuthenticated') {
        g_JaxxApp.getUI().jaxxClearAppDataIfAuthenticated();
    }
    else if (actionName === 'hideVerifyMnemonicButton') {
        // Hides the target button
        $($(".settings.verifyMnemonic .validateMnemonic").attr('targetButton')).hide();
        // Hides the success text
        $('.verifyMnemonic .backupPhraseConfirmText').hide();
    }
    else if (actionName === 'clickProceedToBackupToShowMnemonic') {
        g_JaxxApp.getUI().getIntro().clickProceedToBackupToShowMnemonic();
    }
    else if (actionName === 'checkClosestAncestorCheckable') {
        g_JaxxApp.getUI().checkClosestAncestorCheckable(element);
    }
    else if (actionName === 'clickCheckboxSecurityPinSetup') {
        g_JaxxApp.getUI().getIntro().clickCheckboxSecurityPinSetup();
    }
    else if (actionName === 'clickCheckboxDisplayBackupPhraseInIntro') {
        g_JaxxApp.getUI().getIntro().clickCheckboxDisplayBackupPhraseInIntro();
    }
    else if (actionName === 'clickCheckboxSettingsBackupMnemonicPage') {
        g_JaxxApp.getUI().clickCheckboxSettingsBackupMnemonicPage();
    }
    else if (actionName === 'clickCustomCurrencies') {
        g_JaxxApp.getUI().getIntro().clickCustomCurrencies();
    }
    else if (actionName === 'clearAllData') {
        localStorage.clear();
    }
    else if (actionName === 'clickContinueConfirmPINSettings') {
        Navigation.clearSettings();
        g_JaxxApp.getUI().toggleMainMenu();
    }
}

function scrollIntoView(tableElement, tableContainer, scrollContainer) {
    var scrollAmount = $(tableElement).position().top - $(tableContainer).position().top;
    $(scrollContainer).scrollTop(scrollAmount);
}

// Called when a settings page comes on screen to handle special events
function specialOnEnter(page) {
    if (page === 'onenameComplete') {
        $('.settings.onenameComplete .populateOnename').text(wallet.getOnename());
    }
    else if (page === 'oennameTwitter') {
        $('.settings.onenameTwitter input').val('').trigger('keyup');
    }
}

function scriptAction(event) {
    var e = $(event.currentTarget);
    var effect = e.attr('effect');

    if (e.hasClass('stopPropagation')) {
        event.stopPropagation();
    }

    if (e.hasClass('disabled')) {
        return;
    }

    if (e.hasClass('button') && !e.hasClass('enabled')) {
        return;
    }

    if (e.hasClass('toggleClosestAncestorExpandableText')) {
        g_JaxxApp.getUI().toggleClosestAncestorExpandableText(event);
    }

    var pushSettings = e.attr('pushSettings');

    if (pushSettings) {
        Navigation.pushSettings(pushSettings);
        specialOnEnter(pushSettings);
    }

    if (e.attr('popSettings') == 'true') {
        Navigation.popSettings();
    }

    if (e.attr('clearSettings') == 'true') {
        Navigation.clearSettings();
    }

    var enable = (e.attr('enable') || '').split(',');

    for (var i = 0; i < enable.length; i++) {
        $(enable[i]).removeClass('disabled');
    }

    var disable = (e.attr('disable') || '').split(',');

    for (var i = 0; i < disable.length; i++) {
        $(disable[i]).addClass('disabled');
    }

    var hide = (e.attr('hide') || '').split(',');

    for (var i = 0; i < hide.length; i++) {
        if (effect === 'fade') {
            $(hide[i]).fadeOut();
        }
        else if (effect === 'slide') {
            $(hide[i]).slideUp();
        }
        else {
            $(hide[i]).hide();
        }
    }

    var show = (e.attr('show') || '').split(',');

    for (var i = 0; i < show.length; i++) {
        if (effect === 'fade') {
            $(show[i]).fadeIn();
        }
        else if (effect === 'slide') {
            $(show[i]).slideDown();
        }
        else {
            $(show[i]).show();
        }
    }

    var toggle = (e.attr('toggle') || '').split(',');

    for (var i = 0; i < toggle.length; i++) {
        if (effect === 'fade') {
            $(toggle[i]).fadeToggle();
        }
        else if (effect === 'slide') {
            $(toggle[i]).slideToggle();
        }
        else {
            $(toggle[i]).toggle();
        }
    }

    // Clear the input/textarea value in the attribute "clearValue"
    var clear = (e.attr('clearValue') || '').split(',');

    for (var i = 0; i < clear.length; i++) {
        $(clear[i]).val('').trigger('keyup');
    }

    var showTab = e.attr('showTab');

    if (showTab) {
        Navigation.showTab(showTab);
    }

    var toggleTab = e.attr('toggleTab');

    if (toggleTab) {
        Navigation.toggleTab(toggleTab);
    }

    var collapseTabs = e.attr('collapseTabs');

    if (collapseTabs === 'true') {
        Navigation.toggleTab();
    }

    var openModal = e.attr('openModal');

    if (openModal) {
        Navigation.openModal(openModal);
    }

    var closeModal = e.attr('closeModal');

    if (closeModal === 'true') {
        Navigation.closeModal();
    }

    var flashBanner = e.attr('flashBanner');

    if (flashBanner) {
        var timeout = e.attr('timeout');
        Navigation.flashBanner(flashBanner, timeout);
    }

    var special = e.attr('specialAction');

    if (special) {
        specialAction(special, e);
    }

    var specialActions = e.attr('specialActionMultipleActions');

    if (specialActions) {
        specialActionMultipleActions(specialActions, e);
    }

    var ethereumSecretSelector = e.attr('ethereumSecretSelector');

    if (typeof(ethereumUnlocked) === 'undefined' || ethereumUnlocked === null || ethereumUnlocked === false) {
        if (ethereumSecretSelector !== 'true' && !special) {
            ethereumSecretProgress = 0;
        }
    }
}

$('.tabContent .unitToggle').click(function () {
    // Open menu here
    Navigation.toggleUseFiat();
});

$('.pageSetBitcoinMiningFee .enterCustomMiningFee').keyup((function (event) {
    g_JaxxApp.getController().keyupCustomMiningOption($(event.currentTarget));
}));

$('.tabContent .address input').keyup((function () {
    //onename lookup functionality
    g_JaxxApp.getUI().updateHighlightingInSendTransactionButton();
    var input = $('.tabContent .address input');
    var onenameCache = {};

    return function () {
        if (input.val() !== "" && curCoinType === COIN_ETHEREUM) {
            var isValidAddress = ethereumAddressInputCheck();
            if (isValidAddress === false) {
                return;
            }
        }
        else {
            $('.ethereumChecksumAddressWarningText').slideUp();
        }

        var processData = function (data) {
            if (data.jaxxValue != input.val()) {
                return;
            }

            if (!data.v) {
                input.css({backgroundImage: 'none'}).removeClass('validOnename').removeClass('cssValidOnename');
                input.data('onename', false).data('address', false).data('showAddress', false);
                return;
            }

            var avatarImage = 'img/default-profile_360.png';

            if (data.avatar && data.avatar.url) {
                avatarImage = sanitizeOneNameAvatar(data.avatar.url);
            }

            input.css({backgroundImage: 'url(' + avatarImage + ')'});

            var name = 'unknown';

            if (data.name && data.name.formatted) {
                name = data.name.formatted;
            }

            var bitcoinAddress = null, truncatedBitcoinAddress = null;

            if (data.bitcoin && data.bitcoin.address) {
                bitcoinAddress = data.bitcoin.address;
                truncatedBitcoinAddress = bitcoinAddress.substring(0, 6) + '\u2026' + bitcoinAddress.substring(bitcoinAddress.length - 5);
            }

            var onenameData = {
                avatarImage: avatarImage,
                bitcoinAddress: bitcoinAddress,
                data: data,
                onename: data.jaxxValue,
                name: name,
                success: true,
                truncatedBitcoinAddress: truncatedBitcoinAddress
            };

            input.addClass('validOnename').addClass('cssValidOnename');
            input.data('onename', data.jaxxValue).data('address', bitcoinAddress).data('showAddress', truncatedBitcoinAddress);
            // Update the state of the button
            $('.tabContent .amount input').trigger('keyup');
        };

        input.data('onename', false).data('address', false);
        var continueOneNameCheck = true;
        var value = input.val()

        //Check if equals to shapeshift, avoid doing anything else
        if (value.toUpperCase() === "SHAPESHIFT") {
            console.warn(value.toUpperCase())
            if (g_JaxxApp.getShapeShiftHelper().getIsTriggered() !== true) {
                g_JaxxApp.getUI().showShapeShift();
            }

            continueOneNameCheck = false;
        }
        else {
            if (g_JaxxApp.getShapeShiftHelper().getIsTriggered()) {
                $('.spendable').slideDown(); // Hide Spendable line
                g_JaxxApp.getUI().resetShapeShift();
            }
        }

        var data = onenameCache[value];

        if (continueOneNameCheck === true && data) {
            processData(data);
        }
        else {
            RequestSerializer.getJSON('https://glacial-plains-9083.herokuapp.com/lookup.php?id=' + value, function (data) {
                data.jaxxValue = value;
                onenameCache[value] = data;
                processData(data);
            });
        }

        // Update the state of the button
        $('.tabContent .amount input').trigger('keyup');
    };

})()).change(function () {
    var input = $('.tabContent .address input');
    input.trigger('keyup');
}).focus(function () {
    var input = $('.tabContent .address input');
    if (input.data('onename') && input.data('address')) {
        input.val(input.data('onename'));
    }
}).blur(function () {
    var input = $('.tabContent .address input');
    if (input.data('onename') && input.data('address')) {
        var value = input.data('onename') + ' (' + truncate(input.data('address'), 5, 5) + ')';
        input.val(value);
    }
});

/* Limit input to 8 decimals (bitcoin) or 16 decimals (ethereum) */
function checkForDecimalLimits(inputField) {
    var returnString = "";
    var didModify = false;
    var numDecimals = 8;

    if (Navigation.isUseFiat()) {
        numDecimals = 2;
    }
    else {
        var displayNumDecimals = HDWalletPouch.getStaticCoinPouchImplementation(curCoinType).uiComponents['displayNumDecimals'];
        numDecimals = displayNumDecimals;
    }

    if (inputField.val().indexOf('.') != -1) {
        var inputFieldComponents = inputField.val().split(".");

        if (inputFieldComponents[1].length > numDecimals) {
            if (isNaN(parseFloat(inputField.val()))) {
                console.log("nan");
                return null;
            }
            didModify = true;
            returnString = parseFloat(inputFieldComponents[0] + "." + inputFieldComponents[1].substring(0, numDecimals));
        }
        else {
            didModify = false;
            returnString = inputField.val();
        }
    }
    else {
        didModify = true;
        returnString = null;
    }

    g_JaxxApp.getUI().updateHighlightingInSendTransactionButton();
    return JSON.stringify([didModify, returnString]);
}

$('.tabContent .amount input').keyup(function () {
    if ($('.tabContent .amount input').val() !== "") {
        var returnArray = JSON.parse(checkForDecimalLimits($('.tabContent .amount input')));
        var didModify = returnArray[0];
        var valueString = returnArray[1];

        if (didModify && valueString !== null) {
            $('.tabContent .amount input').val(valueString);
        }
    }

    var isSendingFullMaxSpendable = wallet.getPouchFold(curCoinType).getIsSendingFullMaxSpendable(); // Added to accomodate Anthony's business logic request: Spendable balance must empty wallet
    updateFromInputFieldEntry(isSendingFullMaxSpendable);
});

$('.tabContent .amount input').bind('paste', function (e) {
    setTimeout(function () {
        $('.tabContent .amount input').trigger('keyup');
    }, 10);
});

$('.advancedTabContentEthereum .customGasLimit input').keyup(function () {
    var didModify = false;
    var valueInt = parseInt($('.advancedTabContentEthereum .customGasLimit input').val());

    if (valueInt !== wallet.getHelper().getCustomEthereumGasLimit().toNumber()) {
        didModify = true;
    }

    if (didModify && valueInt !== null) {
        if (isNaN(valueInt)) {
            wallet.getHelper().setCustomEthereumGasLimit(wallet.getHelper().getRecommendedEthereumCustomGasLimit());
        }
        else {
            $('.advancedTabContentEthereum .customGasLimit input').val(valueInt);
            wallet.getHelper().setCustomEthereumGasLimit(valueInt);
        }

        wallet.getPouchFold(COIN_ETHEREUM).clearSpendableBalanceCache();
        updateSpendable();
        updateFromInputFieldEntry();
    }
});

$('.advancedTabContentEthereum .customData input').keyup(function () {
    updateFromInputFieldEntry();
});

var g_attachKeyupToValidateMnemonic = function (affectedMnemonic, callbackOnValidMnemonic, callbackOnInvalidMnemonic) {
    $(affectedMnemonic).keyup(function () {
        var e = $(this);
        var value = $(this).val();

        //Remove whitespace, linebreaks
        value = value.replace(/^\s+|\s+$/g, '');

        var parsedWords = value.trim().toLowerCase().split(" ");
        var numWords = 0;
        var combinedWords = "";

        for (var i = 0; i < parsedWords.length; i++) {
            if (parsedWords[i] !== "") {
                numWords++;
                combinedWords += parsedWords[i];
                if (i < parsedWords.length - 1) {
                    combinedWords += " ";
                }
            }
        }

        if (affectedMnemonic === '.settings.verifyMnemonic textarea.validateMnemonic') {

            var validateActualMnemonic = getStoredData('mnemonic', true);
            validateActualMnemonic = validateActualMnemonic.replace(/^\s+|\s+$/g, '');
            var parsedWordsActualMnemonic = validateActualMnemonic.trim().toLowerCase().split(" ");

            var is_same_backupphrase = parsedWords.length === parsedWordsActualMnemonic.length && parsedWords.every(function (element, index) {
                return element === parsedWordsActualMnemonic[index];
            });

            if (numWords == 12 && thirdparty.bip39.validateMnemonic(combinedWords) && is_same_backupphrase) {
                callbackOnValidMnemonic(e, combinedWords);
            }
            else {
                callbackOnInvalidMnemonic(e, combinedWords);
            }

        }
        else {
            if (numWords == 12 && thirdparty.bip39.validateMnemonic(combinedWords)) {
                callbackOnValidMnemonic(e, combinedWords);
            }
            else {
                callbackOnInvalidMnemonic(e, combinedWords);
            }
        }
    });
};

g_attachKeyupToValidateMnemonic('.settings.verifyMnemonic textarea.validateMnemonic', function (e, combinedWords) {
    e.val(combinedWords);
    $(e.attr('targetButton')).show();
    $('.verifyMnemonic .backupPhraseConfirmText').show();
}, function (e, combinedWords) {
    $(e.attr('targetButton')).hide();
    $('.verifyMnemonic .backupPhraseConfirmText').hide();
});

g_attachKeyupToValidateMnemonic('.settings.verifyMnemonicCustomIntroOption textarea.validateMnemonic', function () {
    g_JaxxApp.getUI().getIntro().mnemonicEnteredIsValidCustomIntroOption();
}, function () {
    g_JaxxApp.getUI().getIntro().mnemonicEnteredIsNotValidCustomIntroOption();
});

g_attachKeyupToValidateMnemonic('.settings.importMnemonic textarea.validateMnemonic', function (e, combinedWords) {
    e.val(combinedWords);
    $(e.attr('targetButton')).addClass('cssEnabled').addClass('enabled');
}, function (e, combinedWords) {
    $(e.attr('targetButton')).removeClass('cssEnabled').removeClass('enabled');
});

g_attachKeyupToValidateMnemonic('.settings.loadJaxxToken textarea.validateMnemonic', function (e, combinedWords) {
    e.val(combinedWords);
    $(e.attr('targetButton')).addClass('cssEnabled').addClass('enabled');
}, function (e, combinedWords) {
    $(e.attr('targetButton')).removeClass('cssEnabled').removeClass('enabled');
});

g_attachKeyupToValidateMnemonic('.settings.introLoadJaxxToken textarea.validateMnemonic', function (e, combinedWords) {
    e.val(combinedWords);
    $(e.attr('targetButton')).addClass('cssEnabled').addClass('enabled');
}, function (e, combinedWords) {
    $(e.attr('targetButton')).removeClass('cssEnabled').removeClass('enabled');
});

$('textarea.validateMnemonic').on('paste', function () {
    var self = this;

    setTimeout(function () {
        $(self).trigger('keyup');
    }, 100);

});

$('.settings.quickVerifyMnemonic input').keyup(function () {
    var input = $('.settings.quickVerifyMnemonic input');
    var value = input.val().toLowerCase();

    if (value === input.data('word')) {
        $(this).val(combinedWords);
        $('.settings.quickVerifyMnemonic .button').addClass('cssEnabled').addClass('enabled');
    }
    else {
        $('.settings.quickVerifyMnemonic .button').removeClass('cssEnabled').removeClass('enabled');
    }
});

$('.settings.sweepPrivateKeyPasswordEntry input').keyup(function () {
    var value = $('.sweepPrivateKeyPasswordEntry input').val();
    var nextSweepPassBehaviours = buttonBehaviours['nextSweepPass'];

    if (value != "" && value != null) {
        nextSweepPassBehaviours.enableButton();
    }
    else {
        nextSweepPassBehaviours.disableButton();
    }
});

$('.settings.onenameSelect input').keyup(function () {
    var input = $('.settings.onenameSelect input')

    var checkOnename = function (value) {
        Onename.usernameAvailable(value, function (error, available) {
            if (value !== input.val()) {
                return;
            }

            if (error) {
                console.log('Onename error', error);

            }
            else {
                if (available) {
                    $('.settings.onenameConfirm .button').data('onename', value);
                    $('.settings.onenameSelect .button').addClass('cssEnabled').addClass('enabled');
                    $('.settings.onenameConfirm .populatePendingOnename').text(value);
                }
            }
        });
    }

    var delayToken = null;

    return function () {
        $('.settings.onenameSelect .button.next').removeClass('cssEnabled').removeClass('enabled');
        var value = input.val()

        if (delayToken) {
            clearTimeout(delayToken);
        }

        delayToken = setTimeout(function () {
            delayToken = null;
            checkOnename(value)
        }, 400);
    };
}());

$('.settings.onenameTwitter input').keyup(function () {
    var input = $(this);
    input.css({backgroundImage: 'none'});
    $('.settings.onenameTwitter .button').removeClass('enabled').removeClass('cssEnabled');

    Onename.lookupTwitter(input.val(), function (username, data) {
        if (username != input.val()) {
            return;
        }
        if (data.status === 'success' && data.twitter == input.val()) {
            var avatarImage = 'img/default-profile_360.png';

            if (data.avatar && data.avatar.url) {
                avatarImage = sanitizeOneNameAvatar(data.avatar.url);
            }

            input.css({backgroundImage: 'url(' + avatarImage + ')'});
            $('.settings.onenameTwitter .button').addClass('enabled').addClass('cssEnabled');
            $('.settings.onenameTwitterProfile .populateOnename').text(wallet.getOnename());
            $('.settings.onenameTwitterProfile .populateTwitter').text(username);
            $('.settings.onenameTwitterProfile .populateName').text(data.name);

            $('.settings.onenameTwitterProfile .populateAvatar').css({
                background: 'url(' + avatarImage + ') no-repeat center center',
                backgroundSize: 'cover',
                display: 'inline-block',
            });

            $('.settings.onenameTwitterProfile .button').data('twitter', data);
        }
    });
});

function sanitizeOneNameAvatar(avatarUrl) {
    var isValidAvatar = true;
    var schemePrefixIdx = avatarUrl.indexOf("://");

    if (schemePrefixIdx !== -1) {
        var prefixScheme = avatarUrl.substr(0, schemePrefixIdx);

        if (prefixScheme !== "http" && prefixScheme !== "https") {
            console.log("avatar invalid prefix scheme :: " + prefixScheme);
            isValidAvatar = false;
        }
        else {
            var hackArray = [")", ","];

            for (var hackIdx in hackArray) {
                var curHackToCheck = hackArray[hackIdx];

                if (avatarUrl.indexOf(curHackToCheck) !== -1) {
                    console.log("avatar has inclusion hack :: " + curHackToCheck);
                    isValidAvatar = false;
                }
            }
        }
    }

    if (isValidAvatar) {
        return avatarUrl;
    }
    else {
        console.log("invalid avatar");
        return "img/default-profile_360.png";
    }
}

var buttonBehaviours = {};

function setupUIButtonBehaviours() {
    buttonBehaviours['nextSweepPass'] = {};

    buttonBehaviours['nextSweepPass'].disableButton = function () {
        var element = $('.nextSweepPass');
        element.removeClass('cssEnabled');
        element.removeClass('cssBlueButton');
        element.addClass('cssGreyButton');
        element.css('cursor', 'default');
        element.attr('specialAction', null);
        element.attr('pushSettings', null);
    };

    buttonBehaviours['nextSweepPass'].enableButton = function () {
        var element = $('.nextSweepPass');
        element.addClass('cssEnabled');
        element.addClass('cssBlueButton');
        element.removeClass('cssGreyButton');
        element.css('cursor', 'pointer');
        element.attr('specialAction', 'sweepPrivateKey.tryToDecrypt');
    };
}

// Make sure all buttons enabled by design is enabled internally
$('.button.cssEnabled').addClass('enabled');

function updateDefaultWalletList() {
    $('.settings.setDefaultWallet .setDefaultWalletList div').each(function () {
        var element = $(this);
        var elementCoinType = parseInt(element.attr('changedefaultcointype'), 10);

        if (elementCoinType === g_JaxxApp.getSettings().getDefaultCoinType()) {
            element.addClass('selected').addClass('cssSelected');
            element.find('.cssCircleUnchecked').addClass('cssCurrencyisChecked').removeClass('cssCircleUnchecked');
            g_JaxxApp.getSettings().setDefaultCoinType(elementCoinType);
            g_JaxxApp.getUI().updateSettingsUI();
        }
        else {
            element.removeClass('selected').removeClass('cssSelected');
            element.find('.cssCurrencyisChecked').removeClass('cssCurrencyisChecked').addClass('cssCircleUnchecked');
        }
    });
}

var g_Vault;

function startJaxx() {
    g_Vault = new Vault();
    g_JaxxApp.getInitializer().startJaxx();
}

function initializeJaxx(callback) {
    g_JaxxApp.getUI().updateChangeLogSummaryFromServer();
    console.log("[ Jaxx Initialize Version " + g_JaxxApp.getVersionCode() + " ]");
    $('.menusAboutVersionCode').text(g_JaxxApp.getVersionCode());
    g_JaxxApp.getUI().setupExternalLink($('.menusAboutWebsiteLink'), 'www.jaxx.io', 'https://jaxx.io/');
    g_JaxxApp.getUI().setupExternalLink($('.menusAboutWebsiteChangeLog'), 'changelog', 'https://jaxx.io/support.html#change_log_modal');
    g_JaxxApp.getUI().setupExternalLink($('.menusAboutWebsiteContact'), 'support.decentral.ca', 'https://decentral.zendesk.com/hc/en-us');
    g_JaxxApp.getUI().setupExternalLink($('.menusHelpResetWalletLink'), 'here', 'https://decentral.zendesk.com/hc/en-us/articles/218375737-How-do-I-reset-my-Jaxx-wallet-');
    g_JaxxApp.getUI().loadExtraStylesheets();
    var defaultCoinType = g_JaxxApp.getSettings().getDefaultCoinType();
    // setupDefaultWalletList();
    showPageScanAddresses(defaultCoinType);

    $('.shapeShiftToggleItem :checkbox').click(function () {
        var $this = $(this);
        var positionZero = $this.is(':checked');
        console.log("checked :: " + positionZero);
        var receiveCoinType = COIN_BITCOIN;

        while (receiveCoinType === curCoinType) {
            receiveCoinType = (receiveCoinType + 1) % COIN_NUMCOINTYPES;
        }

        g_JaxxApp.getShapeShiftHelper().setReceivePairForCoinType(curCoinType, receiveCoinType);
        g_JaxxApp.getShapeShiftHelper().clearUpdateIntervalIfNecessary();
        $('.tabContent .address input').trigger('keyup');
    });

    var receiveCoinType = COIN_BITCOIN;

    if (defaultCoinType === COIN_BITCOIN) {
        receiveCoinType = COIN_ETHEREUM;
    }
    else {
        receiveCoinType = COIN_BITCOIN;
    }

    $('.copied').slideUp(0);
    $('.ethereumChecksumAddressWarningText').slideUp(0);
    $('.ethereumTokenInsufficientGasForSpendableWarningText').slideUp(0);
    g_JaxxApp.getUI().hideShapeshiftSpinner();

    setTimeout(function () {
        $('.copied').css('position', 'relative');
    }, 1500);

    if (window.chrome && chrome.extension) {
        var backgroundPage = chrome.extension.getBackgroundPage();

        if (backgroundPage) {
            console.log("[ Jaxx :: Trying to load background wallet :: " + backgroundPage.Wallet + " ]");
        }

        if (backgroundPage && backgroundPage.Wallet) {
            console.log('Using background wallet');
            var wallet = backgroundPage.Wallet;

            if (wallet) {

                for (var i = 0; i < COIN_NUMCOINTYPES; i++) {
                    wallet.getPouchFold(i).setLogger(console);
                    wallet.getPouchFold(i).dumpLog();
                }

                var success = _loadWallet(wallet);
                console.log('Linked to background wallet: ' + success);
            }
        }
    }

    //Disable the camera if it's not available
    if (!window.native || !native.scanCode) {
        $('.cameraPairFromDevice').hide();
        $('.imageCamera').hide();
        $('.imageQR').hide();
        $('.cameraTab').hide();
        $('.settings.loadJaxxToken .pairFromDevice').hide();
        $('.settings.loadJaxxToken .cssBackContinue .cameraButton').hide();
        $('.settings.introLoadJaxxToken .pairFromDevice').hide();
        $('.settings.introLoadJaxxToken .cssBackContinue .cameraButton').hide();
        $('.tabContent .address input').css('width', 'calc(100% - 20px)');
    }
    else {
        $('.cameraTab').hide(); // Hide the camera - added when fox icon is added
    }

    if (PlatformUtils.mobileCheck() || PlatformUtils.extensionChromeCheck()) {
        console.log("mobile check passed");
        $('.tabSend').removeClass('cssTab');
        $('.tabSend').addClass('cssTabOverrideHover');
        $('.tabReceive').removeClass('cssTab');
        $('.tabReceive').addClass('cssTabOverrideHover');
        $('#ShapeSiftFoxBtn').removeClass('cssTab');
        $('#ShapeSiftFoxBtn').addClass('cssTabOverrideHover');


        if (PlatformUtils.mobileAndroidCheck && window.native && window.native.getAndroidSoftNavbarHeight) {
            console.log("android :: navbar size :: " + window.native.getAndroidSoftNavbarHeight());
        }
    }

    var dontShowReminder = false;
    console.log('wallet ', wallet);
    var lastState = jaxx.Registry.getWalletLastState();

    if (!wallet) {
        console.warn('lastState ' + lastState);
        if (lastState === 'ready') {
            var wallet = new HDWalletMain();
            // wallet.initialize();
            _loadWallet(wallet);
            g_JaxxApp.getUI().functionToCallWhenJaxxIsFinishedLoading();
            g_JaxxApp.getUI().showModalForCoinBulletinIfNotHidden(curCoinType);
        }
        else {
            console.log("[Show Splash Screen]");
            resize();
            dontShowReminder = true;
            var createNewWalletRadioButton = $(".settings.splash .optionTrigger input:radio[value=CreateNewWallet]");
            createNewWalletRadioButton.prop('checked', true);
            specialAction('splashOptionClicked', createNewWalletRadioButton);
            Navigation.pushSettings('splash');
        }

        g_JaxxApp.getUI().hideSplashScreen();
        $('.wallet').removeClass('cssHideUsingSettingsFramework'); // Related to optimizations framework.
        callback();
    }
    else {
        g_JaxxApp.getUI().updateSettingsUI();
        Navigation.startBlit();
        callback();
    }
    jaxx.Registry.application$.triggerHandler(jaxx.Registry.ON_NEW_WALLET_END);
}

// Help Page Question Toggle

$('dd').hide();

$('dt').click(
    function () {
        var toggle = $(this).nextUntil('dt');
        toggle.slideToggle();
        $('dd').not(toggle).slideUp();
    });

/* Hover states off on mobile */
var touch = window.ontouchstart || ('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
console.log("touch :: " + touch);

if (touch) {
    // remove all :hover stylesheets
    try {
        // prevent crash on browsers not supporting DOM styleSheets properly
        for (var si in document.styleSheets) {
            var styleSheet = document.styleSheets[si];
            if (!styleSheet.rules) continue;

            for (var ri = styleSheet.rules.length - 1; ri >= 0; ri--) {
                if (!styleSheet.rules[ri].selectorText) continue;

                if (styleSheet.rules[ri].selectorText.match(':hover')) {
                    styleSheet.deleteRule(ri);
                }
            }
        }
    }
    catch (ex) {
    }
    // Check a box for the default Jaxx currency
    // Assertion: the currency has been loaded into the helper wallet
}

function setupDefaultCoinType(defaultCoinType) {
    curCoinType = defaultCoinType;
    g_JaxxApp.getUI().initializeToCoinType(defaultCoinType);
}

function resize() {
    JaxxUI.runAfterNextFrame(function () {
        g_JaxxApp.getUI().refreshSizes();
        var offsetHeight = 0;
        if (curProfileMode === PROFILE_PORTRAIT) {
            offsetHeight = $('.mainTransactionHistoryHeader').height() + $('.landscapeLeft').height();
            var calculatedHeight = ($(window).height() - $('.landscapeLeft').height() - 2 * ($('#TransactionsHeader').outerHeight()));
            // $('.landscapeRight').css({height: calculatedHeight});
        }
        else if (curProfileMode === PROFILE_LANDSCAPE) {
            var landscapeRightOffsetHeight = $('.logoBanner').height() + $('.imageLogoBannerSVG').height();
            offsetHeight = $('.mainTransactionHistoryHeader').height() + $('.logoBanner').height() + $('.imageLogoBannerSVG').height();
            var wWidth = $(window).width() / 2;
            var leftWindowWidth = wWidth;
            var rightWindowWidth = wWidth;
            var wrapTableCurrencyWidth = $('.wrapTableCurrencySelectionMenu').width();
            var wrapTableCurrencyOffset = (leftWindowWidth / 2) - (rightWindowWidth / 2);
            var positionFromRight = leftWindowWidth;
            $('.cameraTab').css('right', positionFromRight + 'px');
            $('.shapeshiftTab').css('right', positionFromRight + 'px');
            $('.wrapTableCurrencySelectionMenu').css('left', wrapTableCurrencyOffset + 'px');
            //$('.landscapeRight').css({height: ($(window).height() - landscapeRightOffsetHeight)});
        }

        $('.transactions').css({height: ($(window).height() - offsetHeight - 35)}); // For transaction history.
    });
}

var forcePortrait = false;
var forceLandscape = false;

if (PlatformUtils.mobileIphoneCheck()) {
    forcePortrait = true;
}
else if (PlatformUtils.mobileIpadCheck()) {
    forceLandscape = true;
}

if (typeof(window.iosdefaultprofilemode) !== 'undefined') {
    if (window.iosdefaultprofilemode == 1) {
        forceLandscape = true;
        forcePortrait = false;
    }
    else {
        forceLandscape = false;
        forcePortrait = true;
    }
}

if (PlatformUtils.extensionCheck()) {
    console.log("ext check");
    forcePortrait = true;
}
else if (PlatformUtils.mobileAndroidCheck) {
    var lowestScreenDim = (g_JaxxApp.getUI().getWindowHeight() < g_JaxxApp.getUI().getWindowWidth()) ? g_JaxxApp.getUI().getWindowHeight() : g_JaxxApp.getUI().getWindowWidth();
    console.log("ff check");

    if (!(lowestScreenDim > 700)) {
        forcePortrait = true;
    }
}

console.log("forcePortrait :: " + forcePortrait);
console.log("forceLandscape :: " + forceLandscape);

var loadProfileMode = PROFILE_PORTRAIT;

if (forcePortrait) {
    console.log("force portrait mode");
    loadProfileMode = PROFILE_PORTRAIT;
}
else if (forceLandscape) {
    console.log("force landscape mode");
    loadProfileMode = PROFILE_LANDSCAPE;
}
else if (g_JaxxApp.getUI().getWindowHeight() > g_JaxxApp.getUI().getWindowWidth()) {
    console.log("portrait mode detected");
    loadProfileMode = PROFILE_PORTRAIT;
}
else {
    console.log("landscape mode detected");
    loadProfileMode = PROFILE_LANDSCAPE;
}

if (loadProfileMode === PROFILE_PORTRAIT) {
    switchToProfileMode(PROFILE_PORTRAIT);
}
else {
    switchToProfileMode(PROFILE_LANDSCAPE);
    setDefaultProfileMode(PROFILE_LANDSCAPE);
}

if (PlatformUtils.extensionSafariCheck()) {
    safari.self.width = 375;
    safari.self.height = 600;
}

if (PlatformUtils.extensionCheck()) {
    // JaxxUI._sUI.resizeChromeExtension();
}

$(window).on('openurl', function (event, url) {
    console.log("received openurl event :: " + event + " :: url ::" + url);
    checkOpenUrl(url);
});

$(window).resize(resize);

var updateScreenCalled;

if (!exports) {
    var exports = {};
}